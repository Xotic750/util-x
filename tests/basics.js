/*global require, describe, it */

(function (privateUndefined) {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    function returnArgs() {
        return arguments;
    }

    function X() {
        return;
    }

    describe('basics', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.noop()).to.be(privateUndefined);
            expect(utilx.privateUndefined).to.be(privateUndefined);
            expect(utilx.toNumber('-1')).to.be(-1);
            expect(utilx.toNumber('0')).to.be(0);
            expect(utilx.toNumber('1')).to.be(1);
            expect(utilx.toNumber('Infinity')).to.be(Infinity);
            expect(utilx.toNumber('-Infinity')).to.be(-Infinity);
            expect(isNaN(utilx.toNumber('NaN'))).to.be(true);
            expect(utilx.toNumber('Infinity')).to.be(Infinity);
            expect(utilx.toNumber('-Infinity')).to.be(-Infinity);
            expect(utilx.equal(-1, '-1')).to.be(true);
            expect(utilx.equal(0, '0')).to.be(true);
            expect(utilx.equal(1, '1')).to.be(true);
            expect(utilx.equal(Infinity, 'Infinity')).to.be(true);
            expect(utilx.equal(-Infinity, '-Infinity')).to.be(true);
            expect(utilx.equal(isNaN(NaN), isNaN('NaN'))).to.be(true);
            expect(utilx.equal(NaN, NaN)).to.be(false);
            expect(utilx.equal(NaN, 'NaN')).to.be(false);
            expect(utilx.equal(-1, -1)).to.be(true);
            expect(utilx.equal(0, 0)).to.be(true);
            expect(utilx.equal(1, 1)).to.be(true);
            expect(utilx.equal(Infinity, Infinity)).to.be(true);
            expect(utilx.equal(-Infinity, -Infinity)).to.be(true);
            expect(utilx.equal(isNaN(NaN), isNaN(NaN))).to.be(true);
            expect(utilx.notEqual(1, '2')).to.be(true);
            expect(utilx.notEqual(1, 2)).to.be(true);
            expect(utilx.strictEqual(1, 1)).to.be(true);
            expect(utilx.notStrictEqual(1, '1')).to.be(true);
            expect(utilx.notStrictEqual(1, 2)).to.be(true);
            expect(utilx.lt(1, 2)).to.be(true);
            expect(utilx.lt(1, 1)).to.be(false);
            expect(utilx.lt(1, 0)).to.be(false);
            expect(utilx.lte(1, 1)).to.be(true);
            expect(utilx.lte(1, 0)).to.be(false);
            expect(utilx.lte(1, 2)).to.be(true);
            expect(utilx.gt(1, 0)).to.be(true);
            expect(utilx.gt(1, 1)).to.be(false);
            expect(utilx.gte(1, 1)).to.be(true);
            expect(utilx.gte(1, 2)).to.be(false);
            expect(utilx.mod(10, 3)).to.be(10 % 3);
            expect(utilx.mod(-10, 3)).to.be(-10 % 3);
            expect(utilx.clamp(-10, -5, 5)).to.be(-5);
            expect(utilx.clamp(10, -5, 5)).to.be(5);
            expect(utilx.clamp(-5, -5, 5)).to.be(-5);
            expect(utilx.clamp(5, -5, 5)).to.be(5);
            expect(utilx.inRange(-10, -5, 5)).to.be(false);
            expect(utilx.inRange(10, -5, 5)).to.be(false);
            expect(utilx.inRange(-5, -5, 5)).to.be(true);
            expect(utilx.inRange(5, -5, 5)).to.be(true);
            expect(utilx.isUndefined()).to.be(true);
            expect(utilx.isUndefined(null)).to.be(false);
            expect(utilx.isNull(null)).to.be(true);
            expect(utilx.isNull()).to.be(false);
            expect(utilx.isUndefinedOrNull()).to.be(true);
            expect(utilx.isUndefinedOrNull(null)).to.be(true);
            expect(utilx.isUndefinedOrNull()).to.be(true);
            expect(utilx.isUndefinedOrNull(null)).to.be(true);
            expect(utilx.isUndefinedOrNull(0)).to.be(false);
            expect(utilx.isUndefinedOrNull(1)).to.be(false);
            expect(utilx.isUndefinedOrNull('')).to.be(false);
            expect(utilx.isUndefinedOrNull([])).to.be(false);
            expect(utilx.isUndefinedOrNull({})).to.be(false);
            expect(utilx.isTrue(true)).to.be(true);
            expect(utilx.isTrue(1)).to.be(false);
            expect(utilx.isTrue()).to.be(false);
            expect(utilx.isTrue(null)).to.be(false);
            expect(utilx.isFalse(false)).to.be(true);
            expect(utilx.isFalse(0)).to.be(false);
            expect(utilx.isFalse()).to.be(false);
            expect(utilx.isFalse(null)).to.be(false);
            expect(utilx.isBoolean(true)).to.be(true);
            expect(utilx.isBoolean(false)).to.be(true);
            expect(utilx.isBoolean()).to.be(false);
            expect(utilx.isBoolean(null)).to.be(false);
            expect(utilx.isBoolean('')).to.be(false);
            expect(utilx.isBoolean(0)).to.be(false);
            expect(utilx.isBoolean(1)).to.be(false);
            expect(utilx.isBoolean({})).to.be(false);
            expect(utilx.isBoolean([])).to.be(false);
            expect(utilx.toBoolean(true)).to.be(true);
            expect(utilx.toBoolean(false)).to.be(false);
            expect(utilx.toBoolean('true')).to.be(true);
            expect(utilx.toBoolean('false')).to.be(true);
            expect(utilx.toBoolean('-1')).to.be(true);
            expect(utilx.toBoolean('0')).to.be(true);
            expect(utilx.toBoolean('1')).to.be(true);
            expect(utilx.toBoolean('')).to.be(false);
            expect(utilx.toBoolean(-1)).to.be(true);
            expect(utilx.toBoolean(0)).to.be(false);
            expect(utilx.toBoolean(1)).to.be(true);
            expect(utilx.toBoolean([])).to.be(true);
            expect(utilx.toBoolean([-1])).to.be(true);
            expect(utilx.toBoolean([0])).to.be(true);
            expect(utilx.toBoolean([1])).to.be(true);
            expect(utilx.toBoolean({})).to.be(true);
            expect(utilx.toBoolean()).to.be(false);
            expect(utilx.toBoolean(null)).to.be(false);
            expect(utilx.toBoolean(utilx.noop)).to.be(true);
            expect(utilx.isNumber(10)).to.be(true);
            expect(utilx.isNumber(NaN)).to.be(true);
            expect(utilx.isNumber(Infinity)).to.be(true);
            expect(utilx.isNumber(-Infinity)).to.be(true);
            expect(utilx.isNumber('10')).to.be(false);
            expect(utilx.isNumber()).to.be(false);
            expect(utilx.isNumber(null)).to.be(false);
            expect(utilx.isNumber({})).to.be(false);
            expect(utilx.isNumber([])).to.be(false);
            expect(utilx.isZero(0)).to.be(true);
            expect(utilx.isZero(1)).to.be(false);
            expect(utilx.isZero('0')).to.be(false);
            expect(utilx.isZero()).to.be(false);
            expect(utilx.isZero(null)).to.be(false);
            expect(utilx.isString('')).to.be(true);
            expect(utilx.isString()).to.be(false);
            expect(utilx.isString(null)).to.be(false);
            expect(utilx.isString(1)).to.be(false);
            expect(utilx.isString({})).to.be(false);
            expect(utilx.isString([])).to.be(false);
            expect(utilx.isEmptyString('')).to.be(true);
            expect(utilx.isEmptyString(' ')).to.be(false);
            expect(utilx.isEmptyString()).to.be(false);
            expect(utilx.isEmptyString(null)).to.be(false);
            expect(utilx.isEmptyString({})).to.be(false);
            expect(utilx.isEmptyString([])).to.be(false);
            expect(utilx.isPrimitive()).to.be(true);
            expect(utilx.isPrimitive(null)).to.be(true);
            expect(utilx.isPrimitive('')).to.be(true);
            expect(utilx.isPrimitive(1)).to.be(true);
            expect(utilx.isPrimitive(false)).to.be(true);
            expect(utilx.isPrimitive({})).to.be(false);
            expect(utilx.isPrimitive([])).to.be(false);
            expect(utilx.isError(new Error('test'))).to.be(true);
            expect(utilx.isError(new TypeError('test'))).to.be(true);
            expect(utilx.isError(new SyntaxError('test'))).to.be(true);
            expect(utilx.isError(new RangeError('test'))).to.be(true);
            expect(utilx.isError(new Date())).to.be(false);
            expect(utilx.isError(utilx.noop)).to.be(false);
            expect(utilx.isError()).to.be(false);
            expect(utilx.isError(null)).to.be(false);
            expect(utilx.isRegExp(new RegExp('test'))).to.be(true);
            expect(utilx.isRegExp(/test/)).to.be(true);
            expect(utilx.isRegExp([])).to.be(false);
            expect(utilx.isRegExp({})).to.be(false);
            expect(utilx.isRegExp('')).to.be(false);
            expect(utilx.isRegExp(1)).to.be(false);
            expect(utilx.isRegExp(true)).to.be(false);
            expect(utilx.isRegExp()).to.be(false);
            expect(utilx.isRegExp(null)).to.be(false);
            expect(utilx.isRegExp(utilx.noop)).to.be(false);
            expect(utilx.isObject(new RegExp('test'))).to.be(false);
            expect(utilx.isObject(/test/)).to.be(false);
            expect(utilx.isObject([])).to.be(false);
            expect(utilx.isObject({})).to.be(true);
            expect(utilx.isObject('')).to.be(false);
            expect(utilx.isObject(1)).to.be(false);
            expect(utilx.isObject(true)).to.be(false);
            expect(utilx.isObject()).to.be(false);
            expect(utilx.isObject(null)).to.be(false);
            expect(utilx.isObject(utilx.noop)).to.be(false);
            expect(utilx.isFunction(new RegExp('test'))).to.be(false);
            expect(utilx.isFunction(/test/)).to.be(false);
            expect(utilx.isFunction([])).to.be(false);
            expect(utilx.isFunction({})).to.be(false);
            expect(utilx.isFunction('')).to.be(false);
            expect(utilx.isFunction(1)).to.be(false);
            expect(utilx.isFunction(true)).to.be(false);
            expect(utilx.isFunction()).to.be(false);
            expect(utilx.isFunction(null)).to.be(false);
            expect(utilx.isFunction(utilx.noop)).to.be(true);
            expect(utilx.isArguments(new RegExp('test'))).to.be(false);
            expect(utilx.isArguments(/test/)).to.be(false);
            expect(utilx.isArguments([])).to.be(false);
            expect(utilx.isArguments({})).to.be(false);
            expect(utilx.isArguments('')).to.be(false);
            expect(utilx.isArguments(1)).to.be(false);
            expect(utilx.isArguments(true)).to.be(false);
            expect(utilx.isArguments()).to.be(false);
            expect(utilx.isArguments(null)).to.be(false);
            expect(utilx.isArguments(utilx.noop)).to.be(false);
            expect(utilx.isArguments(returnArgs())).to.be(true);
            expect(utilx.arrayIsArray(new RegExp('test'))).to.be(false);
            expect(utilx.arrayIsArray(/test/)).to.be(false);
            expect(utilx.arrayIsArray([])).to.be(true);
            expect(utilx.arrayIsArray({})).to.be(false);
            expect(utilx.arrayIsArray('')).to.be(false);
            expect(utilx.arrayIsArray(1)).to.be(false);
            expect(utilx.arrayIsArray(true)).to.be(false);
            expect(utilx.arrayIsArray()).to.be(false);
            expect(utilx.arrayIsArray(null)).to.be(false);
            expect(utilx.arrayIsArray(utilx.noop)).to.be(false);
            expect(utilx.arrayIsArray(returnArgs())).to.be(false);
            expect(utilx.isEmptyArray(new RegExp('test'))).to.be(null);
            expect(utilx.isEmptyArray(new Date())).to.be(null);
            expect(utilx.isEmptyArray(/test/)).to.be(null);
            expect(utilx.isEmptyArray([])).to.be(true);
            expect(utilx.isEmptyArray([privateUndefined])).to.be(false);
            expect(utilx.isEmptyArray([null])).to.be(false);
            expect(utilx.isEmptyArray({})).to.be(null);
            expect(utilx.isEmptyArray('')).to.be(null);
            expect(utilx.isEmptyArray(1)).to.be(null);
            expect(utilx.isEmptyArray(true)).to.be(null);
            expect(utilx.isEmptyArray()).to.be(null);
            expect(utilx.isEmptyArray(null)).to.be(null);
            expect(utilx.isEmptyArray(utilx.noop)).to.be(null);
            expect(utilx.isEmptyArray(returnArgs())).to.be(true);
            expect(utilx.isEmptyArray(returnArgs(null))).to.be(false);
            expect(utilx.isEmptyArray(returnArgs(privateUndefined))).to.be(false);
            expect(utilx.isTypeOfObject(new RegExp('test'))).to.be(true);
            expect(utilx.isTypeOfObject(new Date())).to.be(true);
            expect(utilx.isTypeOfObject(/test/)).to.be(true);
            expect(utilx.isTypeOfObject([])).to.be(true);
            expect(utilx.isTypeOfObject({})).to.be(true);
            expect(utilx.isTypeOfObject('')).to.be(false);
            expect(utilx.isTypeOfObject(1)).to.be(false);
            expect(utilx.isTypeOfObject(true)).to.be(false);
            expect(utilx.isTypeOfObject()).to.be(false);
            expect(utilx.isTypeOfObject(null)).to.be(true);
            expect(utilx.isTypeOfObject(utilx.noop)).to.be(false);
            expect(utilx.isTypeOfObject(returnArgs())).to.be(true);
            expect(utilx.isTypeObject(new RegExp('test'))).to.be(true);
            expect(utilx.isTypeObject(new Date())).to.be(true);
            expect(utilx.isTypeObject(/test/)).to.be(true);
            expect(utilx.isTypeObject([])).to.be(true);
            expect(utilx.isTypeObject({})).to.be(true);
            expect(utilx.isTypeObject('')).to.be(false);
            expect(utilx.isTypeObject(1)).to.be(false);
            expect(utilx.isTypeObject(true)).to.be(false);
            expect(utilx.isTypeObject()).to.be(false);
            expect(utilx.isTypeObject(null)).to.be(false);
            expect(utilx.isTypeObject(utilx.noop)).to.be(false);
            expect(utilx.isTypeObject(returnArgs())).to.be(true);
            expect(utilx.isDate(new RegExp('test'))).to.be(false);
            expect(utilx.isDate(new Date())).to.be(true);
            expect(utilx.isDate(/test/)).to.be(false);
            expect(utilx.isDate([])).to.be(false);
            expect(utilx.isDate({})).to.be(false);
            expect(utilx.isDate('')).to.be(false);
            expect(utilx.isDate(1)).to.be(false);
            expect(utilx.isDate(true)).to.be(false);
            expect(utilx.isDate()).to.be(false);
            expect(utilx.isDate(null)).to.be(false);
            expect(utilx.isDate(utilx.noop)).to.be(false);
            expect(utilx.isDate(returnArgs())).to.be(false);
            expect(utilx.arrayIsArray(utilx.argumentsSlice(returnArgs()))).to.be(true);
            expect(utilx.arrayIsArray(utilx.argumentsSlice(returnArgs(null)))).to.be(true);
            expect(utilx.arrayIsArray(utilx.argumentsSlice(returnArgs(privateUndefined)))).to.be(true);
            expect(utilx.arrayIsArray(utilx.argumentsSlice(returnArgs(1, 2, 3)))).to.be(true);
            expect(utilx.arrayIsArray(utilx.argumentsSlice(returnArgs({}, {}, {})))).to.be(true);
            expect(utilx.stringTrim('')).to.be('');
            expect(utilx.stringTrim('     ')).to.be('');
            expect(utilx.stringTrim('x ')).to.be('x');
            expect(utilx.stringTrim(' x')).to.be('x');
            expect(utilx.stringTrim(' x ')).to.be('x');
            expect(utilx.stringTrim('    x x x    ')).to.be('x x x');
            expect(utilx.objectInstanceOf(new Date(), Date)).to.be(true);
            expect(utilx.objectInstanceOf(new RegExp(), RegExp)).to.be(true);
            expect(utilx.objectInstanceOf(new X(), X)).to.be(true);
            expect(utilx.isPlainObject()).to.be(false);
            expect(utilx.isPlainObject(null)).to.be(false);
            expect(utilx.isPlainObject(privateUndefined)).to.be(false);
            expect(utilx.isPlainObject([])).to.be(false);
            expect(utilx.isPlainObject({})).to.be(true);
            expect(utilx.isPlainObject(new X())).to.be(false);
            expect(utilx.isDateValid(new Date())).to.be(true);
            expect(utilx.isDateValid(new Date(NaN))).to.be(false);

            expect(utilx.hasProperty({
                foo: privateUndefined
            }, 'foo')).to.be(true);

            expect(utilx.hasProperty({}, 'toString')).to.be(true);
            expect(utilx.hasProperty({}, 'bar')).to.be(false);

            expect(utilx.objectHasOwnProperty({
                toString: privateUndefined
            }, 'toString')).to.be(true);

            expect(utilx.objectHasOwnProperty({}, 'toString')).to.be(false);
            expect(utilx.objectHasOwnProperty({}, 'bar')).to.be(false);
        });
    });
}());

(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
/**
 * @file {@link http://xotic750.github.io/util-x/ util-x}. A Javascript utility library..
 * @version 0.2.0
 * @author Graham Fairweather <xotic750@gmail.com>
 * @copyright Copyright (c) 2013 Graham Fairweather
 * @license {@link <http://www.gnu.org/licenses/gpl-3.0.html> GPL3}
 * @module util-x
 */

/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*jslint
  maxerr:100, indent:2
*/

/*global
  define, global, module, self, window
*/

/*properties
  '', '\b', '\t', '\n', '\f', '\r', '"', '0', '1', '1.', '10', '11', '2',
  '3', '4', '5', '6', '7', '8', '9', A, AffirmError, Array, AssertionError,
  Boolean, Ctr, DP, Date, EPSILON, Error, EvalError, Function, JSON,
  MAX_INT16, MAX_INT32, MAX_INT8, MAX_SAFE_INTEGER, MAX_UINT16, MAX_UINT32,
  MAX_UINT8, MAX_VALUE, MIN_INT16, MIN_INT32, MIN_INT8, MIN_SAFE_INTEGER,
  MIN_VALUE, Math, NEGATIVE_INFINITY, NEGATIVE_ZERO, NaN, Number, Object,
  POSITIVE_INFINITY, POSITIVE_ZERO, RM, RangeError, ReferenceError, RegExp,
  RequireObjectCoercible, String, SyntaxError, ToMethod, ToNumber, ToObject,
  ToPrimitive, ToString, TypeError, UNSAFE_INTEGER, URIError, UWORD16,
  UWORD32, UWORD8, Uint8Array, WORD16, WORD32, WORD8, '\\', abs, actual, add,
  alert, amd, anchor, apply, areSameClass, areSameTypeOf, assert, assign,
  bind, c, call, captureStackTrace, ceil, charAt, charCodeAt, clamp,
  clampToInt, classId, clipDuplicates, codePointAt, concat, configurable,
  console, constructor, contains, copyWithin, countCharacter, create,
  customError, customErrorReplacer, debug, deepEqual, deepFreeze,
  deepStrictEqual, defineGetter, defineProperties, defineProperty,
  defineSetter, doesNotThrow, e, endsWith, enumerable, equal, escapeRegex,
  every, exec, execSlice, expected, exports, factory, fail, fill, filter,
  find, findIndex, first, firstIn, floor, foo, forAll, forEach, forKeys,
  freeze, from, fromCharCode, fromCodePoint, get, getOwnPropertyDescriptor,
  getOwnPropertyNames, getPrototypeOf, getTime, getUTCDate, getUTCFullYear,
  getUTCHours, getUTCMilliseconds, getUTCMinutes, getUTCMonth, getUTCSeconds,
  global, goNative, hasOwn, hasOwnProperty, hasProperty, ifError, ignoreCase,
  inRange, index, indexOf, inherits, instanceOf, interimLastIndex, is,
  isArguments, isArray, isBoolean, isBytestring, isDate, isDigits, isEmpty,
  isError, isErrorTypeConstructor, isEven, isExtensible, isFinite, isFrozen,
  isFunction, isInt16, isInt32, isInt8, isInteger, isNaN, isNativeFunction,
  isNegative, isNumber, isNumeric, isOdd, isPlainObject, isPositive,
  isPrimitive, isPrototypeOf, isRegExp, isSafeInteger, isSealed, isString,
  isSymbol, isUint, isUint16, isUint32, isUint8, isUndefined, isValid, join,
  keys, last, lastIn, lastIndex, lastIndexOf, length, link, localeCompare,
  log, lookupGetter, lookupSetter, map, match, max, message, methods, min,
  minus, modulo, multiline, name, noop, normaliseErrorIEToStringOff,
  normaliseErrorIEToStringOn, normaliseErrorIEToStringState, normalize,
  notDeepEqual, notDeepStrictEqual, notEqual, notOk, notStrictEqual, now, of,
  ok, operator, outRange, padLeadingChar, parse, parseFloat, parseInt, plus,
  pop, pow, powerSet, preventExtensions, propertyIsEnumerable, proto,
  prototype, push, random, randomInt, reduce, reduceRight, regex, remove,
  repeat, replace, replaceAll, returnArgs, reverse, round, s, seal, search,
  sentinel, set, setPrototypeOf, shift, shuffle, sign, slice, some, sort,
  source, splice, split, sqrt, stableSort, stack, stackStartFn,
  stacktrace, startsWith, sticky, strictEqual, stringify, substr, substring,
  swapItems, test, throws, times, toExponential, toFixed, toISOString,
  toInt16, toInt32, toInt8, toInteger, toJSON, toLength, toLocaleLowerCase,
  toLocaleString, toLocaleUpperCase, toLowerCase, toObject, toPrecision,
  toSource, toString, toStringTag, toUint, toUint16, toUint32, toUint8,
  toUpperCase, trim, trimLeft, trimRight, trimString, truncate, typeOf,
  unique, unshift, unwatch, value, valueOf, version, watch, wrapInChars,
  writable, wsStr, hasDeleteBug, str, target, replacement, result,
  isCircular, a, b, cnt, minArgs, maxArgs, unwanted, searchOf, searchLastOf,
  chunk, isNull, isNil, condense, compact, object, flatten
*/

/**
 * Type consisting of the primitive values.
 * @typedef {(null|undefined|boolean|string|number)} module:util-x~primitive
 * @see https://goo.gl/McxjfR
 */

/**
 * A number or string to be used as a number.
 * @typedef {(number|string)} module:util-x~NumberLike
 */

/**
 * A string or number to be used as a string.
 * @typedef {(string|number)} module:util-x~StringLike
 */

/**
 * Host objects that are of an array structure.
 * @typedef {(Array|Arguments)} module:util-x~Arrays
 */

/**
 * Objects that are array like, in that they are an integer indexed list
 * that have a length property which is integer between 0 and 2^32-1 (inclusive)
 * @typedef {(Arrays|Object)} module:util-x~ArrayLike
 */

/**
 * This IIFE contains the private scope of the module.
 *
 * @alias module:util-x
 * @param {?(Object|boolean)} global Reference to the 'global'
 *                            object or false.
 * @param {?(Object|boolean)} module Reference to the 'module'
 *                            object or false - CMD.
 * @param {?(Object|boolean)} define Reference to the 'define'
 *                            object or false - AMD.
 * @param {undefined} Undefined An undefined variable.
 */
(function (global, module, define, Undefined) {
  'use strict';

  var base,

    // not every shim is compatable with every JS engine
    testShims = false,
    enableLog = true,
    $conlog,

    $affirm,

    // Shortcut number constants
    POSITIVE_ZERO = +0,
    NEGATIVE_ZERO = -0,
    WORD8 = 128,
    UWORD8 = 256,
    WORD16 = 32768,
    UWORD16 = 65536,
    WORD32 = 2147483648,
    UWORD32 = 4294967296,
    MAX_UINT32 = 4294967295,
    MAX_INT32 = 2147483647,
    MIN_INT32 = -2147483648,
    MAX_UINT16 = 65535,
    MAX_INT16 = 32767,
    MIN_INT16 = -32768,
    MAX_UINT8 = 255,
    MAX_INT8 = 127,
    MIN_INT8 = -128,
    MAX_SAFE_INTEGER = 9007199254740991,
    MIN_SAFE_INTEGER = -9007199254740991,
    UNSAFE_INTEGER = 9007199254740992,
    MAX_VALUE = 1.7976931348623157e+308,
    MIN_VALUE = 5e-324,
    EPSILON = 2.220446049250313e-16,
    INFINITY = 1 / POSITIVE_ZERO,
    NEGATIVE_INFINITY = 1 / NEGATIVE_ZERO,

    // 'Object#toString' result references.
    stringTagArguments = '[object Arguments]',
    stringTagFunction = '[object Function]',
    stringTagObject = '[object Object]',
    stringTagUndefined = '[object Undefined]',
    stringTagNull = '[object Null]',
    stringTagError = '[object Error]',
    stringTagRegExp = '[object RegExp]',
    stringTagArray = '[object Array]',
    stringTagDate = '[object Date]',
    stringTagString = '[object String]',
    stringTagBoolean = '[object Boolean]',
    stringTagNumber = '[object Number]',
    //stringTagSymbol = '[object Symbol]',


    //stringTagMap = '[object Map]',
    //stringTagSet = '[object Set]',
    //stringTagWeakMap = '[object WeakMap]',

    stringTagArrayBuffer = '[object ArrayBuffer]',
    stringTagFloat32Array = '[object Float32Array]',
    stringTagFloat64Array = '[object Float64Array]',
    stringTagInt8Array = '[object Int8Array]',
    stringTagInt16Array = '[object Int16Array]',
    stringTagInt32Array = '[object Int32Array]',
    stringTagUint8Array = '[object Uint8Array]',
    stringTagUint8ClampedArray = '[object Uint8ClampedArray]',
    stringTagUint16Array = '[object Uint16Array]',
    stringTagUint32Array = '[object Uint32Array]',

    stringTagHTMLCollection = '[object HTMLCollection]',
    stringTagNodeList = '[object NodeList]',

    hasAccessorSupport,
    stringProto = '__proto__',
    stringDefineGetter = '__defineGetter__',
    stringDefineSetter = '__defineSetter__',
    stringLookupGetter = '__lookupGetter__',
    stringLookupSetter = '__lookupGetter__',

    hintString = '',
    hintNumber = 0,

    propConstant,
    propNotEnumerable,
    shadowed,

    // Shortcuts,
    CError,
    CTypeError,
    CSyntaxError,
    CRangeError,
    CReferenceError,
    CEvalError,
    CURIError,
    CNumber,
    CString,
    CDate,
    CRegExp,
    CFunction,
    CBoolean,
    CArray,
    //CObject,

    protoObject,
    protoFunction,
    protoNumber,
    protoBoolean,
    protoString,
    protoDate,
    protoRegExp,
    protoArray,

    protoError,
    protoTypeError,
    protoSyntaxError,
    protoRangeError,
    protoEvalError,
    protoReferenceError,
    protoURIError,

    $Object,
    $Number,

    $min,
    $max,
    $floor,
    $abs,
    $ceil,
    $random,
    $sqrt,
    $pow,
    //mRound,
    $isFunction,
    $throwIfNotFunction,
    $toStringTag,
    hasDontEnumBug,
    hasProtoEnumBug,
    hasEnumArgsBug,
    hasEnumStringBug,
    hasBoxedStringBug,
    hasArrayLengthBug,

    unwantedError,

    hasErrorProps,
    //nonEnumProps,

    wspaceStrings,

    hasWorkingGOPD,
    hasProto,
    hasGetSet,
    isStrictMode,
    hasDeleteBug,
    hasCallBug,
    hasApplyBug,
    hasApplyRequiresArrayLikeBug,
    supportsApplyArrayLike,
    supportsXFrameClass,
    $pSlice,
    $pConcat,

    //hasWorkingCreate,

    // Shortcuts
    $String,
    pMatch,
    pSplit,
    pSearch,

    pCharCodeAt,
    pSIndexOf,

    pReplace,

    pHasOwn,

    pExec,
    pTest,

    //iBind,

    $hasProperty,
    $getItem,
    $toNumber,
    $instanceOf,
    $returnThis,
    $unshift,
    $shift,
    $reverse,
    $hasOwn,
    $repeat,
    $isNumber,
    $isBoolean,
    $isString,
    $isError,
    $isDate,
    $isNative,
    $isArguments,
    $isArray,
    $isRegExp,
    $isSymbol,
    $isInteger,
    $isSafeInteger,
    $isNumeric,
    $inRange,
    $isPlainObject,
    $isErrorTypeConstructor,
    $getPrototypeOf,
    $modulo,
    $forEach,
    $push,
    $pop,
    $deepEqual,
    $deepStrictEqual,
    $defineProperty,
    $defineProperties,
    $assign,
    $create,
    $objectKeys,
    $stringify,
    $truncate,
    $inherits,
    $stringContains,
    $exec,
    $test,
    $slice,
    $argSlice,
    $split,
    $replace,
    $splice,
    $isDigits,
    $join,
    $parseInt,
    $trim,
    $substr,
    $parseFloat,
    $randomInt,
    $pApply,
    $pCall,
    $call,
    $apply,
    $isNaN,
    $isFinite,
    $sort,
    $defProp,
    $deleteProperty,
    $sSlice,
    $forKeys,
    $indexOf,
    $isCircular,
    $propertyIsEnumerable,
    $toMethod,
    $escapeRegex,
    spIndexOf,
    spLastIndexOf,

    BigNum,

    exports;

  /**
   * The main namespace for methods and properties that are to be exported
   * from this library.
   *
   * @name module:util-x~exports
   * @namespace
   */
  exports = {
    /**
     * @name module:util-x~exports.Boolean
     * @namespace
     */
    Boolean: {
      /**
       * @name module:util-x~exports.Boolean.proto
       * @namespace
       */
      proto: {}
    },

    /**
     * @name module:util-x~exports.Number
     * @namespace
     */
    Number: {
      /**
       * @name module:util-x~exports.Number.proto
       * @namespace
       */
      proto: {}
    },

    /**
     * @name module:util-x~exports.String
     * @namespace
     */
    String: {
      /**
       * @name module:util-x~exports.String.proto
       * @namespace
       */
      proto: {}
    },

    /**
     * @name module:util-x~exports.Array
     * @namespace
     */
    Array: {
      /**
       * @name module:util-x~exports.Array.proto
       * @namespace
       */
      proto: {}
    },

    /**
     * @name module:util-x~exports.Object
     * @namespace
     */
    Object: {
      /**
       * @name module:util-x~exports.Object.proto
       * @namespace
       */
      proto: {}
    },

    /**
     * @name module:util-x~exports.Function
     * @namespace
     */
    Function: {
      /**
       * @name module:util-x~exports.Function.proto
       * @namespace
       */
      proto: {}
    },

    /**
     * @name module:util-x~exports.Date
     * @namespace
     */
    Date: {
      /**
       * @name module:util-x~exports.Date.proto
       * @namespace
       */
      proto: {}
    },

    /**
     * @name module:util-x~exports.Error
     * @namespace
     */
    Error: {
      /**
       * @name module:util-x~exports.Error.proto
       * @namespace
       */
      proto: {}
    },

    /**
     * @name module:util-x~exports.RegExp
     * @namespace
     */
    RegExp: {
      /**
       * @name module:util-x~exports.RegExp.proto
       * @namespace
       */
      proto: {}
    },

    /**
     * @name module:util-x~exports.MATH
     * @namespace
     */
    Math: {},

    /**
     * @name module:util-x~exports.JSON
     * @namespace
     */
    JSON: {}
  };

  /**
   * List of unwanted Error prototype prtoperty names that are enumerable.
   *
   * @private
   * @name module:util-x~unwantedError
   * @type {Array.<string>}
   */
  unwantedError = [];

  /**
   * Used to define property values.
   *
   * @private
   * @name module:util-x~propConstant
   * @namespace
   * @const
   * @property {boolean} enumerable false
   * @property {boolean} writable false
   * @property {boolean} configurable false
   */
  propConstant = {
    enumerable: false,
    writable: false,
    configurable: false
  };

  /**
   * Used to define property values.
   *
   * @private
   * @name module:util-x~propNotEnumerable
   * @namespace
   * @const
   * @property {boolean} enumerable false
   * @property {boolean} writable true
   * @property {boolean} configurable true
   */
  propNotEnumerable = {
    enumerable: false,
    writable: true,
    configurable: true
  };

  /**
   * @private
   * @name module:util-x~shadowed
   * @const
   * @type {Array.<string>}
   */
  shadowed = [
    'toString',
    'toLocaleString',
    'valueOf',
    'hasOwnProperty',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'constructor'
  ];

  /**
   * Holds references to language built ins.
   *
   * @private
   * @name module:util-x~base
   * @namespace
   */
  base = {
    /**
     * @private
     * @function
     */
    isNaN: global.isNaN,

    /**
     * @private
     * @function
     */
    isFinite: global.isFinite,

    /**
     * @private
     * @function
     */
    parseInt: global.parseInt,

    /**
     * @private
     * @function
     */
    parseFloat: global.parseFloat,

    /**
     * Holds references to the global Math methods and members.
     *
     * @private
     * @namespace
     */
    Math: {
      /**
       * @private
       * @function
       */
      sign: global.Math.sign,

      /**
       * @private
       * @function
       */
      min: global.Math.min,

      /**
       * @private
       * @function
       */
      max: global.Math.max,

      /**
       * @private
       * @function
       */
      floor: global.Math.floor,

      /**
       * @private
       * @function
       */
      ceil: global.Math.ceil,

      /**
       * @private
       * @function
       */
      abs: global.Math.abs,

      /**
       * @private
       * @function
       */
      random: global.Math.random,

      /**
       * @private
       * @function
       */
      pow: global.Math.pow,

      /**
       * @private
       * @function
       */
      sqrt: global.Math.sqrt,

      /**
       * @private
       * @function
       */
      round: global.Math.round
    },

    /**
     * @private
     * @namespace
     */
    Object: {
      /**
       * @private
       * @constructor
       */
      Ctr: global.Object,

      /**
       * @private
       * @type {Object}
       */
      proto: global.Object.prototype,

      /**
       * @private
       * @function
       */
      assign: global.Object.assign,

      /**
       * @private
       * @function
       */
      create: global.Object.create,

      /**
       * @private
       * @function
       */
      defineProperties: global.Object.defineProperties,

      /**
       * @private
       * @function
       */
      defineProperty: global.Object.defineProperty,

      /**
       * @private
       * @function
       */
      freeze: global.Object.freeze,

      /**
       * @private
       * @function
       */
      getOwnPropertyDescriptor: global.Object.getOwnPropertyDescriptor,

      /**
       * @private
       * @function
       */
      getOwnPropertyNames: global.Object.getOwnPropertyNames,

      /**
       * @private
       * @function
       */
      getPrototypeOf: global.Object.getPrototypeOf,

      /**
       * @private
       * @function
       */
      is: global.Object.is,

      /**
       * @private
       * @function
       */
      isExtensible: global.Object.isExtensible,

      /**
       * @private
       * @function
       */
      isFrozen: global.Object.isFrozen,

      /**
       * @private
       * @function
       */
      isSealed: global.Object.isSealed,

      /**
       * @private
       * @function
       */
      keys: global.Object.keys,

      /**
       * @private
       * @function
       */
      preventExtensions: global.Object.preventExtensions,

      /**
       * @private
       * @function
       */
      seal: global.Object.seal,

      /**
       * @private
       * @function
       */
      setPrototypeOf: global.Object.setPrototypeOf,

      /**
       * @private
       * @function
       */
      defineGetter: global.Object.prototype[stringDefineGetter],

      /**
       * @private
       * @function
       */
      defineSetter: global.Object.prototype[stringDefineSetter],

      /**
       * @private
       * @function
       */
      lookupGetter: global.Object.prototype[stringLookupGetter],

      /**
       * @private
       * @function
       */
      lookupSetter: global.Object.prototype[stringLookupSetter],

      /**
       * @private
       * @function
       */
      hasOwn: global.Object.prototype.hasOwnProperty,

      /**
       * @private
       * @function
       */
      isPrototypeOf: global.Object.prototype.isPrototypeOf,

      /**
       * @private
       * @function
       */
      propertyIsEnumerable: global.Object.prototype.propertyIsEnumerable,

      /**
       * @private
       * @function
       */
      toLocaleString: global.Object.prototype.toLocaleString,

      /**
       * @private
       * @function
       */
      toSource: global.Object.prototype.toSource,

      /**
       * @private
       * @function
       */
      toString: global.Object.prototype.toString,

      /**
       * @private
       * @function
       */
      unwatch: global.Object.prototype.unwatch,

      /**
       * @private
       * @function
       */
      valueOf: global.Object.prototype.valueOf,

      /**
       * @private
       * @function
       */
      watch: global.Object.prototype.watch
    },

    /**
     * Holds references to the global Array methods and members.
     *
     * @private
     * @namespace
     */
    Array: {
      /**
       * @private
       * @constructor
       */
      Ctr: global.Array,

      /**
       * @private
       * @type {Object}
       */
      proto: global.Array.prototype,

      /**
       * @private
       * @function
       */
      isArray: global.Array.isArray,

      /**
       * @private
       * @function
       */
      of: global.Array.of,

      /**
       * @private
       * @function
       */
      from: global.Array.from,

      /**
       * @private
       * @function
       */
      concat: global.Array.prototype.concat,

      /**
       * @private
       * @function
       */
      every: global.Array.prototype.every,

      /**
       * @private
       * @function
       */
      filter: global.Array.prototype.filter,

      /**
       * @private
       * @function
       */
      find: global.Array.prototype.find,

      /**
       * @private
       * @function
       */
      findIndex: global.Array.prototype.findIndex,

      /**
       * @private
       * @function
       */
      forEach: global.Array.prototype.forEach,

      /**
       * @private
       * @function
       */
      indexOf: global.Array.prototype.indexOf,

      /**
       * @private
       * @function
       */
      join: global.Array.prototype.join,

      /**
       * @private
       * @function
       */
      lastIndexOf: global.Array.prototype.lastIndexOf,

      /**
       * @private
       * @function
       */
      map: global.Array.prototype.map,

      /**
       * @private
       * @function
       */
      pop: global.Array.prototype.pop,

      /**
       * @private
       * @function
       */
      push: global.Array.prototype.push,

      /**
       * @private
       * @function
       */
      reduce: global.Array.prototype.reduce,

      /**
       * @private
       * @function
       */
      reduceRight: global.Array.prototype.reduceRight,

      /**
       * @private
       * @function
       */
      reverse: global.Array.prototype.reverse,

      /**
       * @private
       * @function
       */
      shift: global.Array.prototype.shift,

      /**
       * @private
       * @function
       */
      slice: global.Array.prototype.slice,

      /**
       * @private
       * @function
       */
      some: global.Array.prototype.some,

      /**
       * @private
       * @function
       */
      sort: global.Array.prototype.sort,

      /**
       * @private
       * @function
       */
      splice: global.Array.prototype.splice,

      /**
       * @private
       * @function
       */
      toString: global.Array.prototype.toString,

      /**
       * @private
       * @function
       */
      unshift: global.Array.prototype.unshift
    },

    /**
     * Holds references to the global String methods and members.
     *
     * @private
     * @namespace
     */
    String: {
      /**
       * @private
       * @constructor
       */
      Ctr: global.String,

      /**
       * @private
       * @type {Object}
       */
      proto: global.String.prototype,

      /**
       * @private
       * @function
       */
      fromCharCode: global.String.fromCharCode,

      /**
       * @private
       * @function
       */
      fromCodePoint: global.String.fromCodePoint,

      /**
       * @private
       * @function
       */
      anchor: global.String.prototype.anchor,

      /**
       * @private
       * @function
       */
      charAt: global.String.prototype.charAt,

      /**
       * @private
       * @function
       */
      charCodeAt: global.String.prototype.charCodeAt,

      /**
       * @private
       * @function
       */
      codePointAt: global.String.prototype.codePointAt,

      /**
       * @private
       * @function
       */
      concat: global.String.prototype.concat,

      /**
       * @private
       * @function
       */
      contains: global.String.prototype.contains,

      /**
       * @private
       * @function
       */
      endsWith: global.String.prototype.endsWith,

      /**
       * @private
       * @function
       */
      indexOf: global.String.prototype.indexOf,

      /**
       * @private
       * @function
       */
      lastIndexOf: global.String.prototype.lastIndexOf,

      /**
       * @private
       * @function
       */
      link: global.String.prototype.link,

      /**
       * @private
       * @function
       */
      localeCompare: global.String.prototype.localeCompare,

      /**
       * @private
       * @function
       */
      match: global.String.prototype.match,

      /**
       * @private
       * @function
       */
      normalize: global.String.prototype.normalize,

      /**
       * @private
       * @function
       */
      repeat: global.String.prototype.repeat,

      /**
       * @private
       * @function
       */
      replace: global.String.prototype.replace,

      /**
       * @private
       * @function
       */
      search: global.String.prototype.search,

      /**
       * @private
       * @function
       */
      slice: global.String.prototype.slice,

      /**
       * @private
       * @function
       */
      split: global.String.prototype.split,

      /**
       * @private
       * @function
       */
      startsWith: global.String.prototype.startsWith,

      /**
       * @private
       * @function
       */
      substr: global.String.prototype.substr,

      /**
       * @private
       * @function
       */
      substring: global.String.prototype.substring,

      /**
       * @private
       * @function
       */
      toLocaleLowerCase: global.String.prototype.toLocaleLowerCase,

      /**
       * @private
       * @function
       */
      toLocaleUpperCase: global.String.prototype.toLocaleUpperCase,

      /**
       * @private
       * @function
       */
      toLowerCase: global.String.prototype.toLowerCase,

      /**
       * @private
       * @function
       */
      toString: global.String.prototype.toString,

      /**
       * @private
       * @function
       */
      toUpperCase: global.String.prototype.toUpperCase,

      /**
       * @private
       * @function
       */
      trim: global.String.prototype.trim,

      /**
       * @private
       * @function
       */
      trimLeft: global.String.prototype.trimLeft,

      /**
       * @private
       * @function
       */
      trimRight: global.String.prototype.trimRight,

      /**
       * @private
       * @function
       */
      valueOf: global.String.prototype.valueOf
    },

    /**
     * Holds references to the global Number methods and members.
     *
     * @private
     * @namespace
     */
    Number: {
      /**
       * @private
       * @constructor
       */
      Ctr: global.Number,

      /**
       * @private
       * @type {Object}
       */
      proto: global.Number.prototype,

      /**
       * @private
       * @type {number}
       */
      EPSILON: global.Number.EPSILON,

      /**
       * @private
       * @type {number}
       */
      MAX_VALUE: global.Number.MAX_VALUE,

      /**
       * @private
       * @type {number}
       */
      MIN_VALUE: global.Number.MIN_VALUE,

      /**
       * @private
       * @type {number}
       */
      MAX_SAFE_INTEGER: global.Number.MAX_SAFE_INTEGER,

      /**
       * @private
       * @type {number}
       */
      MIN_SAFE_INTEGER: global.Number.MIN_SAFE_INTEGER,

      /**
       * @private
       * @type {number}
       */
      NaN: global.Number.NaN,

      /**
       * @private
       * @type {number}
       */
      POSITIVE_INFINITY: global.Number.POSITIVE_INFINITY,

      /**
       * @private
       * @type {number}
       */
      NEGATIVE_INFINITY: global.Number.NEGATIVE_INFINITY,

      /**
       * @private
       * @function
       */
      isFinite: global.Number.isFinite,

      /**
       * @private
       * @function
       */
      isInteger: global.Number.isInteger,

      /**
       * @private
       * @function
       */
      isSafeInteger: global.Number.isSafeInteger,

      /**
       * @private
       * @function
       */
      isNaN: global.Number.isNaN,

      /**
       * @private
       * @function
       */
      parseFloat: global.Number.parseFloat,

      /**
       * @private
       * @function
       */
      parseInt: global.Number.parseInt,

      /**
       * @private
       * @function
       */
      toExponential: global.Number.prototype.toExponential,

      /**
       * @private
       * @function
       */
      toFixed: global.Number.prototype.toFixed,

      /**
       * @private
       * @function
       */
      toLocaleString: global.Number.prototype.toLocaleString,

      /**
       * @private
       * @function
       */
      toPrecision: global.Number.prototype.toPrecision,

      /**
       * @private
       * @function
       */
      toString: global.Number.prototype.toString,

      /**
       * @private
       * @function
       */
      valueOf: global.Number.prototype.valueOf
    },

    /**
     * Holds references to the global Boolean methods and members.
     *
     * @private
     * @namespace
     */
    Boolean: {
      /**
       * @private
       * @constructor
       */
      Ctr: global.Boolean,

      /**
       * @private
       * @type {Object}
       */
      proto: global.Boolean.prototype,

      /**
       * @private
       * @function
       */
      toString: global.Boolean.prototype.toString,

      /**
       * @private
       * @function
       */
      valueOf: global.Boolean.prototype.valueOf
    },

    /**
     * Holds references to the global Function methods and members.
     *
     * @private
     * @namespace
     */
    Function: {
      /**
       * @private
       * @constructor
       */
      Ctr: global.Function,

      /**
       * @private
       * @type {Object}
       */
      proto: global.Function.prototype,

      /**
       * @private
       * @function
       */
      apply: global.Function.prototype.apply,

      /**
       * @private
       * @function
       */
      bind: global.Function.prototype.bind,

      /**
       * @private
       * @function
       */
      call: global.Function.prototype.call,

      /**
       * @private
       * @function
       */
      toString: global.Function.prototype.toString
    },

    /**
     * Holds references to the global RegExp methods and members.
     *
     * @private
     * @namespace
     */
    RegExp: {
      /**
       * @private
       * @constructor
       */
      Ctr: global.RegExp,

      /**
       * @private
       * @type {Object}
       */
      proto: global.RegExp.prototype,

      /**
       * @private
       * @function
       */
      exec: global.RegExp.prototype.exec,

      /**
       * @private
       * @function
       */
      test: global.RegExp.prototype.test,

      /**
       * @private
       * @function
       */
      toString: global.RegExp.prototype.toString
    },

    /**
     * Holds references to the global Date methods and members.
     *
     * @private
     * @namespace
     */
    Date: {
      /**
       * @private
       * @constructor
       */
      Ctr: global.Date,

      /**
       * @private
       * @type {Object}
       */
      proto: global.Date.prototype,

      /**
       * @private
       * @function
       */
      now: global.Date.now,

      /**
       * @private
       * @function
       */
      toJSON: global.Date.prototype.toJSON,

      /**
       * @private
       * @function
       */
      toISOString: global.Date.prototype.toISOString,

      /**
       * @private
       * @function
       */
      getTime: global.Date.prototype.getTime
    },

    /**
     * Holds references to the global Error methods and members.
     *
     * @private
     * @namespace
     */
    Error: {
      /**
       * @private
       * @constructor
       */
      Ctr: global.Error,

      /**
       * @private
       * @type {Object}
       */
      proto: global.Error.prototype
    },

    /**
     * Holds references to the global TypeError methods and members.
     *
     * @private
     * @namespace
     */
    TypeError: {
      /**
       * @private
       * @constructor
       */
      Ctr: global.TypeError,

      /**
       * @private
       * @type {Object}
       */
      proto: global.TypeError.prototype
    },

    /**
     * Holds references to the global SyntaxError methods and members.
     *
     * @private
     * @namespace
     */
    SyntaxError: {
      /**
       * @private
       * @constructor
       */
      Ctr: global.SyntaxError,

      /**
       * @private
       * @type {Object}
       */
      proto: global.SyntaxError.prototype
    },

    /**
     * Holds references to the global RangeError methods and members.
     *
     * @private
     * @namespace
     */
    RangeError: {
      /**
       * @private
       * @constructor
       */
      Ctr: global.RangeError,

      /**
       * @private
       * @type {Object}
       */
      proto: global.RangeError.prototype
    },

    /**
     * Holds references to the global EvalError methods and members.
     *
     * @private
     * @namespace
     */
    EvalError: {
      /**
       * @private
       * @constructor
       */
      Ctr: global.EvalError,

      /**
       * @private
       * @type {Object}
       */
      proto: global.EvalError.prototype
    },

    /**
     * Holds references to the global ReferenceError methods and members.
     *
     * @private
     * @namespace
     */
    ReferenceError: {
      /**
       * @private
       * @constructor
       */
      Ctr: global.ReferenceError,

      /**
       * @private
       * @type {Object}
       */
      proto: global.ReferenceError.prototype
    },

    /**
     * Holds references to the global Error methods and members.
     *
     * @private
     * @namespace
     */
    URIError: {
      /**
       * @private
       * @constructor
       */
      Ctr: global.URIError,

      /**
       * @private
       * @type {Object}
       */
      proto: global.URIError.prototype
    }
  };

  /**
   * Holds references to the global JSON methods and members. If it exists.
   *
   * @private
   * @namespace
   */
  base.JSON = {};
  if (typeof global.JSON === 'object' && global.JSON) {
    /**
     * @private
     * @function
     */
    base.JSON.parse = global.JSON.parse;

    /**
     * @private
     * @function
     */
    base.JSON.stringify = global.JSON.stringify;
  } else {
    base.JSON.parse = Undefined;
    base.JSON.stringify = Undefined;
  }

  /**
   * Prototypal function, as usually used in
   * {@link https://goo.gl/BHd0El}.
   * @typedef {Function} module:util-x~prototypalFunction
   * @param {...*} [varArgs]
   * @return {*}
   */

  /**
   * Stand alone function created from a
   * {@link prototypalFunction prototypalFunction}.
   * @typedef {Function} module:util-x~boundPrototypalFunction
   * @param {...*} [varArgs]
   * @return {*}
   */

  // Shortcuts
  CError = base.Error.Ctr;
  CTypeError = base.TypeError.Ctr;
  CSyntaxError = base.SyntaxError.Ctr;
  CRangeError = base.RangeError.Ctr;
  CReferenceError = base.ReferenceError.Ctr;
  CEvalError = base.EvalError.Ctr;
  CURIError = base.URIError.Ctr;
  CNumber = base.Number.Ctr;
  CString = base.String.Ctr;
  CDate = base.Date.Ctr;
  CRegExp = base.RegExp.Ctr;
  CFunction = base.Function.Ctr;
  CBoolean = base.Boolean.Ctr;
  CArray = base.Array.Ctr;
  //CObject = base.Object.Ctr;

  protoObject = base.Object.proto;
  protoFunction = base.Function.proto;
  protoNumber = base.Number.proto;
  protoBoolean = base.Boolean.proto;
  protoString = base.String.proto;
  protoDate = base.Date.proto;
  protoRegExp = base.RegExp.proto;
  protoArray = base.Array.proto;

  protoError = base.Error.proto;
  protoTypeError = base.TypeError.proto;
  protoSyntaxError = base.SyntaxError.proto;
  protoRangeError = base.RangeError.proto;
  protoEvalError = base.EvalError.proto;
  protoReferenceError = base.ReferenceError.proto;
  protoURIError = base.URIError.proto;

  $String = base.String.Ctr;
  pMatch = base.String.match;
  pSplit = base.String.split;
  pCharCodeAt = base.String.charCodeAt;
  pSIndexOf = base.String.indexOf;
  pReplace = base.String.replace;
  pSearch = base.String.search;
  pHasOwn = base.Object.hasOwnProperty;
  pExec = base.RegExp.exec;
  pTest = base.RegExp.test;

  /**
   * Shortcut
   * Replaced later
   * This method parses a string argument and returns a floating point number.
   *
   * @private
   * @function module:util-x~$parseFloat
   * @param {StringLike} inputArg
   * @return {number}
   * @see https://goo.gl/SVeQW2
   */
  $parseFloat = base.parseFloat;

  /**
   * Shortcut
   * The Object constructor creates an object wrapper.
   * Keeps jslint happy
   *
   * @private
   * @function module:util-x~$Object
   * @param {*} inputArg
   * @throws TypeError if inputArg is null or undefined
   * @return {Object}
   */
  $Object = base.Object.Ctr;

  /**
   * Shortcut
   * The Number constructor will typecast the argument to a number.
   * Keeps jslint happy
   *
   * @private
   * @function module:util-x~$Number
   * @param {*} inputArg
   * @throws TypeError if inputArg is null or undefined
   * @return {number}
   */
  $Number = base.Number.Ctr;

  /**
   * Shortcut
   * The String constructor creates an object wrapper.
   * Keeps jslint happy
   *
   * @private
   * @function module:util-x~$String
   * @param {*} inputArg
   * @throws TypeError if inputArg is null or undefined
   * @return {*}
   */
  $String = base.String.Ctr;

  /**
   * Shortcut
   *
   * @private
   * @function module:util-x~$min
   * @param {number} number
   * @return {number}
   */
  $min = base.Math.min;

  /**
   * Shortcut
   *
   * @private
   * @function module:util-x~$max
   * @param {number} number
   * @return {number}
   */
  $max = base.Math.max;

  /**
   * Shortcut
   *
   * @private
   * @function module:util-x~$floor
   * @param {number} number
   * @return {number}
   */
  $floor = base.Math.floor;

  /**
   * Shortcut
   *
   * @private
   * @function module:util-x~$abs
   * @param {number} number
   * @return {number}
   */
  $abs = base.Math.abs;

  /**
   * Shortcut
   *
   * @private
   * @function module:util-x~$ceil
   * @param {number} number
   * @return {number}
   */
  $ceil = base.Math.ceil;

  /**
   * Shortcut
   *
   * @private
   * @function module:util-x~$random
   * @return {number}
   */
  $random = base.Math.random;

  /**
   * Shortcut
   *
   * @private
   * @function module:util-x~$sqrt
   * @return {number}
   */
  $sqrt = base.Math.sqrt;

  /**
   * Shortcut
   *
   * @private
   * @function module:util-x~$pow
   * @return {number}
   */
  $pow = base.Math.pow;

  /**
   * Shortcut
   *
   * @private
   * @function module:util-x~$round
   * @return {number}
   */
  //$round = base.Math.round;

  /**
   * Returns the arguments at index.
   * Primarily to keep jslint happy
   *
   * @private
   * @function module:util-x~$getArgItem
   * @param {arguments} args
   * @param {number} index
   * @return {*}
   */
  /*
  function $getArgItem(args, index) {
    return args[index];
  }
  */

  /**
   * Set the value of the arguments at index.
   * Primarily to keep jslint happy
   *
   * @private
   * @function module:util-x~$setArgItem
   * @param {arguments} args
   * @param {number} index
   * @param {*} value
   * @return {*}
   */
  /*
  function $setArgItem(args, index, value) {
      args[index] = value;

      return value;
  }
  */

  /**
   * Returns the first argument unchanged.
   * Primary use with ToMethod.
   *
   * @private
   * @function module:util-x~$firstArg
   * @param {*} [arg]
   * @return {*}
   */
  function $firstArg() {
    return arguments[0];
  }

  /**
   * Returns an arguments object of the arguments supplied.
   *
   * @private
   * @name module:util-x~$returnArgs
   * @param {...*} [varArgs]
   * @return {Arguments}
   */
  function $returnArgs() {
    return arguments;
  }

  /**
   * Shortcut
   * Returns true if the operands are strictly equal with no type conversion.
   *
   * @private
   * @function module:util-x~$strictEqual
   * @param {*} a
   * @param {*} b
   * @return {boolean}
   * @see http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.4
   */
  function $strictEqual(a, b) {
    return a === b;
  }

  /**
   * Shortcut
   * Returns true if the operand inputArg is undefined.
   *
   * @private
   * @function module:util-x~$isUndefined
   * @param {*} inputArg
   * @return {boolean}
   */
  function $isUndefined(inputArg) {
    return typeof inputArg === 'undefined';
  }

  /**
   * Returns true if the operand inputArg is undefined.
   *
   * @function module:util-x~exports.Object.isUndefined
   * @param {*} inputArg
   * @return {boolean}
   */
  exports.Object.isUndefined = $isUndefined;

  /**
   * Returns true if the operand inputArg is null.
   *
   * @function module:util-x~exports.Object.isNull
   * @param {*} inputArg
   * @return {boolean}
   */
  exports.Object.isNull = function (inputArg) {
    return inputArg === null;
  };

  /**
   * Returns true if the operand inputArg is null or undefined.
   *
   * @function module:util-x~exports.Object.isNil
   * @param {*} inputArg
   * @return {boolean}
   */
  exports.Object.isNil = function (inputArg) {
    /*jslint eqeq:true */
    /*jshint eqnull:true */
    return inputArg == null;
  };

  /**
   * The abstract operation converts its argument to a value of type string
   *
   * @private
   * @function module:util-x~$toString
   * @param {*} inputArg
   * @return {string}
   * @see https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tostring
   */
  function $toString(inputArg) {
    var type,
      val;

    if (inputArg === null) {
      val = 'null';
    } else {
      type = typeof inputArg;
      if (type === 'string') {
        val = inputArg;
      } else if (type === 'undefined') {
        val = type;
      } else {
        if (type === 'symbol') {
          throw new CTypeError('Cannot convert symbol to string');
        }

        val = $String(inputArg);
      }
    }

    return val;
  }

  /**
   * The abstract operation throws an error if its argument is a value that
   * cannot be converted to an Object, otherwise returns the argument.
   *
   * @private
   * @function module:util-x~$requireObjectCoercible
   * @param {*} inputArg The object to be tested.
   * @throws {TypeError} If inputArg is null or undefined.
   * @return {*} The inputArg if coercible.
   * @see https://goo.gl/53jNbV
   */
  function $requireObjectCoercible(inputArg) {
    /*jslint eqeq:true */
    /*jshint eqnull:true */
    if (inputArg == null) {
      throw new CTypeError('Cannot convert argument to object: ' + inputArg);
    }

    return inputArg;
  }

  /**
   * Returns true if the operand inputArg is a member of one of the types
   * Undefined, Null, Boolean, Number, Symbol, or String.
   *
   * @private
   * @function module:util-x~isPrimitive
   * @param {*} inputArg
   * @return {boolean}
   * @see https://goo.gl/W68ywJ
   * @see https://goo.gl/ev7881
   */
  function $isPrimitive(inputArg) {
    var type;

    /*jslint eqeq:true */
    /*jshint eqnull:true */
    if (inputArg == null) {
      return true;
    }

    type = typeof inputArg;

    return type === 'boolean' ||
            type === 'string' ||
            type === 'number' ||
            type === 'symbol';
  }

  /**
   * Returns true if the operand inputArg is a member of one of the types
   * Undefined, Null, Boolean, Number, Symbol, or String.
   *
   * @function module:util-x~exports.Object.isPrimitive
   * @param {*} inputArg
   * @return {boolean}
   * @see https://goo.gl/W68ywJ
   * @see https://goo.gl/ev7881
   */
  exports.Object.isPrimitive = $isPrimitive;

  /**
   * The abstract operation converts its argument to a value of type Object but
   * fixes some environment bugs.
   *
   * @private
   * @function module:util-x~$toObject
   * @param {*} inputArg The argument to be converted to an object.
   * @throws {TypeError} If inputArg is not coercible to an object.
   * @return {Object} Value of inputArg as type Object.
   * @see http://www.ecma-international.org/ecma-262/5.1/#sec-9.9
   */
  function $toObject(inputArg) {
    var object;

    if ($isPrimitive($requireObjectCoercible(inputArg))) {
      object = $Object(inputArg);
    } else {
      object = inputArg;
    }

    return object;
  }

  /**
   * Shortcut
   * Redefined later
   * Returns true if the operand inputArg is a Date object.
   *
   * @private
   * @function module:util-x~$isDate
   * @param {*} inputArg
   * @return {boolean}
   */
  $isDate = function (inputArg) {
    return !$isPrimitive(inputArg) &&
            inputArg.constructor &&
            inputArg.constructor === CDate;
  };

  /**
   * Shortcut
   * Redefined later
   * Returns true if the operand inputArg is a Function
   * Replaced later on with a more reliable method, but we need to define
   * more functions first.
   *
   * @private
   * @function module:util-x~$isFunction
   * @param {*} [inputArg] The object to be tested.
   * @return {boolean} True if the object matches the duck typing,
   *                   otherwise false.
   * @see http://www.ecma-international.org/ecma-262/5.1/#sec-9.11
   */
  $isFunction = function (inputArg) {
    // Avoid a Chakra JIT bug in compatibility modes of IE 11
    return typeof inputArg === 'function' || false;
  };

  /**
   * Shortcut
   * Abstract operation that coerces its argument to a primitive value.
   *
   * @private
   * @function module:util-x~$toPrimitive
   * @param {*} [inputArg] The object to convert into a primitive.
   * @param {(string|number)} [preferredType] Anything other than a string or a
   *                                          number will be considered number
   *                                          by default.
   * @return {(string|number)}
   * @see https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toprimitive
   */
  function $toPrimitive(inputArg) {
    var methodNames,
      method,
      index,
      result,
      hint;

    /*
    exoticToPrim = inputarg['@@toPrimitive'];
    if (typeof exoticToPrim !== 'undefined') {
        result = inputarg['@@toPrimitive']();

        if ($isPrimitive(result)) {
            return result;
        }

        throw new CTypeError('exoticToPrim returned an object');
    }
    */

    if ($isPrimitive(inputArg)) {
      result = inputArg;
    } else {
      hint = typeof arguments[1];
      if (hint === 'string' || (hint !== 'number' && $isDate(inputArg))) {
        methodNames = ['toString', 'valueOf'];
      } else {
        methodNames = ['valueOf', 'toString'];
      }

      for (index = 0; index < 2; index += 1) {
        method = methodNames[index];
        if ($isFunction(inputArg[method])) {
          result = inputArg[method]();
          if ($isPrimitive(result)) {
            return result;
          }
        }
      }

      throw new CTypeError('ordinaryToPrimitive returned an object');
    }

    return result;
  }

  /**
   * Abstract operation that coerces its argument to a primitive value.
   *
   * @private
   * @function module:util-x~exports.Object.ToPrimitive
   * @param {*} [inputArg] The object to convert into a primitive.
   * @param {(string|number)} [preferredType] Anything other than a string or a
   *                                          number will be considered number
   *                                          by default.
   * @return {(string|number)}
   * @see https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toprimitive
   */
  exports.Object.ToPrimitive = $toPrimitive;

  /**
   * The abstract operation converts its argument to a value of type number but
   * fixes some environment bugs.
   *
   * @private
   * @function module:util-x~$toNumber
   * @param {*} inputArg The argument to be converted to an object.
   * @throws {TypeError} If inputArg is a symbol.
   * @throws {TypeError} If inputArg is a was not converted to a primitive.
   * @return {Object} Value of inputArg as type number.
   * @see https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tonumber
   */
  $toNumber = (function () {
    var tmp,
      fn;

    fn = function (inputArg) {
      var type,
        val;

      if (inputArg === null) {
        val = +0;
      } else {
        type = typeof inputArg;
        if (type === 'undefined') {
          val = NaN;
        } else if (type === 'boolean') {
          if (inputArg) {
            val = 1;
          } else {
            val = +0;
          }
        } else if (type === 'number') {
          val = inputArg;
        } else if (type === 'string') {
          val = $Number(inputArg);
        } else {
          if (type === 'symbol') {
            throw new TypeError('Can not convert symbol to a number');
          }

          val = fn($toPrimitive(inputArg, hintNumber));
        }
      }

      return val;
    };

    if (!testShims) {
      // Opera 9 fails this
      try {
        tmp = {};
        tmp = +tmp;
        tmp = {
          valueOf: ''
        };
        tmp = +tmp;
        tmp = {
          valueOf: '1'
        };
        tmp = +tmp;
        tmp = {
          valueOf: 1
        };
        tmp = +tmp;
        tmp = {
          valueOf: 1.1
        };
        tmp = +tmp;

        fn = function (inputArg) {
          return +inputArg;
        };
      } catch (ignore) {}
    }

    return fn;
  }());

  /**
   * The abstract operation converts its argument to a value of type number but
   * fixes some environment bugs.
   *
   * @function module:util-x~exports.Object.ToNumber
   * @param {*} inputArg The argument to be converted to an object.
   * @throws {TypeError} If inputArg is a symbol.
   * @throws {TypeError} If inputArg is a was not converted to a primitive.
   * @return {Object} Value of inputArg as type number.
   * @see https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tonumber
   */
  exports.Object.ToNumber = $toNumber;

  /**
   * Shortcut
   * Replaced later
   * Returns true if the argument coerces to NaN, and otherwise returns false.
   *
   * @private
   * @function module:util-x~$isNaN
   * @param {*} inputArg
   * @return {boolean}
   * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.2.4
   */
  $isNaN = function (inputArg) {
    var num = $toNumber(inputArg);

    return num !== num;
  };

  /**
   * Shortcut
   * Replaced later
   * Returns false if the argument coerces to NaN, +INFINITY, or
   * NEGATIVE_INFINITY, and otherwise returns true.
   *
   * @private
   * @function module:util-x~$isFinite
   * @param {*} inputArg
   * @return {boolean}
   * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.2.5
   */
  $isFinite = function (inputArg) {
    var num = $toNumber(inputArg);

    return num === num &&
            num !== INFINITY &&
            num !== NEGATIVE_INFINITY;
  };

  /**
   * The function evaluates the passed value and converts it to an integer.
   *
   * @private
   * @function module:util-x~$toInteger
   * @param {*} inputArg The object to be converted to an integer.
   * @return {number} If the target value is NaN, null or undefined, 0 is
   *                  returned. If the target value is false, 0 is returned
   *                  and if true, 1 is returned.
   * @see http://www.ecma-international.org/ecma-262/5.1/#sec-9.4
   */
  function $toInteger(inputArg) {
    var number = $toNumber(inputArg),
      val = 0;

    if (number === number) {
      if (!number || number === INFINITY || number === NEGATIVE_INFINITY) {
        val = number;
      } else {
        val = (number > 0 || -1) * $floor($abs(number));
      }
    }

    return val;
  }

  /**
   * Shortcut
   * Replaced later
   * The isInteger method determines whether the passed value is an integer.
   * If the target value is an integer, return true, otherwise return false.
   * If the value is NaN or infinite, return false.
   *
   * @private
   * @function module:util-x~$isInteger
   * @param {*} inputArg
   * @return {boolean}
   * @see https://goo.gl/AIekCc
   * @see https://goo.gl/zbc2nB
   */
  $isInteger = function (inputArg) {
    return typeof inputArg === 'number' &&
            inputArg !== INFINITY &&
            inputArg !== NEGATIVE_INFINITY &&
            $toInteger(inputArg) === inputArg;
  };

  /**
   * Shortcut
   * Replaced later
   * The isInteger method determines whether the passed value is an integer.
   * If the target value is an integer, return true, otherwise return false.
   * If the value is NaN or infinite, return false.
   *
   * @private
   * @function module:util-x~$isSafeInteger
   * @param {*} inputArg
   * @return {boolean}
   * @see https://goo.gl/CyRElr
   */
  $isSafeInteger = function (inputArg) {
    return typeof inputArg === 'number' &&
            inputArg !== INFINITY &&
            inputArg !== NEGATIVE_INFINITY &&
            $toInteger(inputArg) === inputArg &&
            inputArg >= MIN_SAFE_INTEGER &&
            inputArg <= MAX_SAFE_INTEGER;
  };

  /**
   * The abstract operation ToLength converts its argument to an integer
   * suitable for use as the length of an array-like object.
   *
   * @private
   * @function module:util-x~$toLength
   * @param {*} inputArg The object to be converted to a length.
   * @return {number} If len <= +0 then +0 else if len is +INFINITY then 2^53-1
   *                  else min(len, 2^53-1).
   * @see https://goo.gl/Mirlq3
   */
  function $toLength(inputArg) {
    return $min($max($toInteger(inputArg), 0), MAX_SAFE_INTEGER);
  }

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This function is based on ES `ToLength`. See the
   * [ES spec](https://goo.gl/Mirlq3) for more details.
   *
   * @private
   * @function module:util-x~$isLength
   * @param {*} inputArg The value to check.
   * @return {boolean} Returns `true` if `value` is a valid length,
   *                   else `false`.
   */
  function $isLength(inputArg) {
    return $isSafeInteger(inputArg) && inputArg >= 0;
  }

  /**
   * Checks if 'value' is a valid array-like index.
   *
   * @private
   * @function module:util-x~$isLength
   * @param {*} inputArg The value to check.
   * @param {number} [length] The upper bounds of a valid index otherwise
   *                          MAX_SAFE_INTEGER - 1.
   * @return {boolean} Returns true if inputArg is a valid index, otherwise
   *                   false.
   */
  function $isIndex(inputArg, length) {
    if ($toLength(arguments.length) > 1) {
      length = $toLength(length);
    } else {
      length = MAX_SAFE_INTEGER - 1;
    }

    inputArg = $toNumber(inputArg);

    return $isLength(inputArg) && inputArg < length;
  }

  /**
   * Indicates if delete throws an error on a property that does not exist.
   * True if it has, otherwise false.
   *
   * @private
   * @name module:util-x~hasDeleteBug
   * @type {boolean}
   */
  hasDeleteBug = (function () {
    var arr = [0, 1, 2, 3],
      rtn;

    try {
      delete arr[2];
      delete arr[2];

      rtn = false;
    } catch (e) {
      rtn = true;
    }

    return rtn;
  }());

  /**
   * Delete an item from an Array or Arguments object with delete bug. Internal
   * use only. Safari 5. IE has another delete bug w.r.t. globally defined
   * variables but I'm not going to mask that problem.
   *
   * @private
   * @function module:util-x~$deleteProperty
   * @param {Object} object
   * @param {string} property
   */
  $deleteProperty = (function () {
    var fn;

    if (hasDeleteBug) {
      fn = function (object, property) {
        try {
          return delete object[property];
        } catch (ehasDeleteBug) {
          return ehasDeleteBug;
        }
      };
    } else {
      fn = function (object, property) {
        return delete object[property];
      };
    }

    return fn;
  }());

  /**
   * Returns the this context of the function.
   *
   * @private
   * @function module:util-x~$returnThis
   * @return {*}
   */
  $returnThis = function () {
    return this;
  };

  /**
   * Indicates if running in strict mode.
   * True if we are, otherwise false.
   *
   * @private
   * @name module:util-x~isStrictMode
   * @type {boolean}
   */
  isStrictMode = !$returnThis();

  /**
   * Indicates if the this argument used with call does not convert to an
   * object when not strict mode. True if it does, otherwise false.
   *
   * @private
   * @name module:util-x~hasCallBug
   * @type {boolean}
   */
  hasCallBug = (function () {
    var returnThis = function () {
        return this;
      },
      rtn;

    // try in case call is missing
    try {
      rtn = !isStrictMode && typeof $call(returnThis, 'foo') === 'string';
    } catch (eHasCallBug) {
      rtn = false;
    }

    return rtn;
  }());

  /**
   * Indicates if the this argument used with apply does not convert to an
   * object when not strict mode. True if it does not, otherwise false.
   *
   * @private
   * @name module:util-x~hasApplyBug
   * @type {boolean}
   */
  hasApplyBug = (function () {
    var rtn;

    // try in case apply is missing
    try {
      rtn = !isStrictMode && typeof $returnThis.apply('foo') === 'string';
    } catch (eHasApplyArrayBug) {
      rtn = false;
    }

    return rtn;
  }());

  /**
   * Indicates if the arrayLike argument used must be an specified and
   * arrayLike. True if it does not, otherwise false.
   *
   * @private
   * @name module:util-x~hasApplyRequiresArrayLikeBug
   * @type {boolean}
   */
  hasApplyRequiresArrayLikeBug = (function () {
    var rtn;

    // try in case apply is missing
    try {
      $returnThis.apply('foo');
      rtn = false;
    } catch (eHasApplyRequiresArrayLikeBug) {
      rtn = true;
    }

    return rtn;
  }());

  /**
   * Indicates if apply works with ArrayLike objects.
   * True if it does not, otherwise false.
   *
   * @private
   * @name module:util-x~supportsApplyArrayLike
   * @type {boolean}
   */
  supportsApplyArrayLike = (function () {
    var returnArg0,
      rtn;

    returnArg0 = function (arg) {
      return arg;
    };

    // try in case apply is missing
    try {
      rtn = returnArg0.apply('foo', $returnArgs(1)) === 1;
      rtn = returnArg0.apply('foo', {
        0: 1,
        length: 1
      }) === 1;
    } catch (eHasApplyArrayBug) {
      rtn = false;
    }

    return rtn;
  }());

  /**
   * Indicates if a string suffers the "indexed accessability bug".
   * True if it does, otherwise false.
   *
   * @private
   * @name module:util-x~hasBoxedStringBug
   * @type {boolean}
   */
  hasBoxedStringBug = (function () {
    var boxedString = $Object('a');

    /*jstwit in: true */
    return boxedString[0] !== 'a' || !(0 in boxedString);
  }());

  /**
   * Shortcut
   * Redefined later
   * Returns true if the operand inputArg is a string.
   *
   * @private
   * @function module:util-x~$isString
   * @param {*} inputArg
   * @return {boolean}
   */
  $isString = function (inputArg) {
    return typeof inputArg === 'string' ||
            (!$isPrimitive(inputArg) &&
              typeof inputArg.length === 'number' &&
              'charAt' in inputArg);
  };

  /**
   * Shortcut
   * Redefined later
   * Returns true if the operand inputArg is an
   * {@link Arguments arguments} object.
   *
   * @private
   * @function module:util-x~$isArguments
   * @param {*} inputArg
   * @return {boolean}
   */
  $isArguments = function (inputArg) {
    return !$isPrimitive(inputArg) &&
            typeof inputArg.length === 'number' &&
            'callee' in inputArg &&
            !('arguments' in inputArg);
  };

  /**
   * @private
   * @function module:util-x~$hasProperty
   * @param {*} inputArg The object to be tested.
   * @param {string} property The property name.
   * @return {boolean} True if the property is on the object or in the object's
   *                   prototype, otherwise false.
   */
  $hasProperty = (function () {
    var fn,
      obj,
      val;

    if (hasBoxedStringBug) {
      fn = function (inputArg, property) {
        var prop = $toString(property);

        /*jstwit in: true */
        return ($isString(inputArg) &&
                $isIndex(prop, inputArg.length)) ||
                prop in $toObject(inputArg);
      };
    } else {
      val = 0;
      obj = $toObject('abc');
      try {
        if (val in obj && 'charAt' in obj) {
          fn = function (inputArg, property) {
            /*jstwit in: true */
            return property in $toObject(inputArg);
          };
        } else {
          throw 'requires toString';
        }
      } catch (eHasProperty) {
        fn = function (inputArg, property) {
          /*jstwit in: true */
          return $toString(property) in $toObject(inputArg);
        };
      }
    }

    return fn;
  }());

  /**
   * Forchecking an objects item by index. Can pacth or objects that don't work
   * with boxed index access. Primary use in Array shims.
   *
   * @private
   * @function module:util-x~$hasItem
   * @param {Object} object
   * @param {number} index
   * @param {boolean} isString
   * @return {boolean}
   */
  function $hasItem(object, index, isString) {
    return isString || $hasProperty(object, index);
  }

  /**
   * @private
   * @function module:util-x~$getName
   * @param {Object} object
   * @param {string} name
   * @return {string}
   */
  function $getName(object, name) {
    while (typeof object[name] !== 'undefined') {
      name += $toString($toInteger($random() * 100));
    }

    return name;
  }

  /**
   * Sets the arguments as per ES3 or ES5 non-strict spec.
   *
   * @private
   * @function module:util-x~$toObjectThisArg
   * @param {*} thisArg
   * @param {boolean} [strictMode]
   * @return {Object}
   */
  function $toObjectThisArg(thisArg, strictMode) {
    if (!strictMode) {
      /*jslint eqeq:true */
      /*jshint eqnull:true */
      if (thisArg == null) {
        thisArg = global;
      } else {
        thisArg = $Object(thisArg);
      }
    }

    return thisArg;
  }

  /**
   * @private
   * @function module:util-x~ $throwArgsWrongType
   * @param {*} inputArg
   * @return {*}
   */
  function $throwArgsWrongType(inputArg) {
    /*jslint eqeq:true */
    /*jshint eqnull:true */
    if (inputArg != null) {
      if ($isPrimitive(inputArg) ||
          (typeof inputArg.length === 'number' && 'charAt' in inputArg)) {

        throw new CTypeError('Arguments list has wrong type');
      }
    }

    return inputArg;
  }

  /**
   * ES3 spec shim
   *
   * @private
   * @function module:util-x~$evalCallApply
   * @param {*} thisArg
   * @param {string} name
   * @param {Function} func
   * @param {ArrayLike} args
   * @param {number} start
   * @return {*}
   */
  function $evalCallApply(thisArg, name, func, args, start) {
    var length = $toLength(args.length),
      last = length - 1,
      argsStrings = '',
      index,
      rtn,
      str;

    for (index = start; index < length; index += 1) {
      argsStrings += 'args[' + index + ']';
      if (index < last) {
        argsStrings += ',';
      }
    }

    thisArg = $toObjectThisArg(thisArg, false);
    name = $getName(thisArg, name);
    thisArg[name] = func;
    str = 'return function () { return fn[name](' + argsStrings + '); }();';
    /*jslint evil: true */
    rtn = new CFunction('fn', 'name', 'args', str)(thisArg, name, args);
    //rtn = eval('(thisArg[name](' + argsStrings + '))');
    /*jslint evil: false */
    $deleteProperty(thisArg, name);

    return rtn;
  }

  /**
   * This method calls a function with a given this value and arguments
   * provided as an array (or an array-like object).
   *
   * @private
   * @function module:util-x~$pApply
   * @this {Function}
   * @param {*} thisArg
   * @param {module:util-x~ArrayLike} [arrayLike]
   * @return {*}
   */
  $pApply = (function (apply) {
    var fn;

    if (!apply) {
      // ES3 spec
      fn = function (thisArg, arrayLike) {
        return $evalCallApply(
          thisArg,
          '__$pApply__',
          this,
          $Object($throwArgsWrongType(arrayLike)),
          0
        );
      };
    } else if (testShims || hasApplyBug || hasApplyRequiresArrayLikeBug ||
               !supportsApplyArrayLike) {

      // ES5 patch
      fn = (function () {
        return function (thisArg, arrayLike) {
          var object = $Object($throwArgsWrongType(arrayLike)),
            length = $toLength(object.length),
            name = $getName(this, '__$pApply_'),
            args = [],
            index,
            rtn;

          this[name] = apply;
          args.length = length;
          for (index = 0; index < length; index += 1) {
            args[index] = object[index];
          }

          rtn = this[name]($toObjectThisArg(thisArg, isStrictMode), args);
          $deleteProperty(this, name);

          return rtn;
        };
      }());
    } else {
      fn = apply;
    }

    return fn;
  }(base.Function.apply));

  /**
   * This method calls a function with a given this value and arguments
   * provided individually.
   *
   * @private
   * @function module:util-x~$pCall
   * @this {Function}
   * @param {*} thisArg
   * @param {*} [varArgs]
   * @return {*}
   */
  $pCall = (function (call) {
    var fn;

    if (!call) {
      // ES3 spec
      fn = function (thisArg) {
        return $evalCallApply(thisArg, '__$pCall__', this, arguments, 1);
      };
    } else if (testShims || hasCallBug) {
      // ES5 patch
      fn = (function () {
        return function (thisArg) {
          var length = $toLength(arguments.length),
            name = $getName(this, '__$pCall__'),
            args = [],
            index,
            rtn;

          this[name] = $pApply;
          args.length = length - 1;
          for (index = 1; index < length; index += 1) {
            args[index - 1] = arguments[index];
          }

          rtn = this[name]($toObjectThisArg(thisArg, isStrictMode), args);
          $deleteProperty(this, name);

          return rtn;
        };
      }());
    } else {
      fn = call;
    }

    return fn;
  }(base.Function.call));

  /**
   * This method calls a function with a given this value and arguments provided
   * individually.
   *
   * @private
   * @function module:util-x~$call
   * @param {Function} func
   * @param {*} thisArg
   * @param {*} [varArgs]
   * @return {*}
   */
  $call = function (func, thisArg) {
    var length = $toLength(arguments.length),
      name = $getName(func, '__$call__'),
      args = [],
      index,
      rtn;

    args.length = $toLength(length - 2);
    for (index = 2; index < length; index += 1) {
      args[index - 2] = arguments[index];
    }

    func[name] = $pApply;
    rtn = func[name](thisArg, args);
    $deleteProperty(func, name);

    return rtn;
  };

  /**
   * This method calls a function with a given this value and arguments provided
   * as an array (or an array-like object).
   *
   * @private
   * @function module:util-x~$apply
   * @param {Function} func
   * @param {*} thisArg
   * @param {module:util-x~ArrayLike} [arrayLike]
   * @return {*}
   */
  $apply = function (func, thisArg, arrayLike) {
    var name = $getName(func, '__$apply__'),
      rtn;

    func[name] = $pApply;
    rtn = func[name](thisArg, arrayLike);
    $deleteProperty(func, name);

    return rtn;
  };

  /**
   * For getting an objects item by index. Can pacth or objects that don't work
   * with boxed index access. Primary use in Array shims.
   *
   * @private
   * @function module:util-x~$getItem
   * @param {Object} object
   * @param {number} index
   * @param {boolean} isString
   * @return {*}
   */
  $getItem = (function (pCharAt) {
    return function (object, index, isString) {
      var item;

      if (hasBoxedStringBug && isString) {
        item = $call(pCharAt, object, index);
      } else {
        item = object[index];
        if (isString && typeof item === 'undefined') {
          item = '';
        }
      }

      return item;
    };
  }(base.String.charAt));

  /**
   * Provides a string representation of the supplied object in the form
   * "[object type]", where type is the object type.
   *
   * @private
   * @function module:util-x~$toStringTag
   * @param {*} inputArg The object for which a class string represntation is
   *                     required.
   * @return {string} A string value of the form "[object type]".
   * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.2.4.2
   */
  $toStringTag = (function (pToString) {
    return function (inputArg) {
      var val;

      if (inputArg === null) {
        val = stringTagNull;
      } else if (typeof inputArg === 'undefined') {
        val = stringTagUndefined;
      } else {
        val = $call(pToString, inputArg);
      }

      return val;
    };
  }(base.Object.toString));

  /**
   * Creates a new array from the arraylike argument, starting at start and
   * ending at end. Combats issues where
   * {@link module:util-x~exports.Array.proto.slice} does not work on the
   * arguments object. Used in the
   * {@link module:util-x~exports.Array.proto.slice} shim when it fails tests,
   * and in the mission critical function {@link module:util-x~$toMethod}.
   *
   * @private
   * @function module:util-x~$pSlice
   * @this {module:util-x~ArrayLike} The object to be sliced.
   * @throws {TypeError} If args is not coercible to an object.
   * @param {module:util-x~NumberLike} [start] The starting index.
   * @param {module:util-x~NumberLike} [end] The ending index.
   * @return {Array} A new array containg the selection.
   * @see https://goo.gl/fJeIK1
   */
  $pSlice = function (start, end) {
    var object = $toObject(this),
      length = $toLength(object.length),
      isString = length && $isString(object),
      relativeStart = $toInteger(start),
      val = [],
      next = 0,
      relativeEnd,
      finalEnd,
      k;

    if (relativeStart < 0) {
      k = $max(length + relativeStart, 0);
    } else {
      k = $min(relativeStart, length);
    }

    if (typeof end === 'undefined') {
      relativeEnd = length;
    } else {
      relativeEnd = $toInteger(end);
    }

    if (relativeEnd < 0) {
      finalEnd = $max(length + relativeEnd, 0);
    } else {
      finalEnd = $min(relativeEnd, length);
    }

    finalEnd = $toLength(finalEnd);
    val.length = $toLength($max(finalEnd - k, 0));
    while (k < finalEnd) {
      if ($hasItem(object, k, isString)) {
        val[next] = $getItem(object, k, isString);
      }

      next += 1;
      k += 1;
    }

    return val;
  };

  /**
   * Shortcut
   * Creates a new array from arguments, starting at start and ending at end.
   * You should not slice on arguments because it prevents optimizations in
   * JavaScript engines (V8 for example). Instead, try constructing a new array
   * by iterating through the arguments object.
   *
   * @private
   * @function module:util-x~$argSlice
   * @param {module:util-x~ArrayLike} array
   * @param {module:util-x~NumberLike} [start]
   * @param {module:util-x~NumberLike} [end]
   * @return {Array}
   * @see https://goo.gl/fJeIK1
   */
  $argSlice = function (array, start, end) {
    return $call($pSlice, array, start, end);
  };

  /**
   * Shortcut
   * Replaced later
   * Creates a new array from arguments, starting at start and ending at end.
   *
   * @private
   * @function module:util-x~$slice
   * @param {module:util-x~ArrayLike} array
   * @param {module:util-x~NumberLike} [start]
   * @param {module:util-x~NumberLike} [end]
   * @return {Array}
   * @see https://goo.gl/fJeIK1
   */
  $slice = $argSlice;

  // redefinition
  $isFunction = (function (pOToString) {
    if (!($isFunction(/x/) || (global.Uint8Array &&
                               !$isFunction(global.Uint8Array)))) {

      return $isFunction;
    }

    return function (inputArg) {
      /*
       * The use of 'Object#toString' avoids issues with the 'typeof' operator
       * in older versions of Chrome and Safari which return 'function' for
       * regexes and Safari 8 equivalents which return 'object' for typed array
       * constructors.
       */
      return $call(pOToString, inputArg) === stringTagFunction;
    };
  }(base.Object.toString));

  /**
   * Throws a TypeError for argument not a fuction.
   *
   * @private
   * @function module:util-x~$throwNotFunction
   * @param {*} [inputArg] The object to be tested.
   * @throws {TypeError} If inputArg is not a function.
   */
  function $throwNotFunction(inputArg) {
    throw new CTypeError('Argument is not a function: ' + $toString(inputArg));
  }

  /**
   * Throws a TypeError if arguments is not a function otherwise returns the
   * function.
   *
   * @private
   * @function module:util-x~$throwIfNotFunction
   * @param {*} [inputArg] The object to be tested.
   * @throws {TypeError} If inputArg is not a function.
   * @return {Function} The supplied function.
   */
  $throwIfNotFunction = function (inputArg) {
    if (!$isFunction(inputArg)) {
      $throwNotFunction(inputArg);
    }

    return inputArg;
  };

  if (typeof window === 'function' || typeof window === 'object') {
    supportsXFrameClass = isStrictMode;
  }

  /**
   * @private
   * @function module:util-x~$checkCrossFrame
   * @param {Object} inputArg
   * @param {string} strCtr
   * @return {boolean}
   */
  function $checkXFrame(inputArg, strCtr) {
    var rtn;

    if (supportsXFrameClass === false) {
      rtn = inputArg.constructor && $toString(inputArg.constructor) === strCtr;
    } else {
      rtn = false;
    }

    return rtn;
  }

  /**
   * Throws a TypeError if the operand inputArg is not an object or not a
   * function, otherise returns the object.
   *
   * @private
   * @function module:util-x~$throwIfIsPrimitive
   * @param {*} inputArg
   * @throws {TypeError} If inputArg is not an object or a function.
   * @return {(Object|Function)}
   */
  function $throwIfIsPrimitive(inputArg) {
    if ($isPrimitive(inputArg)) {
      throw new CTypeError('called on non-object: ' + $toString(inputArg));
    }

    return inputArg;
  }

  /**
   * Returns true if the operand inputArg is a boolean.
   *
   * @private
   * @function module:util-x~$isBoolean
   * @param {*} inputArg
   * @return {boolean}
   */
  $isBoolean = (function (pOToString, strBool) {
    var hasBug;

    if ($call(pOToString, protoBoolean) !== stringTagBoolean) {
      hasBug = true;
    }

    return function (inputArg) {
      return typeof inputArg === 'boolean' ||
        (!$isPrimitive(inputArg) &&
         ((hasBug && inputArg === protoBoolean) ||
          $call(pOToString, inputArg) === stringTagBoolean ||
          $checkXFrame(inputArg, strBool)));
    };
  }(base.Object.toString, $toString(CBoolean)));

  /**
   * Returns true if the operand inputArg is a boolean.
   *
   * @function module:util-x~exports.Boolean.isBoolean
   * @param {*} inputArg
   * @return {boolean}
   */
  exports.Boolean.isBoolean = $isBoolean;

  /**
   * Returns true if the operand inputArg is a Number.
   *
   * @private
   * @function module:util-x~$isNumber
   * @param {*} inputArg
   * @return {boolean}
   */
  $isNumber = (function (pOToString, strNum) {
    var hasBug;

    if ($call(pOToString, protoNumber) !== stringTagNumber) {
      hasBug = true;
    }

    return function (inputArg) {
      return typeof inputArg === 'number' ||
        (!$isPrimitive(inputArg) &&
         ((hasBug && inputArg === protoNumber) ||
          $call(pOToString, inputArg) === stringTagNumber ||
          $checkXFrame(inputArg, strNum)));
    };
  }(base.Object.toString, $toString(CNumber)));

  /**
   * Returns true if the operand inputArg is a Number.
   *
   * @function module:util-x~exports.Number.isNumber
   * @param {*} inputArg
   * @return {boolean}
   */
  exports.Number.isNumber = $isNumber;

  // redefinition
  $isString = (function (pOToString, strStr) {
    var hasBug;

    if ($call(pOToString, protoString) !== stringTagString) {
      hasBug = true;
    }

    return function (inputArg) {
      if (typeof inputArg === 'string') {
        return true;
      }

      if (!$isPrimitive(inputArg)) {
        if (hasBug && inputArg === protoString) {
          return true;
        }

        if ($call(pHasOwn, inputArg, 'length')) {
          if ($call(pOToString, inputArg) === stringTagString ||
              $checkXFrame(inputArg, strStr)) {

            return true;
          }
        }
      }

      return false;
    };
  }(base.Object.toString, $toString(CString)));

  /**
   * Returns true if the operand inputArg is a string.
   *
   * @function module:util-x~exports.String.isString
   * @param {*} inputArg
   * @return {boolean}
   */
  exports.String.isString = $isString;

  /**
   * Returns true if the operand inputArg is a symbol.
   *
   * @private
   * @function module:util-x~$isSymbol
   * @param {*} inputArg
   * @return {boolean}
   */
  $isSymbol = function (inputArg) {
    return typeof inputArg === 'symbol';
  };

  /**
   * Returns true if the operand inputArg is a symbol.
   *
   * @function module:util-x~exports.Object.isSymbol
   * @param {*} inputArg
   * @return {boolean}
   */
  exports.Object.isSymbol = $isSymbol;

  /**
   * Shortcut
   * Replaced later
   * The function takes one argument inputArg, and returns the Boolean value
   * true if the argument is an object whose class internal property is "Array";
   * otherwise it returns false.
   *
   * @private
   * @function module:util-x~$isArray
   * @param {*} inputArg
   * @return {boolean}
   * @see https://goo.gl/pi0fcN
   */
  $isArray = (function (pOToString, strArr) {
    var hasBug;

    if ($call(pOToString, protoArray) !== stringTagArray) {
      hasBug = true;
    }

    return function (inputArg) {
      if (!$isPrimitive(inputArg)) {
        if (hasBug && inputArg === protoArray) {
          return true;
        }

        if ($call(pHasOwn, inputArg, 'length') &&
            !$call(pHasOwn, inputArg, 'callee')) {

          if ($call(pOToString, inputArg) === stringTagArray ||
              $checkXFrame(inputArg, strArr)) {

            return true;
          }
        }
      }

      return false;
    };
  }(base.Object.toString, $toString(CArray)));

  // redefinition
  $isArguments = (function (pOToString) {
    var isArgs = $call(pOToString, $returnArgs()) === stringTagArguments,
      fn;

    function duckType(inputArg) {
      return !$isPrimitive(inputArg) && $call(pHasOwn, inputArg, 'length') &&
        $call(pHasOwn, inputArg, 'callee') &&
        !$call(pHasOwn, inputArg, 'arguments');
    }

    if (isArgs) {
      fn = function (inputArg) {
        return !$isPrimitive(inputArg) && $call(pHasOwn, inputArg, 'length') &&
          ($call(pOToString, inputArg) === stringTagArguments ||
           (supportsXFrameClass === false && duckType(inputArg)));
      };
    } else {
      fn = duckType;
    }

    return fn;
  }(base.Object.toString));

  /**
   * Returns true if the operand inputArg is an {@link Arguments arguments}
   * object.
   *
   * @function module:util-x~exports.Object.isArguments
   * @param {*} inputArg
   * @return {boolean}
   */
  exports.Object.isArguments = $isArguments;

  /**
   * Shortcut
   * Returns true if the operand inputArg is a RegExp.
   *
   * @private
   * @function module:util-x~$isRegExp
   * @param {*} inputArg
   * @return {boolean}
   */
  $isRegExp = (function (pOToString, strRx) {
    var strTag = $call(pOToString, new CRegExp('x')),
      isRegExp = strTag === stringTagRegExp,
      stringTagSafariPrototype,
      hasBug1,
      hasBug2,
      fn;

    if (isRegExp) {
      stringTagSafariPrototype = '[object RegExpPrototype]';
      strTag = $call(pOToString, protoRegExp);
      if (strTag === stringTagSafariPrototype) {
        hasBug1 = true;
      } else if (strTag !== stringTagRegExp) {
        hasBug2 = true;
      }

      fn = function (inputArg) {
        var stringTag;

        if (!$isPrimitive(inputArg)) {
          stringTag = $call(pOToString, inputArg);
          if ($call(pHasOwn, inputArg, 'ignoreCase')) {
            if (stringTag === stringTagRegExp) {
              return true;
            }

            if (hasBug2 && inputArg === protoRegExp) {
              return true;
            }

            if ($checkXFrame(inputArg, strRx)) {
              return true;
            }
          }

          if (hasBug1 && stringTag === stringTagSafariPrototype) {
            return true;
          }
        }

        return false;
      };
    } else {
      fn = function (inputArg) {
        return !$isPrimitive(inputArg) &&
          $call(pHasOwn, inputArg, 'ignoreCase') &&
          typeof inputArg.ignoreCase === 'boolean' &&
          $call(pHasOwn, inputArg, 'global') &&
          typeof inputArg.global === 'boolean' &&
          $call(pHasOwn, inputArg, 'multiline') &&
          typeof inputArg.multiline === 'boolean' &&
          $call(pHasOwn, inputArg, 'source') &&
          typeof inputArg.source === 'string';
      };
    }

    return fn;
  }(base.Object.toString, $toString(CRegExp)));

  /**
   * Returns true if the operand inputArg is a RegExp.
   *
   * @function module:util-x~.exports.RegExp.$isRegExp
   * @param {*} inputArg
   * @return {boolean}
   */
  exports.RegExp.isRegExp = $isRegExp;

  /**
   * Returns true if the operand inputArg is an error.
   *
   * @private
   * @function module:util-x~$isError
   * @param {*} inputArg
   * @return {boolean}
   */
  $isError = (function (pOToString, strErr) {
    var hasBug;

    if ($call(pOToString, protoError) !== stringTagError) {
      hasBug = true;
    }

    return function (inputArg) {
      if (!$isPrimitive(inputArg)) {
        if (hasBug && inputArg === protoError) {
          return true;
        }

        if ($call(pHasOwn, inputArg, 'message')) {
          if ($call(pOToString, inputArg) === stringTagError ||
                $checkXFrame(inputArg, strErr)) {

            return true;
          }
        }
      }

      return false;
    };

  }(base.Object.toString, $toString(CError)));

  /**
   * Returns true if the operand inputArg is an error.
   *
   * @function module:util-x~exports.Error.isError
   * @param {*} inputArg
   * @return {boolean}
   */
  exports.Error.isError = $isError;

  // redefinition
  $isDate = (function (pOToString, strDate) {
    var hasBug;

    if ($call(pOToString, protoDate) !== stringTagArray) {
      hasBug = true;
    }

    return function (inputArg) {
      return !$isPrimitive(inputArg) && ((hasBug && inputArg === protoDate) ||
                $call(pOToString, inputArg) === stringTagDate ||
                $checkXFrame(inputArg, strDate));
    };
  }(base.Object.toString, $toString(CDate)));

  /**
   * Returns true if the operand inputArg is a Date object.
   *
   * @function module:util-x~exports.Date.isDate
   * @param {*} inputArg
   * @return {boolean}
   */
  exports.Date.isDate = $isDate;

  /**
   * Returns true if argument has own property of length
   * which is a safe integer and is greather or equal to 0.
   *
   * @private
   * @function module:util-x~$hasOwnValidLength
   * @param {*} inputArg
   * @return {boolean}
   * @see https://goo.gl/5R9DbH
   */
  function $hasOwnValidLength(inputArg) {
    var object = $toObject(inputArg);

    return ($call(pHasOwn, object, 'length') && $isLength(object.length)) ||
            (hasArrayLengthBug && $isArray(object));
  }

  /**
   * The function tests whether an object has in its prototype chain the
   * prototype property of a constructor.
   *
   * @private
   * @function module:util-x~$instanceOf
   * @param {Object} object The object to be tested.
   * @param {Function} ctr The constructor to test the object against
   * @throws {TypeError} If ctr is not a function.
   * @return {boolean} True if the constructor is in the object chain,
   *                   otherwise false.
   * @see https://goo.gl/8PaXMA
   */
  $instanceOf = (function (pIsPrototypeOf) {
    return function $instanceOf(object, ctr) {
      $throwIfNotFunction(ctr);

      return (!$isPrimitive(object) && (object instanceof ctr ||
              (!$isPrimitive(ctr.prototype) &&
               $call(pIsPrototypeOf, ctr.prototype, object))));
    };
  }(base.Object.isPrototypeOf));

  /**
   * @private
   * @function module:util-x~$bindArgs
   * @param {number} length
   * @param {string} [separator] A single comma with or without leading and
   *                             trailing space characters.
   * @return {string}
   */
  function $bindArgs(length, separator) {
    var len = $toLength(length),
      args = '',
      last,
      index;

    if (len) {
      if (typeof separator !== 'string' ||
          !$call(pTest, /^ *, *$/, separator)) {

        separator = ',';
      }

      last = len - 1;
      for (index = 0; index < len; index += 1) {
        args += '$' + index;
        if (index < last) {
          args += separator;
        }
      }
    }

    return args;
  }

  /**
   * Shortcut
   * Replaced later
   * Check to see if an object is a plain object (created using "{}" or
   * "new Object"). Some gotchas, not all browsers are equal and native objects
   * do not necessarily abide by the rules.
   *
   * @private
   * @function module:util-x~$isPlainObject
   * @param {Object} object
   * @return {boolean}
   */
  $isPlainObject = function (object) {
    return !$isPrimitive(object) && !$isFunction(object) &&
            !$isPrimitive(object.constructor) &&
            object.constructor.prototype === protoObject;
  };

  /**
   * Internal $affirm
   *
   * @private
   * @name module:util-x~$affirm
   * @namespace
   */
  $affirm = {};

  /**
   * @private
   * @constructor module:util-x~$affirm.AffirmError
   * @param {Object} opts
   */
  $affirm.AffirmError = (function () {
    function ClassEmpty() {
      return;
    }

    var fn = function (opts) {
      if (!$isPlainObject(opts)) {
        opts = {};
      }

      if (!$isFunction(opts.stackStartFn)) {
        opts.stackStartFn = $affirm.AffirmError;
      }

      $call(CError, this, opts.message, opts.stackStartFn);
      this.message = opts.message;
      this.actual = opts.actual;
      this.expected = opts.expected;
      this.operator = opts.operator;
    };

    ClassEmpty.prototype = protoError;
    fn.prototype = new ClassEmpty();
    fn.prototype.name = 'AffirmError';
    fn.prototype.constructor = fn;

    return fn;
  }());

  /**
   * @private
   * @function module:util-x~$throwIfNotEnoughArgs
   * @param {arguments} args
   * @param {number} requiredLength
   * @throws {SyntaxError} If args.length < requiredLength
   * @return {number} Arguments length
   */
  function $throwIfNotEnoughArgs(args, requiredLength) {
    var length = (!$isPrimitive(args) && $toLength(args.length)) || 0;

    if (length < $toLength(requiredLength)) {
      throw new CSyntaxError($toString(length) +
                             ' is not enough arguments, requires ' +
                             $toString(requiredLength));
    }

    return length;
  }

  /**
   * Throws an exception that displays the values for actual and expected
   * separated by the provided operator.
   *
   * @private
   * @function module:util-x~$affirm.fail
   * @param {*} actual
   * @param {*} expected
   * @param {string} message
   * @param {string} operator
   * @param {Function} [stackStartFn]
   * @throws {SyntaxError} If not enough arguments
   */
  $affirm.fail = function (actual, expected, message, operator, stackStartFn) {
    $throwIfNotEnoughArgs(arguments, 4);
    if (!$isFunction(stackStartFn)) {
      stackStartFn = $affirm.fail;
    }

    throw new $affirm.AffirmError({
      actual: actual,
      expected: expected,
      message: $toString(message),
      operator: $toString(operator),
      stackStartFn: stackStartFn
    });
  };

  /**
   * Create optional arguments for $affirm
   *
   * @private
   * @function module:util-x~$optArgs
   * @param {number} begin
   * @param {string} message
   * @param {Function} stackStartFn
   * @param {Function} caller
   * @return {Object}
   */
  function $optArgs(begin, message, stackStartFn, caller) {
    var length = $throwIfNotEnoughArgs(arguments, 4);

    begin = $toLength(begin);
    if (length === begin) {
      if ($isFunction(message)) {
        stackStartFn = message;
        message = 'undefined';
      } else {
        message = $toString(message);
      }
    } else if (length > begin) {
      message = $toString(message);
      if (!$isFunction(stackStartFn)) {
        stackStartFn = caller;
      }
    }

    return {
      message: message,
      stackStartFn: stackStartFn
    };
  }

  /**
   * Tests if value is truthy, it is equivalent to
   * $affirm.equal(!!value, true, message);
   *
   * @private
   * @function module:util-x~$affirm.ok
   * @param {*} value
   * @param {string} [message]
   * @param {Function} [stackStartFn]
   */
  $affirm.ok = function (guard, message, stackStartFn) {
    $throwIfNotEnoughArgs(arguments, 1);

    var opt;

    guard = !guard;
    if (guard) {
      opt = $optArgs(2, message, stackStartFn, $affirm.ok);
      $affirm.fail(!guard, true, opt.message, 'ok', opt.stackStartFn);
    }
  };

  /**
   * Tests shallow, coercive equality with the equal comparison operator ( == ).
   *
   * @private
   * @function module:util-x~$affirm.equal
   * @param {*} actual
   * @param {*} expected
   * @param {string} [message]
   * @param {Function} [stackStartFn]
   * @return {undefined}
   */
  $affirm.equal = function (actual, expected, message, stackStartFn) {
    $throwIfNotEnoughArgs(arguments, 2);

    var opt;

    /*jslint eqeq: true */
    if (actual != expected) {
      opt = $optArgs(3, message, stackStartFn, $affirm.equal);
      $affirm.fail(actual, expected, opt.message, '==', opt.stackStartFn);
    }
  };

  /**
   * Tests shallow, coercive non-equality with the not equal
   * comparison operator ( != ).
   *
   * @private
   * @function module:util-x~$affirm.notEqual
   * @param {*} actual
   * @param {*} expected
   * @param {string} [message]
   * @param {Function} [stackStartFn]
   */
  $affirm.notEqual = function (actual, expected, message, stackStartFn) {
    $throwIfNotEnoughArgs(arguments, 2);

    var opt;

    /*jslint eqeq:true */
    if (actual == expected) {
      opt = $optArgs(3, message, stackStartFn, $affirm.notEqual);
      $affirm.fail(actual, expected, opt.message, '!=', opt.stackStartFn);
    }
  };

  /**
   * Tests strict equality, as determined by the strict
   * equality operator ( === ).
   *
   * @private
   * @function module:util-x~$affirm.strictEqual
   * @param {*} actual
   * @param {*} expected
   * @param {string} [message }
   * @param {Function} [stackStartFn]
   */
  $affirm.strictEqual = function (actual, expected, message, stackStartFn) {
    $throwIfNotEnoughArgs(arguments, 2);

    var opt;

    if (actual !== expected) {
      opt = $optArgs(3, message, stackStartFn, $affirm.strictEqual);
      $affirm.fail(actual, expected, opt.message, '===', opt.stackStartFn);
    }
  };

  /**
   * Tests strict non-equality, as determined by the strict not
   * equal operator ( !== ).
   *
   * @private
   * @function module:util-x~$affirm.notStrictEqual
   * @param {*} actual
   * @param {*} expected
   * @param {string} [message }
   * @param {Function} [stackStartFn]
   */
  $affirm.notStrictEqual = function (actual, expected, message, stackStartFn) {
    $throwIfNotEnoughArgs(arguments, 2);

    var opt;

    if (actual === expected) {
      opt = $optArgs(3, message, stackStartFn, $affirm.notStrictEqual);
      $affirm.fail(actual, expected, opt.message, '!==', opt.stackStartFn);
    }
  };

  /**
   * Expects block to throw an error. error can be constructor,
   * regexp or validation function.
   *
   * @private
   * @function module:util-x~$affirm.throws
   * @param {Function} block
   * @param {Function} error
   * @param {string|function} [message]
   * @param {Function} [stackStartFn]
   */
  $affirm.throws = function (block, error, message, stackStartFn) {
    $throwIfNotEnoughArgs(arguments, 2);

    var actual,
      expected,
      opt;

    if ($isFunction(block)) {
      try {
        block();
      } catch (eBlock) {
        actual = eBlock;
      }
    }

    if ($isFunction(error)) {
      try {
        /*jslint newcap:true */
        throw new error();
      } catch (eError) {
        if ($instanceOf(eError, CError)) {
          expected = error;
        }
      }
    }

    if (!expected) {
      expected = CError;
    }

    if (!$instanceOf(actual, expected)) {
      opt = $optArgs(3, message, stackStartFn, $affirm.throws);
      $affirm.fail(actual, expected, opt.message, 'throws', opt.stackStartFn);
    }
  };

  /**
   * Expects block not to throw an error, see $affirm.throws for details.
   *
   * @private
   * @function module:util-x~$affirm.doesNotThrow
   * @param {Function} block
   * @param {string} [message0
   * @param {Function} [stackStartFn]
   */
  $affirm.doesNotThrow = function (block, message, stackStartFn) {
    $throwIfNotEnoughArgs(arguments, 1);

    var actual,
      opt;

    if ($isFunction(block)) {
      try {
        block();
      } catch (eBlock) {
        actual = eBlock;
      }
    }

    if (typeof actual !== 'undefined') {
      opt = $optArgs(2, message, stackStartFn, $affirm.doesNotThrow);
      $affirm.fail(actual, Undefined, opt.message, 'doesNotThrow',
                   opt.stackStartFn);
    }
  };

  /**
   * Tests if value is not a falsy value, throws if it is a truthy value.
   * Useful when testing the first argument, error in callbacks.
   *
   * @private
   * @function module:util-x~$affirm.ifError
   * @param {*} [err]
   */
  $affirm.ifError = function (err) {
    if (err) {
      throw err;
    }
  };

  /**
   * @private
   * @function module:util-x~$decide
   * @param {Function|boolean} affirms A function that throws exceptions or
   *                                   boolean (coerced).
   * @param {Function|*} pass A function to be called or any value. If affirms
   *                          was called then the result of the call will be
   *                          supplied as an argument to a function.
   * @param {Function} fail A function to be called or any value. If affirms was
   *                        called then the result of the call will be supplied
   *                        as an argument to a function.
   * @param {string} [message] Any value will be coerced to a string for
   *                           logging.
   * @return {*}
   */
  function $decide(affirms, pass, fail, message) {
    $throwIfNotEnoughArgs(arguments, 3);

    var result,
      passed,
      returned;

    if ($isFunction(affirms)) {
      try {
        returned = affirms();
        passed = true;
      } catch (eAffirms) {
        message = $toString(message);
        $conlog(message, eAffirms);
        passed = false;
      }
    } else {
      if (affirms) {
        passed = true;
      } else {
        passed = false;
      }
    }

    if (passed) {
      if ($isFunction(pass)) {
        result = pass(returned);
      } else {
        result = pass;
      }

    } else {
      if ($isFunction(fail)) {
        result = fail(returned);
      } else {
        result = fail;
      }
    }

    return result;
  }

  /**
   * When the concat method is called with zero or more arguments item1, item2,
   * etc., it returns an array containing the array elements of the object
   * followed by the array elements of each argument in order.
   *
   * @private
   * @function module:util-x~$pConcat
   * @this {Array} array
   * @param {...*} [varArgs]
   * @return {Array}
   * @see https://goo.gl/aY7KDO
   */
  $pConcat = function () {
    var object = $toObject(this),
      length = $toLength(arguments.length),
      next = 0,
      val = [],
      element,
      index,
      len,
      k;

    for (index = -1; index < length; index += 1) {
      if (index === -1) {
        element = object;
      } else {
        element = arguments[index];
      }

      if ($isArray(element)) {
        k = 0;
        len = $toLength(element.length);
        while (k < len) {
          if ($hasProperty(element, k)) {
            val[next] = element[k];
            k += 1;
          } else {
            val[next] = element;
          }

          next += 1;
        }
      }
    }

    return val;
  };

  /**
   * @private
   * @function module:util-x~$conlog
   * @param {...*} [varArgs]
   */
  $conlog = (function (console) {
    var hasLog = !$isPrimitive(console) && !$isPrimitive(console.log),
      log,
      arr,
      fn;

    if (hasLog) {
      log = console.log;
      arr = ['Test log', true];

      try {
        $apply(log, console, arr);
        arr.length = 1;
        fn = function () {
          if (enableLog) {
            $apply(log, console, arguments);
          }
        };

        fn('Using function apply for logging');
      } catch (eFunction) {
        fn = null;
      }

      if (!fn) {
        try {
          log(arr[0]);
          log(arr[1]);
          fn = function () {
            var length,
              index;

            if (enableLog) {
              length = arguments.length;
              for (index = 0; index < length; index += 1) {
                log(arguments[index]);
              }
            }
          };

          fn('Using for loop for logging');
        } catch (eLoop) {
          fn = null;
        }
      }
    }

    if (!fn) {
      fn = function () {
        return;
      };
    }

    return function () {
      if (global.log && global.log.debug) {
        try {
          $apply(global.log.debug, global.log, arguments);
        } catch (ignore) {}
      }

      $apply(fn, null, arguments);
    };
  }(global.console));

  // redefinition
  $toStringTag = (function (pOToString) {
    return $decide(
      // test
      function () {
        var result;

        $affirm.ok(!testShims, 'testing shim');

        $affirm.doesNotThrow(function () {
          result = $call(pOToString);
        }, 'call no arg');

        $affirm.strictEqual(result, stringTagUndefined, 'no arg');

        $affirm.doesNotThrow(function () {
          result = $call(pOToString, Undefined);
        }, 'call undefined');

        $affirm.strictEqual(result, stringTagUndefined, 'undefined');

        $affirm.doesNotThrow(function () {
          result = $call(pOToString, null);
        }, 'call null');

        $affirm.strictEqual(result, stringTagNull, 'null');

        $affirm.doesNotThrow(function () {
          result = $call(pOToString, arguments);
        }, 'call arguments');

        $affirm.strictEqual(result, stringTagArguments, 'arguments');

        $affirm.doesNotThrow(function () {
          result = $call(pOToString, 'abc');
        }, 'call string');

        $affirm.strictEqual(result, stringTagString, 'string');

        $affirm.doesNotThrow(function () {
          result = $call(pOToString, $Object('abc'));
        }, 'call string object');

        $affirm.strictEqual(result, stringTagString, 'string object');

        $affirm.doesNotThrow(function () {
          result = $call(pOToString, []);
        }, 'call array');

        $affirm.strictEqual(result, stringTagArray, 'array');

        $affirm.doesNotThrow(function () {
          result = $call(pOToString, function () { return; });
        }, 'test3');

        $affirm.strictEqual(result, stringTagFunction, 'function');

        $affirm.doesNotThrow(function () {
          result = $call(pOToString, 1);
        }, 'call number');

        $affirm.strictEqual(result, stringTagNumber, 'number');

        $affirm.doesNotThrow(function () {
          result = $call(pOToString, $Object(1));
        }, 'call number object');

        $affirm.strictEqual(result, stringTagNumber, 'number object');

        $affirm.doesNotThrow(function () {
          result = $call(pOToString, true);
        }, 'call boolean');

        $affirm.strictEqual(result, stringTagBoolean, 'boolean');

        $affirm.doesNotThrow(function () {
          result = $call(pOToString, $Object(true));
        }, 'call boolean object');

        $affirm.strictEqual(result, stringTagBoolean, 'boolean object');

        $affirm.doesNotThrow(function () {
          result = $call(pOToString, new CRegExp(''));
        }, 'call regexp');

        $affirm.strictEqual(result, stringTagRegExp, 'regexp');

        $affirm.doesNotThrow(function () {
          result = $call(pOToString, new CDate());
        }, 'call date');

        $affirm.strictEqual(result, stringTagDate, 'date');

        $affirm.doesNotThrow(function () {
          result = $call(pOToString, new CError(''));
        }, 'call error');

        $affirm.strictEqual(result, stringTagError, 'error');
      },

      // pass
      function () {
        return function (inputArg) {
          return $call(pOToString, inputArg);
        };
      },

      // fail
      function () {
        return function (inputArg) {
          var val;

          if ($isPrimitive(inputArg)) {
            if (inputArg === null) {
              val = stringTagNull;
            } else if (typeof inputArg === 'undefined') {
              val = stringTagUndefined;
            }
          } else if ($call(pHasOwn, inputArg, 'length')) {
            if ($isArguments(inputArg)) {
              val = stringTagArguments;
            } else if ($isArray(inputArg)) {
              val = stringTagArray;
            } else if ($isString(inputArg)) {
              val = stringTagString;
            } else if ($isFunction(inputArg)) {
              val = stringTagFunction;
            }
          } else {
            if ($isNumber(inputArg)) {
              val = stringTagNumber;
            } else if ($isBoolean(inputArg)) {
              val = stringTagBoolean;
            } else if ($isRegExp(inputArg)) {
              val = stringTagRegExp;
            } else if ($isDate(inputArg)) {
              val = stringTagDate;
            } else if ($isError(inputArg)) {
              val = stringTagError;
            }
          }

          if (!val) {
            val = $call(pOToString, inputArg);
          }

          return val;
        };
      },

      // message
      'toStringTag patch'
    );
  }(base.Object.toString));

  /**
   * Indicates if the environment suffers the "don't enum bug".
   * True if it does, otherwise false.
   *
   * @private
   * @name module:util-x~hasDontEnumBug
   * @type {boolean}
   */
  hasDontEnumBug = !$call(base.Object.propertyIsEnumerable, {
    'toString': null
  }, 'toString');

  /**
   * Indicates if the environment's function objects suffer the "prototype is
   * enumerable bug". True if it does, otherwise false.
   *
   * @private
   * @name module:util-x~hasProtoEnumBug
   * @type {boolean}
   */
  hasProtoEnumBug = $call(base.Object.propertyIsEnumerable, function () {
    return;
  }, 'prototype');

  /**
   * Indicates if the arguments object suffers the "index enumeration bug".
   * True if it does, otherwise false.
   *
   * @private
   * @name module:util-x~hasEnumArgsBug
   * @type {boolean}
   */
  hasEnumArgsBug = (function () {
    var argObj = $returnArgs('h', 'e', 'j'),
      expected = {},
      prop;

    /*jslint forin: true */
    for (prop in argObj) {
      if (prop === '0' || prop === '1' || prop === '2') {
        expected[prop] = argObj[prop];
      }
    }

    return expected[0] !== 'h' || expected[1] !== 'e' || expected[2] !== 'j';
  }());

  /**
   * Indicates if a string suffers enumerable bug.
   *
   * @private
   * @name module:util-x~hasEnumStringBug
   * @type {boolean}
   */
  hasEnumStringBug = !$call(pHasOwn, 'x', '0');

  /**
   * Indicates if a arra suffers the "zero length array's length is not a number
   * bug". True if it does, otherwise false.
   *
   * @private
   * @name module:util-x~hasArrayLengthBug
   * @type {boolean}
   */
  hasArrayLengthBug = typeof [].length !== 'number';

  /**
   * Indicates if the Error object has additional enumerable properties.
   * True if it does, otherwise false.
   *
   * @private
   * @name module:util-x~hasErrorProps
   * @type {boolean}
   */
  hasErrorProps = (function () {
    var errObjs = [{
        name: 'Error',
        proto: protoError,
        unwanted: {}
      }, {
        name: 'TypeError',
        proto: protoTypeError,
        unwanted: {}
      }, {
        name: 'SyntaxError',
        proto: protoSyntaxError,
        unwanted: {}
      }, {
        name: 'RangeError',
        proto: protoRangeError,
        unwanted: {}
      }, {
        name: 'EvalError',
        proto: protoEvalError,
        unwanted: {}
      }, {
        name: 'ReferenceError',
        proto: protoReferenceError,
        unwanted: {}
      }, {
        name: 'URIError',
        proto: protoURIError,
        unwanted: {}
      }],
      length = $toLength(errObjs.length),
      hasDefProp = !!base.Object.defineProperty,
      found = false,
      index,
      name,
      prop,
      proto;

    unwantedError.length = 0;
    for (index = 0; index < length; index += 1) {
      name = errObjs[index].name;
      proto = errObjs[index].proto;
      /*jslint forin: true */
      for (prop in proto) {
        if ($call(pHasOwn, proto, prop)) {
          try {
            if (hasDefProp) {
              base.Object.defineProperty(proto, prop, propNotEnumerable);
              if ($call(base.Object.propertyIsEnumerable, proto, prop)) {
                throw new CError('Still enumerable');
              }

              $conlog('Unwanted error prop "' + prop + '": patched');
            } else {
              throw new CError('Still enumerable');
            }
          } catch (eUnwantedError) {
            found = true;
            errObjs[index].unwanted[prop] = proto[prop];
            $conlog('Unwanted "' + name + '" prop "' + prop +
                    '": patch failed');
          }
        }
      }
    }

    if (found) {
      unwantedError = errObjs;
    }

    return found;
  }());

  /**
   * Indicates if __proto__ is supported.
   * True if it is, otherwise false.
   *
   * @private
   * @name module:util-x~hasProto
   * @type {boolean}
   */
  hasProto = protoObject[stringProto] === null;

  /**
   * Indicates if __defineGetter__ and __lookupSetter__ are supported.
   * True if they are, otherwise false.
   *
   * @private
   * @name module:util-x~hasGetSet
   * @type {boolean}
   */
  hasGetSet = $isFunction(base.Object.lookupGetter) &&
              $isFunction(base.Object.lookupSetter);

  /**
   * The function takes an argument protoFn, and returns a bound function as a
   * stand alone method.
   *
   * @private
   * @function module:util-x~$toMethod
   * @param {prototypalFunction} protoFn A prototypal function to be converted
   *                                     to be bound as a stand alone method.
   * @throws {TypeError} If protoFn is not a function.
   * @param {Function} [checkThisArgFn] A function to perform any checks on
   *                                    thisArg. Default checkThisArgFn is to
   *                                    $requireObjectCoercible if none
   *                                    supplied or is not a function.
   * @return {module:util-x~boundPrototypalFunction} Stand alone method.
   */
  $toMethod = (function () {
    function method(pFn, cFn, thisArg, args) {
      var len = $toLength(args.length),
        result = [],
        idx;

      result.length = $toLength(len - 1);
      for (idx = 1; idx < len; idx += 1) {
        result[idx - 1] = args[idx];
      }

      return $apply(pFn, cFn(thisArg), result);
    }

    return function (protoFn, checkThisArgFn) {
      $throwIfNotFunction(protoFn);
      if (!$isFunction(checkThisArgFn)) {
        checkThisArgFn = $requireObjectCoercible;
      }

      var argsStr = $bindArgs($toLength(protoFn.length) + 1, ' ,'),
        theFn = 'return function (thisArg, ' + argsStr +
        ') { return apply(pFn, cFn, thisArg, arguments); };';

      /*jslint evil: true */
      return new CFunction('pFn', 'cFn', 'apply', theFn)(
        protoFn, checkThisArgFn, method
      );
    };
  }());

  // redefinition
  $slice = $toMethod($pSlice);

  $conlog('+++++++++ hasDontEnumBug: ' + hasDontEnumBug);
  $conlog('+++++++++ hasProtoEnumBug: ' + hasProtoEnumBug);
  $conlog('+++++++++ hasEnumArgsBug: ' + hasEnumArgsBug);
  $conlog('+++++++++ hasErrorProps: ' + hasErrorProps);
  $conlog('+++++++++ hasBoxedStringBug: ' + hasBoxedStringBug);
  $conlog('+++++++++ hasEnumStringBug: ' + hasEnumStringBug);
  $conlog('+++++++++ hasArrayLengthBug: ' + hasArrayLengthBug);
  $conlog('+++++++++ hasDeleteBug: ' + hasDeleteBug);
  $conlog('+++++++++ hasCallBug: ' + hasCallBug);
  $conlog('+++++++++ hasApplyBug: ' + hasApplyBug);
  $conlog('+++++++++ hasApplyRequiresArrayLikeBug: ' +
          hasApplyRequiresArrayLikeBug);
  $conlog('+++++++++ supportsApplyArrayLike: ' + supportsApplyArrayLike);
  $conlog('+++++++++ hasProto: ' + hasProto);
  $conlog('+++++++++ hasGetSet: ' + hasGetSet);
  $conlog('+++++++++ isStrictMode: ' + isStrictMode);

  /*
   *
   * EXPORTABLE CONSTANTS
   *
   */

  /**
   * @name module:util-x~exports.version
   * @type {string}
   * @const
   * @default 0.2.0
   */
  exports.version = '0.2.0';

  /**
   * @name module:util-x~exports.Number.POSITIVE_ZERO
   * @type {number}
   * @const
   * @default +0
   */
  exports.Number.POSITIVE_ZERO = POSITIVE_ZERO;

  /**
   * @name module:util-x~exports.Number.NEGATIVE_ZERO
   * @type {number}
   * @const
   * @default -0
   */
  exports.Number.NEGATIVE_ZERO = NEGATIVE_ZERO;

  /**
   * @name module:util-x~exports.Number.WORD8
   * @type {number}
   * @const
   * @default 128
   */
  exports.Number.WORD8 = WORD8;

  /**
   * @name module:util-x~exports.Number.UWORD8
   * @type {number}
   * @const
   * @default 256
   */
  exports.Number.UWORD8 = UWORD8;

  /**
   * @name module:util-x~exports.Number.WORD16
   * @type {number}
   * @const
   * @default 65536
   */
  exports.Number.WORD16 = WORD16;

  /**
   * @name module:util-x~exports.Number.UWORD16
   * @type {number}
   * @const
   * @default 32768
   */
  exports.Number.UWORD16 = UWORD16;

  /**
   * @name module:util-x~exports.Number.WORD32
   * @type {number}
   * @const
   * @default 2147483648
   */
  exports.Number.WORD32 = WORD32;

  /**
   * @name module:util-x~exports.Number.UWORD32
   * @type {number}
   * @const
   * @default 4294967296
   */
  exports.Number.UWORD32 = UWORD32;

  /**
   * @name module:util-x~exports.Number.MAX_UINT32
   * @type {number}
   * @const
   * @default 4294967295
   */
  exports.Number.MAX_UINT32 = MAX_UINT32;

  /**
   * @name module:util-x~exports.Number.MAX_INT32
   * @type {number}
   * @const
   * @default 2147483647
   */
  exports.Number.MAX_INT32 = MAX_INT32;

  /**
   * @name module:util-x~exports.Number.MIN_INT32
   * @type {number}
   * @const
   * @default -2147483648
   */
  exports.Number.MIN_INT32 = MIN_INT32;

  /**
   * @name module:util-x~exports.Number.MAX_UINT16
   * @type {number}
   * @const
   * @default 65535
   */
  exports.Number.MAX_UINT16 = MAX_UINT16;

  /**
   * @name module:util-x~exports.Number.MAX_INT16
   * @type {number}
   * @const
   * @default 32767
   */
  exports.Number.MAX_INT16 = MAX_INT16;

  /**
   * @name module:util-x~exports.Number.MIN_INT16
   * @type {number}
   * @const
   * @default -32768
   */
  exports.Number.MIN_INT16 = MIN_INT16;

  /**
   * @name module:util-x~exports.Number.MAX_UINT8
   * @type {number}
   * @const
   * @default 255
   */
  exports.Number.MAX_UINT8 = MAX_UINT8;

  /**
   * @name module:util-x~exports.Number.MAX_INT8
   * @type {number}
   * @const
   * @default 127
   */
  exports.Number.MAX_INT8 = MAX_INT8;

  /**
   * @name module:util-x~exports.Number.MIN_INT8
   * @type {number}
   * @const
   * @default -128
   */
  exports.Number.MIN_INT8 = MIN_INT8;

  /**
   * @name module:util-x~exports.Number.MAX_SAFE_INTEGER
   * @type {number}
   * @const
   * @default 9007199254740991
   */
  exports.Number.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;

  /**
   * @name module:util-x~exports.Number.MIN_SAFE_INTEGER
   * @type {number}
   * @const
   * @default -9007199254740991
   */
  exports.Number.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;

  /**
   * @name module:util-x~exports.Number.UNSAFE_INTEGER
   * @type {number}
   * @const
   * @default 9007199254740992
   */
  exports.Number.UNSAFE_INTEGER = UNSAFE_INTEGER;

  /**
   * @name module:util-x~exports.Number.MAX_VALUE
   * @type {number}
   * @const
   * @default 1.7976931348623157e+308
   */
  exports.Number.MAX_VALUE = MAX_VALUE;

  /**
   * @name module:util-x~exports.Number.MIN_VALUE
   * @type {number}
   * @const
   * @default 5e-324
   */
  exports.Number.MIN_VALUE = MIN_VALUE;

  /**
   * @name module:util-x~exports.Number.NaN
   * @type {number}
   * @const
   * @default NaN
   */
  exports.Number.NaN = NaN;

  /**
   * @name module:util-x~exports.Number.POSITIVE_INFINITY
   * @type {number}
   * @const
   * @default INFINITY
   */
  exports.Number.POSITIVE_INFINITY = INFINITY;

  /**
   * @name module:util-x~exports.Number.NEGATIVE_INFINITY
   * @type {number}
   * @const
   * @default NEGATIVE_INFINITY
   */
  exports.Number.NEGATIVE_INFINITY = NEGATIVE_INFINITY;

  /**
   * @name module:util-x~exports.Number.EPSILON
   * @type {number}
   * @const
   * @default 2.220446049250313e-16
   */
  exports.Number.EPSILON = EPSILON;

  /*
   *
   * EXPORTABLES THAT DO NOT RELY ON ANY OF OUR FUNCTIONS
   *
   */

  /**
   * Shortcut
   *
   * @private
   * @function module:util-x~noop
   * @return {undefined}
   */
  function noop() {
    return;
  }

  /**
   * Returns the primitive value of undefined.
   *
   * @function module:util-x~exports.Function.noop
   * @return {undefined}
   */
  exports.Function.noop = noop;

  /**
   * Returns an arguments object of the arguments supplied.
   *
   * @function module:util-x~exports.Function.returnArgs
   * @argument {...*} [varArgs]
   * @return {Arguments}
   */
  exports.Function.returnArgs = $returnArgs;

  /**
   * Returns a number clamped to the range set by min and max.
   *
   * @function module:util-x~exports.Number.clamp
   * @param {*} number
   * @param {*} min
   * @param {*} max
   * @return {number}
   */
  exports.Number.clamp = function (number, min, max) {
    return $min($max(number, min), max);
  };

  /**
   * Returns true if the operand inputArg is a number which is positive.
   *
   * @function module:util-x~exports.Number.isPositive
   * @param {*} inputArg
   * @return {boolean}
   */
  exports.Number.isPositive = function (inputArg) {
    var rtn;

    if (typeof inputArg !== 'number') {
      rtn = false;
    } else if (inputArg === 0) {
      rtn = 1 / inputArg === INFINITY;
    } else {
      rtn = inputArg > 0;
    }

    return rtn;
  };

  /**
   * Returns true if the operand inputArg is a number which is negative.
   *
   * @function module:util-x~exports.Number.isNegative
   * @param {*} inputArg
   * @return {boolean}
   */
  exports.Number.isNegative = function (inputArg) {
    var rtn;

    if (typeof inputArg !== 'number') {
      rtn = false;
    } else if (inputArg === 0) {
      rtn = 1 / inputArg !== INFINITY;
    } else {
      rtn = inputArg < 0;
    }

    return rtn;
  };

  /**
   * The abstract operation converts its argument to a value of type Object but
   * fixes some environment bugs. Should be a pointless check, as it should
   * never pass and always fail o the shim.
   *
   * @private
   * @function module:util-x~$toObject
   * @param {*} inputArg The argument to be converted to an object.
   * @throws {TypeError} If inputArg is not coercible to an object.
   * @return {Object} Value of inputArg as type Object.
   * @see http://www.ecma-international.org/ecma-262/5.1/#sec-9.9
   */
  $toObject = $decide(
    // test
    function () {
      var result;

      $affirm.ok(!testShims, 'testing shim');

      $affirm.throws(function () {
        $Object();
      }, CTypeError, 'no arguments');

      $affirm.throws(function () {
        $Object(Undefined);
      }, CTypeError, 'undefined');

      $affirm.throws(function () {
        $Object(null);
      }, CTypeError, 'null');

      $affirm.doesNotThrow(function () {
        result = $Object(false);
      }, 'boolean');

      $affirm.strictEqual(typeof result, 'object', 'boolean object');

      $affirm.doesNotThrow(function () {
        result = $Object(0);
      }, 'number');

      $affirm.strictEqual(typeof result, 'object', 'number object');

      $affirm.doesNotThrow(function () {
        result = $Object('');
      }, 'string');

      $affirm.strictEqual(typeof result, 'object', 'string');
    },

    // pass
    function () {
      return $Object;
    },

    // fail
    function () {
      return $toObject;
    },

    // message
    'ToObject patch'
  );

  /**
   * Shortcut
   * The abstract operation converts its argument to a value of type string
   *
   * @private
   * @function module:util-x~$toString
   * @param {*} inputArg
   * @return {string}
   * @see http://www.ecma-international.org/ecma-262/5.1/#sec-9.8
   */
  $toString = $decide(
    // test
    function () {
      $affirm.ok(!testShims, 'testing shim');

      /*jslint todo: true */
      /** @todo Decide if ToString () should be '' or 'undefined'? */
      /*jslint todo: false */
      $affirm.doesNotThrow(function () {
        $String();
      }, 'test1');

      $affirm.strictEqual($String(), 'undefined', 'test2');

      $affirm.doesNotThrow(function () {
        $String(Undefined);
      }, 'test3');

      $affirm.strictEqual($String(Undefined), 'undefined', 'test4');

      $affirm.doesNotThrow(function () {
        $String(null);
      }, 'test5');

      $affirm.strictEqual($String(null), 'null', 'test3');
    },

    // pass
    function () {
      return $String;
    },

    // fail
    function () {
      return $toString;
    },

    // message
    'ToString patch'
  );

  /**
   * The abstract operation converts its argument to a value of type string
   *
   * @function module:util-x~exports.String.ToString
   * @param {*} inputArg
   * @return {string}
   * @see http://www.ecma-international.org/ecma-262/5.1/#sec-9.8
   */
  exports.String.ToString = $toString;

  /**
   * Shortcut
   * Returns true if the operand inputArg is deemed numeric.
   *
   * @private
   * @function module:util-x~$isNumeric
   * @param {*} inputArg
   * @return {boolean}
   * @see http://stackoverflow.com/a/15043984/592253
   */
  $isNumeric = (function () {
    var plusMinus = new CRegExp('^[+\\-]?');

    return function (inputArg) {
      var val,
        string,
        number;

      if ($isNumber(inputArg) || $isString(inputArg)) {
        string = $call(pReplace, inputArg, plusMinus, '');
        number = $parseFloat(string);
        val = number === number && $isFinite(string);
      } else {
        val = false;
      }

      return val;
    };
  }());

  /**
   * Returns true if the operand inputArg is deemed numeric.
   *
   * @function module:util-x~exports.Object.isNumeric
   * @param {*} inputArg
   * @return {boolean}
   * @see http://stackoverflow.com/a/15043984/592253
   */
  exports.Object.isNumeric = $isNumeric;

  /**
   * Returns true if the operand value is greater than or equal to min and is
   * less than or equal to max.
   *
   * @function module:util-x~exports.Number.inRange
   * @param {module:util-x~NumberLike} value
   * @param {module:util-x~NumberLike} min
   * @param {module:util-x~NumberLike} max
   * @return {boolean}
   */
  exports.Number.inRange = function (value, min, max) {
    min = $toPrimitive(min, hintNumber);
    if (!$isNumber(min) && !$isNumeric(min)) {
      min = NaN;
    }

    max = $toPrimitive(max, hintNumber);
    if (!$isNumber(max) && !$isNumeric(max)) {
      max = NaN;
    }

    return $toNumber(value) >= $toNumber(min) && value <= $toNumber(max);
  };

  /**
   * Shortcut
   * Returns true if the operand value is greater than or equal to min and is
   * less than or equal to max.
   *
   * @private
   * @function module:util-x~$inRange
   * @param {module:util-x~NumberLike} value
   * @param {module:util-x~NumberLike} min
   * @param {module:util-x~NumberLike} max
   * @return {boolean}
   */
  $inRange = exports.Number.inRange;

  /**
   * Returns true if the operand value is less than or equal to min or is
   * greater than or equal to max.
   *
   * @function module:util-x~exports.Number.outRange
   * @param {module:util-x~NumberLike} value
   * @param {module:util-x~NumberLike} min
   * @param {module:util-x~NumberLike} max
   * @return {boolean}
   */
  exports.Number.outRange = function (value, min, max) {
    value = $toPrimitive(value, hintNumber);
    if ((!$isNumber(value) || value !== value) &&
        !$isNumeric(value)) {

      return true;
    }

    min = $toPrimitive(min, hintNumber);
    if ((!$isNumber(min) || min !== min) && !$isNumeric(min)) {
      return true;
    }

    max = $toPrimitive(max, hintNumber);
    if ((!$isNumber(max) || max !== max) && !$isNumeric(max)) {
      return true;
    }

    value = $toNumber(value);

    return value <= $toNumber(min) || value >= $toNumber(max);
  };

  /*
   *
   * EXPORTABLES THAT DO RELY ON ANY OF OUR FUNCTIONS
   *
   */

  /**
   * The abstract operation throws an error if its argument is a value that
   * cannot be  converted to an Object, otherwise returns the argument.
   *
   * @function module:util-x~exports.Object.RequireObjectCoercible
   * @param {*} inputArg
   * @throws {TypeError} If inputArg is null or undefined.
   * @return {*}
   * @see https://goo.gl/WBgacC
   */
  exports.Object.RequireObjectCoercible = $requireObjectCoercible;

  /**
   * Returns a string only if the arguments is coercible otherwise throws an
   * error.
   *
   * @private
   * @function module:util-x~$onlyCoercibleToString
   * @param {*} inputArg
   * @throws {TypeError} If inputArg is null or undefined.
   * @return {string}
   */
  function $onlyCoercibleToString(inputArg) {
    return $toString($requireObjectCoercible(inputArg));
  }

  /**
   * The abstract operation converts its argument to a value of type Object.
   *
   * @function module:util-x~exports.Object.ToObject
   * @param {*} inputArg
   * @return {Object}
   * @see http://www.ecma-international.org/ecma-262/5.1/#sec-9.9
   */
  exports.Object.ToObject = $toObject;

  /**
   * Returns true if the specified property is in the specified object.
   *
   * @function module:util-x~exports.Object.hasProperty
   * @param {Object} object The object that has was called upon.
   * @param {StringLike} property A string or numeric expression representing a
   *                              property name or array index.
   * @return {boolean}
   * @see http://www.ecma-international.org/ecma-262/5.1/#sec-11.8.7
   */
  exports.Object.hasProperty = $hasProperty;

  //
  (function (toStringTag) {
    var runIENativeFunction,
      isIENativeFunction,
      isNativeFunction,
      isFunctionInternal;

    try {
      /*
       * native function cannot be passed
       * to native Function.prototype.toString
       * as scope to evaluate ... only IE, sure
       */
      if (!$isPrimitive(global) && global.alert) {
        $call(base.Function.toString, global.alert);
      }

      runIENativeFunction = false;
    } catch (eRunIENativeFunction) {
      /**
       * Run a spcific detection on IE?
       *
       * @private
       * @type {boolean}
       */
      runIENativeFunction = true;
    }

    /**
     * Returns true if the operand inputArg is a native Function in IE.
     *
     * @private
     * @function isIENativeFunction
     * @param {*} inputArg
     * @return {boolean}
     */
    isIENativeFunction = (function () {
      /*
       * Are we in IE? How to define isIENativeFunction.
       */
      var typeofIE = runIENativeFunction && global.alert &&
                      typeof global.alert.toString,
        beginsFunction = new CRegExp('^\\s*\\bfunction\\b'),
        fn;

      if (typeofIE === 'undefined' &&
          $call(pTest, beginsFunction, global.alert)) {

        fn = function (inputArg) {
          /*
           * inputArg
           * we want return true or false
           *
           * inputArg.toString === undefined
           * native functions do not
           * contain a toString callback
           * as is for every user defined
           * function or object, even if deleted
           * so next step is a "safe" destructuration
           * assumption

           * test(beginsFunction, inputArg)
           * we are looking for a function
           * and IE shows them with function
           * as first word. Eventually
           * there could be a space
           * (never happened, it does not hurt anyway)
           */
          var type = typeof inputArg.toString;

          return type === 'undefined' && $call(pTest, beginsFunction, inputArg);
        };
      } else {
        fn = function () {
          return false;
        };
      }

      return fn;
    }());

    /**
     * Test if a function is native by simply trying to evaluate its original
     * Function.prototype.toString call. Used by
     * {@link exports.Function.isFunction}.
     *
     * @private
     * @function isNativeFunction
     * @param {*} inputArg
     * @return {boolean}
     */
    try {
      /*jslint evil: true */
      eval('(' + $call(base.Function.toString, CFunction) + ')');
      /*jslint evil: false */

      /*
       * Opera 10 doesn't play ball so have to test the string.
       */
      isNativeFunction = (function () {
        var operaNative = new CRegExp('^function \\S*\\(\\) \\{ ' +
            '(\\[native code\\]|\\/\\* source code not available \\*\\/) \\}$');

        return function (inputArg) {
          return $call(pTest, operaNative, inputArg);
        };
      }());
    } catch (eINF1) {
      isNativeFunction = function (inputArg) {
        var val;

        try {
          // no execution
          // just an error if it is native
          // every browser manifest native
          // functions with some weird char
          // that cannot be evaluated [native]
          /*jslint evil: true */
          eval('(' + inputArg.toString() + ')');
          /*jslint evil: false */
          val = false;
        } catch (eFnToString) {
          val = true;
        }

        return val;
      };
    }

    /**
     * Returns true if the operand inputArg is a Function.
     *
     * @private
     * @function isFunctionExtended
     * @param {*} inputArg
     * @return {boolean}
     */
    function isFunctionExtended(inputArg) {
      /*
       * it should be a function in any case
       * before we try to pass it to
       * Function.prototype.toString
       */
      return isFunctionInternal(inputArg, false) && isNativeFunction(inputArg);
    }

    /**
     * Returns true if the operand inputArg is a Function.
     *
     * @private
     * @function isFunctionInternal
     * @param {*} inputArg
     * @return {boolean}
     */
    if (runIENativeFunction) {
      // used when IE
      isFunctionInternal = function (inputArg, n) {
        var val;

        if (n) {
          val = isIENativeFunction(inputArg) || isFunctionExtended(inputArg);
        } else {
          val = $call(toStringTag, inputArg) === stringTagFunction;
        }

        return val;
      };
    } else {
      // this function is for every other browser
      isFunctionInternal = function (inputArg, n) {
        var val;

        if (n) {
          val = isFunctionExtended(inputArg);
        } else {
          val = $call(toStringTag, inputArg) === stringTagFunction;
        }

        return val;
      };
    }

    /**
     * Returns true if the operand inputArg is a Function.
     *
     * @function module:util-x~exports.Function.isFunction
     * @param {*} inputArg
     * @return {boolean}
     * @see http://www.ecma-international.org/ecma-262/5.1/#sec-9.11
     */
    exports.Function.isFunction = function (inputArg) {
      return !$isPrimitive(inputArg) && (isFunctionInternal(inputArg, false) ||
                                         isFunctionInternal(inputArg, true));
    };

    // redefinition
    $isFunction = exports.Function.isFunction;

    /**
     * Returns true if the operand inputArg is a native Function.
     *
     * @function module:util-x~exports.Function.isNativeFunction
     * @param {*} inputArg
     * @return {boolean}
     */
    if (runIENativeFunction) {
      exports.Function.isNativeFunction = function (inputArg) {
        return $isFunction(inputArg) && (isNativeFunction(inputArg) ||
                                         isIENativeFunction(inputArg));
      };
    } else {
      exports.Function.isNativeFunction = function (inputArg) {
        return $isFunction(inputArg) && isNativeFunction(inputArg);
      };
    }
  }(base.Object.toString));

  /**
   * Shortcut
   * Returns true if the operand inputArg is a native Function.
   *
   * @private
   * @function module:util-x~$isNative
   * @param {*} inputArg
   * @return {boolean}
   */
  $isNative = exports.Function.isNativeFunction;

  /**
   * @private
   * @function module:util-x~$affirmBasic
   * @param {Function} Fn Native prototype method
   * @return {Function}
   */
  function $affirmBasic(Fn) {
    return function () {
      $affirm.ok(!testShims, 'testing shim');
      $affirm.ok($isNative(Fn), 'not native');
    };
  }

  /**
   * This method calls a function with a given this value and arguments provided
   * individually.
   *
   * @function module:util-x~exports.Function.proto.call
   * @this {Function}
   * @param {*} thisArg
   * @param {*} [varArgs]
   * @return {*}
   */
  exports.Function.proto.call = (function () {
    return $decide(
      // test
      function () {
        $affirm.ok($isNative(base.Function.call), 'not native');
      },

      // pass
      function () {
        return $decide(
          // test
          function () {
            $affirm.ok(!testShims, 'testing patch');
            $affirm.ok(!hasCallBug, 'strict mode bug');
          },

          // pass
          function () {
            return $pCall;
          },

          // fail
          function () {
            return $pCall;
          },

          // message
          'Function.call patch'
        );
      },

      // fail
      function () {
        return $pCall;
      },

      // message
      'Function.call shim'
    );
  }());

  /**
   * This method calls a function with a given this value and arguments provided
   * individually.
   *
   * @function module:util-x~exports.Function.call
   * @param {Function} func
   * @param {*} thisArg
   * @param {*} [varArgs]
   * @return {*}
   */
  exports.Function.call = $call;

  /**
   * This method calls a function with a given this value and arguments provided
   * as an  array (or an array-like object).
   *
   * @function module:util-x~exports.Function.proto.apply
   * @this {Function}
   * @param {*} thisArg
   * @param {module:util-x~ArrayLike} [arrayLike]
   * @return {*}
   */
  exports.Function.proto.apply = (function () {
    return $decide(
      // test
      function () {
        $affirm.ok($isNative(base.Function.apply), 'not native');
      },

      // pass
      function () {
        return $decide(
          // test
          function () {
            $affirm.ok(!testShims, 'testing patch');
            $affirm.ok(!hasApplyBug, 'strict mode bug');
            $affirm.ok(!hasApplyRequiresArrayLikeBug,
                       'correct arguments and error throwing');
            $affirm.ok(supportsApplyArrayLike, 'supports array like objects');
          },

          // pass
          function () {
            return $pApply;
          },

          // fail
          function () {
            return $pApply;
          },

          // message
          'Function.apply patch'
        );
      },

      // fail
      function () {
        return $pApply;
      },

      // message
      'Function.apply shim'
    );
  }());

  /**
   * This method calls a function with a given this value and arguments provided
   * as an array (or an array-like object).
   *
   * @function module:util-x~exports.Function.apply
   * @param {Function} func
   * @param {*} thisArg
   * @param {module:util-x~ArrayLike} [arrayLike]
   * @return {*}
   */
  exports.Function.apply = $apply;

  /**
   * Shortcut
   * This method returns a string indicating the type of the unevaluated operand.
   *
   * @private
   * @function module:util-x~$typeOf
   * @param {*} inputArg
   * @return {string}
   */
  function $typeOf(inputArg) {
    var rtn;

    if ($isPrimitive(inputArg)) {
      rtn = typeof inputArg;
    } else if (!$isRegExp(inputArg) && $isFunction(inputArg)) {
      rtn = 'function';
    } else {
      rtn = 'object';
    }

    return rtn;
  }

  /**
   * This method returns a string indicating the type of the unevaluated
   * operand.
   *
   * @function module:util-x~exports.Object.typeOf
   * @param {*} inputArg
   * @return {string}
   */
  exports.Object.typeOf = $typeOf;

  /**
   * Returns true if the operands are of the same typeof.
   *
   * @function module:util-x~exports.Object.areSameTypeOf
   * @param {*} a
   * @param {...*} [b]
   * @return {boolean}
   */
  exports.Object.areSameTypeOf = function (a, b) {
    a = $typeOf(a);
    b = $typeOf(b);

    var same = a === b,
      length,
      index;

    if (same) {
      length = $toLength(arguments.length);
      for (index = 2; index < length; index += 1) {
        b = $typeOf(arguments[index]);
        same = a === b;
        if (!same) {
          break;
        }
      }
    }

    return same;
  };

  /**
   * Returns true if the operands are of the same object class.
   *
   * @function module:util-x~exports.Object.areSameClass
   * @param {*} a
   * @param {...*} [b]
   * @return {boolean}
   */
  exports.Object.areSameClass = function (a, b) {
    a = $toStringTag(a);

    var same = a === $toStringTag(b),
      length,
      index;

    if (same) {
      length = $toLength(arguments.length);
      for (index = 2; index < length; index += 1) {
        same = a === $toStringTag(arguments[index]);
        if (!same) {
          break;
        }
      }
    }

    return same;
  };

  /**
   * The function tests whether an object has in its prototype chain the
   * prototype property of a constructor.
   *
   * @function module:util-x~exports.Object.instanceOf
   * @param {Object} object
   * @param {Function} ctr
   * @return {boolean}
   * @see https://goo.gl/8PaXMA
   */
  exports.Object.instanceOf = $instanceOf;

  /**
   * Returns true if the argument coerces to NaN, and otherwise returns false.
   *
   * @function module:util-x~exports.isNaN
   * @param {*} number
   * @return {boolean}
   * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.2.4
   */
  exports.isNaN = $decide(
    // test
    $affirmBasic(base.isNaN),

    // pass
    function () {
      return base.isNaN;
    },

    // fail
    function () {
      return $isNaN;
    },

    // message
    'isNaN shim'
  );

  // redefinition
  $isNaN = exports.isNaN;

  /**
   * Returns false if the argument coerces to NaN, +INFINITY, or
   * NEGATIVE_INFINITY, and otherwise returns true.
   *
   * @private
   * @function module:util-x~exports.isFinite
   * @param {*} number
   * @return {boolean}
   * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.2.5
   */
  exports.isFinite = $decide(
    // test
    $affirmBasic(base.isFinite),

    // pass
    function () {
      return base.isFinite;
    },

    // fail
    function () {
      return $isFinite;
    },

    // message
    'isFinite shim'
  );

  // redefinition
  $isFinite = exports.isFinite;

  /**
   * Creates a new array from this array, starting at start and ending at end.
   *
   * @function module:util-x~exports.Array.proto.slice
   * @this {module:util-x~ArrayLike}
   * @param {module:util-x~NumberLike} [start]
   * @param {module:util-x~NumberLike} [end]
   * @return {Array}
   * @see https://goo.gl/fJeIK1
   */
  exports.Array.proto.slice = $decide(
    // test
    function () {
      $affirmBasic(base.Array.slice)();

      // should throw
      $affirm.throws(function () {
        $call(base.Array.slice);
      }, CTypeError, 'no arguments');

      $affirm.throws(function () {
        $call(base.Array.slice, Undefined);
      }, CTypeError, 'argument is undefined');

      $affirm.throws(function () {
        $call(base.Array.slice, null);
      }, CTypeError, 'argument is null');

      function createArray() {
        var length = arguments.length,
          result = [],
          idx;

        result.length = length;
        for (idx = 0; idx < length; idx += 1) {
          result[idx] = arguments[idx];

        }

        return result;
      }

      var someArgs = $returnArgs(Undefined, null, 1, 'a', 2, 'b', null,
                                 Undefined),
        someArray = createArray(Undefined, null, 1, 'a', 2, 'b', null,
                                Undefined),
        someObject = {
          0: Undefined,
          1: null,
          2: 1,
          3: 'a',
          4: 2,
          5: 'b',
          6: null,
          7: Undefined,
          length: 8
        },
        someString = '1234567890';

      function sOk(original, sliceArgs, expected) {
        var testSlice = $apply(base.Array.slice, original, sliceArgs),
          length = $toLength(expected.length),
          index,
          isOk = true;

        if ($toLength(testSlice.length) !== length) {
          isOk = false;
        } else {
          for (index = 0; index < length; index += 1) {
            if (testSlice[index] !== expected[index]) {
              isOk = false;
              break;
            }
          }
        }

        return isOk;
      }

      // works on array
      $affirm.ok(sOk(someArray, [],
        createArray(Undefined, null, 1, 'a', 2, 'b', null, Undefined)),
                 'test1');
      $affirm.ok(sOk(someArray, [Undefined, Undefined],
        createArray(Undefined, null, 1, 'a', 2, 'b', null, Undefined)),
                 'test2');
      $affirm.ok(sOk(someArray, [-1], createArray(Undefined)), 'test3');
      $affirm.ok(sOk(someArray, [0],
        createArray(Undefined, null, 1, 'a', 2, 'b', null, Undefined)),
                 'test4');
      $affirm.ok(sOk(someArray, [3],
        createArray('a', 2, 'b', null, Undefined)),
                 'test5');
      $affirm.ok(sOk(someArray, [-1, 4], []), 'test6');
      $affirm.ok(sOk(someArray, [0, 4],
        createArray(Undefined, null, 1, 'a')),
                 'test7');
      $affirm.ok(sOk(someArray, [3, 6], createArray('a', 2, 'b')), 'test8');

      // works on arguments
      $affirm.ok(sOk(someArgs, [],
        $returnArgs(Undefined, null, 1, 'a', 2, 'b', null, Undefined)),
                 'test9');
      $affirm.ok(sOk(someArgs, [Undefined, Undefined],
        $returnArgs(Undefined, null, 1, 'a', 2, 'b', null, Undefined)),
                 'test10');
      $affirm.ok(sOk(someArgs, [-1], $returnArgs(Undefined)), 'test11');
      $affirm.ok(sOk(someArgs, [0],
        $returnArgs(Undefined, null, 1, 'a', 2, 'b', null, Undefined)),
                 'test12');
      $affirm.ok(sOk(someArgs, [3],
        $returnArgs('a', 2, 'b', null, Undefined)),
                 'test13');
      $affirm.ok(sOk(someArgs, [-1, 4], []), 'test14');
      $affirm.ok(sOk(someArgs, [0, 4],
        $returnArgs(Undefined, null, 1, 'a')),
                 'test15');
      $affirm.ok(sOk(someArgs, [3, 6], $returnArgs('a', 2, 'b')), 'test16');

      // works on object with length
      $affirm.ok(sOk(someObject, [],
        createArray(Undefined, null, 1, 'a', 2, 'b', null, Undefined)),
                 'test17');
      $affirm.ok(sOk(someObject, [Undefined, Undefined],
        createArray(Undefined, null, 1, 'a', 2, 'b', null, Undefined)),
                 'test18');
      $affirm.ok(sOk(someObject, [-1], createArray(Undefined)), 'test19');
      $affirm.ok(sOk(someObject, [0],
        createArray(Undefined, null, 1, 'a', 2, 'b', null, Undefined)),
                 'test20');
      $affirm.ok(sOk(someObject, [3],
        createArray('a', 2, 'b', null, Undefined)),
                 'test21');
      $affirm.ok(sOk(someObject, [-1, 4], []), 'test22');
      $affirm.ok(sOk(someObject, [0, 4],
        createArray(Undefined, null, 1, 'a')),
                 'test23');
      $affirm.ok(sOk(someObject, [3, 6], createArray('a', 2, 'b')), 'test24');

      // works on strings
      $affirm.ok(sOk(someString, [],
        createArray('1', '2', '3', '4', '5', '6', '7', '8', '9', '0')),
                 'test25');
      $affirm.ok(sOk(someString, [Undefined, Undefined],
        createArray('1', '2', '3', '4', '5', '6', '7', '8', '9', '0')),
                 'test26');
      $affirm.ok(sOk(someString, [-1], createArray('0')), 'test27');
      $affirm.ok(sOk(someString, [0],
        createArray('1', '2', '3', '4', '5', '6', '7', '8', '9', '0')),
                 'test28');
      $affirm.ok(sOk(someString, [3],
        createArray('4', '5', '6', '7', '8', '9', '0')),
                 'test29');
      $affirm.ok(sOk(someString, [-1, 4], createArray()), 'test30');
      $affirm.ok(sOk(someString, [0, 4],
        createArray('1', '2', '3', '4')),
                 'test31');
      $affirm.ok(sOk(someString, [3, 6], createArray('4', '5', '6')), 'test32');
    },

    // pass
    function () {
      return base.Array.slice;
    },

    // fail
    function () {
      return $pSlice;
    },

    // message
    'Array.slice shim'
  );

  /**
   * Creates a new array from the argument array, starting at start and ending
   * at end.
   *
   * @function module:util-x~exports.Array.slice
   * @param {module:util-x~ArrayLike} array
   * @param {module:util-x~NumberLike} [start]
   * @param {module:util-x~NumberLike} [end]
   * @return {Array}
   * @see https://goo.gl/fJeIK1
   */
  exports.Array.slice = $toMethod(exports.Array.proto.slice);

  // redefinition
  $slice = exports.Array.slice;

  /**
   * The function takes one argument protoFn, and returns the bound function as
   * a stand alone method. Default this check is to
   * {@link $requireObjectCoercible}.
   *
   * @function module:util-x~exports.Function.ToMethod
   * @param {prototypalFunction} protoFn
   * @param {Function} checkThisArgFn
   * @throws {TypeError} If protoFn is not a {@link Function function}.
   * @return {boundPrototypalFunction}
   */
  exports.Function.ToMethod = $toMethod;

  /**
   * Return the String value that is the result of concatenating the three
   * Strings "[object ", class, and "]". I.e. [[Class]] A String value
   * indicating a specification defined classification of objects.
   *
   * @function module:util-x~exports.Object.toStringTag
   * @param {*} inputArg
   * @return {string}
   * @see http://www.ecma-international.org/ecma-262/5.1/#sec-8.6.2
   */
  exports.Object.toStringTag = $toStringTag;

  /**
   * Target function.
   * @typedef {Function} module:util-x~bindTargetFunction
   * @param {...*} [varArgs]
   * @return {*}
   */

  /**
   * Bound function.
   * @typedef {Function} module:util-x~boundFunction
   * @this thisArg
   * @param {...*} [varArgs]
   * @return {*}
   */

  /**
   * This function creates a new function (a bound function) with the same
   * function body (internal call property in ECMAScript 5 terms) as the
   * function it is being called on (the bound function's target function)
   * with the this value bound to thisArg,
   * which cannot be overridden.
   *
   * @function module:util-x~exports.Function.proto.bind
   * @this {module:util-x~bindTargetFunction}
   * @throws {TypeError} If fn is not a function.
   * @param {*} thisArg the this argument to be bound to the new function
   * @param {...*} [varArgs] any arguments to be bound to the new function.
   * @return {module:util-x~boundFunction}.
   * @see https://goo.gl/M5bttM
   */
  exports.Function.proto.bind = $decide(
    // test
    function () {
      $affirmBasic(base.Function.bind)();

      var bindArr = [1, 2, 3],
        BindCtr = $call(base.Function.bind, function () {
          return bindArr;
        }, null),
        bindObj = new BindCtr();

      $affirm.strictEqual(bindArr, bindObj, 'same array');

      function BindFn(x) {
        this.name = x || 'A';
      }

      BindCtr = $call(base.Function.bind, BindFn, null, 'B');
      bindObj = new BindCtr();

      $affirm.ok(bindObj instanceof BindFn, 'instanceof a');
      $affirm.ok(bindObj instanceof BindCtr, 'instanceof b');
      $affirm.strictEqual(bindObj.name, 'B', 'return B');
    },

    // pass
    function () {
      return base.Function.bind;
    },

    // fail
    function () {
      function BindCtr() {
        return;
      }

      function makeBound(binder, args) {
        /*jslint evil: true */
        return new CFunction(
          'binder', 'apply',
          'return function (' + args +
          ') { return apply(binder, this, arguments); };')(binder, $apply);
      }

      return function (thisArg) {
        var fn = $throwIfNotFunction(this),
          args = $argSlice(arguments, 1),
          bound = makeBound(function () {
            var binderArgs = [],
              len1 = $toLength(args.length),
              len2 = $toLength(arguments.length),
              result,
              idx;

            binderArgs.length = len1 + len2;
            for (idx = 0; idx < len1; idx += 1) {
              binderArgs[idx] = args[idx];
            }

            for (idx = 0; idx < len2; idx += 1) {
              binderArgs[len1 + idx] = arguments[idx];
            }

            if ($instanceOf(this, bound)) {
              result = $apply(fn, this, binderArgs);
              if ($Object(result) === result) {
                return result;
              }

              return this;
            }

            return $apply(fn, thisArg, binderArgs);
          }, $bindArgs(fn.length - args.length));

        if ($Object(fn.prototype) === fn.prototype) {
          BindCtr.prototype = fn.prototype;
          bound.prototype = new BindCtr();
          BindCtr.prototype = protoFunction;
        }

        return bound;
      };
    },

    // message
    'Function.bind shim'
  );

  /**
   * This function creates a new function (a bound function) with the same
   * function body (internal call property in ECMAScript 5 terms) as the
   * function it is being called on (the bound function's target function)
   * with the this value bound to thisArg,
   * which cannot be overridden.
   *
   * @function module:util-x~exports.Function.bind
   * @param {module:util-x~bindTargetFunction} fn
   * @throws {TypeError} If fn is not a {@link Function function}.
   * @param {*} thisArg the this argument to be bound to the new function
   * @param {...*} [varArgs] any arguments to be bound to the new function.
   * @return {module:util-x~boundFunction}.
   * @see https://goo.gl/M5bttM
   */
  exports.Function.bind = $toMethod(exports.Function.proto.bind);

  /**
   * The function takes one argument inputArg, and returns the Boolean value
   * true if the argument is an object  whose class internal property is
   * "Array"; otherwise it returns false.
   *
   * @function module:util-x~exports.Array.isArray
   * @param {*} inputArg
   * @return {boolean}
   * @see https://goo.gl/pi0fcN
   */
  exports.Array.isArray = $decide(
    // test
    function () {
      $affirmBasic(base.Array.isArray)();
      $affirm.ok(base.Array.isArray([]), 'is an array');
      $affirm.ok(!base.Array.isArray({}), 'is an array');
    },

    // pass
    function () {
      return base.Array.isArray;
    },

    // fail
    function () {
      return $isArray;
    },

    // message
    'Array.isArray shim'
  );

  // redefinition
  $isArray = exports.Array.isArray;

  /**
   * This method joins all elements of an array into a string.
   * The separator is converted to a string if necessary.
   * If omitted, the array elements are separated with a comma.
   *
   * @function module:util-x~exports.Array.proto.join
   * @this {module:util-x~ArrayLike}
   * @throws {TypeError} If inputArg is null or undefined.
   * @param {string} [separator]
   * @return {string}
   * @see https://goo.gl/q62UJk
   */
  exports.Array.proto.join = (function () {
    return $decide(
      // test
      $affirmBasic(base.Array.join),

      // pass
      function () {
        return $decide(
          // test
          function name() {
            $affirm.strictEqual($call(base.Array.join, [1, 2]),
                                '1,2', 'defaults to comma 1');
            $affirm.strictEqual($call(base.Array.join, [1, 2], Undefined),
                                '1,2', 'defaults to comma 2');
          },

          // pass
          function () {
            return base.Array.join;
          },

          // fail
          function () {
            var pJoin = base.Array.join;

            return function (separator) {
              $requireObjectCoercible(this);
              if (typeof separator === 'undefined') {
                separator = ',';
              }

              return $call(pJoin, this, separator);
            };
          },

          // message
          'Array.join patch'
        );
      },

      // fail
      function () {
        return function (separator) {
          var object = $toObject(this),
            length = $toLength(object.length),
            last = length - 1,
            result = '',
            index,
            val;

          if (typeof separator === 'undefined') {
            separator = ',';
          }

          separator = $toString(separator);
          for (index = 0; index < length; index += 1) {
            val = object[index];
            /*jslint eqeq:true */
            /*jshint eqnull:true */
            if (val != null) {
              result += $toString(val);
            }

            if (index < last) {
              result += separator;
            }
          }

          return result;
        };
      },

      // message
      'Array.join shim'
    );
  }());

  /**
   * This method joins all elements of an array into a string.
   * The separator is converted to a string if necessary.
   * If omitted, the array elements are separated with a comma.
   *
   * @function module:util-x~exports.Array.join
   * @param {module:util-x~ArrayLike} inputArg
   * @throws {TypeError} If inputArg is null or undefined.
   * @param {string} [separator]
   * @return {string}
   * @see https://goo.gl/q62UJk
   */
  exports.Array.join = $toMethod(exports.Array.proto.join);

  /**
   * Shortcut
   * This method joins all elements of an array into a string.
   * The separator is converted to a string if necessary.
   * If omitted, the array elements are separated with a comma.
   *
   * @private
   * @function module:util-x~$join
   * @param {module:util-x~ArrayLike} inputArg
   * @throws {TypeError} If inputArg is null or undefined.
   * @param {string} [separator]
   * @return {string}
   * @see https://goo.gl/q62UJk
   */
  $join = exports.Array.join;

  /**
   * Determines whether two values are the same value.
   *
   * @function module:util-x~exports.Object.is
   * @param {*} [x]
   * @param {*} [y]
   * @return {boolean}
   * @see https://goo.gl/5ELsFO
   */
  exports.Object.is = $decide(
    // test
    function () {
      $affirmBasic(base.Object.is)();
    },

    // pass
    function () {
      return base.Object.is;
    },

    // fail
    function () {
      return function (x, y) {
        var val;

        if (x === y) {
          val = x !== 0 || (1 / x) === (1 / y);
        } else {
          val = x !== x && y !== y;
        }

        return val;
      };
    },

    // message
    'Object.is shim'
  );

  /**
   * The function determines whether the passed value is NaN. More robust
   * version of the original global isNaN. NOTE This function differs from the
   * global isNaN function (18.2.3) is that it does not convert its argument
   * to a Number before determining whether it is NaN.
   *
   * @function module:util-x~exports.Number.isNaN
   * @param {*} inputArg
   * @return {boolean}
   * @see https://goo.gl/jSzul8
   */
  exports.Number.isNaN = $decide(
    // test
    function () {
      $affirmBasic(base.Number.isNaN)();
    },

    // pass
    function () {
      return base.Number.isNaN;
    },

    // fail
    function () {
      return function (inputArg) {
        return typeof inputArg === 'number' && base.isNaN(inputArg);
      };
    },

    // message
    'Number.isNaN shim'
  );

  /**
   * The function determines whether the passed value is finite.
   * More robust version of the original global isFinite.
   *
   * @function module:util-x~exports.Number.isFinite
   * @param {*} number
   * @return {boolean}
   * @see https://goo.gl/knTEhF
   */
  exports.Number.isFinite = $decide(
    // test
    function () {
      $affirmBasic(base.Number.isFinite)();
    },

    // pass
    function () {
      return base.Number.isFinite;
    },

    // fail
    function () {
      return function (number) {
        return typeof number === 'number' && number === number &&
                number !== INFINITY && number !== NEGATIVE_INFINITY;
      };
    },

    // message
    'Number.isFinite shim'
  );

  /**
   * The function returns the sign of a number, indicating whether the number is
   * positive, negative or zero. This function has 5 kinds of return values, 1,
   * -1, 0, -0, NaN, which represent "positive number", "negative number",
   * "positive zero",  "negative zero" and NaN respectively.
   *
   * @function module:util-x~exports.Math.sign
   * @param {*} value
   * @return {number}
   */
  exports.Math.sign = $decide(
    // test
    function () {
      $affirmBasic(base.Math.sign)();
    },

    // pass
    function () {
      return base.Math.sign;
    },

    // fail
    function () {
      return function (value) {
        return $toNumber(value) && ($toNumber(value >= 0) || -1);
      };
    },

    // message
    'Math.sign shim'
  );

  /**
   * The function evaluates the passed value and converts it to an integer.
   *
   * @function module:util-x~exports.Number.toInteger
   * @param {*} inputArg The object to be converted to an integer.
   * @return {number} If the target value is NaN, null or undefined, 0 is
   *                  returned. If the target value is false, 0 is returned and
   *                  if true, 1 is returned.
   * @see http://www.ecma-international.org/ecma-262/5.1/#sec-9.4
   */
  exports.Number.toInteger = $toInteger;

  $isInteger = $decide(
    // test
    $affirmBasic(base.Number.isInteger),

    // pass
    function () {
      return base.Number.isInteger;
    },

    // fail
    function () {
      return $isInteger;
    },

    // message
    'Number.isInteger shim'
  );

  /**
   * The isInteger method determines whether the passed value is an integer.
   * If the target value is an integer, return true, otherwise return false.
   * If the value is NaN or infinite, return false.
   *
   * @function module:util-x~exports.Number.isInteger
   * @param {*} inputArg
   * @return {boolean}
   * @see https://goo.gl/AIekCc
   * @see https://goo.gl/T2gVSh
   */
  exports.Number.isInteger = $isInteger;

  $isSafeInteger = $decide(
    // test
    function () {
      $affirmBasic(base.Number.isSafeInteger)();
      $affirm.ok(!base.Number.isSafeInteger(UNSAFE_INTEGER), 'max unsafe');
      $affirm.ok(!base.Number.isSafeInteger(-UNSAFE_INTEGER), 'min unsafe');
    },

    // pass
    function () {
      return base.Number.isSafeInteger;
    },

    // fail
    function () {
      return $isSafeInteger;
    },

    // message
    'Number.isSafeInteger shim'
  );

  /**
   * The isInteger method determines whether the passed value is an integer.
   * If the target value is an integer, return true, otherwise return false.
   * If the value is NaN or infinite, return false.
   *
   * @function module:util-x~exports.Number.isSafeInteger
   * @param {*} inputArg
   * @return {boolean}
   * @see https://goo.gl/GTxRU8
   */
  exports.Number.isSafeInteger = $isSafeInteger;

  /**
   * Shortcut
   * The abstract operation converts its argument to one of 2^32 integer values
   * in the range -2^31 through 2^31-1, inclusive.
   *
   * @private
   * @function module:util-x~toInt32
   * @param {*} inputArg
   * @return {number}
   */
  function toInt32(inputArg) {
    var number = $toNumber(inputArg),
      val = 0;

    if (number && number === number && number !== INFINITY &&
        number !== NEGATIVE_INFINITY) {

      val = ((number > 0 || -1) * $floor($abs(number))) % UWORD32;
      if (val > MAX_INT32) {
        val -= UWORD32;
      } else if (val < MIN_INT32) {
        val += UWORD32;
      }
    }

    return val;
  }

  /**
   * The abstract operation converts its argument to one of 2^32 integer values
   * in the range -2^31 through 2^31-1, inclusive.
   *
   * @function module:util-x~exports.Number.toInt32
   * @param {*} inputArg
   * @return {number}
   */
  exports.Number.toInt32 = toInt32;

  /**
   * The exports.Number.isInt32() method determines whether the passed value is
   * an integer. If the target value is an integer in the range -2^31 through
   * 2^31-1, inclusive, return true, otherwise return false. If the value is NaN
   * or infinite, return false.
   *
   * @function module:util-x~exports.Number.isInt32
   * @param {*} inputArg
   * @return {boolean}
   */
  exports.Number.isInt32 = function (inputArg) {
    return $isSafeInteger(inputArg) && inputArg >= MIN_INT32 &&
            inputArg <= MAX_INT32;
  };

  /**
   * The Number.modulo function is a modified implementation of the `%`
   * operator. This algorithm uses the formula `remainder = dividend - divisor *
   * quotient`; the `%` operator uses a truncating division. Known as Rounding
   * division, Floored division or Integer division.
   *
   * @function module:util-x~exports.Number.proto.modulo
   * @this {number}
   * @param {number} divisor
   * @return {number}
   * @see http://goo.gl/68uAd8
   */
  exports.Number.proto.modulo = function (divisor) {
    return this - divisor * $floor(this / divisor);
  };

  /**
   * The Number.modulo function is a modified implementation of the `%`
   * operator. This algorithm uses the formula `remainder = dividend - divisor *
   * quotient`; the `%` operator uses a truncating division. Known as Rounding
   * division, Floored division or Integer division.
   *
   * @function module:util-x~exports.Number.modulo
   * @param {number} dividend
   * @param {number} divisor
   * @return {number}
   * @see http://goo.gl/68uAd8
   */
  exports.Number.modulo = $toMethod(exports.Number.proto.modulo, $firstArg);

  /**
   * Shortcut
   * The Number.modulo function is a modified implementation of the `%`
   * operator. This algorithm uses the formula `remainder = dividend - divisor *
   * quotient`; the `%` operator uses a truncating division. Known as Rounding
   * division, Floored division or Integer division.
   *
   * @private
   * @function module:util-x~$modulo
   * @param {number} dividend
   * @param {number} divisor
   * @return {number}
   * @see http://goo.gl/68uAd8
   */
  $modulo = exports.Number.modulo;

  /**
   * The Number.isOdd returns true if the integer is odd otherwise false.
   *
   * @function module:util-x~exports.Number.isOdd
   * @param {number} inputArg
   * @return {boolean}
   */
  exports.Number.isOdd = function (inputArg) {
    return $isInteger(inputArg) && inputArg % 2 !== 0;
  };

  /**
   * The Number.isEven returns true if the integer is even otherwise false.
   *
   * @function module:util-x~exports.Number.isEven
   * @param {number} inputArg
   * @return {boolean}
   */
  exports.Number.isEven = function (inputArg) {
    return $isInteger(inputArg) && inputArg % 2 === 0;
  };

  /**
   * The abstract operation converts its argument to one of 2^53 integer values
   * in the range 0 through 2^53-1,inclusive.
   *
   * @function module:util-x~exports.Number.toUint
   * @param {*} inputArg
   * @return {number}
   */
  exports.Number.toUint = function (inputArg) {
    var number = $toNumber(inputArg),
      val = 0;

    if (number && number === number && number !== INFINITY &&
        number !== NEGATIVE_INFINITY) {

      val = $modulo($toInteger(number), UNSAFE_INTEGER);
    }

    return val;
  };

  /**
   * This method determines whether the passed value is an integer.
   * If the target value is an integer in the  range 0 through 2^53-1,
   * inclusive, return true, otherwise return false. If the value is NaN or
   * infinite, return false.
   *
   * @function module:util-x~exports.Number.isUint
   * @param {*} inputArg
   * @return {boolean}
   */
  exports.Number.isUint = function (inputArg) {
    return $isSafeInteger(inputArg) && inputArg >= 0 &&
            inputArg <= MAX_SAFE_INTEGER;
  };

  /**
   * The abstract operation ToLength converts its argument to an integer
   * suitable for use as the length of an array-like object.
   *
   * @function module:util-x~exports.Number.toLength
   * @param {*} inputArg
   * @return {number}
   * @see https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
   */
  exports.Number.toLength = $toLength;

  /**
   * The abstract operation converts its argument to one of 2^32 integer values
   * in the range 0 through 2^32-1,inclusive.
   *
   * @function module:util-x~exports.Number.toUint32
   * @param {*} inputArg
   * @return {number}
   */
  exports.Number.toUint32 = function (inputArg) {
    var number = $toNumber(inputArg),
      val = 0;

    if (number && number === number && number !== INFINITY &&
        number !== NEGATIVE_INFINITY) {

      val = $modulo($toInteger(number), UWORD32);
    }

    return val;
  };

  /**
   * Shortcut
   * This method determines whether the passed value is an integer.
   * If the target value is an integer in the  range 0 through 2^32-1,
   * inclusive, return true, otherwise return false. If the value is NaN or
   * infinite, return false.
   *
   * @private
   * @function module:util-x~$isUint32
   * @param {*} inputArg
   * @return {boolean}
   */
  function $isUint32(inputArg) {
    return $isSafeInteger(inputArg) && inputArg >= 0 && inputArg <= MAX_UINT32;
  }

  /**
   * This method determines whether the passed value is an integer.
   * If the target value is an integer in the  range 0 through 2^32-1,
   * inclusive, return true, otherwise return false. If the value is NaN or
   * infinite, return false.
   *
   * @function module:util-x~exports.Number.isUint32
   * @param {*} inputArg
   * @return {boolean}
   */
  exports.Number.isUint32 = $isUint32;

  /**
   * The abstract operation converts its argument to one of 2^16 integer values
   * in the range -2^15 through 2^15-1, inclusive.
   *
   * @function module:util-x~exports.Number.toInt16
   * @param {*} inputArg
   * @return {number}
   */
  exports.Number.toInt16 = function (inputArg) {
    var number = $toNumber(inputArg),
      val = 0;

    if (number && number === number && number !== INFINITY &&
        number !== NEGATIVE_INFINITY) {

      val = ((number > 0 || -1) * $floor($abs(number))) % UWORD16;
      if (val > MAX_INT16) {
        val -= UWORD16;
      } else if (val < MIN_INT16) {
        val += UWORD16;
      }
    }

    return val;
  };

  /**
   * This method determines whether the passed value is an integer.
   * If the target value is an integer in the range -2^15 through 2^15-1,
   * inclusive, return true, otherwise return false. If the value is NaN or
   * infinite, return false.
   *
   * @function module:util-x~exports.Number.isInt16
   * @param {*} inputArg
   * @return {boolean}
   */
  exports.Number.isInt16 = function (inputArg) {
    return $isSafeInteger(inputArg) && inputArg >= MIN_INT16 &&
            inputArg <= MAX_INT16;
  };

  /**
   * The abstract operation converts its argument to one of 2^16 integer values
   * in the range 0 through 2^16-1,inclusive.
   *
   * @function module:util-x~exports.Number.toUint16
   * @param {*} inputArg
   * @return {number}
   */
  exports.Number.toUint16 = function (inputArg) {
    var number = $toNumber(inputArg),
      val = 0;

    if (number && number === number && number !== INFINITY &&
        number !== NEGATIVE_INFINITY) {

      val = $modulo($toInteger(number), UWORD16);
    }

    return val;
  };

  /**
   * This method determines whether the passed value is an integer.
   * If the target value is an integer in the  range 0 through 2^16-1,
   * inclusive, return true, otherwise return false. If the value is NaN or
   * infinite, return false.
   *
   * @function module:util-x~exports.Number.isUint16
   * @param {*} inputArg
   * @return {boolean}
   */
  exports.Number.isUint16 = function (inputArg) {
    return $isSafeInteger(inputArg) && inputArg >= 0 && inputArg <= MAX_UINT16;
  };

  /**
   * The abstract operation converts its argument to one of 2^8 integer values
   * in the range -2^7 through 2^7-1, inclusive.
   *
   * @function module:util-x~exports.Number.toInt8
   * @param {*} inputArg
   * @return {number}
   */
  exports.Number.toInt8 = function (inputArg) {
    var number = $toNumber(inputArg),
      val = 0;

    if (number && number === number && number !== INFINITY &&
        number !== NEGATIVE_INFINITY) {

      val = ((number > 0 || -1) * $floor($abs(number))) % UWORD8;
      if (val > MAX_INT8) {
        val -= UWORD8;
      } else if (val < MIN_INT8) {
        val += UWORD8;
      }
    }

    return val;
  };

  /**
   * This method determines whether the passed value is an integer.
   * If the target value is an integer in the range -2^7 through 2^7-1,
   * inclusive, return true, otherwise return false. If the value is NaN or
   * infinite, return false.
   *
   * @function module:util-x~exports.Number.isInt8
   * @param {*} inputArg
   * @return {boolean}
   */
  exports.Number.isInt8 = function (inputArg) {
    return $isSafeInteger(inputArg) && inputArg >= MIN_INT8 &&
            inputArg <= MAX_INT8;
  };

  /**
   * The abstract operation converts its argument to one of 2^8 integer values
   * in the range 0 through 2^8-1,inclusive.
   *
   * @function module:util-x~exports.Number.toUint8
   * @param {*} inputArg
   * @return {number}
   */
  exports.Number.toUint8 = function (inputArg) {
    var number = $toNumber(inputArg),
      val = 0;

    if (number && number === number && number !== INFINITY &&
        number !== NEGATIVE_INFINITY) {

      val = $modulo($toInteger(number), UWORD8);
    }

    return val;
  };

  /**
   * This method determines whether the passed value is an integer.
   * If the target value is an integer in the  range 0 through 2^8-1, inclusive,
   * return true, otherwise return false.
   * If the value is NaN or infinite, return false.
   *
   * @function module:util-x~exports.Number.isUint8
   * @param {*} inputArg
   * @return {boolean}
   */
  exports.Number.isUint8 = function (inputArg) {
    return $isSafeInteger(inputArg) && inputArg >= 0 && inputArg <= MAX_UINT8;
  };

  /**
   * When the concat method is called with zero or more arguments item1, item2,
   * etc., it returns an array containing the array elements of the object
   * followed by the array elements of each argument in order.
   *
   * @function module:util-x~exports.Array.proto.concat
   * @this {Array} array
   * @param {...*} [varArgs]
   * @return {Array}
   * @see https://goo.gl/aY7KDO
   */
  exports.Array.proto.concat = $decide(
    // test
    function () {
      $affirmBasic(base.Array.concat)();
      $affirm.doesNotThrow(function () {
        $call(base.Array.concat, [], true);
      });

      var concatArr = [1, 2, 3],
        expected = $slice($returnArgs(1, 2, 3, Undefined, null, false)),
        resArr,
        index;

      $affirm.doesNotThrow(function () {
        resArr = $call(
          base.Array.concat, concatArr,
          $slice($returnArgs(undefined, null, false))
        );
      });

      $affirm.strictEqual(resArr.length, 6, 'array length incorrect');
      for (index = 0; index < resArr.length; index += 1) {
        $affirm.ok($call(pHasOwn, resArr, index), 'array value not set');
        $affirm.strictEqual(resArr[index], expected[index],
                            'array wrong return value');
      }
    },

    // pass
    function () {
      return base.Array.concat;
    },

    // fail
    function () {
      return $pConcat;
    },

    // message
    'Array.concat shim'
  );

  /**
   * When the concat method is called with zero or more arguments item1, item2,
   * etc., it returns an array containing the array elements of the object
   * followed by the array elements of each argument in order.
   *
   * @function module:util-x~exports.Array.concat
   * @param {Array} array
   * @param {...*} [varArgs]
   * @return {Array}
   * @see https://goo.gl/aY7KDO
   */
  exports.Array.concat = $toMethod(exports.Array.proto.concat);

  /**
   * This method adds one or more elements to the end of the array and
   * returns the new length of the array.
   *
   * @function module:util-x~exports.Array.proto.push
   * @this {module:util-x~ArrayLike}
   * @param {...*} [varArgs]
   * @return {number}
   * @see https://goo.gl/JkTMIH
   */
  exports.Array.proto.push = $decide(
    // test
    function () {
      $affirmBasic(base.Array.push)();
      $affirm.doesNotThrow(function () {
        $call(base.Array.push, [], true);
      });

      var pushArr = [],
        pushObj = {};

      $affirm.strictEqual($call(base.Array.push, pushArr, Undefined), 1,
                          'array wrong return count');
      $affirm.strictEqual(pushArr.length, 1, 'array length incorrect');
      $affirm.ok($call(pHasOwn, pushArr, 0), 'array value not set');
      $affirm.strictEqual(pushArr[0], Undefined, 'array value incorrect');

      $affirm.strictEqual($call(base.Array.push, pushObj, Undefined), 1,
                          'object wrong return count');
      $affirm.strictEqual(pushObj.length, 1, 'object length incorrect');
      $affirm.ok($call(pHasOwn, pushObj, 0), 'object value not set');
      $affirm.strictEqual(pushObj[0], Undefined, 'object value incorrect');

      $affirm.strictEqual($call(base.Array.push, pushArr, 0), 2,
                          'array wrong return count');
      $affirm.strictEqual(pushArr.length, 2, 'array length incorrect');
      $affirm.ok($call(pHasOwn, pushArr, 1), 'array value not set');
      $affirm.strictEqual(pushArr[1], 0, 'array value incorrect');

      $affirm.strictEqual($call(base.Array.push, pushObj, 0), 2,
                          'object wrong return count');
      $affirm.strictEqual(pushObj.length, 2, 'object length incorrect');
      $affirm.ok($call(pHasOwn, pushObj, 1), 'object value not set');
      $affirm.strictEqual(pushObj[1], 0, 'object value incorrect');
    },

    // pass
    function () {
      return base.Array.push;
    },

    // fail
    function () {
      return function () {
        var object = $toObject(this),
          length = $toLength(object.length),
          len = $toLength(arguments.length),
          index;

        object.length = length + len;
        for (index = 0; index < len; index += 1) {
          object[length + index] = arguments[index];
        }

        return object.length;
      };
    },

    // message
    'Array.push shim'
  );

  /**
   * This method adds one or more elements to the end of the array and
   * returns the new length of the array.
   *
   * @function module:util-x~exports.Array.push
   * @param {module:util-x~ArrayLike} array
   * @param {...*} [varArgs]
   * @return {number}
   * @see https://goo.gl/JkTMIH
   */
  exports.Array.push = $toMethod(exports.Array.proto.push);

  /**
   * Shortcut
   * This method adds one or more elements to the end of the array and
   * returns the new length of the array.
   *
   * @private
   * @function module:util-x~$push
   * @param {module:util-x~ArrayLike} array
   * @param {...*} [varArgs]
   * @return {number}
   * @see https://goo.gl/JkTMIH
   */
  $push = exports.Array.push;

  /**
   * This method removes the last element from an array and returns that
   * element.
   *
   *
   * @function module:util-x~exports.Array.proto.pop
   * @this {module:util-x~ArrayLike} array
   * @return {*}
   * @see https://goo.gl/TJMDDW
   */
  exports.Array.proto.pop = $decide(
    // test
    function () {
      $affirmBasic(base.Array.pop)();
      $affirm.doesNotThrow(function () {
        $call(base.Array.pop, []);
      });

      var popArr = [1, 2, 3],
        popObj = {
          0: 1,
          1: 2,
          2: 3,
          length: 3
        };

      $affirm.strictEqual($call(base.Array.pop, popArr), 3,
                          'array wrong return value');
      $affirm.strictEqual(popArr.length, 2, 'array length incorrect');
      $affirm.ok(!$call(pHasOwn, popArr, 2), 'array value 2 not deleted');

      $affirm.strictEqual($call(base.Array.pop, popObj), 3,
                          'object wrong return value');
      $affirm.strictEqual(popObj.length, 2, 'object length incorrect');
      $affirm.ok(!$call(pHasOwn, popObj, 2), 'object value 2 not deleted');

      $affirm.strictEqual($call(base.Array.pop, popArr), 2,
                          'array wrong return value');
      $affirm.strictEqual(popArr.length, 1, 'array length incorrect');
      $affirm.ok(!$call(pHasOwn, popArr, 1), 'array value 1 not deleted');

      $affirm.strictEqual($call(base.Array.pop, popObj), 2,
                          'object wrong return value');
      $affirm.strictEqual(popObj.length, 1, 'object length incorrect');
      $affirm.ok(!$call(pHasOwn, popObj, 1), 'object value 1 not deleted');
    },

    // pass
    function () {
      return base.Array.pop;
    },

    // fail
    function () {
      return function () {
        var object = $toObject(this),
          len = $toLength(object.length),
          index,
          value;

        if (len === 0) {
          object.length = 0;
        } else {
          index = len - 1;
          value = object[index];
          $deleteProperty(object, index);
          object.length = index;
        }

        return value;
      };
    },

    // message
    'Array.pop shim'
  );

  /**
   * This method removes the last element from an array and returns that
   * element.
   *
   * @function module:util-x~exports.Array.pop
   * @param {module:util-x~ArrayLike} array
   * @return {*}
   * @see https://goo.gl/TJMDDW
   */
  exports.Array.pop = $toMethod(exports.Array.proto.pop);

  /**
   * Shortcut
   * This method removes the last element from an array and returns that
   * element.
   *
   * @private
   * @function module:util-x~$pop
   * @param {module:util-x~ArrayLike} array
   * @return {*}
   * @see https://goo.gl/TJMDDW
   */
  $pop = exports.Array.pop;

  /**
   * The first element of the array is removed from the array and returned.
   *
   *
   * @function module:util-x~exports.Array.proto.shift
   * @this {module:util-x~ArrayLike} array
   * @return {*}
   * @see https://goo.gl/mr92Gc
   */
  exports.Array.proto.shift = $decide(
    // test
    function () {
      $affirmBasic(base.Array.shift)();
      $affirm.doesNotThrow(function () {
        $call(base.Array.shift, []);
      });

      var shiftArr = [1, 2, 3],
        shiftObj = {
          0: 1,
          1: 2,
          2: 3,
          length: 3
        };

      $affirm.strictEqual($call(base.Array.shift, shiftArr), 1,
                          'array wrong return value');
      $affirm.strictEqual(shiftArr.length, 2, 'array length incorrect');
      $affirm.ok(!$call(pHasOwn, shiftArr, 2), 'array value 2 not deleted');

      $affirm.strictEqual($call(base.Array.shift, shiftObj), 1,
                          'object wrong return value');
      $affirm.strictEqual(shiftObj.length, 2, 'object length incorrect');
      $affirm.ok(!$call(pHasOwn, shiftObj, 2), 'object value 2 not deleted');

      $affirm.strictEqual($call(base.Array.shift, shiftArr), 2,
                          'array wrong return value');
      $affirm.strictEqual(shiftArr.length, 1, 'array length incorrect');
      $affirm.ok(!$call(pHasOwn, shiftArr, 1), 'array value 1 not deleted');

      $affirm.strictEqual($call(base.Array.shift, shiftObj), 2,
                          'object wrong return value');
      $affirm.strictEqual(shiftObj.length, 1, 'object length incorrect');
      $affirm.ok(!$call(pHasOwn, shiftObj, 1), 'object value 1 not deleted');

      // IE7
      shiftObj = {
        0: Undefined,
        1: null,
        2: -1,
        3: 0,
        4: 1,
        5: false,
        6: true,
        7: Undefined,
        8: '',
        9: 'abc',
        10: null,
        11: Undefined
      };

      $affirm.strictEqual($call(base.Array.shift, shiftObj),
                          Undefined, 'test1');
      $affirm.strictEqual($call(base.Array.shift, shiftObj),
                          Undefined, 'test2');
      $affirm.strictEqual($call(base.Array.shift, shiftObj),
                          Undefined, 'test3');
      $affirm.strictEqual($call(base.Array.shift, shiftObj),
                          Undefined, 'test4');
      $affirm.strictEqual($call(base.Array.shift, shiftObj),
                          Undefined, 'test5');
      $affirm.strictEqual($call(base.Array.shift, shiftObj),
                          Undefined, 'test6');
      $affirm.strictEqual($call(base.Array.shift, shiftObj),
                          Undefined, 'test7');
      $affirm.strictEqual($call(base.Array.shift, shiftObj),
                          Undefined, 'test8');
      $affirm.strictEqual($call(base.Array.shift, shiftObj),
                          Undefined, 'test9');
      $affirm.strictEqual($call(base.Array.shift, shiftObj),
                          Undefined, 'test10');
      $affirm.strictEqual($call(base.Array.shift, shiftObj),
                          Undefined, 'test11');
      $affirm.strictEqual($call(base.Array.shift, shiftObj),
                          Undefined, 'test112');
      $affirm.strictEqual(shiftObj[9], 'abc', 'test13');
      $affirm.strictEqual(shiftObj.length, 0, 'test14');
    },

    // pass
    function () {
      return base.Array.shift;
    },

    // fail
    function () {
      return function () {
        var object = $toObject(this),
          len = $toLength(object.length),
          index,
          value,
          to;

        if (len === 0) {
          object.length = 0;
        } else {
          value = object[0];
          for (index = 1; index < len; index += 1) {
            to = index - 1;
            if ($hasProperty(object, index)) {
              object[to] = object[index];
            } else {
              $deleteProperty(object, to);
            }
          }

          $deleteProperty(object, len - 1);
          object.length = len - 1;
        }

        return value;
      };
    },

    // message
    'Array.shift shim'
  );

  /**
   * The first element of the array is removed from the array and returned.
   *
   * @function module:util-x~exports.Array.shift
   * @param {module:util-x~ArrayLike} array
   * @return {*}
   * @see https://goo.gl/mr92Gc
   */
  exports.Array.shift = $toMethod(exports.Array.proto.shift);

  /**
   * Shortcut
   * The first element of the array is removed from the array and returned.
   *
   * @private
   * @function module:util-x~$shift
   * @param {module:util-x~ArrayLike} array
   * @return {*}
   * @see https://goo.gl/mr92Gc
   */
  $shift = exports.Array.shift;

  /**
   * This method adds one or more elements to the beginning of an array and
   * returns the new length of the array.
   *
   * @function module:util-x~exports.Array.proto.unshift
   * @this {module:util-x~ArrayLike}
   * @param {...*} [varArgs]
   * @return {number}
   * @see https://goo.gl/V4SFuQ
   */

  exports.Array.proto.unshift = $decide(
    // test
    function () {
      $affirmBasic(base.Array.unshift)();
      $affirm.doesNotThrow(function () {
        $call(base.Array.unshift, [], true);
      });

      var unshiftArr = [],
        unshiftObj = {},
        arrCmp,
        i;

      $affirm.strictEqual($call(base.Array.unshift, unshiftArr, Undefined), 1,
                          'array wrong return count');
      $affirm.strictEqual(unshiftArr.length, 1, 'array length incorrect');
      $affirm.ok($call(pHasOwn, unshiftArr, 0), 'array value not set');
      $affirm.strictEqual(unshiftArr[0], Undefined, 'array value incorrect');

      $affirm.strictEqual($call(base.Array.unshift, unshiftObj, Undefined), 1,
                          'object wrong return count');
      $affirm.strictEqual(unshiftObj.length, 1, 'object length incorrect');
      $affirm.ok($call(pHasOwn, unshiftObj, 0), 'object value not set');
      $affirm.strictEqual(unshiftObj[0], Undefined, 'object value incorrect');

      $affirm.strictEqual($call(base.Array.unshift, unshiftArr, 0), 2,
                          'array wrong return count');
      $affirm.strictEqual(unshiftArr.length, 2, 'array length incorrect');
      $affirm.ok($call(pHasOwn, unshiftArr, 0), 'array value not set');
      $affirm.strictEqual(unshiftArr[0], 0, 'array value incorrect');

      $affirm.strictEqual($call(base.Array.unshift, unshiftObj, 0), 2,
                          'object wrong return count');
      $affirm.strictEqual(unshiftObj.length, 2, 'object length incorrect');
      $affirm.ok($call(pHasOwn, unshiftObj, 0), 'object value not set');
      $affirm.strictEqual(unshiftObj[0], 0, 'object value incorrect');

      arrCmp = [];
      arrCmp.length = 12;
      arrCmp[0] = Undefined;
      arrCmp[1] = null;
      arrCmp[2] = -1;
      arrCmp[3] = 0;
      arrCmp[4] = 1;
      arrCmp[5] = false;
      arrCmp[6] = true;
      arrCmp[7] = Undefined;
      arrCmp[8] = '';
      arrCmp[9] = 'abc';
      arrCmp[10] = null;
      arrCmp[11] = Undefined;

      unshiftArr = [];
      $affirm.strictEqual($call(base.Array.unshift, unshiftArr, Undefined),
                          1, 'test1');
      $affirm.strictEqual($call(base.Array.unshift, unshiftArr, null),
                          2, 'test2');
      $affirm.strictEqual($call(base.Array.unshift, unshiftArr, 'abc'),
                          3, 'test3');
      $affirm.strictEqual($call(base.Array.unshift, unshiftArr, ''),
                          4, 'test4');
      $affirm.strictEqual($call(base.Array.unshift, unshiftArr, Undefined),
                          5, 'test5');
      $affirm.strictEqual($call(base.Array.unshift, unshiftArr), 5, 'test6');
      $affirm.strictEqual($call(base.Array.unshift, unshiftArr), 5, 'test7');
      $affirm.strictEqual($call(base.Array.unshift, unshiftArr), 5, 'test8');
      $affirm.strictEqual($call(base.Array.unshift, unshiftArr), 5, 'test9');
      $affirm.strictEqual($call(base.Array.unshift, unshiftArr, true),
                          6, 'test10');
      $affirm.strictEqual($call(base.Array.unshift, unshiftArr, false),
                          7, 'test11');
      $affirm.strictEqual($call(base.Array.unshift, unshiftArr, 1),
                          8, 'test12');
      $affirm.strictEqual($call(base.Array.unshift, unshiftArr, 0),
                          9, 'test13');
      $affirm.strictEqual($call(base.Array.unshift, unshiftArr, -1),
                          10, 'test14');
      $affirm.strictEqual($call(base.Array.unshift, unshiftArr, null),
                          11, 'test15');
      $affirm.strictEqual($call(base.Array.unshift, unshiftArr, Undefined),
                          12, 'test16');
      $affirm.strictEqual(unshiftArr.length, arrCmp.length, 'test17');
      for (i = 0; i < unshiftArr.length; i += 1) {
        $affirm.ok($call(pHasOwn, unshiftArr, i), 'hasOwn test' + i);
        $affirm.strictEqual(unshiftArr[i], arrCmp[i], 'strictEqual test' + i);
      }
    },

    //pass
    function () {
      return base.Array.unshift;
    },

    // fail
    function () {
      return function () {
        var object = $toObject(this),
          len = $toLength(object.length),
          k = len,
          argCount = $toLength(arguments.length),
          from,
          to,
          j;

        object.length = len + argCount;
        for (k = len; k > 0; k -= 1) {
          from = k - 1;
          to = k + argCount - 1;
          if ($hasProperty(object, from)) {
            object[to] = object[from];
          } else {
            $deleteProperty(object, to);
          }
        }

        for (j = 0; j < argCount; j += 1) {
          object[j] = arguments[j];
        }

        return object.length;
      };
    },

    // message
    'Array.unshift shim'
  );

  /**
   * This method adds one or more elements to the beginning of an array and
   * returns the new length of the array.
   *
   * @function module:util-x~exports.Array.unshift
   * @param {module:util-x~ArrayLike} array
   * @param {...*} [varArgs]
   * @return {number}
   * @see https://goo.gl/V4SFuQ
   */
  exports.Array.unshift = $toMethod(exports.Array.proto.unshift);

  /**
   * Shortcut
   * This method adds one or more elements to the beginning of an array and
   * returns the new length of the array.
   *
   * @private
   * @function module:util-x~$unshift
   * @param {module:util-x~ArrayLike} array
   * @param {...*} [varArgs]
   * @return {number}
   * @see https://goo.gl/V4SFuQ
   */
  $unshift = exports.Array.unshift;

  /**
   * The elements of the array are rearranged so as to reverse their order.
   *
   * @function module:util-x~exports.Array.proto.reverse
   * @this {module:util-x~ArrayLike}
   * @return {module:util-x~ArrayLike}
   * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.8
   */
  exports.Array.proto.reverse = $decide(
    // test
    function () {
      $affirmBasic(base.Array.reverse)();
      $affirm.doesNotThrow(function () {
        $call(base.Array.reverse, 1);
      }, 'number');

      $affirm.doesNotThrow(function () {
        $call(base.Array.reverse, true);
      }, 'boolean');

      $affirm.doesNotThrow(function () {
        $call(base.Array.reverse, 'a');
      }, 'string');

      var arrCmp = [];

      arrCmp.length = 12;
      arrCmp[0] = Undefined;
      arrCmp[1] = null;
      arrCmp[2] = -1;
      arrCmp[3] = 0;
      arrCmp[4] = 1;
      arrCmp[5] = false;
      arrCmp[6] = true;
      arrCmp[8] = '';
      arrCmp[9] = 'abc';
      arrCmp[10] = null;
      arrCmp[11] = Undefined;

      $affirm.doesNotThrow(function () {
        $call(base.Array.reverse, arrCmp);
      }, 'test1');

      $affirm.strictEqual(arrCmp.length, 12, 'test2');
      $affirm.strictEqual(arrCmp[11], Undefined, 'test3');
      $affirm.ok($call(pHasOwn, arrCmp, 11), 'test4');
      $affirm.strictEqual(arrCmp[10], null, 'test5');
      $affirm.strictEqual(arrCmp[9], -1, 'test6');
      $affirm.strictEqual(arrCmp[8], 0, 'test7');
      $affirm.strictEqual(arrCmp[7], 1, 'test8');
      $affirm.strictEqual(arrCmp[6], false, 'test9');
      $affirm.strictEqual(arrCmp[5], true, 'test10');
      $affirm.strictEqual(arrCmp[4], Undefined, 'test11');
      $affirm.ok(!$call(pHasOwn, arrCmp, 4), 'test12');
      $affirm.strictEqual(arrCmp[3], '', 'test13');
      $affirm.strictEqual(arrCmp[2], 'abc', 'test14');
      $affirm.strictEqual(arrCmp[1], null, 'test15');
      $affirm.strictEqual(arrCmp[0], Undefined, 'test16');
      $affirm.ok($call(pHasOwn, arrCmp, 0), 'test17');
    },

    //pass
    function () {
      return base.Array.reverse;
    },

    // fail
    function () {
      return function () {
        var object = $toObject(this),
          length = $toLength(object.length),
          middle = $floor(length / 2),
          lower = 0,
          lowerValue,
          upperValue,
          lowerExists,
          upperExists,
          upper;

        while (lower !== middle) {
          upper = length - lower - 1;
          lowerValue = object[lower];
          upperValue = object[upper];
          lowerExists = $hasProperty(object, lower);
          upperExists = $hasProperty(object, upper);
          if (lowerExists && upperExists) {
            object[lower] = upperValue;
            object[upper] = lowerValue;
          } else if (!lowerExists && upperExists) {
            object[lower] = upperValue;
            $deleteProperty(object, upper);
          } else if (lowerExists && !upperExists) {
            object[upper] = lowerValue;
            $deleteProperty(object, lower);
          }

          lower += 1;
        }

        return object;
      };
    },

    // message
    'Array.reverse shim'
  );

  /**
   * The elements of the array are rearranged so as to reverse their order.
   *
   * @function module:util-x~exports.Array.reverse
   * @param {module:util-x~ArrayLike} array
   * @return {module:util-x~ArrayLike}
   * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.8
   */
  exports.Array.reverse = $toMethod(exports.Array.proto.reverse);

  /**
   * Shortcut
   * The elements of the array are rearranged so as to reverse their order.
   *
   * @private
   * @function module:util-x~$reverse
   * @param {module:util-x~ArrayLike} array
   * @return {module:util-x~ArrayLike}
   * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.8
   */
  $reverse = exports.Array.reverse;

  /**
   * Returns an integer clamped to the range set by min and max. The arguments
   * are converted to integers with the
   * {@link exports.Number.toInteger toInteger} method.
   *
   * @function module:util-x~exports.Number.clampToInt
   * @param {*} num
   * @param {*} min
   * @param {*} max
   * @return {number}
   */
  exports.Number.clampToInt = function (num, min, max) {
    return $min($max($toInteger(num), $toInteger(min)), $toInteger(max));
  };

  /**
   * The slice method takes two arguments, start and end, and returns a
   * substring of the result of converting this object to a String, starting
   * from index start and running to, but not including, index end (or through
   * the end of the String if end is undefined). If start is negative, it is
   * treated as sourceLength+start where sourceLength is the length of the
   * String. If end is negative, it is treated as sourceLength+end where
   * sourceLength is the length of the String. The result is a String value,
   * not a String object.
   *
   * @function module:util-x~exports.String.proto.slice
   * @this {string}
   * @param {number} start
   * @param {number} end
   * @return {string}
   * @see https://goo.gl/fPAGVx
   */
  exports.String.proto.slice = $decide(
    // test
    function () {
      $affirmBasic(base.String.slice)();
    },

    // pass
    function () {
      return base.String.slice;
    },

    // fail
    function () {
      return function (start, end) {
        var object = $onlyCoercibleToString(this),
          length = $toLength(object.length),
          intStart = $toInteger(start),
          result = '',
          index,
          intEnd,
          from,
          to;

        if (typeof end === 'undefined') {
          intEnd = length;
        } else {
          intEnd = $toInteger(end);
        }

        if (intStart < 0) {
          from = $max(length + intStart, 0);
        } else {
          from = $min(intStart, length);
        }

        if (intEnd < 0) {
          to = $max(length + intEnd, 0);
        } else {
          to = $min(intEnd, length);
        }

        for (index = from; index < to; index += 1) {
          result += $getItem(object, index, stringTagString);
        }

        return result;
      };
    },

    //argsNames
    ['start', 'end'],

    // message
    'String.slice shim'
  );

  /**
   * The slice method takes two arguments, start and end, and returns a
   * substring of the result of converting this object to a String, starting
   * from index start and running to, but not including, index end (or through
   * the end of the String if end is undefined). If start is negative, it is
   * treated as sourceLength+start where sourceLength is the length of the
   * String. If end is negative, it is treated as sourceLength+end where
   * sourceLength is the length of the String. The result is a String value,
   * not a String object.
   *
   * @function module:util-x~exports.String.slice
   * @param {string} string
   * @param {number} start
   * @param {number} end
   * @return {string}
   * @see https://goo.gl/fPAGVx
   */
  exports.String.slice = $toMethod(exports.String.proto.slice);

  /**
   * The slice method takes two arguments, start and end, and returns a
   * substring of the result of converting this object to a String, starting
   * from index start and running to, but not including, index end (or through
   * the end of the String if end is undefined). If start is negative, it is
   * treated as sourceLength+start where sourceLength is the length of the
   * String. If end is negative, it is treated as sourceLength+end where
   * sourceLength is the length of the String. The result is a String value,
   * not a String object.
   *
   * @private
   * @function module:util-x~$sSlice
   * @param {string} string
   * @param {number} start
   * @param {number} end
   * @return {string}
   * @see https://goo.gl/fPAGVx
   */
  $sSlice = exports.String.slice;

  /**
   * Repeat the current string several times, return the new string.
   *
   * @function module:util-x~exports.String.proto.repeat
   * @this {string}
   * @param {number} count
   * @return {string}
   * @see https://goo.gl/CJ7Xor
   */
  exports.String.proto.repeat = $decide(
    // test
    $affirmBasic(base.String.repeat),

    // pass
    function () {
      return base.String.repeat;
    },

    // fail
    function () {
      /**
       * Repeat the current string several times, return the new string. Used by
       * String.repeat
       *
       * @param {string} s
       * @param {number} count
       * @return {string}
       */
      function stringRepeatRep(s, count) {
        var half,
          val;

        if (count < 1 || s.length < 1) {
          val = '';
        } else if (count % 2 === 1) {
          count -= 1;
          if (count > 0) {
            val = stringRepeatRep(s, count) + s;
          } else {
            val = s;
          }
        } else {
          half = stringRepeatRep(s, count / 2);
          val = half + half;
        }

        return val;
      }

      return function (count) {
        var thisString = $onlyCoercibleToString(this);

        count = $toInteger(count);
        if (count < 0) {
          throw new CRangeError('repeat count must be non-negative');
        }

        if (count === INFINITY) {
          throw new CRangeError('repeat count must be less than infinity');
        }

        return stringRepeatRep(thisString, count);
      };
    },

    // messgae
    'String.repeat shim'
  );

  /**
   * Repeat the current string several times, return the new string.
   *
   * @function module:util-x~exports.String.repeat
   * @param {string} string
   * @param {number} count
   * @return {string}
   * @see https://goo.gl/CJ7Xor
   */
  exports.String.repeat = $toMethod(exports.String.proto.repeat);

  /**
   * Repeat the current string several times, return the new string.
   *
   * @private
   * @function module:util-x~$repeat
   * @param {string} string
   * @param {number} count
   * @return {string}
   * @see https://goo.gl/CJ7Xor
   */
  $repeat = exports.String.repeat;

  /**
   * Return the value of the [[Prototype]] internal property of object.
   * Actually based on the ECMA6 draft, which only throws on undefined or null.
   *
   * @function module:util-x~exports.Object.getPrototypeOf
   * @param {Object} object
   * @return {Prototype}
   * @see https://goo.gl/vhm11T
   * @see https://goo.gl/TaQjPt
   */
  exports.Object.getPrototypeOf = (function () {
    return $decide(
      // test
      $affirmBasic(base.Object.getPrototypeOf),

      // pass
      function () {
        return $decide(
          // test
          function () {
            var proto;

            $affirm.doesNotThrow(function () {
              proto = base.Object.getPrototypeOf(1);
            }, 'get number literal proto');

            $affirm.strictEqual(proto, protoNumber,
                                'work with number literal');

            $affirm.doesNotThrow(function () {
              proto = base.Object.getPrototypeOf(true);
            }, 'get boolean literal proto');

            $affirm.strictEqual(proto, protoBoolean,
                                'work with boolean literal');

            $affirm.doesNotThrow(function () {
              proto = base.Object.getPrototypeOf('');
            }, 'get string literal proto');

            $affirm.strictEqual(proto, protoString,
                                'work with string literal');
          },

          // pass
          function () {
            return base.Object.getPrototypeOf;
          },

          // fail
          function () {
            var mGetPrototypeOf = base.Object.getPrototypeOf;

            return function (object) {
              return mGetPrototypeOf($toObject(object));
            };
          },

          // message
          'Object.getPrototypeOf primitive patch'
        );
      },

      // fail
      function () {
        return $decide(
          // test
          function () {
            var proto;

            $affirm.doesNotThrow(function () {
              proto = protoObject[stringProto];
            }, 'get __proto__');

            $affirm.strictEqual(protoObject[stringProto], null,
                                'has __proto__');

            $affirm.doesNotThrow(function () {
              proto = $toObject(1)[stringProto];
            }, 'get number literal proto');

            $affirm.strictEqual(proto, protoNumber,
                                'work with number literal');

            $affirm.doesNotThrow(function () {
              proto = $toObject(true)[stringProto];
            }, 'get boolean literal proto');

            $affirm.strictEqual(proto, protoBoolean,
                                'work with boolean literal');

            $affirm.doesNotThrow(function () {
              proto = $toObject('')[stringProto];
            }, 'get string literal proto');

            $affirm.strictEqual(proto, protoString,
                                'work with string literal');
            $affirm.ok(!testShims, 'testing shim');
          },

          // pass
          function () {
            return function (object) {
              return $toObject(object)[stringProto];
            };
          },

          // fail
          function () {
            var fixOpera10GetPrototypeOf;

            if ($returnArgs().constructor.prototype !== protoObject) {
              fixOpera10GetPrototypeOf = true;
            }

            return function (object) {
              var obj = $toObject(object),
                ctrProto,
                protoObj;

              if (obj === protoObject) {
                return null;
              }

              if ($isFunction(obj.constructor)) {
                if (fixOpera10GetPrototypeOf && $isArguments(obj)) {
                  ctrProto = protoObject;
                } else {
                  ctrProto = obj.constructor.prototype;
                }
              } else {
                protoObj = obj[stringProto];
                if ($toStringTag(protoObj) === stringTagObject &&
                    !$isFunction(protoObj)) {

                  ctrProto = protoObj;
                } else {
                  ctrProto = protoObject;
                }
              }

              if (obj === ctrProto) {
                return protoObject;
              }

              return ctrProto;
            };
          },

          // message
          'Object.getPrototypeOf full shim'
        );
      },

      // message
      'Object.getPrototypeOf __proto__ shim'
    );
  }());

  /**
   * Return the value of the [[Prototype]] internal property of object.
   * Actually based on the ECMA6 draft, which only throws on undefined or null.
   *
   * @private
   * @function module:util-x~$getPrototypeOf
   * @param {Object} object
   * @return {Prototype}
   * @see https://goo.gl/x7fjYT
   * @see https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tointeger
   */
  $getPrototypeOf = exports.Object.getPrototypeOf;

  /**
   * Check to see if an object is a plain object (created using "{}" or
   * "new Object"). Some gotchas, not all browsers are equal and native objects
   * do not necessarily abide by the rules.
   *
   * @function module:util-x~exports.Object.isPlainObject
   * @param {Object} object
   * @return {boolean}
   */
  exports.Object.isPlainObject = function (object) {
    return $toStringTag(object) === stringTagObject &&
            $getPrototypeOf(object) === protoObject;
  };

  // redefinition
  $isPlainObject = exports.Object.isPlainObject;

  /**
   * Returns a boolean indicating whether the object has the specified property.
   * This function can be used to determine whether an object has the specified
   * property as a direct property of that object; unlike the exports.Object.has
   * function, this method does not check down the object's prototype chain.
   *
   * @function module:util-x~exports.Object.proto.hasOwnProperty
   * @this {Object}
   * @param {StringLike} property
   * @return {boolean}
   * @see https://goo.gl/r3Hh0J
   */
  /* jshint -W001 */
  exports.Object.proto.hasOwnProperty = (function (phop) {
    return $decide(
      // test
      function () {
        $affirm.ok($call(phop, 'abc', '1'), 'hasStringOwnPropBug');
        $affirm.ok($call(phop, $Object('abc'), '1'), 'hasStringOwnPropBug');
      },

      // pass
      function () {
        return phop;
      },

      // fail
      function () {
        return function (property) {
          var object = $toObject(this),
            prop = $toString(property);

          return ($isString(object) &&
                  $isIndex(prop, $toLength(object.length))) ||
                  $call(phop, object, prop);
        };
      },

      // message
      'Object.hasOwnProperty hasStringOwnPropBug patch'
    );
  }(pHasOwn));

  /**
   * Returns a boolean indicating whether the object has the specified property.
   * This function can be used to determine whether an object has the specified
   * property as a direct property of that object; unlike the exports.Object.has
   * function, this method does not check down the object's prototype chain.
   *
   * @function module:util-x~exports.Object.hasOwnProperty
   * @param {Object} object
   * @param {StringLike} property
   * @return {boolean}
   * @see https://goo.gl/r3Hh0J
   */
  exports.Object.hasOwnProperty = function (object, property) {
    return pHasOwn.call(object, property);
  };

  exports.Object.hasOwnProperty = $toMethod(exports.Object.proto.hasOwnProperty);
  /* jshint +W001 */

  /**
   * Returns a boolean indicating whether the object has the specified property.
   * This function can be used to determine whether an object has the specified
   * property as a direct property of that object; unlike the exports.Object.has
   * function, this method does not check down the object's prototype chain.
   *
   * @private
   * @function module:util-x~$hasOwn
   * @param {Object} object
   * @param {StringLike} property
   * @return {boolean}
   * @see https://goo.gl/r3Hh0J
   */
  $hasOwn = exports.Object.hasOwnProperty;

  /**
   * This method returns a Boolean indicating whether the specified property is
   * enumerable.
   *
   * @function module:util-x~exports.Object.proto.propertyIsEnumerable
   * @this {Object}
   * @param {StringLike} prop The name of the property to test.
   * @return {boolean}
   * @see https://goo.gl/8xX7OY
   */
  exports.Object.proto.propertyIsEnumerable = (function (pPropertyIsEnumerable) {
    var strPropEnumBug = true;

    return $decide(
      // test
      function () {
        $affirmBasic(pPropertyIsEnumerable)();

        $affirm.ok($call(pPropertyIsEnumerable, 'abc', '0'),
                   'String indexes');
        $affirm.ok($call(pPropertyIsEnumerable, $toObject('abc'), '0'),
                   'String object indexes');
        strPropEnumBug = false;
        $affirm.ok(!hasDontEnumBug, 'hasDontEnumBug');
        $affirm.ok(!hasEnumStringBug, 'hasEnumStringBug');
        $affirm.ok(!hasEnumArgsBug, 'hasEnumArgsBug');
        $affirm.ok(!$call(pPropertyIsEnumerable, protoObject,
                          'toString'), 'Object.prototype.toString');
        $affirm.ok(!$call(pPropertyIsEnumerable, protoObject,
                          'toLocaleString'), 'Object.prototype.toLocaleString');
        $affirm.ok(!$call(pPropertyIsEnumerable, protoObject,
                          'valueOf'), 'Object.prototype.valueOf');
        $affirm.ok(!$call(pPropertyIsEnumerable, protoObject,
                          'hasOwnProperty'), 'Object.prototype.hasOwnProperty');
        $affirm.ok(!$call(pPropertyIsEnumerable, protoObject,
                          'isPrototypeOf'), 'Object.prototype.isPrototypeOf');
        $affirm.ok(!$call(pPropertyIsEnumerable, protoObject,
                          'propertyIsEnumerable'),
                   'Object.prototype.propertyIsEnumerable');
        $affirm.ok(!$call(pPropertyIsEnumerable, protoObject,
                          'constructor'), 'Object.prototype.constructor');

      },

      // pass
      function () {
        return pPropertyIsEnumerable;
      },

      // fail
      function () {
        var length = $toLength(shadowed.length);

        return function (property) {
          var object = $toObject(this),
            prop = $toString(property),
            rtn = $call(pPropertyIsEnumerable, object, prop),
            found,
            index,
            name,
            isProto,
            skip,
            subject;

          if (!rtn) {
            if ((((hasEnumStringBug || strPropEnumBug) && $isString(object)) ||
                 (hasEnumArgsBug && $isArguments(object) &&
                  $call(pHasOwn, object, prop))) &&
                  $isIndex(prop, $toLength(object.length))) {

              rtn = true;
            } else if (hasDontEnumBug) {
              for (index = 0; index < length; index += 1) {
                if (prop === shadowed[index]) {
                  /*jslint forin: true */
                  for (name in base) {
                    subject = base[name];
                    /*jslint eqeq:true */
                    /*jshint eqnull:true */
                    if (subject != null && object === subject.proto) {
                      isProto = true;
                      break;
                    }
                  }

                  skip = prop === 'constructor' &&
                          $hasProperty(object, 'constructor') &&
                          object.constructor.prototype !== object;
                  if (!skip && !isProto) {
                    $conlog('found : ' + prop);
                    found = true;
                  }

                  break;
                }
              }

              if (found && $call(pHasOwn, object, prop)) {
                $conlog(name + ' : ' + prop + ' : ' +
                        object[prop] !== base[name][prop]);
                rtn = object[prop] !== base[name][prop];
              }
            }
          }

          return rtn;
        };
      },

      // message
      'Object.propertyIsEnumerable patch'
    );
  }(base.Object.propertyIsEnumerable));

  /**
   * Shortcut
   * This method returns a Boolean indicating whether the specified property is
   * enumerable.
   *
   * @private
   * @function module:util-x~$propertyIsEnumerable
   * @param {Object} The object to be tested
   * @param {StringLike} prop The name of the property to test.
   * @return {boolean}
   * @see https://goo.gl/8xX7OY
   */
  $propertyIsEnumerable = $toMethod(exports.Object.proto.propertyIsEnumerable);

  /**
   * This method returns a Boolean indicating whether the specified property is
   * enumerable.
   *
   * @function module:util-x~exports.Object.propertyIsEnumerable
   * @param {Object} The object to be tested
   * @param {StringLike} prop The name of the property to test.
   * @return {boolean}
   * @see https://goo.gl/8xX7OY
   */
  exports.Object.propertyIsEnumerable = $propertyIsEnumerable;

  /**
   * Returns an array of a given object's own enumerable properties, in the same
   * order as that provided by a for-in loop (the difference being that a for-in
   * loop enumerates properties in the prototype chain as well). Some gotchas to
   * watch for, not all browsers agree on what properties are enumerable:
   * IE 6 to 9: Error: description, message
   * IE 10: Error: description
   * FF 3 to 5: Error: message, fileName, lineNumber, stack
   * FF 3 to 3.5: Function: prototype
   * Chrome 5 to 9: Error: message, stack
   * Chrome 10 to 13: Error: arguments, type, message, stack
   * V8 Error object has: captureStackTrace, stackTraceLimit
   * Opera 10 to 12 & next: Error: message
   * Opera 11.5: Function: prototype
   * Safari 4 to 6 & next: Error: message
   * There are most probably other native objects that do not agree: Object and
   * Array should be fine in all
   * environments.
   *
   * @function module:util-x~exports.Object.keys
   * @param {Object} object
   * @return {Array}
   * @see https://goo.gl/qIyqWO
   */
  /*jslint todo: true */
  /** @todo: fix unwanted error, constructor and prototype properties */
  /*jslint todo: false */
  exports.Object.keys = (function () {
    return $decide(
      // test
      function () {
        $affirmBasic(base.Object.keys)();

        var value;

        $affirm.doesNotThrow(function () {
          value = base.Object.keys($returnArgs(1, 2));
        }, 'test1');

        $affirm.strictEqual(value.length, 2, 'works with arguments object');
        $affirm.ok(!hasErrorProps, 'works with error objects');

        $affirm.doesNotThrow(function () {
          value = base.Object.keys(CError.prototype);
        }, 'test2');

        // Error prototype should not list
        $affirm.strictEqual(value.length, 0, 'Error prototype zero list');
      },

      // pass
      function () {
        return $decide(
          // test
          function () {
            var value;

            $affirm.doesNotThrow(function () {
              value = base.Object.keys(1);
            }, 'number literal');

            $affirm.strictEqual(value.length, 0, 'number literal');

            $affirm.doesNotThrow(function () {
              value = base.Object.keys('a');
            }, 'string literal');

            $affirm.strictEqual(value.length, 1, 'string literal');

            $affirm.doesNotThrow(function () {
              value = base.Object.keys(true);
            }, 'boolean literal');

            $affirm.strictEqual(value.length, 0, 'boolean literal');
          },

          // pass
          function () {
            return base.Object.keys;
          },

          // fail
          function () {
            var mKeys = base.Object.keys;

            return function (object) {
              return mKeys($toObject(object));
            };
          },

          // message
          'Object.keys patch'
        );
      },

      // fail
      function () {
        var length = $toLength(shadowed.length),
          uLen = 0;

        if (hasErrorProps) {
          uLen = $toLength(unwantedError.length);
        }

        return function (object) {
          var obj = $toObject(object),
            theKeys = [],
            isString = hasEnumStringBug && $isString(obj),
            dontEnum,
            skip,
            name,
            index,
            isProto,
            subject;

          if (isString || (hasEnumArgsBug && $isArguments(obj))) {
            length = $toLength(obj.length);
            for (index = 0; index < length; index += 1) {
              if (isString || $call(pHasOwn, obj, index)) {
                $push(theKeys, $toString(index));
              }
            }
          }

          /*jslint forin: true */
          for (name in obj) {
            if ($call(pHasOwn, obj, name)) {
              if (hasErrorProps) {
                skip = false;
                for (index = 0; index < uLen; index += 1) {
                  subject = unwantedError[index];
                  if (obj === subject.proto) {
                    dontEnum = subject.unwanted;
                    if ($call(pHasOwn, dontEnum, name) &&
                        obj[name] === dontEnum[name]) {

                      skip = true;
                    }

                    break;
                  }
                }
              }

              if (!skip) {
                $push(theKeys, name);
              }
            }
          }

          if (hasDontEnumBug) {
            /*jslint forin: true */
            for (name in base) {
              subject = base[name];
              /*jslint eqeq:true */
              /*jshint eqnull:true */
              if (subject != null && obj === subject.proto) {
                isProto = true;
                break;
              }
            }

            skip = !isProto && $hasProperty(obj, 'constructor') &&
                    obj.constructor.prototype === obj;
            for (index = 0; index < length; index += 1) {
              dontEnum = shadowed[index];
              if ($call(pHasOwn, obj, dontEnum)) {
                if (isProto) {
                  if (obj[dontEnum] !== subject[dontEnum]) {
                    $push(theKeys, dontEnum);
                  }
                } else if (!(skip && dontEnum === 'constructor')) {
                  $push(theKeys, dontEnum);
                }
              }
            }
          }

          return theKeys;
        };
      },

      // message
      'Object.keys shim'
    );
  }());

  /**
   * Returns an array of a given object's own enumerable properties, in the same
   * order as that provided by a for-in loop (the difference being that a for-in
   * loop enumerates properties in the prototype chain as well). Some gotchas to
   * watch for, not all browsers agree on what properties are enumerable:
   * IE 6 to 9: Error: description, message
   * IE 10: Error: description
   * FF 3 to 5: Error: message, fileName, lineNumber, stack
   * FF 3 to 3.5: Function: prototype
   * Chrome 5 to 9: Error: message, stack
   * Chrome 10 to 13: Error: arguments, type, message, stack
   * V8 Error object has: captureStackTrace, stackTraceLimit
   * Opera 10 to 12 & next: Error: message
   * Opera 11.5: Function: prototype
   * Safari 4 to 6 & next: Error: message
   * There are most probably other native objects that do not agree: Object and
   * Array should be fine in all
   * environments.
   *
   * @private
   * @function module:util-x~exports.Object.keys
   * @param {Object} object
   * @return {Array}
   * @see https://goo.gl/qIyqWO
   */
  $objectKeys = exports.Object.keys;

  /**
   * Default compare function for stableSort.
   *
   * @private
   * @function module:util-x~$ascending
   * @param {*} left
   * @param {*} right
   * @return {number}
   */
  function $ascending(left, right) {
    var leftS = $toString(left),
      rightS = $toString(right),
      val;

    if (leftS === rightS) {
      val = +0;
    } else if (leftS < rightS) {
      val = -1;
    } else {
      val = 1;
    }

    return val;
  }

  /**
   * Default compare function for stableSort.
   *
   * @private
   * @function module:util-x~$descending
   * @param {*} left
   * @param {*} right
   * @return {number}
   */
  function $descending(left, right) {
    var leftS = $toString(left),
      rightS = $toString(right),
      val;

    if (leftS === rightS) {
      val = +0;
    } else if (leftS < rightS) {
      val = 1;
    } else {
      val = -1;
    }

    return val;
  }

  /**
   * This method sorts the elements of the array in place and returns the array.
   * This is a stable sort. The default sort order is lexicographic
   * (not numeric).
   *
   * @function module:util-x~exports.Array.proto.stableSort
   * @this {module:util-x~ArrayLike}
   * @throws {TypeError} If array is null or undefined
   * @param {Function} [compareFN]
   * @throws {TypeError} If compareFN is not undefined or is not a function
   * @return {module:util-x~ArrayLike} same type as supplied array argument.
   * @see https://goo.gl/Vy3v90
   * @see http://en.wikipedia.org/wiki/Sorting_algorithm#Stability
   */
  exports.Array.proto.stableSort = (function () {
    /**
     * sortCompare function for stableSort.
     *
     * @private
     * @function
     * @param {*} object
     * @param {*} left
     * @param {*} right
     * @return {number}
     */
    function sortCompare(left, right) {
      var hasj = $call(pHasOwn, left, 0),
        hask = $call(pHasOwn, right, 0),
        isUndefX,
        isUndefY,
        val;

      if (!hasj && !hask) {
        val = +0;
      } else if (!hasj) {
        val = 1;
      } else if (!hask) {
        val = -1;
      } else {
        isUndefX = typeof left[0] === 'undefined';
        isUndefY = typeof right[0] === 'undefined';
        if (isUndefX && isUndefY) {
          val = +0;
        } else if (isUndefX) {
          val = 1;
        } else if (isUndefY) {
          val = -1;
        }
      }

      return val;
    }

    /**
     * merge function for stableSort.
     *
     * @private
     * @function
     * @param {module:util-x~ArrayLike} left
     * @param {module:util-x~ArrayLike} right
     * @param {Function} comparison
     * @return {Array}
     */
    function merge(left, right, comparison) {
      var result = [],
        next = 0,
        sComp;

      result.length = $toLength($toLength(left.length) +
                                $toLength(right.length));
      while ($toLength(left.length) && $toLength(right.length)) {
        sComp = sortCompare(left, right);
        if (typeof sComp !== 'number') {
          if (comparison(left[0], right[0]) <= 0) {
            if ($call(pHasOwn, left, 0)) {
              result[next] = left[0];
            }

            $shift(left);
          } else {
            if ($call(pHasOwn, right, 0)) {
              result[next] = right[0];
            }

            $shift(right);
          }
        } else if (sComp <= 0) {
          if ($call(pHasOwn, left, 0)) {
            result[next] = left[0];
          }

          $shift(left);
        } else {
          if ($call(pHasOwn, right, 0)) {
            result[next] = right[0];
          }

          $shift(right);
        }

        next += 1;
      }

      while ($toLength(left.length)) {
        if ($call(pHasOwn, left, 0)) {
          result[next] = left[0];
        }

        $shift(left);
        next += 1;
      }

      while ($toLength(right.length)) {
        if ($call(pHasOwn, right, 0)) {
          result[next] = right[0];
        }

        $shift(right);
        next += 1;
      }

      return result;
    }

    /**
     * mergeSort function for stableSort.
     *
     * @private
     * @function module:util-x~mergeSort
     * @param {module:util-x~ArrayLike} array
     * @param {Function} comparefn
     * @return {Array}
     */
    function mergeSort(array, comparefn) {
      var length = $toLength(array.length),
        middle,
        front,
        back,
        val;

      if (length < 2) {
        val = $slice(array);
      } else {
        middle = $ceil(length / 2);
        front = $slice(array, 0, middle);
        back = $slice(array, middle);
        val = merge(
          mergeSort(front, comparefn),
          mergeSort(back, comparefn),
          comparefn
        );
      }

      return val;
    }

    return function (comparefn) {
      var object = $toObject(this),
        length = $toLength(object.length),
        index,
        sorted;

      if (typeof comparefn === 'undefined') {
        comparefn = $ascending;
      }

      $throwIfNotFunction(comparefn);
      if (length > 1) {
        sorted = mergeSort(object, comparefn);
        if ($isArray(object) || $isArguments(object)) {
          object.length = 0;
        } else {
          $splice(object, 0, $toLength(object.length));
        }

        object.length = $toLength(sorted.length);
        for (index = 0; index < length; index += 1) {
          if ($call(pHasOwn, sorted, index)) {
            object[index] = sorted[index];
          }
        }
      }

      return object;
    };
  }());

  /**
   * This {@link module:util-x~boundPrototypalFunction method} method sorts
   * the elements of an array in place and returns the array.  This is a stable
   * sort. The default sort order is lexicographic (not numeric).
   *
   * @function module:util-x~exports.Array.stableSort
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @param {Function} [compareFN]
   * @throws {TypeError} If compareFN is defined and is not a function
   * @return {module:util-x~ArrayLike} same type as supplied array argument.
   * @see https://goo.gl/Vy3v90
   * @see http://en.wikipedia.org/wiki/Sorting_algorithm#Stability
   */
  exports.Array.stableSort = $toMethod(exports.Array.proto.stableSort);

  /**
   * This method sorts the elements the array in place and returns the array.
   * The sort may be unstable depending on the browser. The default sort order
   * is lexicographic (not numeric).
   *
   * @function module:util-x~exports.Array.proto.sort
   * @this {module:util-x~ArrayLike}
   * @throws {TypeError} If array is null or undefined
   * @param {Function} [compareFN]
   * @throws {TypeError} If compareFN is not undefined or is not a function
   * @return {module:util-x~ArrayLike} same type as supplied array argument.
   * @see https://goo.gl/Vy3v90
   */
  exports.Array.proto.sort = (function () {
    return $decide(
      // test
      function () {
        $affirmBasic(base.Array.sort)();

        var sortArr = [],
          sortObj;

        sortArr.length = 9;
        sortArr[0] = 'f';
        sortArr[1] = 'e';
        sortArr[2] = 'd';
        sortArr[4] = null;
        sortArr[5] = Undefined;
        sortArr[6] = 'a';
        sortArr[7] = 'c';
        sortArr[8] = 'b';

        $call(base.Array.sort, sortArr);
        $affirm.strictEqual(sortArr.length, 9, 'test1');
        $affirm.strictEqual(sortArr[0], 'a', 'test2');
        $affirm.strictEqual(sortArr[1], 'b', 'test3');
        $affirm.strictEqual(sortArr[2], 'c', 'test4');
        $affirm.strictEqual(sortArr[3], 'd', 'test5');
        $affirm.strictEqual(sortArr[4], 'e', 'test6');
        $affirm.strictEqual(sortArr[5], 'f', 'test7');
        $affirm.strictEqual(sortArr[6], null, 'test8');
        $affirm.strictEqual(sortArr[7], Undefined, 'test9');
        $affirm.strictEqual(sortArr[8], Undefined, 'test110');
        $affirm.ok($call(pHasOwn, sortArr, 7), 'test11');
        $affirm.ok(!$call(pHasOwn, sortArr, 8), 'test12');

        sortArr.length = 9;
        sortArr[0] = 'f';
        sortArr[1] = 'e';
        sortArr[2] = 'd';
        sortArr[3] = Undefined;
        sortArr[4] = null;
        sortArr[5] = 'a';
        sortArr[6] = 'c';
        sortArr[7] = 'b';

        $call(base.Array.sort, sortArr, $descending);
        $affirm.strictEqual(sortArr.length, 9, 'test13');
        $affirm.strictEqual(sortArr[0], null, 'test14');
        $affirm.strictEqual(sortArr[1], 'f', 'test15');
        $affirm.strictEqual(sortArr[2], 'e', 'test16');
        $affirm.strictEqual(sortArr[3], 'd', 'test17');
        $affirm.strictEqual(sortArr[4], 'c', 'test18');
        $affirm.strictEqual(sortArr[5], 'b', 'test19');
        $affirm.strictEqual(sortArr[6], 'a', 'test20');
        $affirm.strictEqual(sortArr[7], Undefined, 'test21');
        $affirm.strictEqual(sortArr[8], Undefined, 'test22');
        $affirm.ok($call(pHasOwn, sortArr, 7), 'test23');
        $affirm.ok(!$call(pHasOwn, sortArr, 8), 'test24');

        sortObj = {
          0: 5,
          1: 2,
          2: 4,
          4: null,
          6: 1,
          7: 3,
          length: 8
        };

        $call(base.Array.sort, sortObj, $descending);
        $affirm.strictEqual(sortObj.length, 8, 'test25');
        $affirm.strictEqual(sortObj[0], null, 'test26');
        $affirm.strictEqual(sortObj[1], 5, 'test27');
        $affirm.strictEqual(sortObj[2], 4, 'test28');
        $affirm.strictEqual(sortObj[3], 3, 'test29');
        $affirm.strictEqual(sortObj[4], 2, 'test30');
        $affirm.strictEqual(sortObj[5], 1, 'test31');
        $affirm.strictEqual(sortObj[6], Undefined, 'test32');
        $affirm.strictEqual(sortObj[7], Undefined, 'test33');
        $affirm.ok(!$call(pHasOwn, sortObj, 6), 'test34');
        $affirm.ok(!$call(pHasOwn, sortObj, 7), 'test35');
      },

      // pass
      function () {
        return $decide(
          // test
          function () {
            $affirm.doesNotThrow(function () {
              $call(base.Array.sort, []);
            }, 'no compare argument');

            $affirm.doesNotThrow(function () {
              $call(base.Array.sort, [], Undefined);
            }, 'undefined compare argument');

            $affirm.throws(function () {
              $call(base.Array.sort, [], null);
            }, CTypeError, 'null compare argument');

            $affirm.throws(function () {
              $call(base.Array.sort, [], 1);
            }, CTypeError, 'number compare argument');

            $affirm.throws(function () {
              $call(base.Array.sort, [], true);
            }, CTypeError, 'boolean compare argument');

            $affirm.throws(function () {
              $call(base.Array.sort, [], 'a');
            }, CTypeError, 'string compare argument');

            $affirm.throws(function () {
              $call(base.Array.sort, [], {});
            }, CTypeError, 'object compare argument');

            $affirm.throws(function () {
              $call(base.Array.sort, [], []);
            }, CTypeError, 'array compare argument');
          },

          // pass
          function () {
            return base.Array.sort;
          },

          // fail
          function () {
            var pSort = base.Array.sort;

            return function (comparefn) {
              if (typeof comparefn === 'undefined') {
                comparefn = $ascending;
              }

              return $call(
                pSort,
                $requireObjectCoercible(this),
                $throwIfNotFunction(comparefn)
              );
            };
          },

          // message
          'Array.sort patch'
        );
      },

      // fail
      function () {
        return exports.Array.proto.stableSort;
      },

      // message
      'Array.sort shim'
    );
  }());

  /**
   * This {@link module:util-x~boundPrototypalFunction method} sorts the
   * elements of an array in place and returns the array. The sort may be
   * unstable depending on the browser. The default sort order is lexicographic
   * (not numeric).
   *
   * @function module:util-x~exports.Array.sort
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @param {Function} [compareFN]
   * @throws {TypeError} If compareFN is defined and is not a function
   * @return {module:util-x~ArrayLike} same type as supplied array argument.
   * @see https://goo.gl/Vy3v90
   */
  exports.Array.sort = $toMethod(exports.Array.proto.sort);

  /**
   * Shortcut
   * This {@link module:util-x~boundPrototypalFunction method} sorts the
   * elements of an array in place and returns the array.The sort may be
   * unstable depending on the browser. The default sort order is lexicographic
   * (not numeric).
   *
   * @private
   * @function module:util-x~$sort
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @param {Function} [compareFN]
   * @throws {TypeError} If compareFN is defined and is not a function
   * @return {module:util-x~ArrayLike} same type as supplied array argument.
   * @see https://goo.gl/Vy3v90
   */
  $sort = exports.Array.sort;

  /**
   * This method returns the first index at which a given element can
   * be found in the array, or -1 if it is not present.
   *
   * @function module:util-x~exports.Array.proto.indexOf
   * @this {module:util-x~ArrayLike}
   * @throws {TypeError} If array is null or undefined
   * @param {*} searchElement
   * @param {number} [fromIndex]
   * @return {number}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf
   */
  exports.Array.proto.indexOf = $decide(
    // test
    function () {
      $affirmBasic(base.Array.indexOf)();

      var value;

      $affirm.doesNotThrow(function () {
        value = $call(base.Array.indexOf, [0, 1], 1, 2);
      }, 'test1');

      $affirm.strictEqual(value, -1, 'item not found');
    },

    // pass
    function () {
      return base.Array.indexOf;
    },

    // fail
    function () {
      return function (searchElement, fromIndex) {
        var object = $toObject(this),
          length = $toLength(object.length),
          isString = length && $isString(object),
          val = -1,
          index;

        if (length) {
          if (arguments.length > 1) {
            fromIndex = $toInteger(fromIndex);
          } else {
            fromIndex = 0;
          }

          if (fromIndex < length) {
            if (fromIndex < 0) {
              fromIndex = length - $abs(fromIndex);
              if (fromIndex < 0) {
                fromIndex = 0;
              }
            }

            for (index = fromIndex; index < length; index += 1) {
              if ($hasItem(object, index, isString) &&
                  searchElement === $getItem(object, index, isString)) {

                val = index;
                break;
              }
            }
          }
        }

        return val;
      };
    },

    // message
    'Array.indexOf shim'
  );

  /**
   * This {@link module:util-x~boundPrototypalFunction method} returns the
   * first index at which a given element can be found in the array, or -1 if it
   * is not present.
   *
   * @function module:util-x~exports.Array.indexOf
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @param {*} searchElement
   * @param {number} [fromIndex]
   * @return {number}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf
   */
  exports.Array.indexOf = $toMethod(exports.Array.proto.indexOf);

  /**
   * Shortcut
   * This {@link module:util-x~boundPrototypalFunction method} returns the
   * first index at which a given element can be found in the array, or -1 if it
   * is not present.
   *
   * @private
   * @function module:util-x~$indexOf
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @param {*} searchElement
   * @param {number} [fromIndex]
   * @return {number}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf
   */
  $indexOf = exports.Array.indexOf;

  /**
   * Returns true if the specified searchElement is in the specified array.
   * Using strict equality (the same method used by the === comparison
   * operator).
   *
   * @function module:util-x~exports.Array.proto.contains
   * @this {module:util-x~ArrayLike}
   * @throws {TypeError} If array is null or undefined
   * @param {*} searchElement
   * @return {boolean}
   */
  exports.Array.proto.contains = (function (pEAIndexOf) {
    return function () {
      return $apply(pEAIndexOf, this, arguments) !== -1;
    };
  }(exports.Array.proto.indexOf));

  /**
   * Returns true if the specified searchElement is in the specified array.
   * Using strict equality (the same method used by the === comparison
   * operator).
   *
   * @function module:util-x~exports.Array.contains
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @param {*} searchElement
   * @return {boolean}
   */
  exports.Array.contains = $toMethod(exports.Array.proto.contains);

  /**
   * Tests a deep equality relation.
   *
   * @function module:util-x~exports.Object.deepEqual
   * @param {*} a
   * @param {*} b
   * @return {boolean}
   * @see http://wiki.commonjs.org/wiki/Unit_Testing/1.0
   */
  exports.Object.deepEqual = (function () {
    var de = function (a, b, circ) {
      if (a === b) {
        return true;
      }

      var aIsString,
        bIsString,
        aType,
        bType,
        aIsArgs,
        bIsArgs,
        aIsPrim,
        bIsPrim,
        aCirc,
        bCirc,
        ka,
        kb,
        length,
        index,
        it;

      if ($isDate(a) && $isDate(b)) {
        return $toPrimitive(a, hintString) === $toPrimitive(b, hintString);
      }

      if ($isRegExp(a) && $isRegExp(b)) {
        return a.source === b.source &&
          a.global === b.global &&
          a.multiline === b.multiline &&
          a.lastIndex === b.lastIndex &&
          a.ignoreCase === b.ignoreCase &&
          a.sticky === b.sticky;
      }

      aIsPrim = $isPrimitive(a);
      bIsPrim = $isPrimitive(b);
      if ((aIsPrim || $isFunction(a)) && (bIsPrim || $isFunction(b))) {
        /*jslint eqeq:true */
        return a == b;
      }

      if (aIsPrim || bIsPrim) {
        return a === b;
      }

      if (a.prototype !== b.prototype) {
        return false;
      }

      if ($indexOf(circ.a, a) === -1) {
        $push(circ.a, a);
      } else {
        aCirc = true;
      }

      if ($indexOf(circ.b, b) === -1) {
        $push(circ.b, b);
      } else {
        bCirc = true;
      }

      if (aCirc && bCirc) {
        circ.cnt += 1;
      } else {
        circ.cnt = 0;
      }

      if (circ.cnt > 200) {
        throw new CRangeError('Circular reference limit exceeded');
      }

      aIsArgs = $isArguments(a);
      bIsArgs = $isArguments(b);
      if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs)) {
        return false;
      }

      if (aIsArgs) {
        return de($slice(a), $slice(b), circ);
      }

      ka = $objectKeys(a);
      kb = $objectKeys(b);
      length = $toLength(ka.length);
      if (length !== $toLength(kb.length)) {
        if ($isArray(a) && $isArray(b)) {
          if (a.length !== b.length) {
            return false;
          }
        } else {
          return false;
        }
      } else {
        $sort(ka);
        $sort(kb);
        for (index = 0; index < length; index += 1) {
          if (ka[index] !== kb[index]) {
            return false;
          }
        }
      }

      aIsString = $isString(a);
      bIsString = $isString(b);
      for (index = 0; index < length; index += 1) {
        it = ka[index];
        if (!de($getItem(a, it, aIsString), $getItem(b, it, bIsString), circ)) {
          return false;
        }
      }

      aType = typeof a;
      bType = typeof b;

      return aType === bType;
    };

    return function (a, b) {
      return de(a, b, {
        a: [],
        b: [],
        cnt: 0
      });
    };
  }());

  /**
   * Tests a deep equality relation.
   *
   * @private
   * @function module:util-x~$deepEqual
   * @param {*} a
   * @param {*} b
   * @return {boolean}
   * @see http://wiki.commonjs.org/wiki/Unit_Testing/1.0
   */
  $deepEqual = exports.Object.deepEqual;

  /**
   * Tests for deep equality, coercive equality with the equal comparison
   * operator ( == ) and equivalent.
   *
   * @private
   * @function module:util-x~$affirm.deepEqual
   * @param {*} actual
   * @param {*} expected
   * @param {string} [message]
   * @param {Function} [stackStartFn]
   * @return {undefined}
   */
  $affirm.deepEqual = function (actual, expected, message, stackStartFn) {
    $throwIfNotEnoughArgs(arguments, 2);

    var opt;

    if (!$deepEqual(actual, expected)) {
      opt = $optArgs(3, message, stackStartFn, $affirm.deepEqual);
      $affirm.fail(actual, expected, opt.message, 'deepEqual',
                   opt.stackStartFn);
    }
  };

  /**
   * Tests a deep equality relation.
   *
   * @function module:util-x~exports.Object.deepStrictEqual
   * @param {*} a
   * @param {*} b
   * @return {boolean}
   */
  exports.Object.deepStrictEqual = (function () {
    var de = function (a, b, circ) {
      if (a === b) {
        return true;
      }

      var aIsString,
        bIsString,
        aType,
        bType,
        aIsArgs,
        bIsArgs,
        aIsPrim,
        bIsPrim,
        aCirc,
        bCirc,
        ka,
        kb,
        length,
        index,
        it;

      if ($isDate(a) && $isDate(b)) {
        return $toPrimitive(a, hintString) === $toPrimitive(b, hintString);
      }

      if ($isRegExp(a) && $isRegExp(b)) {
        return a.source === b.source &&
          a.global === b.global &&
          a.multiline === b.multiline &&
          a.lastIndex === b.lastIndex &&
          a.ignoreCase === b.ignoreCase &&
          a.sticky === b.sticky;
      }

      aIsPrim = $isPrimitive(a);
      bIsPrim = $isPrimitive(b);
      if ((aIsPrim || $isFunction(a)) && ($isPrimitive(b) || $isFunction(b))) {
        return a === b;
      }

      if (aIsPrim || bIsPrim) {
        return a === b;
      }

      if ($getPrototypeOf(a) !== $getPrototypeOf(b)) {
        return false;
      }

      if ($indexOf(circ.a, a) === -1) {
        $push(circ.a, a);
      } else {
        aCirc = true;
      }

      if ($indexOf(circ.b, b) === -1) {
        $push(circ.b, b);
      } else {
        bCirc = true;
      }

      if (aCirc && bCirc) {
        circ.cnt += 1;
      } else {
        circ.cnt = 0;
      }

      if (circ.cnt > 200) {
        throw new CRangeError('Circular reference limit exceeded');
      }

      aIsArgs = $isArguments(a);
      bIsArgs = $isArguments(b);
      if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs)) {
        return false;
      }

      if (aIsArgs) {
        return de($slice(a), $slice(b), circ);
      }

      ka = $objectKeys(a);
      kb = $objectKeys(b);
      length = $toLength(ka.length);
      if (length !== $toLength(kb.length)) {
        if ($isArray(a) && $isArray(b)) {
          if (a.length !== b.length) {
            return false;
          }
        } else {
          return false;
        }
      } else {
        $sort(ka);
        $sort(kb);
        for (index = 0; index < length; index += 1) {
          if (ka[index] !== kb[index]) {
            return false;
          }
        }
      }

      aIsString = $isString(a);
      bIsString = $isString(b);
      for (index = 0; index < length; index += 1) {
        it = ka[index];
        if (!de($getItem(a, it, aIsString), $getItem(b, it, bIsString), circ)) {
          return false;
        }
      }

      aType = typeof a;
      bType = typeof b;

      return aType === bType;
    };

    return function (a, b) {
      return de(a, b, {
        a: [],
        b: [],
        cnt: 0
      });
    };
  }());

  /**
   * Tests a deep equality relation.
   *
   * @private
   * @function module:util-x~$deepStrictEqual
   * @param {*} a
   * @param {*} b
   * @return {boolean}
   */
  $deepStrictEqual = exports.Object.deepStrictEqual;

  // RegExp closure
  (function () {
    var clipDups = new CRegExp('([\\s\\S])(?=[\\s\\S]*\\1)', 'g'),
      // Check for correct `exec` handling of nonparticipating capturing groups
      npcgType = typeof $call(pExec, new CRegExp('()??'), '')[1],
      escapeThese = new CRegExp('[\\[\\](){}?*+\\^$\\\\.|]', 'g'),
      correctExecNpcg = npcgType === 'undefined',
      replacementToken = new CRegExp('\\$(?:\\{(\\$+)\\}|(\\d\\d?|[\\s\\S]))',
                                     'g'),
      getNativeFlags = new CRegExp('\\/([a-z]*)$', 'i'),
      es5limit = $join($call(pSplit, 'test', /(?:)/, -1), '') === 'test' &&
        $join($call(pSplit, 'a b c d', / /, -(UWORD32 - 1)), '') === 'a' &&
        $join($call(pSplit, 'a b c d', / /, UWORD32 + 1), '') === 'a' &&
        $join($call(pSplit, 'a b c d', / /, INFINITY), '') === '';

    /**
     * This method takes a string and puts a backslash in front of every
     * character that is part of the regular expression syntax. This is useful
     * if you have a run-time string that you need to match in some text and the
     * string may contain special regex characters. Throws an error if the
     * argument can not be coerced, i.e. null or undefined.
     *
     * @function module:util-x~exports.String.proto.escapeRegex
     * @this {string}
     * @return {string}
     */
    exports.String.proto.escapeRegex = function () {
      return $call(pReplace, $onlyCoercibleToString(this), escapeThese, '\\$&');
    };

    /**
     * This {@link module:util-x~boundPrototypalFunction method} takes a
     * string and puts a backslash in front of every character that is part of
     * the regular expression syntax. This is useful if you have a run-time
     * string that you need to match in some text and the string may contain
     * special regex characters. Throws an error if the argument can not be
     * coerced, i.e. null or undefined.
     *
     * @private
     * @function module:util-x~$escapeRegex
     * @param {string} string
     * @return {string}
     */
    $escapeRegex = $toMethod(exports.String.proto.escapeRegex);

    /**
     * This {@link module:util-x~boundPrototypalFunction method} takes a
     * string and puts a backslash in front of every character that is part of
     * the regular expression syntax. This is useful if you have a run-time
     * string that you need to match in some text and the string may contain
     * special regex characters. Throws an error if the argument can not be
     * coerced, i.e. null or undefined.
     *
     * @function module:util-x~exports.String.escapeRegex
     * @param {string} string
     * @return {string}
     */
    exports.String.escapeRegex = $escapeRegex;

    /**
     * Removes any duplicate characters from the provided string.
     *
     * @function module:util-x~exports.String.clipDuplicates
     * @param {string} str String to remove duplicate characters from.
     * @return {string} String with any duplicate characters removed.
     */
    exports.String.clipDuplicates = function (str) {
      return $call(pReplace, $onlyCoercibleToString(str), clipDups, '');
    };

    /**
     * Throws a TypeError if the argument is not a RegExp.
     *
     * @private
     * @function module:util-x~throwIfNotRegExp
     * @param {*} inputArg
     * @throws {TypeError} If inputArg is not a RegExp.
     * @return {RegExp}
     */
    function throwIfNotRegExp(inputArg) {
      if (!$isRegExp(inputArg)) {
        throw new CTypeError('Type RegExp expected: ' + $toString(inputArg));
      }

      return inputArg;
    }

    /**
     * Copies a regex object. Allows adding and removing native flags while
     * copying the regex.
     *
     * @private
     * @function module:util-x~copyRegExp
     * @param {RegExp} regex Regex to copy.
     * @param {Object} [options] Allows specifying native flags to add or remove
     *                           while copying the regex.
     * @return {RegExp} Copy of the provided regex, possibly with modified
     *                  flags.
     */
    function copyRegExp(regExpArg, options) {
      var flags;

      if (!$isPlainObject(options)) {
        options = {};
      }

      // Get native flags in use
      flags = $onlyCoercibleToString(
        $call(pExec, getNativeFlags, $toString(regExpArg))[1]);
      if (options.add) {
        flags = $call(pReplace, flags + options.add, clipDups, '');
      }

      if (options.remove) {
        // Would need to escape `options.remove` if this was public
        flags = $call(pReplace, flags, new CRegExp('[' + options.remove + ']+',
                                                   'g'), '');
      }

      return new CRegExp(regExpArg.source, flags);
    }

    /**
     * Fixes browser bugs in the native `RegExp.prototype.exec`.
     *
     * @function module:util-x~exports.RegExp.proto.exec
     * @this {RegExp}
     * @param {string} stringArg String to search.
     * @return {Array} Match array with named backreference properties, or
     *                 `null`.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec
     */
    exports.RegExp.proto.exec = $decide(
      // test
      function () {
        $affirmBasic(pExec)();

        $affirm.throws(function () {
          $call(pExec);
        }, CTypeError, 'should throw if no arguments');

        $affirm.throws(function () {
          $call(pExec, Undefined);
        }, CTypeError, 'should throw if argument is undefined');

        $affirm.throws(function () {
          $call(pExec, null);
        }, CTypeError, 'should throw if argument is null');

        $affirm.doesNotThrow(function () {
          $call(pExec, /x/);
        }, 'should not throw if no string argument');

        $affirm.doesNotThrow(function () {
          $call(pExec, /x/, Undefined);
        }, 'should not throw if string argument is undefined');

        $affirm.doesNotThrow(function () {
          $call(pExec, /x/, null);
        }, 'should not throw if string argument is null');

        var regex = /x/,
          match;

        regex.lastIndex = 4;
        $affirm.deepEqual($slice($call(pExec, regex, '123x5')), ['x'],
          'should ignore lastIndex and set the search start position at 0 for a nonglobal regex');

        regex = /x/g;

        regex.lastIndex = 4;
        $affirm.strictEqual($call(pExec, regex, '123x5'), null,
          'should use lastIndex to set the search start position ' +
          'for a global regex');

        regex.lastIndex = 2;
        $affirm.deepEqual($slice($call(pExec, regex, '123x5')), ['x'],
          'should use lastIndex to set the search start position for ' +
          'a global regex');

        regex = /x/g;

        regex.lastIndex = '3';
        $affirm.deepEqual($slice($call(pExec, regex, '123x5')), ['x'],
          'should type convert lastIndex when setting the search start ' +
          'position');

        regex.lastIndex = '4';
        $affirm.strictEqual($call(pExec, regex, '123x5'), null,
          'should type convert lastIndex when setting the search start ' +
          'position');

        regex = /\b/g;
        match = $call(pExec, regex, '1,2');

        $affirm.deepEqual(match[0].length, 0,
          'should not increment index on zero length mathces');
        $affirm.deepEqual(regex.lastIndex, match.index,
          'should not increment index on zero length mathces');

        regex = /x/;

        $call(pExec, regex, '123x5');

        $affirm.strictEqual(regex.lastIndex, 0,
          'should not increment lastIndex non global');
      },

      // pass
      function () {
        return pExec;
      },

      // fail
      function () {
        return function (stringArg) {
          var origLastIndex = $toNumber(throwIfNotRegExp(this).lastIndex),
            match = $apply(pExec, this, arguments),
            found,
            len,
            idx;

          if ($isArray(match)) {
            /* Fix browsers whose `exec` methods don't return `undefined` for
             * nonparticipating capturing groups. This fixes IE 5.5-8, but not
             * IE 9's quirks mode or emulation of older IEs. IE 9 in standards
             * mode follows the spec
             */
            len = $toLength(match.length);
            if (!correctExecNpcg && len > 1) {
              for (idx = 0; idx < len; idx += 1) {
                if ('' === match[idx]) {
                  found = true;
                  break;
                }
              }

              if (found) {
                /* Using `str.slice(match.index)` rather than `match[0]` in
                 * case lookahead allowed matching due to characters outside
                 * the match
                 */
                $call(
                 pReplace,
                 $sSlice($toString(stringArg), $toNumber(match.index)),
                 copyRegExp(this, { remove: 'g' }),
                 function () {
                  var length = $toLength(arguments.length) - 2,
                    index,
                    it;

                  // Skip index 0 and the last 2
                  for (index = 1; index < length; index += 1) {
                    it = arguments[index];
                    if ($isUndefined(it)) {
                      match[index] = it;
                    }
                  }
                });
              }
            }

            // Fix browsers that increment `lastIndex` after zero-length matches
            if (this.global && !$toLength(match[0].length) &&
                $toNumber(this.lastIndex) > $toNumber(match.index)) {

              this.lastIndex = $toNumber(match.index);
            }
          }

          if (!this.global) {
            // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
            this.lastIndex = origLastIndex;
          }

          return match;
        };
      },

      // message
      'RegExp.exec patch'
    );

    /**
     * Fixes browser bugs in the native `RegExp.prototype.exec`.
     *
     * @function module:util-x~exports.RegExp.exec
     * @param {RegExp} regExpArg
     * @param {string} stringArg String to search.
     * @return {Array} Match array with named backreference properties, or
     *                 `null`.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec
     */
    exports.RegExp.exec = $toMethod(exports.RegExp.proto.exec);

    /**
     * Fixes browser bugs in the native `RegExp.prototype.exec`.
     *
     * @private
     * @function module:util-x~$exec
     * @param {RegExp} regExpArg
     * @param {string} stringArg String to search.
     * @return {Array} Match array with named backreference properties, or
     *                 `null`.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec
     */
    $exec = exports.RegExp.exec;

    /**
     * Fixes browser bugs in the native `RegExp.prototype.test`.
     *
     * @function module:util-x~exports.RegExp.proto.test
     * @this {RegExp}
     * @param {string} stringArg String to search.
     * @return {Boolean} Whether the regex matched the provided value.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test
     */
    exports.RegExp.proto.test = $decide(
      // test
      function () {
        $affirmBasic(pTest)();
        $affirm.strictEqual(exports.RegExp.proto.exec, pExec,
                            'RegExp.exec was patched');

        $affirm.throws(function () {
          $call(pTest);
        }, CTypeError, 'should throw if no arguments');

        $affirm.throws(function () {
          $call(pTest, Undefined);
        }, CTypeError, 'should throw if argument is undefined');

        $affirm.throws(function () {
          $call(pTest, null);
        }, CTypeError, 'should throw if argument is null');

        $affirm.doesNotThrow(function () {
          $call(pTest, /x/);
        }, 'should not throw if no string argument');

        $affirm.doesNotThrow(function () {
          $call(pTest, /x/, Undefined);
        }, 'should not throw if string argument is undefined');

        $affirm.doesNotThrow(function () {
          $call(pTest, /x/, null);
        }, 'should not throw if string argument is null');

        var regex = /x/;

        regex.lastIndex = 4;
        $affirm.ok($call(pTest, regex, '123x5'),
          'should ignore lastIndex and set the search start position at ' +
          '0 for a nonglobal regex');

        regex = /x/g;
        regex.lastIndex = 4;
        $affirm.ok(!$call(pTest, regex, '123x5'),
          'should use lastIndex to set the search start position for a ' +
          'global regex');

        regex.lastIndex = 2;
        $affirm.ok($call(pTest, regex, '123x5'),
          'should use lastIndex to set the search start position for a ' +
          'global regex');

        regex = /x/g;
        regex.lastIndex = '3';
        $affirm.ok($call(pTest, regex, '123x5'),
          'should type convert lastIndex when setting the search start ' +
          'position');

        regex.lastIndex = '4';
        $affirm.ok(!$call(pTest, regex, '123x5'),
          'should type convert lastIndex when setting the search start ' +
          'position');

        regex = /x/g;
        $affirm.ok(!$call(pTest, regex), 'should type no argument to string');
        $affirm.ok(!$call(pTest, regex, undefined),
          'should type undefined to string');
        $affirm.ok(!$call(pTest, regex, null), 'should type null to string');
        $affirm.ok(!$call(pTest, regex, 1), 'should type 1 to string');
        $affirm.ok(!$call(pTest, regex, true), 'should type true to string');
        $affirm.ok(!$call(pTest, regex, {}), 'should type {} to string');
        $affirm.ok(!$call(pTest, regex, []), 'should type [] to string');
      },

      // pass
      function () {
        return pTest;
      },

      // fail
      function () {
        return function (stringArg) {
          // Do this the easy way :-)
          return !!$exec(this, stringArg);
        };
      },

      // message
      'RegExp.test shim'
    );

    /**
     * Fixes browser bugs in the native `RegExp.prototype.test`.
     *
     * @function module:util-x~exports.RegExp.test
     * @param {RegExp} regExpArg
     * @param {string} stringArg String to search.
     * @return {Boolean} Whether the regex matched the provided value.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test
     */
    exports.RegExp.test = $toMethod(exports.RegExp.proto.test);

    /**
     * Fixes browser bugs in the native `RegExp.prototype.test`.
     *
     * @private
     * @function module:util-x~$test
     * @param {RegExp} regExpArg
     * @param {string} stringArg String to search.
     * @return {Boolean} Whether the regex matched the provided value.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test
     */
    $test = exports.RegExp.test;

    /**
     * Checks to see that the string is only comprised of byte sized characters.
     *
     * @function module:util-x~exports.String.proto.isBytestring
     * @this {string}
     * @return {Boolean} Is a bytestring or not.
     */
    exports.String.proto.isBytestring = function () {
      return $test(/^[\x00-\xFF]*$/, $onlyCoercibleToString(this));
    };

    /**
     * Checks to see that the string is only comprised of byte sized characters.
     *
     * @function module:util-x~exports.String.isBytestring
     * @param {string} stringArg String to check.
     * @return {Boolean} Is a bytestring or not.
     */
    exports.String.isBytestring = $toMethod(exports.String.proto.isBytestring);

    /**
     * Executes a search for a match between a regular expression and this
     * String object.
     *
     * @function module:util-x~exports.String.proto.search
     * @this {string}
     * @param {RegExp|string} regex A regular expression object. If a non-RegExp
     *                              object obj is passed,  it is implicitly
     *                              converted to a RegExp by using
     *                              new RegExp(obj).
     * @return {Number} If successful, returns the index of the first match of
     *                  the regular expression inside the string. Otherwise,
     *                  it returns -1.
     */
    exports.String.proto.search = $decide(
      // test
      function () {
        $affirmBasic(pSearch)();

        var rx1 = new CRegExp('c'),
          rx2 = new CRegExp('c', 'gmi'),
          testStr = 'abcdefgabcdefg',
          index;

        $affirm.doesNotThrow(function () {
          index = $call(pSearch, testStr, rx1);
        }, 'should not throw performing search rx1');

        $affirm.strictEqual(index, 2,
                            'rx1 gives correct index');
        $affirm.strictEqual(rx1.source, 'c',
                            'rx1 source should be unchanged');
        $affirm.strictEqual(rx1.global, false,
                            'rx1 global should be unchanged');
        $affirm.strictEqual(rx1.ignoreCase, false,
                            'rx1 ignoreCase should be unchanged');
        $affirm.strictEqual(rx1.multiline, false,
                            'rx1 multiline should be unchanged');
        $affirm.strictEqual(rx1.lastIndex, 0,
                            'rx1 lastIndex should be unchanged');

        $affirm.doesNotThrow(function () {
          index = $call(pSearch, testStr, rx2);
        }, 'should not throw performing search rx2');

        $affirm.strictEqual(index, 2,
                            'rx2 gives correct index');
        $affirm.strictEqual(rx2.source, 'c',
                            'rx2 source should be unchanged');
        $affirm.strictEqual(rx2.global, false,
                            'rx2 global should be unchanged');
        $affirm.strictEqual(rx2.ignoreCase, false,
                            'rx2 ignoreCase should be unchanged');
        $affirm.strictEqual(rx2.multiline, false,
                            'rx2 multiline should be unchanged');
        $affirm.strictEqual(rx2.lastIndex, 0,
                            'rx2 lastIndex should be unchanged');
      },

      //pass
      function () {
        return pSearch;
      },

      //fail
      function () {
        return function (regex) {
          var str = $onlyCoercibleToString(this),
            result = -1,
            match,
            rx;

          if ($isRegExp(regex)) {
            rx = copyRegExp(regex, {
              remove: 'gy'
            });
          } else {
            if (typeof regex === 'undefined') {
              regex = '';
            }

            rx = new CRegExp($toString(regex));
          }

          match = $exec(rx, str);
          if (match) {
            result = $toNumber(match.index);
          }

          return result;
        };
      },

      // message
      'String.search shim'
    );

    /**
     * Executes a search for a match between a regular expression and this
     * String object.
     *
     * @function module:util-x~exports.String.search
     * @param {string} stringArg String to search.
     * @param {RegExp|string} regex A regular expression object. If a non-RegExp
     *                              object obj is passed, it is implicitly
     *                              converted to a RegExp by using
     *                              new RegExp(obj).
     * @return {Number} If successful, returns the index of the first match of
     *                  the regular expression inside the string. Otherwise,
     *                  it returns -1.
     */
    exports.String.search = $toMethod(exports.String.proto.search);



    exports.String.proto.indexOf = base.String.indexOf;

    spIndexOf = exports.String.proto.indexOf;

    exports.String.indexOf = $toMethod(exports.String.proto.indexOf);

    exports.String.proto.lastIndexOf = base.String.lastIndexOf;

    spLastIndexOf = exports.String.proto.lastIndexOf;

    exports.String.lastIndexOf = $toMethod(exports.String.proto.lastIndexOf);


    /**
     * This method returns the index within the calling String object of
     * the first occurrence of the specified value, starting the search at
     * fromIndex. Returns -1 if the value is not found.
     *
     * @function module:util-x~exports.String.proto.searchOf
     * @this {string}
     * @param {RegExp|string} regex A regular expression object or a String.
     *                              Anything else is implicitly converted to
     *                              a String.
     * @param {Number} [fromIndex] The location within the calling string
     *                             to start the search from. It can be any
     *                             integer. The default value is 0. If
     *                             fromIndex < 0 the entire string is
     *                             searched (same as passing 0). If
     *                             fromIndex >= str.length, the method will
     *                             return -1 unless searchValue is an empty
     *                             string in which case str.length is
     *                             returned.
     * @return {Number} If successful, returns the index of the first
     *                   match of the regular expression inside the
     *                   string. Otherwise, it returns -1.
     */
    exports.String.proto.searchOf = function (regex) {
      var str = $onlyCoercibleToString(this),
        result = -1,
        fromIndex,
        match,
        rx;

      if (!$isRegExp(regex)) {
        return $apply(spIndexOf, str, arguments);
      }

      rx = copyRegExp(regex, {
        add: 'g',
        remove: 'y'
      });

      if ($toLength(arguments.length) > 1) {
        fromIndex = $toNumber(arguments[1]);
        if (fromIndex < 0) {
          fromIndex = 0;
        }
      } else {
        fromIndex = 0;
      }

      if (fromIndex >= $toLength(str.length)) {
        return result;
      }

      rx.lastIndex = fromIndex;
      match = $exec(rx, str);
      if (match) {
        result = $toNumber(match.index);
      }

      return result;
    };

    /**
     * This method returns the index within the calling String object of
     * the first occurrence of the specified value, starting the search at
     * fromIndex. Returns -1 if the value is not found.
     *
     * @function module:util-x~exports.String.searchOf
     * @param {string} stringArg String to search.
     * @param {RegExp|string} regex A regular expression object or a String.
     *                              Anything else is implicitly converted to
     *                              a String.
     * @param {Number} [fromIndex] The location within the calling string
     *                             to start the search from. It can be any
     *                             integer. The default value is 0. If
     *                             fromIndex < 0 the entire string is
     *                             searched (same as passing 0). If
     *                             fromIndex >= str.length, the method will
     *                             return -1 unless searchValue is an empty
     *                             string in which case str.length is
     *                             returned.
     * @return {Number} If successful, returns the index of the first
     *                   match of the regular expression inside the
     *                   string. Otherwise, it returns -1.
     */
    exports.String.searchOf = $toMethod(exports.String.proto.searchOf);

    /**
     * This method returns the index within the calling String object of
     * the last occurrence of the specified value, or -1 if not found.
     * The calling string is searched backward, starting at fromIndex.
     *
     * @function
     * @this {string}
     * @param {RegExp|string} regex A regular expression object or a String.
     *                              Anything else is implicitly converted to
     *                              a String.
     * @param {Number} [fromIndex] Optional. The location within the
     *                             calling string to start the search at,
     *                             indexed from left to right. It can be
     *                             any integer. The default value is
     *                             str.length. If it is negative, it is
     *                             treated as 0. If fromIndex > str.length,
     *                             fromIndex is treated as str.length.
     * @return {Number} If successful, returns the index of the first
     *                   match of the regular expression inside the
     *                   string. Otherwise, it returns -1.
     */
    exports.String.proto.searchLastOf = function (regex) {
      var str = $onlyCoercibleToString(this),
        result = -1,
        arg1,
        numPos,
        fromIndex,
        length,
        match,
        pos,
        rx;

      if (!$isRegExp(regex)) {
        return $apply(spLastIndexOf, str, arguments);
      }

      rx = copyRegExp(regex, {
        add: 'g',
        remove: 'y'
      });

      arg1 = arguments[1];
      numPos = $toNumber(arg1);
      length = $toLength(str.length);
      if (numPos !== numPos) {
        fromIndex = length;
      } else {
        if ($toLength(arguments.length) > 1) {
          fromIndex = $toInteger(arg1);
        } else {
          fromIndex = length - 1;
        }
      }

      if (fromIndex >= 0) {
        fromIndex = $min(fromIndex, length - 1);
      } else {
        fromIndex = 0;
      }

      pos = 0;
      while (pos <= fromIndex) {
        rx.lastIndex = pos;
        match = $exec(rx, str);
        if (!match) {
          break;
        }

        pos = $toNumber(match.index);
        if (pos <= fromIndex) {
          result = pos;
        }

        pos += 1;
      }

      return result;
    };

    /**
     * This method returns the index within the calling String object of
     * the last occurrence of the specified value, or -1 if not found.
     * The calling string is searched backward, starting at fromIndex.
     *
     * @function module:util-x~exports.String.searchLastOf
     * @param {string} stringArg
     * @param {RegExp|string} regex A regular expression object or a String.
     *                              Anything else is implicitly converted to
     *                              a String.
     * @param {Number} [fromIndex] Optional. The location within the
     *                             calling string to start the search at,
     *                             indexed from left to right. It can be
     *                             any integer. The default value is
     *                             str.length. If it is negative, it is
     *                             treated as 0. If fromIndex > str.length,
     *                             fromIndex is treated as str.length.
     * @return {Number} If successful, returns the index of the first
     *                   match of the regular expression inside the
     *                   string. Otherwise, it returns -1.
     */
    exports.String.searchLastOf = $toMethod(exports.String.proto.searchLastOf);

    /**
     * This method chunks a string into an array of strings of a specified
     * chunk size.
     *
     * @function module:util-x~exports.String.proto.chunk
     * @this {string} The string to be chunked.
     * @param {Number} chunkSize The size of the chunks that the string will
     *                           be chunked into.
     * @return {Array} Returns an array of the chunked string.
     */
    exports.String.proto.chunk = function (chunkSize) {
      var str = $onlyCoercibleToString(this),
        chunkLength = $toInteger(chunkSize),
        chunked = [],
        numChunks,
        length,
        index,
        start,
        end;

      if (chunkLength < 1) {
        return chunked;
      }

      length = $toLength(str.length);
      numChunks = $ceil(length / chunkLength);
      index = 0;
      start = 0;
      end = chunkLength;
      chunked.length = numChunks;
      while (index < numChunks) {
        chunked[index] = $sSlice(str, start, end);
        start = end;
        end += chunkLength;
        index += 1;
      }

      return chunked;
    };

    /**
     * This method chunks a string into an array of strings of a specified
     * chunk size.
     *
     * @function module:util-x~exports.String.chunk
     * @param {string} stringArg The string to be chunked.
     * @param {Number} chunkSize The size of the chunks that the string will
     *                           be chunked into.
     * @return {Array} Returns an array of the chunked string.
     */
    exports.String.chunk = $toMethod(exports.String.proto.chunk);

    /**
     * Splits a String object into an array of strings by separating the string
     * into substrings.
     *
     * @function module:util-x~exports.String.proto.split
     * @this {string} stringArg
     * @param {string|RegExp}} [separator]
     * @param {number} [limit]
     * @return {Array.<string>}
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split
     */
    exports.String.proto.split = $decide(
      // test
      function () {
        $affirmBasic(pSplit)();

        $affirm.throws(function () {
          $call(pSplit);
        }, CTypeError, 'should throw if no arguments');

        $affirm.throws(function () {
          $call(pSplit, Undefined);
        }, CTypeError, 'should throw if argument is undefined');

        $affirm.throws(function () {
          $call(pSplit, null);
        }, CTypeError, 'should throw if argument is null');

        $affirm.deepEqual($call(pSplit, 'abcdef', ''),
                          ['a', 'b', 'c', 'd', 'e', 'f'],
                          'should not throw on basic tests');
        $affirm.deepEqual($call(pSplit, 'abcdefabcdefabcdef', 'c'),
                          ['ab', 'defab', 'defab', 'def'],
                          'should not throw on basic tests');
        $affirm.deepEqual($call(pSplit, 'abcdefabcdefabcdef', new CRegExp('c')),
                          ['ab', 'defab', 'defab', 'def'],
                          'should not throw on basic tests');
        $affirm.deepEqual($call(pSplit, 'ab'),
                          ['ab'],
                          'If "separator" is undefined must return Array ' +
                          'with one String - "this" string');
        $affirm.deepEqual($call(pSplit, 'ab', Undefined),
                          ['ab'],
                          'If "separator" is undefined must return Array ' +
                          'with one String - "this" string');
        $affirm.deepEqual($call(pSplit, ''),
                          [''],
                          '(\'\') results in [\'\']');
        $affirm.deepEqual($call(pSplit, '', new CRegExp('.')),
                          [''],
                          '(\'\', /./) results in [\'\']');
        $affirm.deepEqual($call(pSplit, '', new CRegExp('.?')),
                          [],
                          '(\'\', /.?/) results in []');
        $affirm.deepEqual($call(pSplit, '', new CRegExp('.??')),
                          [],
                          '(\'\', /.??/) results in []');
        $affirm.deepEqual($call(pSplit, 'ab', /a*/),
                          ['', 'b'],
                          '(\'ab\', /a*/) results in [\'\', \'b\']');
        $affirm.deepEqual($call(pSplit, 'ab', /a*?/),
                          ['a', 'b'], '(\'ab\', /a*?/) results in ' +
                          '[\'a\', \'b\']');
        $affirm.deepEqual($call(pSplit, 'ab', /(?:ab)/),
                          ['', ''],
                          '(\'ab\', /(?:ab)/) results in [\'\', \'\']');
        $affirm.deepEqual($call(pSplit, 'ab', /(?:ab)*/),
                          ['', ''], '(\'ab\', /(?:ab)*/) results in ' +
                          '[\'\', \'\']');
        $affirm.deepEqual($call(pSplit, 'ab', /(?:ab)*?/),
                          ['a', 'b'],
                          '(\'ab\', /(?:ab)*?/) results in [\'a\', \'b\']');
        $affirm.deepEqual($call(pSplit, 'test', ''),
                          ['t', 'e', 's', 't'], '(\'test\', \'\') results in ' +
                          '[\'t\', \'e\', \'s\', \'t\']');
        $affirm.deepEqual($call(pSplit, 'test'),
                          ['test'],
                          '(\'test\', ) results in [\'test\']');
        $affirm.deepEqual($call(pSplit, '111', 1),
                          ['', '', '', ''], '(\'111\', 1) results in '+
                          '[\'\', \'\', \'\', \'\']');
        $affirm.deepEqual($call(pSplit, 'test', /(?:)/, 2),
                          ['t', 'e'],
                          '(\'test\', /(?:)/, 2) results in [\'t\', \'e\']');
        $affirm.deepEqual($call(pSplit, 'test', /(?:)/, -1),
                          [], '(\'test\', /(?:)/, -1) results in []');
        $affirm.deepEqual($call(pSplit, 'test', /(?:)/, Undefined),
                          ['t', 'e', 's', 't'],
                          '(\'test\', /(?:)/, undefined) results in ' +
                          '[\'t\', \'e\', \'s\', \'t\']');
        $affirm.deepEqual($call(pSplit, 'test', /(?:)/, null),
                          [], '(\'test\', /(?:)/, null) results in []');
        $affirm.deepEqual($call(pSplit, 'test', /(?:)/, NaN),
                          [],
                          '(\'test\', /(?:)/, NaN) results in []');
        $affirm.deepEqual($call(pSplit, 'test', /(?:)/, true),
                          ['t'], '(\'test\', /(?:)/, true) results in [\'t\']');
        $affirm.deepEqual($call(pSplit, 'test', /(?:)/, '2'),
                          ['t', 'e'],
                          '(\'test\', /(?:)/, \'2\') results in ' +
                          '[\'t\', \'e\']');
        $affirm.deepEqual($call(pSplit, 'test', /(?:)/, 'two'),
                          [], '(\'test\', /(?:)/, \'two\') results in []');
        $affirm.deepEqual($call(pSplit, 'a', /-/),
                          ['a'],
                          '(\'a\', /-/) results in [\'a\']');
        $affirm.deepEqual($call(pSplit, 'a', /-?/),
                          ['a'], '(\'a\', /-?/) results in [\'a\']');
        $affirm.deepEqual($call(pSplit, 'a', /-??/),
                          ['a'],
                          '(\'a\', /-??/) results in [\'a\']');
        $affirm.deepEqual($call(pSplit, 'a', /a/),
                          ['', ''],
                          '(\'a\', /a/) results in [\'\', \'\']');
        $affirm.deepEqual($call(pSplit, 'a', /a?/),
                          ['', ''],
                          '(\'a\', /a?/) results in [\'\', \'\']');
        $affirm.deepEqual($call(pSplit, 'a', /a??/),
                          ['a'],
                          '(\'a\', /a??/) results in [\'a\']');
        $affirm.deepEqual($call(pSplit, 'ab', /-/),
                          ['ab'],
                          '(\'ab\', /-/) results in [\'ab\']');
        $affirm.deepEqual($call(pSplit, 'ab', /-?/),
                          ['a', 'b'],
                          '(\'ab\', /-?/) results in [\'a\', \'b\']');
        $affirm.deepEqual($call(pSplit, 'ab', /-??/),
                          ['a', 'b'],
                          '(\'ab\', /-??/) results in [\'a\', \'b\']');
        $affirm.deepEqual($call(pSplit, 'a-b', /-/),
                          ['a', 'b'],
                          '(\'a-b\', /-/) results in [\'a\', \'b\']');
        $affirm.deepEqual($call(pSplit, 'a-b', /-?/),
                          ['a', 'b'],
                          '(\'a-b\', /-?/) results in [\'a\', \'b\']');
        $affirm.deepEqual($call(pSplit, 'a-b', /-??/),
                          ['a', '-', 'b'],
                          '(\'a-b\', /-??/) results in [\'a\', \'-\', \'b\']');
        $affirm.deepEqual($call(pSplit, 'a--b', /-/),
                          ['a', '', 'b'],
                          '(\'a--b\', /-/) results in [\'a\', \'\', \'b\']');
        $affirm.deepEqual($call(pSplit, 'a--b', /-?/),
                          ['a', '', 'b'],
                          '(\'a--b\', /-?/) results in [\'a\', \'\', \'b\']');
        $affirm.deepEqual($call(pSplit, 'a--b', /-??/),
                          ['a', '-', '-', 'b'],
                          '(\'a--b\', /-??/) results in ' +
                          '[\'a\', \'-\', \'-\', \'b\']');
        $affirm.deepEqual($call(pSplit, '', /()()/),
                          [],
                          '(\'\', /()()/) results in []');
        $affirm.deepEqual($call(pSplit, '.', /()()/),
                          ['.'],
                          '(\'.\', /()()/) results in [\'.\']');
        $affirm.deepEqual($call(pSplit, '.', new CRegExp('(.?)(.?)')),
                          ['', '.', '', ''],
                          '(\'.\', /(.?)(.?)/) results in ' +
                          '[\'\', \'.\', \'\', \'\']');
        $affirm.deepEqual($call(pSplit, '.', new CRegExp('(.??)(.??)')),
                          ['.'],
                          '(\'.\', /(.??)(.??)/) results in [\'.\']');

        var arrCmp = [];

        arrCmp.length = 4;
        arrCmp[0] = '';
        arrCmp[1] = '.';
        arrCmp[2] = Undefined;
        arrCmp[3] = '';

        $affirm.deepEqual($call(pSplit, '.', new CRegExp('(.)?(.)?')),
                          arrCmp,
                          '(\'.\', /(.)?(.)?/) results in ' +
                          '[\'\', \'.\', undefined, \'\']');

        arrCmp = [];
        arrCmp.length = 13;
        arrCmp[0] = 'A';
        arrCmp[1] = Undefined;
        arrCmp[2] = 'B';
        arrCmp[3] = 'bold';
        arrCmp[4] = '/';
        arrCmp[5] = 'B';
        arrCmp[6] = 'and';
        arrCmp[7] = Undefined;
        arrCmp[8] = 'CODE';
        arrCmp[9] = 'coded';
        arrCmp[10] = '/';
        arrCmp[11] = 'CODE';
        arrCmp[12] = '';

        $affirm.deepEqual($call(pSplit, 'A<B>bold</B>and<CODE>coded</CODE>'),
          arrCmp,
          '(\'A<B>bold</B>and<CODE>coded</CODE>\', /<(\\/)?([^<>]+)>/) ' +
          'results in [\'A\', undefined, \'B\', \'bold\', \'/\', \'B\', ' +
          '\'and\', undefined, \'CODE\', \'coded\', \'/\', \'CODE\', \'\']');

        arrCmp = [];
        arrCmp.length = 5;
        arrCmp[0] = 't';
        arrCmp[1] = Undefined;
        arrCmp[2] = 'e';
        arrCmp[3] = 's';
        arrCmp[4] = 'e';

        $affirm.deepEqual($call(pSplit, 'tesst', /(s)*/),
                          arrCmp,
                          '(\'test\', /(s)*/) results in ' +
                          '[\'t\', undefined, \'e\', \'s\', \'t\']');

        arrCmp = [];
        arrCmp.length = 7;
        arrCmp[0] = 't';
        arrCmp[1] = Undefined;
        arrCmp[2] = 'e';
        arrCmp[3] = Undefined;
        arrCmp[4] = 's';
        arrCmp[5] = Undefined;
        arrCmp[6] = 'e';

        $affirm.deepEqual($call(pSplit, 'tesst', /(s)*?/),
                          arrCmp,
                          '(\'test\', /(s)*?/) results in [\'t\', undefined, ' +
                          '\'e\', undefined, \'s\', undefined, \'s\', '+
                          'undefined, \'t\']');
        $affirm.deepEqual($call(pSplit, 'tesst', /(s*)/),
                          ['t', '', 'e', 'ss', 't'],
                          '(\'test\', /(s*)/) results in [\'t\', \'\', ' +
                          '\'e\', \'ss\', \'t\']');
        $affirm.deepEqual($call(pSplit, 'tesst', /(s*?)/),
                          ['t', '', 'e', '', 's', '', 's', '', 't'],
                          '(\'test\', /(s*?)/) results in [\'t\', \'\', ' +
                          '\'e\', \'\', \'s\', \'\', \'s\', \'\', \'t\']');
        $affirm.deepEqual($call(pSplit, 'tesst', /(?:s)*/),
                          ['t', 'e', 't'],
                          '(\'test\', /(?:s)*/) results in [\'t\', \'e\', ' +
                          '\'t\']');
        $affirm.deepEqual($call(pSplit, 'tesst', /(?=s+)/),
                          ['te', 's', 'st'],
                          '(\'test\', /(?=s+)/) results in [\'te\', \'s\', ' +
                          '\'st\']');
        $affirm.deepEqual($call(pSplit, 'test', 't'),
                          ['', 'es', ''],
                          '(\'test\', \'t\') results in [\'\', \'es\', \'\']');
        $affirm.deepEqual($call(pSplit, 'test', 'es'),
                          ['t', 't'],
                          '(\'test\', \'es\') results in [\'t\', \'t\']');
        $affirm.deepEqual($call(pSplit, 'test', /t/),
                          ['', 'es', '']);
        $affirm.deepEqual($call(pSplit, 'test', /es/),
                          ['t', 't'],
                          '(\'test\', /es/) results in [\'t\', \'t\']');
        $affirm.deepEqual($call(pSplit, 'test', /(t)/),
                          ['', 't', 'es', 't', ''],
                          '(\'test\', /(t)/) results in [\'\', \'t\', ' +
                          '\'es\', \'t\', \'\']');
        $affirm.deepEqual($call(pSplit, 'test', /(es)/),
                          ['t', 'es', 't'],
                          '(\'test\', /(es)/) results in [\'t\', \'es\', ' +
                          '\'t\']');
        $affirm.deepEqual($call(pSplit, 'test', /(t)(e)(s)(t)/),
                          ['', 't', 'e', 's', 't', ''],
                          '(\'test\', /(t)(e)(s)(t)/) results in [\'\', ' +
                         ' \'t\', \'e\', \'s\', \'t\', \'\']');
        $affirm.deepEqual($call(pSplit, '.', new CRegExp('(((.((.??)))))')),
                          ['', '.', '.', '.', '', '', ''],
                          '(\'.\', /(((.((.??)))))/) results in ' +
                          '[\'\', \'.\', \'.\', \'.\', \'\', \'\', \'\']');
        $affirm.deepEqual($call(pSplit, '.', new CRegExp('(((((.??)))))')),
                          ['.'],
                          '(\'.\', /(((((.??)))))/) results in [\'.\']');
        $affirm.deepEqual($call(pSplit, 'a b c d', / /, -($pow(2, 32) - 1)),
                          [],
                          '(\'a b c d\', / /, -(Math.pow(2, 32) - 1)) ' +
                          'results in []');
        $affirm.deepEqual($call(pSplit, 'a b c d', / /, $pow(2, 32) + 1),
                          ['a', 'b', 'c', 'd'],
                          '(\'a b c d\', / /, Math.pow(2, 32) + 1) ' +
                          'results in []');
        $affirm.deepEqual($call(pSplit, 'a b c d', / /, INFINITY),
                          ['a', 'b', 'c', 'd'],
                          '(\'a b c d\', / /, INFINITY) results in []');
      },

      // pass
      function () {
        return $decide(
          // test
          function () {
            $affirm.deepEqual($call(pSplit, 'ab', Undefined, 0),
                              [],
                              'If "separator" is undefined and "limit" set ' +
                              'to 0 must return Array[]');
          },

          // pass
          function () {
            return pSplit;
          },

          // fail
          function () {
            return function (separator, limit) {
              var isUndef,
                val;

              // "0".split(undefined, 0) -> []
              if (typeof separator === 'undefined' && limit === 0) {
                val = [];
              } else {
                isUndef = typeof limit === 'undefined';
                if (es5limit) {
                  if (isUndef) {
                    limit = MAX_UINT32;
                  } else {
                    limit = $min($toLength(limit), MAX_UINT32);
                  }
                } else {
                  if (isUndef) {
                    limit = MAX_SAFE_INTEGER;
                  } else {
                    limit = $toLength(limit);
                  }
                }

                val = $call(
                  pSplit,
                  $onlyCoercibleToString(this),
                  separator,
                  limit
                );
              }

              return val;
            };
          },

          // message
          'String.split patch 2'
        );
      },

      // fail
      function () {
        function search(str, regex, pos) {
          var r2 = copyRegExp(regex, {
              add: 'g',
              remove: 'y'
            }),
            match;

          r2.lastIndex = pos;
          match = $exec(r2, str);
          if (regex.global) {
            if (match) {
              regex.lastIndex = $toNumber(r2.lastIndex);
            } else {
              regex.lastIndex = 0;
            }
          }

          return match;
        }

        return function (separator, limit) {
          var str = $onlyCoercibleToString(this),
            isUndef,
            output,
            origLastIndex,
            lastLastIndex,
            lastLength,
            match,
            length,
            mIndex,
            m0Len,
            slc,
            idx,
            len;

          // "0".split(undefined, 0) -> []
          if (typeof separator === 'undefined' && limit === 0) {
            output = [];
          } else {
            isUndef = typeof limit === 'undefined';
            if (es5limit) {
              if (isUndef) {
                limit = MAX_UINT32;
              } else {
                limit = $min($toLength(limit), MAX_UINT32);
              }
            } else {
              if (isUndef) {
                limit = MAX_SAFE_INTEGER;
              } else {
                limit = $toLength(limit);
              }
            }

            if (!$isRegExp(separator)) {
              /* Browsers handle nonregex split correctly,
               * so use the faster native method
               */
              output = $call(pSplit, str, separator, limit);
            } else {
              output = [];
              origLastIndex = $toNumber(separator.lastIndex);
              lastLastIndex = 0;
              length = $toLength(str.length);
              match = search(str, separator, 0);
              while (match) {
                mIndex = $toNumber(match.index);
                m0Len = $toLength(match[0].length);
                // This condition is not the same as `if (match[0].length)`
                if ((mIndex + m0Len) > lastLastIndex) {
                  $push(output, $sSlice(str, lastLastIndex, mIndex));
                  if ($toLength(match.length) > 1 && mIndex < length) {
                    slc = $slice(match, 1);
                    len = $toLength(slc.length);
                    for (idx = 0; idx < len; idx += 1) {
                      if ($hasProperty(slc, idx)) {
                        $push(output, slc[idx]);
                      } else {
                        output.length += 1;
                      }
                    }
                  }

                  lastLength = m0Len;
                  lastLastIndex = mIndex + lastLength;
                }

                match = search(str, separator, mIndex + (m0Len || 1));
              }

              if (lastLastIndex === length) {
                if (!$test(separator, '') || lastLength) {
                  $push(output, '');
                }
              } else {
                $push(output, $sSlice(str, lastLastIndex));
              }

              separator.lastIndex = origLastIndex;
              if ($toLength(output.length) > limit) {
                output = $slice(output, 0, limit);
              }
            }
          }

          return output;
        };
      },

      // message
      'String.split patch 1'
    );

    /**
     * Splits a String object into an array of strings by separating the string
     * into subbase.str.
     *
     * @function module:util-x~exports.String.split
     * @param {string} stringArg
     * @param {string|RegExp}} [separator]
     * @param {number} [limit]
     * @return {Array.<string>}
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split
     */
    exports.String.split = $toMethod(exports.String.proto.split);

    /**
     * Splits a String object into an array of strings by separating the string
     * into subbase.str.
     *
     * @private
     * @function module:util-x~$split
     * @param {string} stringArg
     * @param {string|RegExp}} [separator]
     * @param {number} [limit]
     * @return {Array.<string>}
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split
     */
    $split = exports.String.split;

    /**
     * Fixes browser bugs in replacement text syntax when performing a
     * replacement using a nonregex search value, and the value of a replacement
     * regex's `lastIndex` property during replacement iterations and upon
     * completion. Note that this doesn't support SpiderMonkey's proprietary
     * third (`flags`) argument.
     *
     * @function module:util-x~exports.String.proto.replace
     * @this {string}
     * @param {RegExp|string} search Search pattern to be replaced.
     * @param {string|Function} replacement Replacement string or a function
     *                                      invoked to create it.
     * @return {string} New string with one or all matches replaced.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace
     */
    exports.String.proto.replace = $decide(
      // test
      function () {
        $affirmBasic(pReplace)();

        $affirm.throws(function () {
          $call(pReplace);
        }, CTypeError, 'should throw if no arguments');

        $affirm.throws(function () {
          $call(pReplace, Undefined);
        }, CTypeError, 'should throw if argument is undefined');


        $affirm.throws(function () {
          $call(pReplace, null);
        }, CTypeError, 'should throw if argument is null');

        $affirm.strictEqual($call(pReplace, 'aaa', /a/, 'b'), 'baa', 'should replace the first match only when given a nonglobal regex');
        $affirm.strictEqual($call(pReplace, 'aaa', /a/g, 'b'), 'bbb', 'should replace all matches when given a global regex');
        $affirm.strictEqual($call(pReplace, 'aaa', 'a', 'b'), 'baa', 'should replace the first match only when given a string as the search pattern');
        $affirm.strictEqual($call(pReplace, 'aaa', 'a(a)', 'b'), 'aaa', 'should not type convert a string search pattern to a regex');
        $affirm.strictEqual($call(pReplace, 'a(a)a', 'a(a)', 'b'), 'ba', 'should not type convert a string search pattern to a regex');
        $affirm.strictEqual($call(pReplace, 'aaa', /a(a)/, '$1b', 'should handle single-digit backreference $1 in the replacement string'), 'aba');
        // Backreference to a nonparticipating capturing group
        $affirm.strictEqual($call(pReplace, 'test', /t|(e)/g, '$1'), 'es', 'should handle single-digit backreference $1 in the replacement string');
        $affirm.strictEqual($call(pReplace, 'aaa', /a(a)/, '$01b'), 'aba', 'should handle double-digit backreferences $01, $10, and $99 in the replacement string');
        $affirm.strictEqual($call(pReplace, 'aaa', new CRegExp('a' + $repeat('()', 9) + '(a)'), '$10b'), 'aba', 'should handle double-digit backreferences $01, $10, and $99 in the replacement string');
        $affirm.strictEqual($call(pReplace, 'aaa', new CRegExp('a' + $repeat('()', 98) + '(a)'), '$99b'), 'aba', 'should handle double-digit backreferences $01, $10, and $99 in the replacement string');
        $affirm.strictEqual($call(pReplace, 'aaa', new CRegExp('a' + $repeat('()', 99) + '(a)'), '$100b'), '0ba', 'should end backreferences in the replacement string after two digits');
        /*
         * NOTE: IE < 9 incorrectly treats all occurrences of $ as literal text
         * when performing a replacement based on a search value that is not a
         * regex.
         */
        $affirm.strictEqual($call(pReplace, 'aaa', /aa/, '$&b'), 'aaba', 'should handle backreference $& in the replacement string');
        $affirm.strictEqual($call(pReplace, 'aaa', 'aa', '$&b'), 'aaba', 'should handle backreference $& in the replacement string');
        $affirm.strictEqual($call(pReplace, 'aaa', /aa/, '$\'b'), 'aba', 'should handle right context token $\' in the replacement string');
        $affirm.strictEqual($call(pReplace, 'aaa', 'aa', '$\'b'), 'aba', 'should handle right context token $\' in the replacement string');
        $affirm.strictEqual($call(pReplace, 'xaaa', /aa/, '$`b'), 'xxba', 'should handle left context token $` in the replacement string');
        $affirm.strictEqual($call(pReplace, 'xaaa', 'aa', '$`b'), 'xxba', 'should handle left context token $` in the replacement string');
        $affirm.strictEqual($call(pReplace, 'aaa', /aa/, '$$b'), '$ba', 'should handle token $$ in the replacement string');
        $affirm.strictEqual($call(pReplace, 'aaa', 'aa', '$$b'), '$ba', 'should handle token $$ in the replacement string');

        $affirm.strictEqual($call(pReplace, 'aaa', /a/, function () {
          return 'b';
        }), 'baa', 'should allow a function to generate the replacement');

        $affirm.strictEqual($call(pReplace, 'aaa', /a/g, function () {
          return 'b';
        }), 'bbb', 'should allow a function to generate the replacement');

        $affirm.strictEqual($call(pReplace, 'aaa', 'a', function () {
          return 'b';
        }), 'baa', 'should allow a function to generate the replacement');

        $affirm.strictEqual($call(pReplace, 'aaa', /aa/, function ($0) {
          return $0 + 'b';
        }), 'aaba', 'should allow using backreferences with replacement functions');

        /*jshint -W098 */
        $affirm.strictEqual($call(pReplace, 'aaa', /a(a)/, function ($0, $1) {
          /*jslint unparam: true */
          /*jshint unused: false */
          return $1 + 'b';
        }), 'aba', 'should allow using backreferences with replacement functions');
        /*jshint +W098 */

        $affirm.strictEqual($call(pReplace, 'aaa', 'aa', function ($0) {
          return $0 + 'b';
        }), 'aaba', 'should allow using backreferences with replacement functions');

        // Regex search...
        /*jshint -W098 */
        $affirm.strictEqual($call(pReplace, 'aaa', /a(a)/, function ($0, $1) {
          /*jslint unparam: true */
          /*jshint unused: false */
          return '$1';
        }), '$1a', 'should not substitute tokens returned by replacement functions');
        /*jshint +W098 */

        $affirm.strictEqual($call(pReplace, 'aaa', /a/, function () {
          return '$&';
        }), '$&aa', 'should not substitute tokens returned by replacement functions');

        /*jshint -W098 */
        $affirm.strictEqual($call(pReplace, 'xaaa', /a/, function ($0, pos) {
          /*jslint unparam: true */
          /*jshint unused: false */
          return $toString(pos);
        }), 'x1aa', 'should allow using the match position within replacement functions');

        $affirm.strictEqual($call(pReplace, 'xaaa', /a/g, function ($0, pos) {
          /*jslint unparam: true */
          /*jshint unused: false */
          return $toString(pos);
        }), 'x123', 'should allow using the match position within replacement functions');

        $affirm.strictEqual($call(pReplace, 'xaaa', /(a)/g, function ($0, $1, pos) {
          /*jslint unparam: true */
          /*jshint unused: false */
          return $toString(pos);
        }), 'x123', 'should allow using the match position within replacement functions');

        $affirm.strictEqual($call(pReplace, 'xaaa', 'a', function ($0, pos) {
          /*jslint unparam: true */
          /*jshint unused: false */
          return $toString(pos);
        }), 'x1aa', 'should allow using the match position within replacement functions');
        /*jshint +W098 */

        /*jshint -W098 */
        $affirm.strictEqual($call(pReplace, 'xaaa', /a/, function ($0, pos, str) {
          /*jslint unparam: true */
          /*jshint unused: false */
          return str;
        }), 'xxaaaaa', 'should allow using the source string within replacement functions');

        $affirm.strictEqual($call(pReplace, 'xaaa', /(a)/, function ($0, $1, pos, str) {
          /*jslint unparam: true */
          /*jshint unused: false */
          return str;
        }), 'xxaaaaa', 'should allow using the source string within replacement functions');

        $affirm.strictEqual($call(pReplace, 'xaaa', 'a', function ($0, pos, str) {
          /*jslint unparam: true */
          /*jshint unused: false */
          return str;
        }), 'xxaaaaa', 'should allow using the source string within replacement functions');
        /*jshint +W098 */

        // NOTE: This tests for IE < 9, which doesn't get this correct natively
        /*jshint -W098 */
        $affirm.strictEqual($call(pReplace, '100', /0/, function ($0, pos, str) {
          /*jslint unparam: true */
          /*jshint unused: false */
          return typeof str;
        }), '1string0', 'should return string as the typeof the last argument in replacement functions');

        /*jshint -W053 */
        $affirm.strictEqual($call(pReplace, new CString('100'), /0/, function ($0, pos, str) {
          /*jslint unparam: true */
          /*jshint unused: false */
          return typeof str;
        }), '1string0', 'should return string as the typeof the last argument in replacement functions');
        /*jshint +W053 */

        $affirm.strictEqual($call(pReplace, 100, /0/, function ($0, pos, str) {
          /*jslint unparam: true */
          /*jshint unused: false */
          return typeof str;
        }), '1string0', 'should return string as the typeof the last argument in replacement functions');
        /*jshint +W098 */

        $affirm.strictEqual($call(pReplace, 0, /^/, '$`'), '0', 'should handle nonstring context when using a replacement text token that references the subject text');

        var regex = /x/,
          interimLastIndex,
          values,
          value,
          length,
          index;

        $call(pReplace, '123x567', regex, '_');
        $affirm.strictEqual(regex.lastIndex, 0, 'should not modify the lastIndex of a nonglobal regex');

        regex.lastIndex = 1;
        $call(pReplace, '123x567', regex, '_');
        $affirm.strictEqual(regex.lastIndex, 1, 'should not modify the lastIndex of a nonglobal regex');

        $call(pReplace, 'nomatch', regex, '_');
        $affirm.strictEqual(regex.lastIndex, 1, 'should not modify the lastIndex of a nonglobal regex');

        regex = /x/g;

        regex.lastIndex = 1;
        $call(pReplace, '123x567', regex, '_');
        $affirm.strictEqual(regex.lastIndex, 0, 'should reset the lastIndex of a global regex to 0');

        regex.lastIndex = 1;
        $call(pReplace, 'nomatch', regex, '_');
        $affirm.strictEqual(regex.lastIndex, 0, 'should reset the lastIndex of a global regex to 0');

        regex = /x/;
        regex.lastIndex = 5;
        $affirm.strictEqual($call(pReplace, '123x567', regex, '_'), '123_567', 'should ignore lastIndex when setting the search start position');

        regex = /x/g;
        regex.lastIndex = 5;
        $affirm.strictEqual($call(pReplace, '123x567', regex, '_'), '123_567', 'should ignore lastIndex when setting the search start position');

        regex = /x/g;
        interimLastIndex = 0;

        $call(pReplace, '1x2', regex, function () {
          interimLastIndex = regex.lastIndex;
        });

        $affirm.strictEqual(interimLastIndex, 2, 'should update lastIndex during replacement iterations');

        values = [{
          target: '10x10',
          search: 10,
          replacement: 'x',
          expected: 'xx10'
        }, {
          target: 'xaaa,ba,b',
          search: ['a', 'b'],
          replacement: 'x',
          expected: 'xaaxa,b'
        }, {
          target: 'undefined',
          search: undefined,
          replacement: 'x',
          expected: 'x'
        }];

        length = $toLength(values.length);
        for (index = 0; index < length; index += 1) {
          value = values[index];
          $affirm.strictEqual($call(pReplace, value.target, value.search, value.replacement), value.expected, 'should convert any provided nonstring search to a string');
        }

        // Implicit undefined search and replacement
        $affirm.strictEqual($call(pReplace, 'undefined'), 'undefined', 'should convert any provided nonstring search to a string');

        values = [{
          target: 'xaaa',
          search: /a/g,
          replacement: 1.1,
          expected: 'x1.11.11.1'
        }, {
          target: 'xaaa',
          search: /a/g,
          replacement: ['a', 'b'],
          expected: 'xa,ba,ba,b'
        }, {
          target: 'x',
          search: /x/,
          replacement: /x/,
          expected: '/x/'
        }, {
          target: 'xaaa',
          search: /a/,
          replacement: undefined,
          expected: 'xundefinedaa'
        }];

        length = $toLength(values.length);
        for (index = 0; index < length; index += 1) {
          value = values[index];
          $affirm.strictEqual($call(pReplace, value.target, value.search, value.replacement), value.expected, 'should convert any provided nonstring/nonfunction replacement to a string');
        }

        // Implicit undefined replacement
        $affirm.strictEqual($call(pReplace, 'xaaa', /a/), 'xundefinedaa', 'should convert any provided nonstring/nonfunction replacement to a string');

        values = [
          100, {},
          true,
          false,
          NaN, ['a']
        ];

        length = $toLength(values.length);
        for (index = 0; index < length; index += 1) {
          value = values[index];
          $affirm.strictEqual($call(pReplace, value, /^/, 'x'), 'x' + value, 'should convert any nonstring context to a string (except null and undefined)');
        }
      },

      // pass
      function () {
        return pReplace;
      },

      // fail
      function () {
        return function (search, replacement) {
          var str = $onlyCoercibleToString(this),
            isRegex = $isRegExp(search),
            origLastIndex,
            result;

          if (isRegex) {
            // Only needed if `search` is nonglobal
            origLastIndex = $toNumber(search.lastIndex);
          } else {
            // Type-convert
            search = $toString(search);
          }

          // Don't use `typeof`; some older browsers return 'function' for regex objects
          if ($isFunction(replacement)) {
            // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement
            // functions isn't type-converted to a string
            result = $call(pReplace, str, search, function () {
              var args = $argSlice(arguments);

              args[2] = $toString(args[2]);

              // Update `lastIndex` before calling `replacement`. Fixes IE, Chrome, Firefox,
              // Safari bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)
              if (isRegex && search.global) {
                search.lastIndex = args[$toLength(args.length) - 2] + arguments[0].length;
              }

              // Should pass `undefined` as context; see
              // <https://bugs.ecmascript.org/show_bug.cgi?id=154>
              return $apply(replacement, Undefined, args);
            });
          } else {
            // Ensure that the last value of `args` will be a string when given nonstring `this`,
            // while still throwing on `null` or `undefined` context
            result = $call(pReplace, str, search, function () {
              // Keep this function's `arguments` available through closure
              var args = arguments,
                length = $toLength(arguments.length);

              return $call(pReplace, $toString(replacement), replacementToken, function () {
                var $2 = $toString(arguments[2]);

                // Special variable or numbered backreference without curly braces
                // $$
                if ($2 === '$') {
                  return '$';
                }

                // $&, $0 (not followed by 1-9), $00
                if ($2 === '&' || $toNumber($2) === 0) {
                  return args[0];
                }

                // $` (left context)
                if ($2 === '`') {
                  return $sSlice(args[2], 0, $toNumber(args[1]));
                }

                // $' (right context)
                if ($2 === '\'') {
                  return $sSlice(args[2], $toNumber(args[1]) + $toLength(args[0].length));
                }

                // Numbered backreference without curly braces
                // Type-convert; drop leading zero
                $2 = $toNumber($2);
                /*
                 * Native behavior
                 * - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.
                 * - `$1` is a literal `$1` if no capturing groups.
                 * - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.
                 * - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.
                 * - `$0` is a literal `$0`.
                 */
                if ($2 === $2) {
                  if ($2 > (length - 3)) {
                    throw new CSyntaxError('Backreference to undefined group ' + $toString(arguments[0]));
                  }

                  return args[$2] || '';
                }

                throw new CSyntaxError('Invalid token ' + $toString(arguments[0]));
              });
            });
          }

          if (isRegex) {
            if (search.global) {
              // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
              search.lastIndex = 0;
            } else {
              // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
              search.lastIndex = origLastIndex;
            }
          }

          return result;
        };
      },

      // message
      'String.replace patch'
    );

    /**
     * Fixes browser bugs in replacement text syntax when performing a replacement using a nonregex search
     * value, and the value of a replacement regex's `lastIndex` property during replacement iterations
     * and upon completion. Note that this doesn't support SpiderMonkey's proprietary third (`flags`)
     * argument.
     *
     * @function module:util-x~exports.String.replace
     * @param {string} inputArg the string on which to perform the replace.
     * @param {RegExp|string} search Search pattern to be replaced.
     * @param {string|Function} replacement Replacement string or a function invoked to create it.
     * @return {string} New string with one or all matches replaced.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace
     */
    exports.String.replace = $toMethod(exports.String.proto.replace);

    /**
     * Fixes browser bugs in replacement text syntax when performing a replacement using a nonregex search
     * value, and the value of a replacement regex's `lastIndex` property during replacement iterations
     * and upon completion. Note that this doesn't support SpiderMonkey's proprietary third (`flags`)
     * argument.
     *
     * @private
     * @function module:util-x~$replace
     * @param {string} inputArg the string on which to perform the replace.
     * @param {RegExp|string} search Search pattern to be replaced.
     * @param {string|Function} replacement Replacement string or a function invoked to create it.
     * @return {string} New string with one or all matches replaced.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace
     */
    $replace = exports.String.replace;

    /**
     * This method replaces all occurences of a string pattern within
     * the string with the string characters.
     *
     * @function module:util-x~exports.String.proto.replaceAll
     * @this {string}
     * @throws {Error} an If the argument can not be coerced, i.e. null or undefined.
     * @param {(string|RegExp)} pattern
     * @param {string} characters
     * @return {string}
     */
    exports.String.proto.replaceAll = function (pattern, characters) {
      if ($isString(pattern)) {
        pattern = new CRegExp($replace($onlyCoercibleToString(pattern), escapeThese, '\\$&'), 'g');
      } else if ($isRegExp(pattern)) {
        pattern = copyRegExp(pattern, {
          add: 'g'
        });
      }

      if (!$isString(characters) && !$isNumber(characters)) {
        characters = '';
      } else {
        characters = $toString(characters);
      }

      return $replace($onlyCoercibleToString(this), pattern, characters);
    };

    /**
     * This {@link module:util-x~boundPrototypalFunction method} replaces all occurences of a string pattern within
     * a string with the string characters.
     *
     * @function module:util-x~exports.String.replaceAll
     * @param {string} string
     * @throws {Error} an If the argument can not be coerced, i.e. null or undefined.
     * @param {(string|RegExp)} pattern
     * @param {string} characters
     * @return {string}
     */
    exports.String.replaceAll = $toMethod(exports.String.proto.replaceAll);

    /**
     * Fixes browser bugs in the native `String.prototype.match`.
     *
     * @function module:util-x~exports.String.proto.match
     * @this {string}
     * @param {(RegExp|*)} regExpArg Regex to search with. If not a regex object, it is passed to `RegExp`.
     * @return {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,
     * the result of calling `$exec(regExpArg)`.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match
     */
    exports.String.proto.match = $decide(
      // test
      function () {
        $affirmBasic(pMatch)();

        $affirm.throws(function () {
          $call(pMatch);
        }, CTypeError, 'should throw if no arguments');

        $affirm.throws(function () {
          $call(pMatch, Undefined);
        }, CTypeError, 'should throw if argument is undefined');

        $affirm.throws(function () {
          $call(pMatch, null);
        }, CTypeError, 'should throw if argument is null');

        // https://github.com/es-shims/es5-shim/issues/293
        /*jslint regexp: true */
        $affirm.deepEqual($slice($call(pMatch, '4', /(?=(?:...)*$)/)), [''], '"4".match(/(?=(?:...)*$)/) == [""]');
        /*jslint regexp: false */

        $affirm.deepEqual($slice($call(pMatch, 'a bc', /(\w)/g)), ['a', 'b', 'c'], 'should return an array with all matches');
        $affirm.strictEqual($call(pMatch, 'a bc', /x/g), null, 'should return null if no match is found');

        var regex = /x/g,
          tests,
          length,
          index,
          test;

        regex.lastIndex = 1;
        $call(pMatch, '123x5', regex);
        $affirm.strictEqual(regex.lastIndex, 0, 'should reset lastIndex to 0 when a match is found');

        regex = /x/g;
        regex.lastIndex = 1;
        $call(pMatch, '123', regex);
        $affirm.strictEqual(regex.lastIndex, 0, 'should reset lastIndex to 0 when no match is found');

        regex = /x/g;
        regex.lastIndex = 4;
        $affirm.ok($call(pMatch, '123x5', regex), 'should start the search at the beginning of the string, ignoring lastIndex');

        $affirm.deepEqual($slice($call(pMatch, 11, /1/g)), ['1', '1'], 'should convert any nonstring context to a string (except null and undefined)');

        // These don't error because, per the spec, the values are passed through new RegExp()
        // before being used as the context object for the (fixed) RegExp.prototype.exec
        tests = [
          {
            str: '12',
            regex: '^(1)',
            result: ['1', '1']
          },
          // This would throw if the string was converted to an XRegExp rather than RegExp
          {
            str: '\x01',
            regex: '\\1',
            result: ['\x01']
          },
          // The converted value '[object Object]' creates a character class
          {
            str: '[obj]',
            regex: {},
            result: ['o']
          }, {
            str: 'null',
            regex: null,
            result: ['null']
          }
        ];

        length = $toLength(tests.length);
        for (index = 0; index < length; index += 1) {
          test = tests[index];
          $affirm.deepEqual($slice($call(pMatch, test.str, test.regex)), test.result, 'should convert any provided non RegExp object to a RegExp');
        }
      },

      // pass
      function () {
        return pMatch;
      },

      // fail
      function () {
        return function (regExpArg) {
          var str = $onlyCoercibleToString(this),
            result;

          if (!$isRegExp(regExpArg)) {
            regExpArg = new CRegExp(regExpArg);
          } else if (regExpArg.global) {
            result = $apply(pMatch, str, arguments);
            // Fixes IE bug
            regExpArg.lastIndex = 0;

            return result;
          }

          return $exec(regExpArg, str);
        };
      },

      // message
      'String.match patch'
    );

    /**
     * Fixes browser bugs in the native `String.prototype.match`.
     *
     * @function module:util-x~exports.String.match
     * @param {string} stringArg String to search.
     * @param {(RegExp|*)} regExpArg Regex to search with. If not a regex object, it is passed to `RegExp`.
     * @return {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,
     * the result of calling `$exec(regExpArg)`.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match
     */
    exports.String.match = $toMethod(exports.String.proto.match);
  }());

  /**
   * Coerces its argument to a string and returns the first character of that string.
   * If the argument is an empty string, returns an empty string.
   * Throws an error if the argument can not be coerced, i.e. null or undefined.
   *
   * @function module:util-x~exports.String.proto.first
   * @this {string}
   * @return {string}
   */
  exports.String.proto.first = function () {
    return $getItem($onlyCoercibleToString(this), 0, stringTagString);
  };

  /**
   * Coerces its argument to a string and returns the first character of that string.
   * If the argument is an empty string, returns an empty string.
   * Throws an error if the argument can not be coerced, i.e. null or undefined.
   *
   * @function module:util-x~exports.String.first
   * @param {string} inputArg
   * @return {string}
   */
  exports.String.first = $toMethod(exports.String.proto.first);

  /**
   * Coerces its argument to a string and returns the last character of that string.
   * If the argument is an empty string, returns an empty string.
   * Throws an error if the argument can not be coerced, i.e. null or undefined.
   *
   * @function module:util-x~exports.String.proto.last
   * @this {string}
   * @return {string}
   */
  exports.String.proto.last = function () {
    var str = $onlyCoercibleToString(this);

    return $getItem(str, str.length - 1, stringTagString);
  };

  /**
   * Coerces its argument to a string and returns the last character of that string.
   * If the argument is an empty string, returns an empty string.
   * Throws an error if the argument can not be coerced, i.e. null or undefined.
   *
   * @function module:util-x~exports.String.last
   * @param {string} inputArg
   * @return {string}
   */
  exports.String.last = $toMethod(exports.String.proto.last);

  /**
   * Coerces inputArg to a string and counts the occurences of the argument character.
   * Throws an error if the arguments can not be coerced, i.e. null or undefined.
   *
   * @function module:util-x~exports.String.proto.countCharacter
   * @this {string}
   * @param {string} character
   * @return {number}
   */
  exports.String.proto.countCharacter = function (character) {
    var str = $onlyCoercibleToString(this),
      first = $getItem($onlyCoercibleToString(character), 0, stringTagString),
      val;

    if (first === '') {
      val = INFINITY;
    } else {
      val = $min($max($split(str, first).length - 1, 0), INFINITY);
    }

    return val;
  };

  /**
   * Coerces inputArg to a string and counts the occurences of the argument character.
   * Throws an error if the arguments can not be coerced, i.e. null or undefined.
   *
   * @function module:util-x~exports.String.countCharacter
   * @param {string} inputArg
   * @param {string} character
   * @return {number}
   */
  exports.String.countCharacter = $toMethod(exports.String.proto.countCharacter);

  /**
   * Coerces inputArg to a string and repeatedly adds the argument character to the beginning until
   * the string is greater than or Object.equal to the specified length.
   * Throws an error if the arguments can not be coerced, i.e. null or undefined.
   *
   * @function module:util-x~exports.String.proto.padLeadingChar
   * @this {string}
   * @param {string} character
   * @param {number} size
   * @return {string}
   */
  exports.String.proto.padLeadingChar = function (character, size) {
    var string = $onlyCoercibleToString(this),
      singleChar = $getItem($onlyCoercibleToString(character), 0, stringTagString),
      count = $toInteger(size) - string.length;

    if (count < 0 || count === INFINITY) {
      count = 0;
    }

    return exports.String.repeat(singleChar, count) + string;
  };

  /**
   * Coerces inputArg to a string and repeatedly adds the argument character to the beginning until
   * the string is greater than or Object.equal to the specified length.
   * Throws an error if the arguments can not be coerced, i.e. null or undefined.
   *
   * @function module:util-x~exports.String.padLeadingChar
   * @param {string} inputArg
   * @param {string} character
   * @param {number} size
   * @return {string}
   */
  exports.String.padLeadingChar = $toMethod(exports.String.proto.padLeadingChar);

  /**
   * Determines whether a string begins with the characters of another string,
   * returning true or false as appropriate.
   *
   * @function module:util-x~exports.String.proto.startsWith
   * @this {string}
   * @param {string} searchString
   * @param {number} [position]
   * @return {boolean}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
   */
  exports.String.proto.startsWith = $decide(
    // test
    $affirmBasic(base.String.startsWith),

    // pass
    function () {
      return base.String.startsWith;
    },

    // fail
    function () {
      return function (searchString, position) {
        var thisStr = $onlyCoercibleToString(this),
          searchStr = $toString(searchString),
          start = $min($max($toInteger(position), 0), thisStr.length);

        return $sSlice(thisStr, start, start + searchStr.length) === searchStr;
      };
    },

    // message
    'String.startsWith shim'
  );

  /**
   * Determines whether a string begins with the characters of another string,
   * returning true or false as appropriate.
   *
   * @function module:util-x~exports.String.startsWith
   * @param {string} string
   * @param {string} searchString
   * @param {number} [position]
   * @return {boolean}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
   */
  exports.String.startsWith = $toMethod(exports.String.proto.startsWith);

  /**
   * Determines whether a string ends with the characters of another string,
   * returning true or false as appropriate.
   *
   * @function module:util-x~exports.String.proto.endsWith
   * @this {string}
   * @param {string} searchString
   * @param {number} [position]
   * @return {boolean}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
   */
  exports.String.proto.endsWith = $decide(
    // test
    $affirmBasic(base.String.endsWith),

    // pass
    function () {
      return base.String.endsWith;
    },

    // fail
    function () {
      return function (searchString, position) {
        var thisStr = $onlyCoercibleToString(this),
          searchStr = $toString(searchString),
          thisLen = thisStr.length,
          end,
          start;

        if (typeof position === 'undefined') {
          position = thisLen;
        } else {
          position = $toInteger(position);
        }

        end = $min($max(position, 0), thisLen);
        start = end - searchStr.length;

        return start >= 0 && $sSlice(thisStr, start, end) === searchStr;
      };
    },

    // message
    'String.endsWith shim'
  );

  /**
   * Determines whether a string ends with the characters of another string,
   * returning true or false as appropriate.
   *
   * @function module:util-x~exports.String.endsWith
   * @param {string} string
   * @param {string} searchString
   * @param {number} [position]
   * @return {boolean}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
   */
  exports.String.endsWith = $toMethod(exports.String.proto.endsWith);

  /**
   * Determines whether a string contains the characters of another string, returning true or
   * false as appropriate.
   *
   * @function module:util-x~exports.String.proto.contains
   * @this {string}
   * @param {string} searchString
   * @param {number} [position]
   * @return {boolean}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/contains
   */
  exports.String.proto.contains = $decide(
    // test
    $affirmBasic(base.String.contains),

    // pass
    function () {
      return base.String.contains;
    },

    // fail
    function () {
      return function (searchString, position) {
        var str = $onlyCoercibleToString(this),
          searchStr = $toString(searchString),
          length = str.length;

        if (typeof position === 'undefined') {
          position = 0;
        } else {
          position = $toInteger(position);
        }

        return $call(pSIndexOf, str, searchStr, $min($max(position, 0), length)) !== -1;
      };
    },

    // message
    'String.contains shim'
  );

  /**
   * Determines whether a string contains the characters of another string, returning true or
   * false as appropriate.
   *
   * @function module:util-x~exports.String.contains
   * @param {string} string
   * @param {string} searchString
   * @param {number} [position]
   * @return {boolean}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/contains
   */
  exports.String.contains = $toMethod(exports.String.proto.contains);

  /**
   * Determines whether a string contains the characters of another string, returning true or
   * false as appropriate.
   *
   * @private
   * @function module:util-x~$stringContains
   * @param {string} string
   * @param {string} searchString
   * @param {number} [position]
   * @return {boolean}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/contains
   */
  $stringContains = exports.String.contains;

  /**
   * @private
   * @function module:util-x~$specialToObject
   * @param {module:util-x~ArrayLike} inputArg
   * @return {(boolean|null)}
   */
  function $specialToObject(inputArg) {
    var object = $toObject(inputArg);

    if (!$hasOwnValidLength(object)) {
      throw new CTypeError('invalid length property: ' + $toString(object));
    }

    if ($isFunction(inputArg)) {
      throw new CTypeError('argument is a function: ' + $toString(object));
    }

    return object;
  }

  /**
   * The function takes one argument inputArg of an ArrayLike object and eturns true if length is zero
   * otherwise it returns false.
   *
   * @function module:util-x~exports.Array.isEmpty
   * @param {module:util-x~ArrayLike} inputArg
   * @return {boolean}
   */
  exports.Array.isEmpty = function (inputArg) {
    return !$specialToObject(inputArg).length;
  };

  /**
   * Returns the first element of an array i.e. array[0]
   * Use in combination .isEmpty
   *
   * @function module:util-x~exports.Array.proto.first
   * @this {module:util-x~ArrayLike}
   * @return {*}
   */
  exports.Array.proto.first = function () {
    var object = $specialToObject(this);

    return $getItem(object, 0, $isString(object));
  };

  /**
   * Returns the first element of an array i.e. array[0]
   * Use in combination .isEmpty
   *
   * @function module:util-x~exports.Array.first
   * @param {module:util-x~ArrayLike} inputArg
   * @return {*}
   */
  exports.Array.first = $toMethod(exports.Array.proto.first);

  /**
   * Returns the first populated elements index in an array ignoring holes, otherwise -1.
   *
   * @function module:util-x~exports.Array.proto.firstIn
   * @this {module:util-x~ArrayLike}
   * @return {number}
   */
  exports.Array.proto.firstIn = function () {
    var object = $specialToObject(this),
      length = $toLength(object.length),
      rtn = -1,
      index;

    if ($isString(object)) {
      rtn = length - 1;
    } else {
      for (index = 0; index < length; index += 1) {
        if ($hasProperty(object, index)) {
          rtn = index;
          break;
        }
      }
    }

    return rtn;
  };

  /**
   * Returns the first populated elements index in an array ignoring holes, otherwise -1.
   *
   * @function module:util-x~exports.Array.firstIn
   * @param {module:util-x~ArrayLike} inputArg
   * @return {*}
   */
  exports.Array.firstIn = $toMethod(exports.Array.proto.firstIn);

  /**
   * Returns the last element of an array; otherwise returns undefined.
   *
   * @function module:util-x~exports.Array.proto.last
   * @this {module:util-x~ArrayLike}
   * @return {*}
   */
  exports.Array.proto.last = function () {
    var object = $specialToObject(this);

    return $getItem(object, object.length - 1, $isString(object));
  };

  /**
   * Returns the last element of an array; otherwise returns undefined.
   *
   * @function module:util-x~exports.Array.last
   * @param {module:util-x~ArrayLike} inputArg
   * @return {*}
   */
  exports.Array.last = $toMethod(exports.Array.proto.last);

  /**
   * Returns the last populated elements index of an array ignoring holes, otherwise -1.
   *
   * @function module:util-x~exports.Array.proto.lastIn
   * @this {module:util-x~ArrayLike}
   * @return {*}
   */
  exports.Array.proto.lastIn = function () {
    var object = $specialToObject(this),
      last = $toLength(object.length) - 1,
      rtn = -1,
      index;

    if ($isString(object)) {
      rtn = last;
    } else {
      for (index = last; index >= 0; index -= 1) {
        if ($hasProperty(object, index)) {
          rtn = index;
          break;
        }
      }
    }

    return rtn;
  };

  /**
   * Returns the last populated elements index of an array ignoring holes, otherwise -1.
   *
   * @function module:util-x~exports.Array.lastIn
   * @param {module:util-x~ArrayLike} inputArg
   * @return {*}
   */
  exports.Array.lastIn = $toMethod(exports.Array.proto.lastIn);

  /**
   * Compares operand a against operand b and returns true if they are deemed to be the same value.
   * Otherwise returns false.
   * @typedef {Function} module:util-x~equalityFn
   * @param {*} a
   * @param {*} b
   * @return {boolean}
   */

  /**
   * This method creates a new array of unique occurences using
   * the {@link module:util-x~exports.Object.strictEqual strictEqual} comparison.
   * The new array is ordered as per the original array.
   * A function can be provided as an alternative comparison method.
   *
   * @function module:util-x~exports.Array.proto.unique
   * @this {module:util-x~ArrayLike}
   * @throws {TypeError} If array is null or undefined.
   * @param {module:util-x~equalityFn} [equalFn]
   * @throws {TypeError} If equalFn is not a {@link Function function}.
   * @param {*} [thisArg]
   * @return {Array}
   */
  exports.Array.proto.unique = (function () {
    return function (equalFn, thisArg) {
      var object = $toObject(this),
        isString,
        length,
        index,
        eqFn,
        arr,
        idx,
        val,
        it;

      if (typeof equalFn === 'undefined') {
        eqFn = $strictEqual;
      } else {
        eqFn = equalFn;
      }

      $throwIfNotFunction(eqFn);
      arr = [];
      length = $toLength(object.length);
      isString = length && $isString(object);
      for (index = 0; index < length; index += 1) {
        if ($hasItem(object, index, isString)) {
          it = $getItem(object, index, isString);
          val = true;
          for (idx = 0; idx < length; idx += 1) {
            if (idx < index && $hasItem(object, idx, isString) && $call(eqFn, thisArg, it, $getItem(object, idx, isString))) {
              val = false;
              break;
            }
          }

          if (val) {
            $push(arr, it);
          }
        }
      }

      return arr;
    };
  }());

  /**
   * This method creates a new array of unique occurences using
   * the {@link module:util-x~exports.Object.strictEqual strictEqual} comparison.
   * The new array is ordered as per the original array.
   * A function can be provided as an alternative comparison method.
   *
   * @function module:util-x~exports.Array.unique
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined.
   * @param {module:util-x~equalityFn} [equalFn]
   * @throws {TypeError} If equalFn is not a {@link Function function}.
   * @param {*} [thisArg]
   * @return {Array}
   */
  exports.Array.unique = $toMethod(exports.Array.proto.unique);

  /**
   * Returns a property descriptor for an own property (that is, one directly present on an object,
   * not present by dint of being along an object's prototype chain) of a given object.
   * On environments that do not support it natively, this is just a sham to allow code to work.
   *
   * @function module:util-x~exports.Object.getOwnPropertyDescriptor
   * @param {Object} object
   * @param {string} property
   * @return {Object}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor
   */
  exports.Object.getOwnPropertyDescriptor = (function () {
    return $decide(
      // test
      function () {
        $affirmBasic(base.Object.getOwnPropertyDescriptor)();

        var gOPDsentinel = {
            sentinel: null
          },
          gOPDarray = [10, 20, 30];

        gOPDarray[4] = Undefined;

        $affirm.strictEqual(base.Object.getOwnPropertyDescriptor(gOPDsentinel, 'sentinel').value, null, 'test1');
        $affirm.strictEqual(base.Object.getOwnPropertyDescriptor(gOPDarray, 2).value, 30, 'test2');
        $affirm.strictEqual(base.Object.getOwnPropertyDescriptor(gOPDarray, '2').value, 30, 'test3');
        $affirm.ok($call(pHasOwn, base.Object.getOwnPropertyDescriptor(gOPDarray, 4), 'value'), 'test4');
        $affirm.strictEqual(base.Object.getOwnPropertyDescriptor(gOPDarray, 4).value, Undefined, 'test5');
        $affirm.strictEqual(base.Object.getOwnPropertyDescriptor(gOPDarray, 5), Undefined, 'test6');
      },

      // pass
      function () {
        hasWorkingGOPD = true;
        return $decide(
          // test
          function () {
            // This is an intrusive patch but if it can be done correctly then it's worth it.
            try {
              if (base.Object.getOwnPropertyDescriptor(protoFunction, 'length').writable) {
                base.Object.defineProperty(protoFunction, 'length', propConstant);
                if (base.Object.getOwnPropertyDescriptor(protoFunction, 'length').writable) {
                  throw new CError('Still writable');
                }
              }
            } catch (eLengthPatch) {
              $conlog('Failed to patch Function.prototype.length', eLengthPatch);
            }

            $affirm.ok(!(base.Object.getOwnPropertyDescriptor(function () {
              return;
            }, 'length').writable), 'Function.length should be read only.');
          },

          // pass
          function () {
            return $decide(
              // test
              function () {
                $affirm.throws(function () {
                  base.Object.getOwnPropertyDescriptor(Undefined, 'name');
                }, CTypeError, 'undefined');

                $affirm.throws(function () {
                  base.Object.getOwnPropertyDescriptor(null, 'name');
                }, CTypeError, 'null');

                $affirm.doesNotThrow(function () {
                  base.Object.getOwnPropertyDescriptor(42, 'name');
                }, 'number');

                $affirm.doesNotThrow(function () {
                  base.Object.getOwnPropertyDescriptor(true, 'name');
                }, 'boolean');

                $affirm.doesNotThrow(function () {
                  base.Object.getOwnPropertyDescriptor('a', 'name');
                }, 'string');
              },

              // pass
              function () {
                return base.Object.getOwnPropertyDescriptor;
              },

              // fail
              function () {
                var mGetOwnPropertyDescriptor = base.Object.getOwnPropertyDescriptor;

                return function (object, property) {
                  return mGetOwnPropertyDescriptor($toObject(object), property);
                };
              },

              // message
              'Object.getOwnPropertyDescriptor throws patch'
            );
          },

          // fail
          function () {
            var mGetOwnPropertyDescriptor = base.Object.getOwnPropertyDescriptor;

            return function (object, property) {
              var obj = $toObject(object),
                descriptor = mGetOwnPropertyDescriptor(obj, property);

              if (property === 'length' && descriptor.writable && $isFunction(obj)) {
                descriptor.writable = false;
              }

              return descriptor;
            };
          },

          // message
          'Object.getOwnPropertyDescriptor read only patch'
        );
      },

      // fail
      function () {
        var mLookupGetter = base.Object.lookupSetter,
          mLookupSetter = base.Object.lookupSetter;

        return function (object, property) {
          var obj = $toObject(object),
            descriptor,
            prototype,
            getter,
            setter;

          if ($hasOwn(obj, property)) {
            descriptor = {};
            descriptor.configurable = true;
            descriptor.enumerable = true;
            if (hasGetSet) {
              prototype = obj[stringProto];
              obj[stringProto] = protoObject;
              getter = $call(mLookupGetter, obj, property);
              setter = $call(mLookupSetter, obj, property);
              if (typeof prototype === 'undefined') {
                $deleteProperty(obj, stringProto);
              } else {
                obj[stringProto] = prototype;
              }

              if ($isNative(getter) || $isNative(setter)) {
                if ($isNative(getter)) {
                  descriptor.get = getter;
                }

                if ($isNative(setter)) {
                  descriptor.set = setter;
                }
              }
            }

            descriptor.value = obj[property];
            descriptor.writable = true;
          }

          return descriptor;
        };
      },

      //message
      'Object.getOwnPropertyDescriptor sham'
    );
  }());

  /**
   * This method changes the content of an array,
   * adding new elements while removing old elements.
   *
   * @function module:util-x~exports.Array.proto.splice
   * @this {module:util-x~ArrayLike}
   * @param {number} start
   * @param {number} [deleteCount]
   * @param {...*} [element]
   * @return {Array}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice
   */
  exports.Array.proto.splice = (function () {
    var readOnlyLengths = {};

    // Used to identify `toStringTag` values of object with read only length.
    readOnlyLengths[stringTagFunction] = true;
    readOnlyLengths[stringTagString] = true;
    readOnlyLengths[stringTagArrayBuffer] = true;
    readOnlyLengths[stringTagFloat32Array] = true;
    readOnlyLengths[stringTagFloat64Array] = true;
    readOnlyLengths[stringTagInt8Array] = true;
    readOnlyLengths[stringTagInt16Array] = true;
    readOnlyLengths[stringTagInt32Array] = true;
    readOnlyLengths[stringTagUint8Array] = true;
    readOnlyLengths[stringTagUint8ClampedArray] = true;
    readOnlyLengths[stringTagUint16Array] = true;
    readOnlyLengths[stringTagUint32Array] = true;
    readOnlyLengths[stringTagHTMLCollection] = true;
    readOnlyLengths[stringTagNodeList] = true;

    // this is by no means perfect but it's better than nothing
    function readOnlyLength(inputArg) {
      var stringTag = $toStringTag(inputArg);

      if (readOnlyLengths[stringTag] || (hasWorkingGOPD && $call(pHasOwn, inputArg, 'length') && !exports.Object.getOwnPropertyDescriptor(inputArg, 'length').writable)) {
        throw new CTypeError('Cannot assign to read only property \'length\' of ' + stringTag);
      }

      return inputArg;
    }

    return $decide(
      // test
      function () {
        $affirmBasic(base.Array.splice)();
        $affirm.strictEqual($call(base.Array.splice, [1, 2], 0).length, 2, 'correct length');
      },

      // pass
      function () {
        return $decide(
          // test
          function () {
            $affirm.strictEqual($call(base.Array.splice, [1, 2]).length, 0, 'is zero');

            $affirm.throws(function () {
              $call(base.Array.splice, 'abc');
            }, CTypeError, 'string should throw');

            $affirm.throws(function () {
              $call(base.Array.splice, function () {
                return;
              });
            }, CTypeError, 'function should throw');
          },

          // pass
          function () {
            return base.Array.splice;
          },

          // fail
          function () {
            var pSplice = base.Array.splice;

            return function () {
              var object = readOnlyLength($toObject(this)),
                val;

              if ($toLength(arguments.length) < 1) {
                val = [];
              } else {
                val = $apply(pSplice, object, arguments);
              }

              return val;
            };
          },

          // message
          'Array.splice patch'
        );
      },

      // fail
      function () {
        return function (start, deleteCount) {
          var object = readOnlyLength($toObject(this)),
            length = $toLength(object.length),
            removed = [],
            relativeStart = $toInteger(start),
            isString = length && $isString(object),
            actualStart,
            actualDeleteCount,
            k = 0,
            from,
            argLength = $toLength(arguments.length),
            item = 2,
            itemCount = $max(argLength - item, 0),
            to,
            loopCache;

          if (argLength < 1) {
            return removed;
          }

          if (relativeStart < 0) {
            actualStart = $max(length + relativeStart, 0);
          } else {
            actualStart = $min(relativeStart, length);
          }

          if (argLength < 2) {
            deleteCount = length - actualStart;
          }

          actualDeleteCount = $min($max($toLength(deleteCount), 0), length - actualStart);
          while (k < actualDeleteCount) {
            from = actualStart + k;
            if ($hasItem(object, from, isString)) {
              $push(removed, $getItem(object, from, isString));
            }

            k += 1;
          }

          if (itemCount < actualDeleteCount) {
            k = actualStart;
            loopCache = length - actualDeleteCount;
            while (k < loopCache) {
              from = k + actualDeleteCount;
              to = k + itemCount;
              if ($hasItem(object, from, isString)) {
                object[to] = $getItem(object, from, isString);
              } else {
                $deleteProperty(object, to);
              }

              k += 1;
            }

            k = length;
            loopCache = length - actualDeleteCount + itemCount;
            while (k > loopCache) {
              $deleteProperty(object, k - 1);
              k -= 1;
            }
          } else if (itemCount > actualDeleteCount) {
            k = length - actualDeleteCount;
            while (k > actualStart) {
              from = k + actualDeleteCount - 1;
              to = k + itemCount - 1;
              if ($hasItem(object, from, isString)) {
                object[to] = $getItem(object, from, isString);
              } else {
                $deleteProperty(object, to);
              }

              k -= 1;
            }
          }

          k = actualStart;
          while (item < argLength) {
            object[k] = arguments[item];
            k += 1;
            item += 1;
          }

          object.length = $toLength(length - actualDeleteCount + itemCount);

          return removed;
        };
      },

      // message
      'Array.splice shim'
    );
  }());

  /**
   * This method changes the content of an array,
   * adding new elements while removing old elements.
   *
   * @function module:util-x~exports.Array.splice
   * @param {module:util-x~ArrayLike} array
   * @param {number} start
   * @param {number} [deleteCount]
   * @param {...*} [element]
   * @return {Array}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice
   */
  exports.Array.splice = $toMethod(exports.Array.proto.splice);

  /**
   * This) method changes the content of an array,
   * adding new elements while removing old elements.
   *
   * @private
   * @function module:util-x~$splice
   * @param {module:util-x~ArrayLike} array
   * @param {number} start
   * @param {number} [deleteCount]
   * @param {...*} [element]
   * @return {Array}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice
   */
  $splice = exports.Array.splice;

  /**
   * Checks if the supplied function suffers from the V8 strict mode bug.
   *
   * @private
   * @function module:util-x~$testV8StrictBug
   * @param {Function} fn
   * @return {boolean}
   */
  function $testV8StrictBug(fn) {
    var bug = false;

    if (isStrictMode) {
      $affirm.doesNotThrow(function () {
        $call(fn, [1], function () {
          bug = $typeOf(this) === 'object';
        }, 'foo');
      }, 'should not throw when calling function');
    }

    return bug;
  }

  /**
   * @private
   * @function module:util-x~$affirmArrayMethodTestsBasic
   * @param {Function} [thisArg]
   * @return {Function}
   */
  function $affirmArrayMethodTestsBasic(Fn) {
    return function () {
      $affirmBasic(Fn)();
      $affirm.ok(!$testV8StrictBug(Fn), 'V8 bug');
    };
  }

  /**
   * @private
   * @function module:util-x~$affirmArrayMethodTestsObject
   * @param {Function} [thisArg]
   * @return {Function}
   */
  function $affirmArrayMethodTestsObject(Fn) {
    return function () {
      $affirmArrayMethodTestsBasic(Fn)();

      var result;

      $affirm.doesNotThrow(function () {
        $call(Fn, 'foo', function () {
          result = arguments[$toLength(arguments.length) - 1];
        });
      }, 'should not throw when calling function');

      $affirm.strictEqual($typeOf(result), 'object', 'is object');
      $affirm.ok($isString(result), 'is string');
    };
  }

  /**
   * forEach executes the callback function once for each array element;
   * unlike every and some it does not return a value.
   * If a thisArg parameter is provided to forEach, it will be passed to callback when invoked,
   * for use as its this value. Otherwise, the value undefined will be passed for use as its this value.
   * @typedef {Function} module:util-x~forEachCallback
   * @param {*} element The current element being processed in the array.
   * @param {number} index The index of the current element being processed in the array.
   * @param {Object} object The object that forEach was called upon.
   * @return {undefined}
   */

  /**
   * Executes a provided function once per array element.
   *
   * @function module:util-x~exports.Array.proto.forEach
   * @this {module:util-x~ArrayLike}
   * @throws {TypeError} If array is null or undefined
   * @param {module:util-x~forEachCallback} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [thisArg]
   * @return {undefined}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
   */
  exports.Array.proto.forEach = $decide(
    // test
    $affirmArrayMethodTestsObject(base.Array.forEach),

    // pass
    function () {
      return base.Array.forEach;
    },

    //fail
    function () {
      return function (fn, thisArg) {
        var object = $toObject(this),
          isString,
          length,
          index;

        $throwIfNotFunction(fn);
        length = $toLength(object.length);
        isString = length && $isString(object);
        for (index = 0; index < length; index += 1) {
          if ($hasItem(object, index, isString)) {
            $call(fn, thisArg, $getItem(object, index, isString), index, object);
          }
        }
      };
    },

    // message
    'Array.forEach shim'
  );

  /**
   * Executes a provided function once per array element.
   *
   * @function module:util-x~exports.Array.forEach
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @param {module:util-x~forEachCallback} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [thisArg]
   * @return {undefined}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
   */
  exports.Array.forEach = $toMethod(exports.Array.proto.forEach);

  /**
   * Executes a provided function once per array element.
   *
   * @private
   * @function module:util-x~$forEach
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @param {module:util-x~forEachCallback} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [thisArg]
   * @return {undefined}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
   */
  $forEach = exports.Array.forEach;

  /**
   * Executes a provided function once per array element position.
   * Unlike forEach, this method treats the array as dense and allows a some like break.
   *
   * @function module:util-x~exports.Array.proto.forAll
   * @this {module:util-x~ArrayLike}
   * @throws {TypeError} If array is null or undefined
   * @param {module:util-x~someCallback} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [thisArg]
   * @return {undefined}
   */
  exports.Array.proto.forAll = function (fn, thisArg) {
    var object = $toObject(this),
      isString,
      length,
      index,
      val;

    $throwIfNotFunction(fn);
    length = $toLength(object.length);
    isString = length && $isString(object);
    val = false;
    for (index = 0; index < length; index += 1) {
      val = !!$call(fn, thisArg, $getItem(object, index, isString), index, object);
      if (val) {
        break;
      }
    }

    return val;
  };

  /**
   * Executes a provided function once per array element position.
   * Unlike forEach, this method treats the array as dense and allows a some like break.
   *
   * @function module:util-x~exports.Array.forAll
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @param {module:util-x~someCallback} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [thisArg]
   * @return {undefined}
   */
  exports.Array.forAll = $toMethod(exports.Array.proto.forAll);

  /**
   * some executes the callback function once for each element present in the array until it finds one
   * where callback returns a true value.
   * If a thisArg parameter is provided to some, it will be passed to callback when invoked,
   * for use as its this value. Otherwise, the value undefined will be passed for use as its this value.
   * @typedef {Function} module:util-x~someCallback
   * @param {*} element The current element being processed in the array.
   * @param {number} index The index of the current element being processed in the array.
   * @param {Object} object The object that some was called upon.
   * @return {boolean}
   */

  /**
   * Tests whether some element in the array passes the test implemented by the provided function.
   *
   * @function module:util-x~exports.Array.proto.some
   * @this {module:util-x~ArrayLike}
   * @throws {TypeError} If array is null or undefined
   * @param {module:util-x~someCallback} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [thisArg]
   * @return {boolean}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
   */
  exports.Array.proto.some = $decide(
    // test
    $affirmArrayMethodTestsObject(base.Array.some),

    // pass
    function () {
      return base.Array.some;
    },

    // fail
    function () {
      return function (fn, thisArg) {
        var object = $toObject(this),
          isString,
          val,
          length,
          index;

        $throwIfNotFunction(fn);
        length = $toLength(object.length);
        isString = length && $isString(object);
        val = false;
        for (index = 0; index < length; index += 1) {
          if ($hasItem(object, index, isString)) {
            val = !!$call(fn, thisArg, $getItem(object, index, isString), index, object);
            if (val) {
              break;
            }
          }
        }

        return val;
      };
    },

    // message
    'Array.some shim'
  );

  /**
   * Tests whether some element in the array passes the test implemented by the provided function.
   *
   * @function module:util-x~exports.Array.some
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @param {module:util-x~someCallback} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [thisArg]
   * @return {boolean}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
   */
  exports.Array.some = $toMethod(exports.Array.proto.some);

  /**
   * The find method executes the callback function once for each element present in the array until it
   * finds one where callback returns a true value.
   * If a thisArg parameter is provided to some, it will be passed to callback when invoked,
   * for use as its this value. Otherwise, the value undefined will be passed for use as its this value.
   * @typedef {Function} module:util-x~findCallback
   * @param {*} element The current element being processed in the array.
   * @param {number} index The index of the current element being processed in the array.
   * @param {Object} object The object that find was called upon.
   * @return {boolean}
   */

  /**
   * This method returns a value in the array, if an element in the array satisfies the provided testing function.
   * Otherwise undefined is returned.
   *
   * @function module:util-x~exports.Array.proto.find
   * @this {module:util-x~ArrayLike}
   * @throws {TypeError} If array is null or undefined
   * @param {module:util-x~findCallback} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [thisArg]
   * @return {*}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
   */
  exports.Array.proto.find = $decide(
    // test
    function () {
      $affirmArrayMethodTestsBasic(base.Array.find)();

      var obj = {
          0: 1,
          1: 2,
          2: 3,
          length: -3
        },
        foundIndex;

      $affirm.doesNotThrow(function () {
        foundIndex = $call(base.Array.find, obj, function () {
          throw new CError('should not reach here');
        });
      }, 'should not iterate object with negative length');

      $affirm.strictEqual(foundIndex, -1, 'object with negative length');
    },

    // pass
    function () {
      return base.Array.find;
    },

    // fail
    function () {
      return function (fn, thisArg) {
        var object = $toObject(this),
          isString,
          length,
          index,
          val,
          it;

        $throwIfNotFunction(fn);
        length = $toLength(object.length);
        isString = length && $isString(object);
        for (index = 0; index < length; index += 1) {
          it = $getItem(object, index, isString);
          if ($call(fn, thisArg, it, index, object)) {
            val = it;
            break;
          }
        }

        return val;
      };
    },

    // message
    'Array.find shim'
  );

  /**
   * This method returns a value in the array, if an element in the array satisfies the provided testing function.
   * Otherwise undefined is returned.
   *
   * @function module:util-x~exports.Array.find
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @param {module:util-x~findCallback} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [thisArg]
   * @return {*}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
   */
  exports.Array.find = $toMethod(exports.Array.proto.find);

  /**
   * The findIndex method executes the callback function once for each element present in the array until it
   * finds one where callback returns a true value.
   * If a thisArg parameter is provided to some, it will be passed to callback when invoked,
   * for use as its this value. Otherwise, the value undefined will be passed for use as its this value.
   * @typedef {Function} module:util-x~findIndexCallback
   * @param {*} element The current element being processed in the array.
   * @param {number} index The index of the current element being processed in the array.
   * @param {Object} object The object that findIndex was called upon.
   * @return {boolean}
   */

  /**
   * This method returns an index in the array, if an element in the array satisfies the provided testing function.
   * Otherwise -1 is returned.
   *
   * @function module:util-x~exports.Array.proto.findIndex
   * @this {module:util-x~ArrayLike}
   * @throws {TypeError} If array is null or undefined
   * @param {module:util-x~findIndexCallback} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [thisArg]
   * @return {number}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
   */
  exports.Array.proto.findIndex = $decide(
    // test
    function () {
      $affirmArrayMethodTestsBasic(base.Array.findIndex)();

      var obj = {
          0: 1,
          1: 2,
          2: 3,
          length: -3
        },
        foundIndex;

      $affirm.doesNotThrow(function () {
        foundIndex = $call(base.Array.findIndex, obj, function () {
          throw new CError('should not reach here');
        });
      }, 'should not iterate object with negative length');

      $affirm.strictEqual(foundIndex, -1, 'object with negative length');
    },

    // pass
    function () {
      return base.Array.findIndex;
    },

    // fail
    function () {
      return function (fn, thisArg) {
        var object = $toObject(this),
          isString,
          val,
          length,
          index;

        $throwIfNotFunction(fn);
        length = $toLength(object.length);
        isString = length && $isString(object);
        val = -1;
        for (index = 0; index < length; index += 1) {
          if ($call(fn, thisArg, $getItem(object, index, isString), index, object)) {
            val = index;
            break;
          }
        }

        return val;
      };
    },

    // message
    'Array.findIndex'
  );

  /**
   * This method returns an index in the array, if an element in the array satisfies the provided testing function.
   * Otherwise -1 is returned.
   *
   * @function module:util-x~exports.Array.findIndex
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @param {module:util-x~findIndexCallback} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [thisArg]
   * @return {number}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
   */
  exports.Array.findIndex = $toMethod(exports.Array.proto.findIndex);

  /**
   * from calls a provided callback function once for each element in an arrayLike object, in order,
   * and constructs a new array from the results.
   * @typedef {Function} module:util-x~fromCallback
   * @param {*} element The current element being processed in the array.
   * @param {number} index The index of the current element being processed in the array.
   * @return {*}
   */

  /**
   * Converts a single argument that is an array-like object or list (eg. arguments, NodeList,
   * DOMTokenList (used by classList), NamedNodeMap (used by attributes property)) into a new Array() and returns it.
   *
   * @function module:util-x~exports.Array.from
   * @param {module:util-x~ArrayLike} arrayLike
   * @param {module:util-x~fromCallback} [mapfn]
   * @param {*} [thisArg]
   * @return {Array}
   */
  exports.Array.from = $decide(
    // test
    $affirmBasic(base.Array.from),

    // pass
    function () {
      return base.Array.from;
    },

    // fail
    function () {
      return function (arrayLike, mapfn, thisArg) {
        var object = $toObject(arrayLike),
          isString,
          length,
          array,
          mapping,
          index,
          it;

        if (typeof mapfn !== 'undefined') {
          mapping = !!$throwIfNotFunction(mapfn);
        }

        length = $toLength(object.length);
        if ($isFunction(this)) {
          array = new this(length);
        } else {
          array = [];
        }

        array.length = length;
        /*
        if (length) {
            thisArg = $toObjectCallFix(thisArg);
        }
        */

        isString = length && $isString(object);
        for (index = 0; index < length; index += 1) {
          it = $getItem(object, index, isString);
          if (mapping) {
            it = $call(mapfn, thisArg, it, index);
          }

          array[index] = it;
        }

        return array;
      };
    },

    // message
    'Array.from shim'
  );

  /**
   * The every method executes the provided callback function once for each element present in the array
   * until it finds one where callback returns a falsy value (a value that becomes false when converted to a Boolean).
   * If a thisArg parameter is provided to some, it will be passed to callback when invoked,
   * for use as its this value. Otherwise, the value undefined will be passed for use as its this value.
   * @typedef {Function} module:util-x~everyCallback
   * @param {*} element The current element being processed in the array.
   * @param {number} index The index of the current element being processed in the array.
   * @param {Object} object The object that every was called upon.
   * @return {*}
   */

  /**
   * Tests whether all elements in the array pass the test implemented by the provided function.
   *
   * @function module:util-x~exports.Array.proto.every
   * @this {module:util-x~ArrayLike}
   * @throws {TypeError} If array is null or undefined
   * @param {module:util-x~everyCallback} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [thisArg]
   * @return {boolean}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every
   */
  exports.Array.proto.every = $decide(
    // test
    $affirmArrayMethodTestsObject(base.Array.every),

    // pass
    function () {
      return base.Array.every;
    },

    // fail
    function () {
      return function (fn, thisArg) {
        var object = $toObject(this),
          isString,
          length,
          val,
          index;

        $throwIfNotFunction(fn);
        length = $toLength(object.length);
        isString = length && $isString(object);
        val = true;
        for (index = 0; index < length; index += 1) {
          if ($hasItem(object, index, isString)) {
            val = !!$call(fn, thisArg, $getItem(object, index, isString), index, object);
            if (!val) {
              break;
            }
          }
        }

        return val;
      };
    },

    // message
    'Array.every shim'
  );

  /**
   * Tests whether all elements in the array pass the test implemented by the provided function.
   *
   * @function module:util-x~exports.Array.every
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @param {module:util-x~everyCallback} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [thisArg]
   * @return {boolean}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every
   */
  exports.Array.every = $toMethod(exports.Array.proto.every);

  /**
   * map calls a provided callback function once for each element in an arrayLike object, in order,
   * and constructs a new array from the results.
   * If a thisArg parameter is provided to some, it will be passed to callback when invoked,
   * for use as its this value. Otherwise, the value undefined will be passed for use as its this value.
   * @typedef {Function} module:util-x~mapCallback
   * @param {*} element The current element being processed in the array.
   * @param {number} index The index of the current element being processed in the array.
   * @param {Object} object The object that map was called upon.
   * @return {*}
   */

  /**
   * Creates a new array with the results of calling a provided function on every element in this array.
   *
   * @function module:util-x~exports.Array.proto.map
   * @this {module:util-x~ArrayLike}
   * @throws {TypeError} If array is null or undefined
   * @param {module:util-x~mapCallback} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [thisArg]
   * @return {Array}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
   */
  exports.Array.proto.map = $decide(
    // test
    $affirmArrayMethodTestsObject(base.Array.map),

    // pass
    function () {
      return base.Array.map;
    },

    // fail
    function () {
      return function (fn, thisArg) {
        var object = $toObject(this),
          isString,
          length,
          arr,
          index;

        $throwIfNotFunction(fn);
        arr = [];
        arr.length = length = $toLength(object.length);
        isString = length && $isString(object);
        for (index = 0; index < length; index += 1) {
          if ($hasItem(object, index, isString)) {
            arr[index] = $call(fn, thisArg, $getItem(object, index, isString), index, object);
          }
        }

        return arr;
      };
    },

    // message
    'Array.map shim'
  );

  /**
   * Creates a new array with the results of calling a provided function on every element in this array.
   *
   * @function module:util-x~exports.Array.map
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @param {module:util-x~mapCallback} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [thisArg]
   * @return {Array}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
   */
  exports.Array.map = $toMethod(exports.Array.proto.map);

  /**
   * This method creates a new Array instance with a variable number of arguments,
   * regardless of number or type of the arguments.
   *
   * @function module:util-x~exports.Array.of
   * @param {...*} [varArgs]
   * @return {Array}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
   */
  exports.Array.of = $decide(
    // test
    $affirmBasic(base.Array.of),

    // pass
    function () {
      return base.Array.of;
    },

    // fail
    function () {
      return function () {
        return $argSlice(arguments);
      };
    },

    // message
    'Array.of shim'
  );

  /**
   * Creates a new array with all elements that pass the test implemented by the provided function.
   *
   * @function module:util-x~exports.Array.proto.filter
   * @this {module:util-x~ArrayLike}
   * @throws {TypeError} If array is null or undefined
   * @param {Function} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [thisArg]
   * @return {Array}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
   */
  exports.Array.proto.filter = $decide(
    // test
    $affirmArrayMethodTestsObject(base.Array.filter),

    // pass
    function () {
      return base.Array.filter;
    },

    // fail
    function () {
      return function (fn, thisArg) {
        var object = $toObject(this),
          isString,
          length,
          arr,
          index,
          it;

        $throwIfNotFunction(fn);
        length = $toLength(object.length);
        isString = length && $isString(object);
        arr = [];
        for (index = 0; index < length; index += 1) {
          if ($hasItem(object, index, isString)) {
            it = $getItem(object, index, isString);
            if ($call(fn, thisArg, it, index, object)) {
              $push(arr, it);
            }
          }
        }

        return arr;
      };
    },

    // message
    'Array.filter shim'
  );

  /**
   * Creates a new array with all elements that pass the test implemented by the provided function.
   *
   * @function module:util-x~exports.Array.filter
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @param {Function} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [thisArg]
   * @return {Array}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
   */
  exports.Array.filter = $toMethod(exports.Array.proto.filter);

  /**
   * Creates a new array with all the 'holes' removed.
   *
   * @function module:util-x~exports.Array.proto.condense
   * @this {module:util-x~ArrayLike}
   * @throws {TypeError} If array is null or undefined
   * @return {Array}
   */
  exports.Array.proto.condense = function () {
    var object = $toObject(this),
      length = $toLength(object.length),
      isString = length && $isString(object),
      arr = [],
      index;

    for (index = 0; index < length; index += 1) {
      if ($hasItem(object, index, isString)) {
        $push(arr, $getItem(object, index, isString));
      }
    }

    return arr;
  };

  /**
   * Creates a new array with all the 'holes' removed.
   *
   * @function module:util-x~exports.Array.condense
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @return {Array}
   */
  exports.Array.condense = $toMethod(exports.Array.proto.condense);

  /**
   * Creates an array with all falsey values removed. The values false, null,
   * 0, "", undefined, and NaN are falsey.
   *
   * @function module:util-x~exports.Array.proto.compact
   * @this {module:util-x~ArrayLike}
   * @throws {TypeError} If array is null or undefined
   * @return {Array}
   */
  exports.Array.proto.compact = function () {
    var object = $toObject(this),
      length = $toLength(object.length),
      isString = length && $isString(object),
      arr = [],
      value,
      index;

    for (index = 0; index < length; index += 1) {
      if ($hasItem(object, index, isString)) {
        value = $getItem(object, index, isString);
        if (value) {
          $push(arr, value);
        }
      }
    }

    return arr;
  };

  /**
   * Creates an array with all falsey values removed. The values false, null,
   * 0, "", undefined, and NaN are falsey.
   *
   * @function module:util-x~exports.Array.compact
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @return {Array}
   */
  exports.Array.compact = $toMethod(exports.Array.proto.compact);

  /**
   * Flattens a nested array. If deep is true the array is recursively
   * flattened, otherwise it's only flattened a single level.
   *
   * @function module:util-x~exports.Array.proto.flatten
   * @this {Array} The array to flatten.
   * @param {boolean} [deep] Specify a deep flatten.
   * @return {Array} Returns the new flattened array.
   */
  exports.Array.proto.flatten = function (deep) {
    var object = $toObject(this),
      length = $toLength(object.length),
      result = [],
      index,
      stack,
      value,
      idx,
      len;

    if (!length || !$isArray(object)) {
      return result;
    }

    index = 0;
    if (deep) {
      stack = [];
    }

nextChildFlatten:
    while (index < length) {
      if ($hasProperty(object, index)) {
        value = object[index];
        if ($isArray(value)) {
          if (deep) {
            $push(stack, {
              object: object,
              length: length,
              index: index
            });

            object = value;
            length = $toLength(value.length);
            index = 0;
            /*jslint continue:true*/
            continue nextChildFlatten;
          }

          len = $toLength(value.length);
          for (idx = 0; idx < len; idx += 1) {
            if ($hasProperty(value, idx)) {
              $push(result, value[idx]);
            } else {
              result.length += 1;
            }
          }
        } else {
          $push(result, value);
        }
      } else {
        result.length += 1;
      }

      index += 1;
      if (deep && index >= length && $toLength(stack.length)) {
        value = $pop(stack);
        object = value.object;
        length = value.length;
        index = value.index + 1;
        /*jslint continue:true*/
        continue nextChildFlatten;
      }
    }

    return result;
  };

  /**
   * Flattens a nested array. If deep is true the array is recursively
   * flattened, otherwise it's only flattened a single level.
   *
   * @function module:util-x~exports.Array.flatten
   * @param {Array} array The array to flatten.
   * @param {boolean} [deep] Specify a deep flatten.
   * @return {Array} Returns the new flattened array.
   */
  exports.Array.flatten = $toMethod(exports.Array.proto.flatten);

  /**
   * Apply a function against an accumulator and each value of the array (from left-to-right)
   * as to reduce it to a single value.
   *
   * @function module:util-x~exports.Array.proto.reduce
   * @this {module:util-x~ArrayLike}
   * @throws {TypeError} If array is null or undefined
   * @param {Function} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [initialValue]
   * @return {*}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce
   */
  exports.Array.proto.reduce = $decide(
    // test
    $affirmArrayMethodTestsObject(base.Array.reduce),

    // pass
    function () {
      return base.Array.reduce;
    },

    // fail
    function () {
      var reduceTypeErrorMessage = 'reduce of empty array with no initial value';

      return function (fn, initialValue) {
        var object = $toObject(this),
          isString,
          accumulator,
          length,
          kPresent,
          index;

        $throwIfNotFunction(fn);
        length = $toLength(object.length);
        if (!length && $toLength(arguments.length) === 1) {
          throw new CTypeError(reduceTypeErrorMessage);
        }

        index = 0;
        isString = length && $isString(object);
        if ($toLength(arguments.length) > 1) {
          accumulator = initialValue;
        } else {
          kPresent = false;
          while (!kPresent && index < length) {
            kPresent = $hasItem(object, index, isString);
            if (kPresent) {
              accumulator = $getItem(object, index, isString);
              index += 1;
            }
          }

          if (!kPresent) {
            throw new CTypeError(reduceTypeErrorMessage);
          }
        }

        while (index < length) {
          if ($hasItem(object, index, isString)) {
            accumulator = $call(fn, Undefined, accumulator, $getItem(object, index, isString), index, object);
          }

          index += 1;
        }

        return accumulator;
      };
    },

    // message
    'Array.reduce shim'
  );

  /**
   * Apply a function against an accumulator and each value of the array (from left-to-right)
   * as to reduce it to a single value.
   *
   * @function module:util-x~exports.Array.reduce
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @param {Function} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [initialValue]
   * @return {*}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce
   */
  exports.Array.reduce = $toMethod(exports.Array.proto.reduce);

  /**
   * this method applies a function against an accumulator and
   * each value of the array (from left-to-right) as to reduce it to a single value.
   *
   * @function module:util-x~exports.Array.proto.reduceRight
   * @this {module:util-x~ArrayLike}
   * @throws {TypeError} If array is null or undefined
   * @param {Function} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [initialValue]
   * @return {*}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight
   */
  exports.Array.proto.reduceRight = $decide(
    // test
    $affirmArrayMethodTestsObject(base.Array.reduceRight),

    // pass
    function () {
      return base.Array.reduceRight;
    },

    // fail
    function () {
      var reduceRightTypeErrorMessage = 'reduceRight of empty array with no initial value';

      return function (fn, initialValue) {
        var object = $toObject(this),
          isString,
          accumulator,
          length,
          kPresent,
          index;

        $throwIfNotFunction(fn);
        length = $toLength(object.length);
        if (!length && $toLength(arguments.length) === 1) {
          throw new CTypeError(reduceRightTypeErrorMessage);
        }

        isString = length && $isString(object);
        index = length - 1;
        if ($toLength(arguments.length) > 1) {
          accumulator = initialValue;
        } else {
          kPresent = false;
          while (!kPresent && index >= 0) {
            kPresent = $hasItem(object, index, isString);
            if (kPresent) {
              accumulator = $getItem(object, index, isString);
              index -= 1;
            }
          }

          if (!kPresent) {
            throw new CTypeError(reduceRightTypeErrorMessage);
          }
        }

        while (index >= 0) {
          if ($hasItem(object, index, isString)) {
            accumulator = $call(fn, Undefined, accumulator, $getItem(object, index, isString), index, object);
          }

          index -= 1;
        }

        return accumulator;
      };
    },

    // message
    'Array.reduceRight shim'
  );

  /**
   * This {@link module:util-x~boundPrototypalFunction method} applies a function against an accumulator and
   * each value of the array (from left-to-right) as to reduce it to a single value.
   *
   * @function module:util-x~exports.Array.reduceRight
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @param {Function} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [initialValue]
   * @return {*}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight
   */
  exports.Array.reduceRight = $toMethod(exports.Array.proto.reduceRight);

  /**
   * This method groups array elements into groups of num elements.
   *
   * @function module:util-x~exports.Array.proto.chunk
   * @param {*} chunkSize
   * @throws {TypeError} If array is null or undefined
   * @return {Array}
   */
  exports.Array.proto.chunk = function (chunkSize) {
    var object = $toObject(this),
      chunkLength = $toInteger(chunkSize),
      chunked = [],
      numChunks,
      length,
      index,
      start,
      end;

    if (chunkLength < 1) {
      return chunked;
    }

    length = $toLength(object.length);
    numChunks = $ceil(length / chunkLength);
    index = 0;
    start = 0;
    end = chunkLength;
    chunked.length = numChunks;
    while (index < numChunks) {
      chunked[index] = $slice(object, start, end);
      start = end;
      end += chunkLength;
      index += 1;
    }

    return chunked;
  };

  /**
   * This method groups array elements into groups of num elements.
   *
   * @function module:util-x~exports.Array.chunk
   * @param {module:util-x~ArrayLike} array
   * @param {*} num
   * @throws {TypeError} If array is null or undefined
   * @return {Array}
   */
  exports.Array.chunk = $toMethod(exports.Array.proto.chunk);

  /**
   * Returns a safe integer for the supplied argument.
   *
   * @private
   * @@function module:util-x~clampSafeInt
   * @param {number} number
   * @return {number}
   */
  function clampSafeInt(number) {
    return $min($max($toInteger(number), MIN_SAFE_INTEGER), MAX_SAFE_INTEGER);
  }

  /**
   * Returns a uniformly distributed random safe integer between the supplied min and max arguments.
   * Max: MAX_SAFE_INTEGER, Min: MIN_SAFE_INTEGER
   * If min is not supplied then 0 is used.
   *
   * @function module:util-x~exports.Number.randomInt
   * @param {number} [min]
   * @param {number} max
   * @return {number}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
   */
  exports.Number.randomInt = function (min, max) {
    if ($toLength(arguments.length) === 1) {
      max = min;
      min = 0;
    }

    min = clampSafeInt(min);
    max = clampSafeInt(max);
    if (min === max) {
      return min;
    }

    var tmp = max - min + 1,
      val;

    if (tmp > MAX_SAFE_INTEGER) {
      tmp = new BigNum(max).minus(min).plus(1);
      val = $floor(tmp.times($random())) + min;
    } else {
      val = $floor($random() * tmp + min);
    }

    return val;
  };

  /**
   * Shortcut
   * Returns a uniformly distributed random safe integer between the supplied min and max arguments.
   * Max: MAX_SAFE_INTEGER, Min: MIN_SAFE_INTEGER
   * If min is not supplied then 0 is used.
   *
   * @private
   * @function module:util-x~$randomInt
   * @param {number} [min]
   * @param {number} max
   * @return {number}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
   */
  $randomInt = exports.Number.randomInt;

  /**
   * @private
   * @name module:util-x~wspaceStrings
   * @namespace
   */
  wspaceStrings = (function () {
    var whiteSpaces = [
        0x0009, // Tab
        0x000a, // Line Feed
        0x000b, // Vertical Tab
        0x000c, // Form Feed
        0x000d, // Carriage Return
        0x0020, // Space
        //0x0085, // Next line
        0x00a0, // No-break space
        0x1680, // Ogham space mark
        0x180e, // Mongolian vowel separator
        0x2000, // En quad
        0x2001, // Em quad
        0x2002, // En space
        0x2003, // Em space
        0x2004, // Three-per-em space
        0x2005, // Four-per-em space
        0x2006, // Six-per-em space
        0x2007, // Figure space
        0x2008, // Punctuation space
        0x2009, // Thin space
        0x200a, // Hair space
        //0x200b, // Zero width space
        0x2028, // Line separator
        0x2029, // Paragraph separator
        0x202f, // Narrow no-break space
        0x205f, // Medium mathematical space
        0x3000, // Ideographic space
        0xfeff // Byte Order Mark
      ],
      length = $toLength(whiteSpaces.length),
      index,
      hex,
      wsStr = '',
      trimString = '';

    for (index = 0; index < length; index += 1) {
      hex = $call(base.Number.toString, whiteSpaces[index], 16);
      wsStr += '\\u' + $sSlice('0000', 0, -$toLength(hex.length)) + hex;
      trimString += base.String.fromCharCode(whiteSpaces[index]);
    }

    return {
      /**
       * For creating a RegExp
       *
       * @private
       * @name module:util-x~wspaceStrings.wsStr
       * type {string}
       * */
      wsStr: wsStr,

      /**
       * For testing trim
       *
       * @private
       * @name module:util-x~wspaceStrings.trimString
       * type {string}
       * */
      trimString: trimString
    };
  }());

  /**
   * This method removes whitespace from both ends of the string.
   *
   * @function module:util-x~exports.String.proto.trim
   * @this {string}
   * @return {string}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim
   */
  exports.String.proto.trim = $decide(
    // test
    function () {
      $affirmBasic(base.String.trim)();

      var value;

      $affirm.doesNotThrow(function () {
        value = $call(base.String.trim, wspaceStrings.trimString);
      }, 'test1');

      $affirm.strictEqual(value.length, 0, 'not all whitespace trimmed');

      $affirm.doesNotThrow(function () {
        value = $call(base.String.trim, base.String.fromCharCode(0x200b));
      }, 'test2');

      $affirm.strictEqual(value.length, 1, 'trimmed 0x200b bug');

      $affirm.doesNotThrow(function () {
        value = $call(base.String.trim, base.String.fromCharCode(0x0085));
      }, 'test3');

      $affirm.strictEqual(value.length, 1, 'trimmed 0x0085 bug');
    },

    // pass
    function () {
      return base.String.trim;
    },

    // fail
    function () {
      var wsTrim = new CRegExp('^[' + wspaceStrings.wsStr + ']+|[' + wspaceStrings.wsStr + ']+$', 'g');

      return function () {
        return $replace($onlyCoercibleToString(this), wsTrim, '');
      };
    },

    // message
    'String.trim shim'
  );

  /**
   * This {@link module:util-x~boundPrototypalFunction method} removes whitespace from both ends of the string.
   *
   * @function module:util-x~exports.String.trim
   * @param {string} inputArg
   * @return {string}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim
   */
  exports.String.trim = $toMethod(exports.String.proto.trim);

  /**
   * Shortcut
   * This {@link module:util-x~boundPrototypalFunction method} removes whitespace from both ends of the string.
   *
   * @private
   * @function module:util-x~$trim
   * @param {string} inputArg
   * @return {string}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim
   */
  $trim = exports.String.trim;

  /**
   * This function parses a string argument and returns an integer of the specified radix or base.
   *
   * @function module:util-x~exports.parseInt
   * @param {StringLike} inputArg
   * @param {number} radix
   * @return {number}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt
   */
  exports.parseInt = $decide(
    // test
    function () {
      $affirm.ok(!testShims, 'testing shim');

      var value;

      $affirm.doesNotThrow(function () {
        value = base.parseInt(wspaceStrings.trimString + '08' + wspaceStrings.trimString);
      }, 'test1');

      $affirm.strictEqual(value, 8, 'test2');

      $affirm.doesNotThrow(function () {
        value = base.parseInt(wspaceStrings.trimString + '0x16' + wspaceStrings.trimString);
      }, 'test3');

      $affirm.strictEqual(value, 22, 'test4');

      $affirm.doesNotThrow(function () {
        value = base.parseInt(wspaceStrings.trimString + '0x16' + wspaceStrings.trimString, 10);
      }, 'test5');

      $affirm.strictEqual(value, 0, 'test6');
    },

    // pass
    function () {
      return base.parseInt;
    },

    // fail
    function () {
      var mParseInt = base.parseInt,
        hexRx = new CRegExp('^0[xX]');

      return function (str, radix) {
        str = $trim(str);
        if (typeof radix === 'undefined' || !toInt32(radix)) {
          if ($test(hexRx, str)) {
            radix = 16;
          } else {
            radix = 10;
          }
        }

        if (radix === 10 && $test(hexRx, str)) {
          return 0;
        }

        return mParseInt(str, radix);
      };
    },

    // message
    'parseInt patch'
  );

  /**
   * Shortcut
   * This function parses a string argument and returns an integer of the specified radix or base.
   *
   * @private
   * @function module:util-x~$parseInt
   * @param {StringLike} inputArg
   * @param {number} radix
   * @return {number}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt
   */
  $parseInt = exports.parseInt;

  /**
   * This function parses a string argument and returns an integer of the specified radix or base.
   *
   * @function module:util-x~exports.Number.parseInt
   * @param {StringLike} inputArg
   * @param {number} radix
   * @return {number}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt
   */
  exports.Number.parseInt = $decide(
    // test
    function () {
      $affirmBasic(base.Number.parseInt)();

      var value;

      $affirm.doesNotThrow(function () {
        value = base.Number.parseInt(wspaceStrings.trimString + '08' + wspaceStrings.trimString);
      }, 'test1');

      $affirm.strictEqual(value, 8, 'test2');

      $affirm.doesNotThrow(function () {
        value = base.Number.parseInt(wspaceStrings.trimString + '0x16' + wspaceStrings.trimString);
      }, 'test3');

      $affirm.strictEqual(value, 22, 'test4');

      $affirm.doesNotThrow(function () {
        value = base.Number.parseInt(wspaceStrings.trimString + '0x16' + wspaceStrings.trimString, 10);
      }, 'test5');

      $affirm.strictEqual(value, 0, 'test6');
    },

    // pass
    function () {
      return base.Number.parseInt;
    },

    // fail
    function () {
      return function () {
        return $apply($parseInt, null, arguments);
      };
    },

    // message
    'Number.parseInt shim'
  );

  /**
   * This method parses a string argument and returns a floating point number.
   *
   * @function module:util-x~exports.parseFloat
   * @param {StringLike} inputArg
   * @return {number}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseFloat
   */
  exports.parseFloat = $decide(
    // test
    function () {
      $affirm.ok(!testShims, 'testing shim');
      var value;

      $affirm.doesNotThrow(function () {
        value = base.parseFloat(wspaceStrings.trimString + '123.45678' + wspaceStrings.trimString);
      }, 'test1');

      $affirm.strictEqual(value, 123.45678, 'test2');

      $affirm.doesNotThrow(function () {
        value = base.parseFloat(wspaceStrings.trimString + '0123.45678' + wspaceStrings.trimString);
      }, 'test3');

      $affirm.strictEqual(value, 123.45678, 'test4');

      $affirm.doesNotThrow(function () {
        value = base.parseFloat(wspaceStrings.trimString + '123.456780' + wspaceStrings.trimString);
      }, 'test5');

      $affirm.strictEqual(value, 123.45678, 'test6');
    },

    // pass
    function () {
      return base.parseFloat;
    },

    // fail
    function () {
      var mParseFloat = base.parseFloat;

      return function (str) {
        return mParseFloat($trim(str));
      };
    },

    // message
    'parseFloat patch'
  );

  // redefinition
  $parseFloat = exports.parseFloat;

  /**
   * This method parses a string argument and returns a floating point number.
   *
   * @function module:util-x~exports.Number.parseFloat
   * @param {StringLike} inputArg
   * @return {number}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseFloat
   */
  exports.Number.parseFloat = $decide(
    // test
    // test
    function () {
      $affirmBasic(base.parseFloat)();

      var value;

      $affirm.doesNotThrow(function () {
        value = base.parseFloat(wspaceStrings.trimString + '123.45678' + wspaceStrings.trimString);
      }, 'test1');

      $affirm.strictEqual(value, 123.45678, 'test2');

      $affirm.doesNotThrow(function () {
        value = base.parseFloat(wspaceStrings.trimString + '0123.45678' + wspaceStrings.trimString);
      }, 'test3');

      $affirm.strictEqual(value, 123.45678, 'test4');

      $affirm.doesNotThrow(function () {
        value = base.parseFloat(wspaceStrings.trimString + '123.456780' + wspaceStrings.trimString);
      }, 'test5');

      $affirm.strictEqual(value, 123.45678, 'test6');
    },

    // pass
    function () {
      return base.parseFloat;
    },

    // fail
    function () {
      return $parseFloat;
    },

    // message
    'Number.parseFloat shim'
  );

  /**
   * This method formats a number using fixed-point notation.
   *
   * @function module:util-x~exports.Number.toFixed
   * @this {number}
   * @param {number} fractionDigits
   * @return {string}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed
   */
  exports.Number.proto.toFixed = $decide(
    // test
    function () {
      $affirmBasic(base.Number.toFixed)();

      var value;

      $affirm.doesNotThrow(function () {
        value = $call(base.Number.toFixed, 0.00008, 3);
      }, 'test1');

      $affirm.strictEqual(value, '0.000', 'test2');

      $affirm.doesNotThrow(function () {
        value = $call(base.Number.toFixed, 0.9, 0);
      }, 'test3');

      $affirm.strictEqual(value, '1', 'test4');

      $affirm.doesNotThrow(function () {
        value = $call(base.Number.toFixed, 1.255, 2);
      }, 'test5');

      $affirm.strictEqual(value, '1.25', 'test6');

      $affirm.doesNotThrow(function () {
        value = $call(base.Number.toFixed, 1000000000000000128, 0);
      }, 'test7');

      $affirm.strictEqual(value, '1000000000000000128', 'test8');
    },

    // pass
    function () {
      return base.Number.toFixed;
    },

    // fail
    function () {
      var baseNum = 1e7,
        data = [0, 0, 0, 0, 0, 0],
        size = $toLength(data.length),
        last = size - 1;

      function multiply(n, c) {
        var index;

        for (index = 0; index < size; index += 1) {
          c += n * data[index];
          data[index] = c % baseNum;
          c = $floor(c / baseNum);
        }
      }

      function divide(n) {
        var c = 0,
          index;

        for (index = last; index >= 0; index -= 1) {
          c += data[index];
          data[index] = $floor(c / n);
          c = (c % n) * baseNum;
        }
      }

      function numToString() {
        var s = '',
          index,
          it;

        for (index = last; index >= 0; index -= 1) {
          it = data[index];
          if (s || !index || it) {
            it = $toString(it);
            if (!s) {
              s = it;
            } else {
              s += $sSlice('0000000', 0, 7 - it.length) + it;
            }
          }
        }

        return s;
      }

      function pow(x, n, acc) {
        if (n) {
          if (n % 2) {
            acc = pow(x, n - 1, acc * x);
          } else {
            acc = pow(x * x, n / 2, acc);
          }
        }

        return acc;
      }

      function log(x) {
        var n = 0;

        while (x >= 4096) {
          n += 12;
          x /= 4096;
        }

        while (x >= 2) {
          n += 1;
          x /= 2;
        }

        return n;
      }

      return function (fractionDigits) {
        var f,
          x,
          s,
          m,
          e,
          z,
          j,
          k;

        f = $toNumber(fractionDigits);
        // Test for NaN and round fractionDigits down
        if (f !== f) {
          f = 0;
        } else {
          f = $floor(f);
        }

        if (f < 0 || f > 20) {
          throw new CRangeError('Number.toFixed called with invalid number of decimals');
        }

        x = $toNumber(this);
        // Test for NaN or if it is too big or small, return the string value of the number.
        if (x !== x || x <= -1e21 || x >= 1e21) {
          return $toString(x);
        }

        s = '';
        if (x < 0) {
          s = '-';
          x = -x;
        }

        m = '0';
        if (x > 1e-21) {
          // 1e-21 < x < 1e21
          // -70 < log2(x) < 70
          e = log(x * pow(2, 69, 1)) - 69;
          if (e < 0) {
            z = x * pow(2, -e, 1);
          } else {
            z = x / pow(2, e, 1);
          }

          // Math.pow(2, 52)
          z *= 0x10000000000000;
          e = 52 - e;

          // -18 < e < 122
          // x = z / 2 ^ e
          if (e > 0) {
            multiply(0, z);
            j = f;
            while (j >= 7) {
              multiply(1e7, 0);
              j -= 7;
            }

            multiply(pow(10, j, 1), 0);
            j = e - 1;
            while (j >= 23) {
              /*jslint bitwise:true */
              divide(1 << 23);
              /*jslint bitwise:false */
              j -= 23;
            }

            /*jslint bitwise:true */
            divide(1 << j);
            /*jslint bitwise:false */
            multiply(1, 1);
            divide(2);
            m = numToString();
          } else {
            multiply(0, z);
            /*jslint bitwise:true */
            multiply(1 << (-e), 0);
            /*jslint bitwise:false */
            m = numToString() + $sSlice('0.00000000000000000000', 2, 2 + f);
          }
        }

        if (f > 0) {
          k = m.length;
          if (k <= f) {
            m = s + $sSlice('0.0000000000000000000', 0, f - k + 2) + m;
          } else {
            m = s + $sSlice(m, 0, k - f) + '.' + $sSlice(m, k - f);
          }
        } else {
          m = s + m;
        }

        return m;
      };
    },

    // message
    'Number.toFixed shim'
  );

  /**
   * This {@link module:util-x~boundPrototypalFunction method} formats a number using fixed-point notation.
   *
   * @function module:util-x~exports.Number.toFixed
   * @param {number} number The number to be formatted.
   * @param {number} fractionDigits
   * @return {string}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed
   */
  exports.Number.toFixed = $toMethod(exports.Number.proto.toFixed, $firstArg);

  /**
   * This method returns the first index at which a given element
   * can be found in the array, or -1 if it is not present.
   *
   * @memberOf exports.Array.proto
   * @name lastIndexOf
   * @function module:util-x~exports.Array.proto.lastIndexOf
   * @this {module:util-x~ArrayLike}
   * @throws {TypeError} If array is null or undefined
   * @param {Object} searchElement
   * @param {number} [fromIndex]
   * @return {number}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf
   */
  exports.Array.proto.lastIndexOf = $decide(
    // test
    function () {
      $affirmBasic(base.Array.lastIndexOf)();

      var value;

      $affirm.doesNotThrow(function () {
        value = $call(base.Array.lastIndexOf, [0, 1], 0, -3);
      }, 'test1');

      $affirm.strictEqual(value, -1, 'item not found');
    },

    // pass
    function () {
      return base.Array.lastIndexOf;
    },

    // fail
    function () {
      return function (searchElement, fromIndex) {
        var object = $toObject(this),
          length = $toLength(object.length),
          isString = length && $isString(object),
          val = -1,
          index;

        if (length) {
          if (arguments.length > 1) {
            fromIndex = $toInteger(fromIndex);
          } else {
            fromIndex = length - 1;
          }

          if (fromIndex >= 0) {
            fromIndex = $min(fromIndex, length - 1);
          } else {
            fromIndex = length - $abs(fromIndex);
          }

          for (index = fromIndex; index >= 0; index -= 1) {
            if ($hasItem(object, index, isString) && searchElement === $getItem(object, index, isString)) {
              val = index;
              break;
            }
          }
        }

        return val;
      };
    },

    // message
    'Array.lastIndexOf shim'
  );

  /**
   * This {@link module:util-x~boundPrototypalFunction method} returns the first index at which a given element
   * can be found in the array, or -1 if it is not present.
   *
   * @function module:util-x~exports.Array.lastIndexOf
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @param {Object} searchElement
   * @param {number} [fromIndex]
   * @return {number}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf
   */
  exports.Array.lastIndexOf = $toMethod(exports.Array.proto.lastIndexOf);

  /**
   * With this {@link module:util-x~boundPrototypalFunction method}, fill every element of array from start up
   * to but not including end is assigned value.
   *
   * @memberOf exports.Array.proto
   * @name fill
   * @function module:util-x~exports.Array.proto.fill
   * @this {module:util-x~ArrayLike}
   * @throws {TypeError} If array is null or undefined
   * @param {*} value
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill
   */
  exports.Array.proto.fill = $decide(
    // test
    $affirmBasic(base.Array.fill),

    // pass
    function () {
      return base.Array.fill;
    },

    // fail
    function () {
      return function (value, start, end) {
        var object = $toObject(this),
          length = $toLength(object.length),
          relativeStart = $toInteger(start),
          relativeEnd,
          finalEnd,
          index;

        if (start < 0) {
          relativeStart = $max(length + relativeStart, 0);
        } else {
          relativeStart = $min(relativeStart, length);
        }

        if (typeof end === 'undefined') {
          relativeEnd = length;
        } else {
          relativeEnd = $toInteger(end);
        }

        if (relativeEnd < 0) {
          finalEnd = $max(length + relativeEnd, 0);
        } else {
          finalEnd = $min(relativeEnd, length);
        }

        for (index = relativeStart; index < finalEnd; index += 1) {
          object[index] = value;
        }

        return object;
      };
    },

    // message
    'Array.fill shim'
  );

  /**
   * With this {@link module:util-x~boundPrototypalFunction method}, fill every element of array from start up
   * to but not including end is assigned value.
   *
   * @function module:util-x~exports.Array.fill
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @param {*} value
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill
   */
  exports.Array.fill = $toMethod(exports.Array.proto.fill);

  /**
   * With this {@link module:util-x~boundPrototypalFunction method}, every element of array from start up to but
   * not including end is assigned value.
   *
   * @memberOf exports.Array.proto
   * @name copyWithin
   * @function module:util-x~exports.Array.proto.copyWithin
   * @this {module:util-x~ArrayLike}
   * @throws {TypeError} If array is null or undefined
   * @param {number} target
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array}
   */
  exports.Array.proto.copyWithin = $decide(
    // test
    $affirmBasic(base.Array.copyWithin),

    // pass
    function () {
      return base.Array.copyWithin;
    },

    // fail
    function () {
      return function (target, start, end) {
        var object = $toObject(this),
          length = $toLength(object.length),
          relativeTarget = $toInteger(target),
          relativeStart = $toInteger(start),
          relativeEnd,
          to,
          from,
          finalEnd,
          count,
          direction,
          index;

        if (relativeTarget < 0) {
          to = $max(length + relativeTarget, 0);
        } else {
          to = $min(relativeTarget, length);
        }

        if (relativeStart < 0) {
          from = $max(length + relativeStart, 0);
        } else {
          from = $min(relativeStart, length);
        }

        if (typeof end === 'undefined') {
          relativeEnd = length;
        } else {
          relativeEnd = $toInteger(end);
        }

        if (relativeEnd < 0) {
          finalEnd = $max(length + relativeEnd, 0);
        } else {
          finalEnd = $min(relativeEnd, length);
        }

        count = $min(finalEnd - from, length - to);
        if (from < to && to < from + count) {
          direction = -1;
          from += count - 1;
          to += count - 1;
        } else {
          direction = 1;
        }

        for (index = count; index >= 1; index -= 1) {
          if ($call(pHasOwn, object, from)) {
            object[to] = object[from];
          } else {
            $deleteProperty(object, to);
          }

          from += direction;
          to += direction;
        }

        return object;
      };
    },

    // message
    'Array.copyWithin shim'
  );

  /**
   * With this {@link module:util-x~boundPrototypalFunction method}, every element of array from start up to but
   * not including end is assigned value.
   *
   * @function module:util-x~exports.Array.copyWithin
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @param {number} target
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array}
   */
  exports.Array.copyWithin = $toMethod(exports.Array.proto.copyWithin);

  /**
   * forKeys executes the callback function once for each own property present in the object until it finds one
   * where callback returns a true value.
   * If a thisArg parameter is provided to some, it will be passed to callback when invoked,
   * for use as its this value. Otherwise, the value undefined will be passed for use as its this value.
   *
   * @typedef {Function} module:util-x~forKeysCallback
   * @param {*} element The current property being processed in the object.
   * @param {prop} index The property name of the current property being processed in the object.
   * @param {Object} object The object that some was called upon.
   * @return {boolean}
   */

  /**
   * Executes a provided function once per object property and allows a some like break.
   *
   * @function module:util-x~exports.Object.proto.forKeys
   * @this {Object}
   * @throws {TypeError} If object is primitive
   * @param {module:util-x~forKeysCallback} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [thisArg]
   * @return {boolean}
   */
  exports.Object.proto.forKeys = function (fn, thisArg) {
    var object = $toObject(this),
      isString,
      keys,
      length,
      val,
      index,
      it,
      item;

    $throwIfNotFunction(fn);
    keys = $objectKeys(object);
    length = $toLength(keys.length);
    /*
    if (length) {
        thisArg = $toObjectCallFix(thisArg);
    }
    */

    isString = length && $isString(object);
    val = false;
    for (index = 0; index < length; index += 1) {
      it = keys[index];
      if (isString && $toString($toInteger(it)) === it && it >= 0 && it <= MAX_SAFE_INTEGER) {
        item = $getItem(object, it, true);
      } else {
        item = object[it];
      }

      val = !!$call(fn, thisArg, item, it, object);
      if (val) {
        break;
      }
    }

    return val;
  };

  /**
   * Executes a provided function once per object property and allows a some like break.
   *
   * @function module:util-x~exports.Object.forKeys
   * @param {Object} object
   * @throws {TypeError} If object is primitive
   * @param {module:util-x~forKeysCallback} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [thisArg]
   * @return {boolean}
   */
  exports.Object.forKeys = $toMethod(exports.Object.proto.forKeys);

  /**
   * Executes a provided function once per object property and allows a some like break.
   *
   * @private
   * @function module:util-x~$.forKeys
   * @param {Object} object
   * @throws {TypeError} If object is primitive
   * @param {module:util-x~forKeysCallback} fn
   * @throws {TypeError} If fn is not a function
   * @param {*} [thisArg]
   * @return {boolean}
   */
  $forKeys = exports.Object.forKeys;

  /**
   * @private
   * @function module:util-x~$isCircular
   * @param {*} inputArg
   * @return {boolean}
   */
  $isCircular = (function () {
    var isCirc,
      cb;

    cb = function (item) {
      return !$isPrimitive(item) && ($indexOf(this, item) !== -1 || isCirc(item, this));
    };

    isCirc = function (obj, arr) {
      if ($isPrimitive(obj)) {
        return false;
      }

      $push(arr, obj);

      return $forKeys(obj, cb, arr);
    };

    return function (inputArg) {
      return isCirc(inputArg, []);
    };
  }());

  /**
   * @function module:util-x~exports.Object.isCircular
   * @param {*} inputArg
   * @return {boolean}
   */
  exports.Object.isCircular = $isCircular;

  /**
   * Check to see if an object is empty (contains no enumerable properties).
   * Some gotchas to watch for, not all browsers agree on what properties are enumerable:
   * IE 6 to 9: Error: description, message
   * IE 10: Error: description
   * FF 3 to 5: Error: message, fileName, lineNumber, stack
   * FF 3 to 3.5: Function: prototype
   * Chrome 5 to 9: Error: message, stack
   * Chrome 10 to 13: Error: arguments, type, message, stack
   * V8 Error object has: captureStackTrace, stackTraceLimit
   * Opera 10 to 12 & next: Error: message
   * Opera 11.5: Function: prototype
   * Safari 4 to 6 & next: Error: message
   * There are most probably other native objects that do not agree: Object and Array should be fine in all
   * environments..
   *
   * @function module:util-x~exports.Object.isEmpty
   * @param {Object} inputArg
   * @return {boolean}
   */
  exports.Object.isEmpty = function (inputArg) {
    return !$objectKeys(inputArg).length;
  };

  /**
   * This method returns true if the string
   * only contains numerical digits.
   *
   * @function module:util-x~exports.String.proto.isDigits
   * @this {string}
   * @return {boolean}
   */
  exports.String.proto.isDigits = (function () {
    var notDigits = new CRegExp('^\\d+$');

    return function () {
      return $test(notDigits, $onlyCoercibleToString(this));
    };
  }());

  /**
   * This {@link module:util-x~boundPrototypalFunction method} returns true if the operand inputArg is a String and
   * only contains numerical digits.
   *
   * @function module:util-x~exports.String.isDigits
   * @param {*} string
   * @return {boolean}
   */
  exports.String.isDigits = $toMethod(exports.String.proto.isDigits);

  /**
   * This {@link module:util-x~boundPrototypalFunction method} returns true if the operand inputArg is a String and
   * only contains numerical digits.
   *
   * @private
   * @function module:util-x~exports.String.isDigits
   * @param {*} string
   * @return {boolean}
   */
  $isDigits = exports.String.isDigits;

  hasAccessorSupport = $call(pHasOwn, protoObject, stringDefineGetter);

  /**
   * Defines a new property directly on an object, or modifies an existing property on an object,
   * and returns the object.
   *
   * @private
   * @function module:util-x~$defProp
   * @param {Object} object
   * @param {string} property
   * @param {Object} descriptor
   * @return {Object}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty
   */
  $defProp = (function (mLookupGetter, mLookupSetter, mDefineGetter, mDefineSetter) {
    return function $defProp(object, property, descriptor) {
      $throwIfIsPrimitive(object);
      descriptor = $assign({}, $throwIfIsPrimitive(descriptor));

      var hasValue = $call(pHasOwn, descriptor, 'value'),
        hasGet = $call(pHasOwn, descriptor, 'get'),
        hasSet = $call(pHasOwn, descriptor, 'set'),
        prototype,
        isIdx;

      if (hasValue) {
        if (hasGet || hasSet) {
          throw new CTypeError('Invalid property. A property cannot have accessors and a value');
        }
      } else {
        if ($call(pHasOwn, object, property)) {
          descriptor.value = object[property];
        } else if (!hasGet && !hasSet) {
          descriptor.value = Undefined;
        }
      }

      // If it's a data property.
      if ($call(pHasOwn, descriptor, 'value')) {
        // fail silently if 'writable', 'enumerable', or 'configurable'
        // are requested but not supported
        /*
        // alternate approach:
        if ( // can't implement these features; allow false but not true
            ('writable' in descriptor && !descriptor.writable) ||
            ('enumerable' in descriptor && !descriptor.enumerable) ||
            ('configurable' in descriptor && !descriptor.configurable)
        ))
            throw new CRangeError(
                'This implementation of Object.defineProperty does not support configurable, enumerable, or writable.'
            );
        */

        if ($isArray(object) || $isArguments(object)) {
          property = $toString(property);
          if ($isDigits(property) && $getItem(property, 0, stringTagString) !== '0' && $isIndex($toNumber(property), MAX_UINT32 - 1)) {
            property = $toNumber(property);
            isIdx = true;
          }
        }

        if (!isIdx && (hasAccessorSupport && ($call(mLookupGetter, object, property) || $call(mLookupSetter, object, property)))) {
          // As accessors are supported only on engines implementing
          // `__proto__` we can safely override `__proto__` while defining
          // a property to make sure that we don't hit an inherited
          // accessor.
          prototype = object[stringProto];
          object[stringProto] = protoObject;
          // Deleting a property anyway since getter / setter may be
          // defined on object itself.
          $deleteProperty(object, property);
          object[property] = descriptor.value;
          // Setting original `__proto__` back now.
          object[stringProto] = prototype;
        } else {
          if (isIdx) {
            if (property >= $toLength(object.length)) {
              object.length = property + 1;
            }
          }

          object[property] = descriptor.value;
        }
      } else {
        if (!hasAccessorSupport) {
          throw new CTypeError('getters & setters can not be defined on this javascript engine');
        }

        // If we got that far then getters and setters can be defined !!
        if (hasGet) {
          $call(mDefineGetter, object, property, descriptor.get);
        }

        if (hasSet) {
          $call(mDefineSetter, object, property, descriptor.set);
        }
      }

      return object;
    };
  }(base.Object.lookupGetter, base.Object.lookupSetter, base.Object.defineGetter, base.Object.defineSetter));

  /**
   * Defines a new property directly on an object, or modifies an existing property on an object,
   * and returns the object.
   *
   * @function module:util-x~exports.Object.defineProperty
   * @param {Object} object
   * @param {string} property
   * @param {Object} descriptor
   * @return {Object}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty
   */
  exports.Object.defineProperty = (function () {
    return $decide(
      //test
      function () {
        $affirmBasic(base.Object.defineProperty)();
        $affirm.strictEqual(base.Object.defineProperty({}, 'sentinel', {
          value: null
        }).sentinel, null, 'test1');
      },

      // pass
      function () {
        return $decide(
          // test
          function () {
            // should not throw an error definining elements on arrays using trailing point numbers strings
            var testObj,
              testArr = [];

            $affirm.doesNotThrow(function () {
              testObj = base.Object.defineProperty([], '1.', {
                value: null
              });
            }, 'should not throw an error definining elements on arrays using trailing point numbers strings');

            $affirm.strictEqual(testObj.length, 0, 'test1');
            $affirm.strictEqual(testObj[1], Undefined, 'test2');
            $affirm.strictEqual(testObj['1.'], null, 'test3');

            // should not throw an error definining elements on arrays using integer strings
            $affirm.doesNotThrow(function () {
              testObj = base.Object.defineProperty([], '1', {
                value: Undefined
              });
            }, 'should not throw an error definining elements on arrays using integer strings');

            $affirm.strictEqual(testObj.length, 2, 'test4');
            $affirm.strictEqual(testObj[1], Undefined, 'test5');

            $affirm.doesNotThrow(function () {
              testObj = base.Object.defineProperty([], '1', {
                value: null
              });
            }, 'should not throw an error definining elements on arrays using integer strings');

            $affirm.strictEqual(testObj.length, 2, 'test6');
            $affirm.strictEqual(testObj[1], null, 'test7');

            $affirm.doesNotThrow(function () {
              testObj = base.Object.defineProperty([], '1', {});
            }, 'should not throw an error definining elements on arrays using integer strings');

            $affirm.strictEqual(testObj.length, 2, 'test8');
            $affirm.strictEqual(testObj[1], Undefined, 'test9');

            $affirm.doesNotThrow(function () {
              testObj = base.Object.defineProperty([], '1', {
                value: null
              });
            }, 'should not throw an error definining elements on arrays using integer strings');

            $affirm.strictEqual(testObj.length, 2, 'test10');
            $affirm.strictEqual(testObj[1], null, 'test11');

            // Test overwrite array properties when no value defined, no value change
            $affirm.doesNotThrow(function () {
              testObj = base.Object.defineProperty([10, 20], '1', {});
            }, 'Test overwrite array properties when no value defined, no value change');

            $affirm.strictEqual(testObj.length, 2, 'test12');
            $affirm.strictEqual(testObj[1], 20, 'test13');

            // should not throw an error redefinining elements on arrays
            $affirm.doesNotThrow(function () {
              testObj = base.Object.defineProperty([10], '0', {
                enumerable: true,
                writable: true,
                configurable: true
              });
            }, 'should not throw an error redefinining elements on arrays');

            $affirm.strictEqual(testObj.length, 1, 'length after re-define');
            $affirm.strictEqual(testObj[0], 10, 'value after re-define');

            // should not throw an error definining elements/properties on arrays
            testArr = [];
            $affirm.doesNotThrow(function () {
              base.Object.defineProperty(testArr, '0', {
                value: 10,
                enumerable: true,
                writable: true,
                configurable: true
              });
            }, 'should not throw an error definining elements on arrays');

            $affirm.doesNotThrow(function () {
              base.Object.defineProperty(testArr, '1', {
                value: true,
                enumerable: true,
                writable: true,
                configurable: true
              });
            }, 'should not throw an error definining elements on arrays');

            $affirm.doesNotThrow(function () {
              base.Object.defineProperty(testArr, '2', {
                value: 'x',
                enumerable: true,
                writable: true,
                configurable: true
              });
            }, 'should not throw an error definining elements on arrays');

            $affirm.doesNotThrow(function () {
              base.Object.defineProperty(testArr, 'foo', {
                value: noop,
                enumerable: true,
                writable: true,
                configurable: true
              });
            }, 'should not throw an error definining properties on arrays');

            $affirm.strictEqual(testArr.length, 3, 'length after define');
            $affirm.strictEqual(testArr[0], 10, 'first value');
            $affirm.strictEqual(testArr[1], true, 'second value');
            $affirm.strictEqual(testArr[2], 'x', 'third value');
            $affirm.strictEqual(testArr.foo, noop, 'fourth value');

            //should not throw an error definining elements on arrays using float numbers
            testObj = base.Object.defineProperty([], 1.1, {
              enumerable: true,
              writable: true,
              configurable: true
            });

            $affirm.ok($call(pHasOwn, testObj, 1.1), 'have own property');
            $affirm.strictEqual(testObj.length, 0, 'be zero length');
            $affirm.strictEqual(testObj[1.1], Undefined, 'value should be undefined');
          },

          // pass
          function () {
            return base.Object.defineProperty;
          },

          // fail
          function () {
            var mDefineProperty = base.Object.defineProperty;

            return function (object, property, descriptor) {
              if ($isArray(object) || $isArguments(object)) {
                property = $toString(property);
                if (($isDigits(property) && $getItem(property, 0, stringTagString) !== '0' && $isIndex($toNumber(property), MAX_UINT32 - 1)) || $isNumeric(property)) {
                  return $defProp(object, property, descriptor);
                }
              }

              return mDefineProperty(object, property, descriptor);
            };
          },

          // message
          'Object.defineProperty patch'
        );
      },

      // fail
      function () {
        return $defProp;
      },

      //message
      'Object.defineProperty sham'
    );
  }());

  /**
   * Defines a new property directly on an object, or modifies an existing property on an object,
   * and returns the object.
   *
   * @private
   * @function module:util-x~$defineProperty
   * @param {Object} object
   * @param {string} property
   * @param {Object} descriptor
   * @return {Object}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty
   */
  $defineProperty = exports.Object.defineProperty;

  /**
   * Defines new or modifies existing properties directly on an object, returning the object.
   *
   * @function module:util-x~exports.Object.defineProperties
   * @param {Object} object
   * @param {Object} props
   * @return {Object}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties
   */
  exports.Object.defineProperties = (function () {
    var mDefineProperties = base.Object.defineProperties;

    /**
     * @private
     * @function module:util-x~throwString
     * @param {Object} props
     * @throws If props is a string
     * @return {Object}
     */
    function throwString(props) {
      if ($isString(props)) {
        throw new CTypeError('Property description must be an object: ' + $toString(props));
      }

      return props;
    }

    return $decide(
      // test
      function () {
        $affirmBasic(mDefineProperties)();
        $affirm.strictEqual($defineProperty, base.Object.defineProperty, 'defineProperty was patched or shimmed');
      },

      // pass
      function () {
        return $decide(
          // test
          function () {
            $affirm.throws(function () {
              mDefineProperties({});
            }, CTypeError, 'no properties argument');

            $affirm.throws(function () {
              mDefineProperties({}, Undefined);
            }, CTypeError, 'properties undefined');

            $affirm.throws(function () {
              mDefineProperties({}, null);
            }, CTypeError, 'properties null');

            $affirm.doesNotThrow(function () {
              mDefineProperties({}, true);
            }, 'boolean');

            $affirm.doesNotThrow(function () {
              mDefineProperties({}, 1);
            }, 'properties number');

            $affirm.throws(function () {
              mDefineProperties({}, 'a');
            }, CTypeError, 'properties string');
          },

          // pass
          function () {
            return mDefineProperties;
          },

          // fail
          function () {
            return function (object, props) {
              return mDefineProperties($throwIfIsPrimitive(object), throwString($toObject(props)));
            };
          },

          // message
          'Object.defineProperties patch'
        );
      },

      // fail
      function () {
        return function (object, props) {
          $throwIfIsPrimitive(object);
          props = throwString($toObject(props));

          var keys = $objectKeys(props),
            length = $toLength(keys.length),
            key,
            index;

          for (index = 0; index < length; index += 1) {
            key = keys[index];
            $defineProperty(object, key, props[key]);
          }

          return object;
        };
      },

      // message
      'Object.defineProperties using Object.defineProperty'
    );
  }());

  /**
   * Defines new or modifies existing properties directly on an object, returning the object.
   *
   * @private
   * @function module:util-x~$defineProperties
   * @param {Object} object
   * @param {Object} props
   * @return {Object}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties
   */
  $defineProperties = exports.Object.defineProperties;

  /**
   * Freezes an object: that is, prevents new properties from being added to it; prevents existing properties
   * from being removed; and prevents existing properties, or their enumerability, configurability, or
   * writability, from being changed.
   * In essence the object is made effectively immutable. Returns the object being frozen.
   *
   * @function module:util-x~exports.Object.freeze
   * @param {Object} object
   * @return {Object}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
   */
  exports.Object.freeze = $decide(
    // test
    $affirmBasic(base.Object.freeze),

    // pass
    function () {
      return base.Object.freeze;
    },

    // fail
    function () {
      return function (object) {
        return $throwIfIsPrimitive(object);
      };
    },

    // message
    'Object.freeze sham'
  );

  // detect a Rhino bug and patch it
  exports.Object.freeze = $decide(
    // test
    function () {
      $affirm.doesNotThrow(function () {
        exports.Object.freeze({
          noop: noop
        });
      }, 'does not throw an error in Rhino');
    },

    // pass
    function () {
      return exports.Object.freeze;
    },

    // fail
    function () {
      var freezeObject = exports.Object.freeze;

      return function (object) {
        var val;

        if ($isFunction(object)) {
          val = object;
        } else {
          val = freezeObject(object);
        }

        return val;
      };
    },

    // message
    'Object.freeze Rhino bug patch'
  );

  /**
   * Determine if an object is frozen.
   *
   * @function module:util-x~exports.Object.isFrozen
   * @param {Object} object
   * @return {boolean}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
   */
  exports.Object.isFrozen = $decide(
    // test
    $affirmBasic(base.Object.isFrozen),

    // pass
    function () {
      return base.Object.isFrozen;
    },

    // fail
    function () {
      return function (object) {
        $throwIfIsPrimitive(object);

        return false;
      };
    },

    //  message
    'Object.isFrozen sham'
  );

  /**
   * To make object fully immutable, freeze each object in object.
   *
   * @function module:util-x~exports.Object.deepFreeze
   * @param {Object} object
   * @return {Object}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
   */
  exports.Object.deepFreeze = function (object) {
    var propKey,
      propVal;

    exports.Object.freeze(object);
    for (propKey in object) {
      /*jslint forin: false*/
      propVal = $getItem(object, propKey, $isString(object));
      if (!$isPrimitive(propVal) && !exports.Object.isFrozen(propVal)) {
        exports.Object.deepFreeze(propVal);
      }
      /*jslint forin: true*/
    }

    return object;
  };

  /**
   * The assign function is used to copy the values of all of the enumerable own properties from a
   * source object to a target object.
   *
   * @function module:util-x~exports.Object.assign
   * @param {Object} target
   * @param {...Object} source
   * @return {Object}
   * @see https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign
   */
  exports.Object.assign = $decide(
    // test
    $affirmBasic(base.Object.assign),

    // pass
    function () {
      return base.Object.assign;
    },

    // fail
    function () {
      return function (target) {
        var to = $toObject(target),
          length = $toLength(arguments.length),
          isString,
          from,
          index,
          keysArray,
          len,
          nextIndex,
          nextKey,
          arg;

        if (length >= 2) {
          for (index = 1; index < length; index += 1) {
            arg = arguments[index];
            /*jslint eqeq:true */
            /*jshint eqnull:true */
            if (arg != null) {
              from = $toObject(arg);
              keysArray = $objectKeys(from);
              len = $toLength(keysArray.length);
              for (nextIndex = 0; nextIndex < len; nextIndex += 1) {
                nextKey = keysArray[nextIndex];
                isString = $isString(from);
                if ($hasItem(from, nextKey, isString)) {
                  to[nextKey] = $getItem(from, nextKey, isString);
                }
              }
            }
          }
        }

        return to;
      };
    },

    // message
    'Object.assign shim'
  );

  /**
   * The assign function is used to copy the values of all of the enumerable own properties from a
   * source object to a target object.
   *
   * @private
   * @function module:util-x~$assign
   * @param {Object} target
   * @param {...Object} source
   * @return {Object}
   * @see https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign
   */
  $assign = exports.Object.assign;

  /**
   * This method creates a new object with the specified prototype object and properties.
   *
   * @function module:util-x~exports.Object.create
   * @param {Prototype} prototype
   * @return {Object}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
   */
  exports.Object.create = $decide(
    // test
    function () {
      $affirmBasic(base.Object.create)();

      /**
       * @private
       * @constructor module:util-x~createFn
       */
      function createFn() {
        return;
      }

      var created = base.Object.create(createFn.prototype, {
        /**
         * @private
         * @constructor module:util-x~createFn.prototype.constructor
         */
        constructor: $assign({
          value: createFn
        }, propNotEnumerable),

        /**
         * @private
         * @name module:util-x~createFn.prototype.foo
         * type {?string}
         */
        foo: $assign({
          value: 'test'
        }, propNotEnumerable)
      });

      $affirm.strictEqual(created.foo, 'test', 'test1');
    },

    //pass
    function () {
      return base.Object.create;
    },

    // fail
    function () {
      /**
       * The constructor used by {@link module:util-x~exports.Object.create} if shimmed.
       *
       * @private
       * @constructor ObjectCreateFunc
       */
      function ObjectCreateFunc() {
        return;
      }

      return function (prototype, propertiesObject) {
        ObjectCreateFunc.prototype = $throwIfIsPrimitive(prototype);

        var newObject = new ObjectCreateFunc();

        $defineProperty(newObject, stringProto, $assign({
          value: prototype
        }, propNotEnumerable));

        if ($isPlainObject(propertiesObject)) {
          $defineProperties(newObject, propertiesObject);
        }

        return newObject;
      };
    },

    // message
    'Object.create shim'
  );

  /**
   * This method creates a new object with the specified prototype object and properties.
   *
   * @private
   * @function module:util-x~$create
   * @param {Prototype} prototype
   * @return {Object}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
   */
  $create = exports.Object.create;

  /**
   * This method returns true if the Date object is valid.
   *
   * @function module:util-x~exports.Date.proto.isValid
   * @this {Date}
   * @return {boolean}
   */
  exports.Date.proto.isValid = (function (pGetTime) {
    return function () {
      if (!$isDate(this)) {
        throw new CTypeError('this is not a Date object.');
      }

      var ms = $call(pGetTime, this);

      return ms === ms;
    };
  }(base.Date.getTime));

  /**
   * This {@link module:util-x~boundPrototypalFunction method} returns true if the operand inputArg is a Date object and is valid.
   *
   * @function module:util-x~exports.Date.isValid
   * @param {*} dateObject
   * @return {boolean}
   */
  exports.Date.isValid = $toMethod(exports.Date.proto.isValid);

  /**
   * This method returns the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC.
   *
   * @function module:util-x~exports.Date.now
   * @return {number}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now
   */
  exports.Date.now = $decide(
    // test
    $affirmBasic(base.Date.now),

    // pass
    function () {
      return base.Date.now;
    },

    // fail
    function () {
      var pGetTime = base.Date.getTime;

      return function now() {
        return $call(pGetTime, new CDate());
      };
    },

    // message
    'Date.now shim'
  );

  /**
   * This method wraps the string within the given character.
   *
   * @function module:util-x~exports.String.proto.wrapInChars
   * @this {string}
   * @param {string} character
   * @return {string}
   */
  exports.String.proto.wrapInChars = function (characters) {
    if (!$isString(characters) && !$isNumber(characters)) {
      characters = '';
    } else {
      characters = $toString(characters);
    }

    return characters + $onlyCoercibleToString(this) + characters;
  };

  /**
   * This {@link module:util-x~boundPrototypalFunction method} wraps a string within the given character.
   *
   * @function module:util-x~exports.String.wrapInChars
   * @param {string} string
   * @param {string} character
   * @return {string}
   */
  exports.String.wrapInChars = $toMethod(exports.String.proto.wrapInChars);

  /**
   * This method truncates a long string to the length specified by n;
   * used by AssertionError.toString
   *
   * @function module:util-x~exports.String.proto.truncate
   * @this {string}
   * @param {module:util-x~NumberLike} n
   * @return {string}
   */
  exports.String.proto.truncate = function (n) {
    var s = $onlyCoercibleToString(this);

    n = $toNumber(n);
    if (n === n && n >= 0 && s.length > n) {
      s = $sSlice(s, 0, n);
    }

    return s;
  };

  /**
   * This {@link module:util-x~boundPrototypalFunction method} truncates a long string to the length specified by n;
   * used by AssertionError.toString
   *
   * @function module:util-x~exports.String.truncate
   * @param {string} s
   * @param {module:util-x~NumberLike} n
   * @return {string}
   */
  exports.String.truncate = $toMethod(exports.String.proto.truncate);

  /**
   * This {@link module:util-x~boundPrototypalFunction method} truncates a long string to the length specified by n;
   * used by AssertionError.toString
   *
   * @private
   * @function module:util-x~$truncate
   * @param {string} s
   * @param {module:util-x~NumberLike} n
   * @return {string}
   */
  $truncate = exports.String.truncate;

  /**
   * This method inherits the prototype methods from one constructor into another.
   *
   * @function module:util-x~exports.Function.proto.inherits
   * @this {Function}
   * @param {Function} superCtor
   * @return {undefined}
   */
  exports.Function.proto.inherits = function (superCtor) {
    $throwIfNotFunction(this);
    $throwIfNotFunction(superCtor);

    $defineProperty(this, 'superCtor', $assign({
      value: superCtor
    }, propConstant));

    this.prototype = $create(superCtor.prototype);
    $defineProperty(this.prototype, 'constructor', $assign({
      value: this
    }, propNotEnumerable));
  };

  /**
   * This {@link module:util-x~boundPrototypalFunction method} inherits the prototype methods from one constructor into another.
   *
   * @function module:util-x~exports.Function.inherits
   * @param {Function} ctor
   * @param {Function} superCtor
   * @return {undefined}
   */
  exports.Function.inherits = $toMethod(exports.Function.proto.inherits);

  /**
   * This {@link module:util-x~boundPrototypalFunction method} inherits the prototype methods from one constructor into another.
   *
   * @private
   * @function module:util-x~$inherits
   * @param {Function} ctor
   * @param {Function} superCtor
   * @return {undefined}
   */
  $inherits = exports.Function.inherits;

  /**
   * Tests to see if the argument is one of the seven standard Error type constructors.
   *
   * @function module:util-x~exports.Error.isErrorTypeConstructor
   * @param {*} inputArg
   * @return {boolean}
   */
  exports.Error.isErrorTypeConstructor = function (inputArg) {
    var result;

    switch (inputArg) {
    case CError:
      /* falls through */
    case CTypeError:
      /* falls through */
    case CSyntaxError:
      /* falls through */
    case CRangeError:
      /* falls through */
    case CEvalError:
      /* falls through */
    case CReferenceError:
      /* falls through */
    case CURIError:
      result = true;
      break;
    default:
      result = false;
    }

    return result;
  };

  /**
   * Tests to see if the argument is one of the seven standard Error type constructors.
   *
   * @private
   * @function module:util-x~$isErrorTypeConstructor
   * @param {*} inputArg
   * @return {boolean}
   */
  $isErrorTypeConstructor = exports.Error.isErrorTypeConstructor;

  /**
   * Custom replacer used to help stringify error messages.
   *
   * @function module:util-x~exports.customErrorReplacer
   * @param {string} key Unused
   * @param {*} value
   * @return {string}
   */
  exports.customErrorReplacer = function () {
    var value = arguments[1],
      type = typeof value,
      result;

    if (type === 'string') {
      result = value;
    } else if (type === 'undefined' ||
        value === INFINITY ||
        value === NEGATIVE_INFINITY ||
        exports.Number.isNaN(value) ||
        $isFunction(value) ||
        $isRegExp(value)) {

      result = $toString(value);
    } else {
      result = value;
    }

    return result;
  };

  // Error closure
  (function () {
    var patchedIEErrorToString = false,
      previousIEErrorToString;

    /**
     * Pathces IE6 & 7 Error.prototype.toString to make it function as expected in all other browsers.
     * This is an obtrusive fix.
     *
     * @function module:util-x~exports.normaliseErrorIEToStringOn
     * @return {boolean}
     */
    exports.normaliseErrorIEToStringOn = function () {
      var message = 'Should we patch IE6&7?';

      try {
        throw new CError(message);
      } catch (ePatch) {
        if (ePatch.message === message && ePatch.toString() === stringTagError) {
          previousIEErrorToString = protoError.toString;
          $defineProperties(protoError, {
            toString: $assign({
              value: function () {
                return this.name + ': ' + this.message;
              }
            }, propNotEnumerable)
          });

          patchedIEErrorToString = true;
        }
      }

      return patchedIEErrorToString;
    };

    /**
     * Pathces IE6 & 7 Error.prototype.toString to make it function as expected in all other browsers.
     * This is an obtrusive fix.
     *
     * @function module:util-x~exports.normaliseErrorIEToStringOff
     * @return {boolean}
     */
    exports.normaliseErrorIEToStringOff = function () {
      if (patchedIEErrorToString) {
        $defineProperties(protoError, {
          toString: $assign({
            value: previousIEErrorToString
          }, propNotEnumerable)
        });

        previousIEErrorToString = null;
        patchedIEErrorToString = false;
      }

      return patchedIEErrorToString;
    };

    /**
     * Pathces IE6 & 7 Error.prototype.toString to make it function as expected in all other browsers.
     * This is an obtrusive fix.
     *
     * @function module:util-x~exports.normaliseErrorIEToStringState
     * @return {boolean}
     */
    exports.normaliseErrorIEToStringState = function () {
      return patchedIEErrorToString;
    };
  }());

  /**
   * Creates a custom Error. If and invalid ErrorConstructor is provided it will default to Error.
   * If a valid native Error type constructor is provided but not supporte by the browesr the it will
   * also default to Error. (Looking at you IE < 9)
   *
   * @function module:util-x~exports.customError
   * @param {string} name
   * @param {Function} [ErrorConstructor] Does not work with IE < 9, only Error can be used (defult: Error)
   * @param {module:util-x~NumberLike} [maxMessageLength] Range 64 to INFINITY (128 default)
   * @return {Function}
   */
  exports.customError = (function () {
    var splitNewLine = new CRegExp('\\r\\n|\\n'),
      isOkToUseOtherErrors,
      Custom;

    /**
     * Creates a custom Error constructor.
     *
     * @private
     * @function makeCustomError
     * @param {string} name
     * @param {Function} ErrorConstructor Does not work with IE < 9, only Error can be used
     * @param {module:util-x~NumberLike} [maxMessageLength] Range 64 to INFINITY (128 default)
     * @return {Function}
     */
    function makeCustomError(name, ErrorConstructor, maxMessageLength) {
      var CustomError;

      if (typeof name !== 'string' || name === '') {
        throw new CTypeError('"name" was not a valid string: ' + $toString(name));
      }

      if (!$isErrorTypeConstructor(ErrorConstructor)) {
        throw new CTypeError('"ErrorConstructor" was not an Error type');
      }

      maxMessageLength = +maxMessageLength;
      if (maxMessageLength !== maxMessageLength || maxMessageLength < 64) {
        maxMessageLength = 128;
      }

      /**
       * @private
       * @constructor makeCustomError
       * @augments ErrorConstructor
       */
      CustomError = function (message, stackStartFn) {
        var err;

        if (typeof message !== 'string') {
          message = $truncate($stringify(message, exports.customErrorReplacer), maxMessageLength);
        }

        $defineProperty(this, 'message', $assign({
          value: message
        }, propNotEnumerable));

        if (!$isFunction(stackStartFn)) {
          stackStartFn = CustomError;
        }

        this.stackStartFn = stackStartFn;
        if ($isFunction(ErrorConstructor.captureStackTrace)) {
          ErrorConstructor.captureStackTrace(this, this.stackStartFn);
        } else {
          err = $call(ErrorConstructor, this);
          if (typeof err.stack === 'string') {
            $defineProperty(this, 'stack', $assign({
              value: err.stack
            }, propNotEnumerable));
          } else if (typeof err.stacktrace === 'string') {
            $defineProperty(this, 'stack', $assign({
              value: err.stacktrace
            }, propNotEnumerable));
          }
        }
      };

      $inherits(CustomError, ErrorConstructor);

      $defineProperties(CustomError.prototype, {
        /**
         * @private
         * @name CustomError.prototype.name
         * @type {string}
         */
        name: $assign({
          value: name
        }, propNotEnumerable),

        /**
         * @private
         * @function CustomError.prototype.toString
         */
        toString: $assign({
          value: function () {
            var arr = $split(this.message, splitNewLine),
              messageToString = this.name + ': ',
              length = $toLength(arr.length),
              tempArr,
              element,
              index;

            if (length > 1) {
              tempArr = [];
              for (index = 0; index < length; index += 1) {
                element = arr[index];
                if (!$stringContains(element, 'opera:config#UserPrefs|Exceptions Have Stacktrace')) {
                  $push(tempArr, element);
                }
              }

              messageToString += $join(tempArr, '\n');
            } else {
              messageToString += this.message;
            }

            return messageToString;
          }
        }, propNotEnumerable)
      });

      return CustomError;
    }

    try {
      Custom = makeCustomError('CustomSyntaxError', CSyntaxError);
      isOkToUseOtherErrors = $instanceOf(new Custom('test'), CSyntaxError);
    } catch (eCSE) {
      // IE < 9
      isOkToUseOtherErrors = false;
    }

    return function (name, ErrorConstructor, maxMessageLength) {
      if (typeof name !== 'string') {
        throw new CTypeError('"name" was not a string: ' + $toString(name));
      }

      if (name === '') {
        throw new CSyntaxError('"name" was an empty string');
      }

      if (typeof maxMessageLength === 'undefined') {
        var type = typeof ErrorConstructor;

        if (type === 'number' || type === 'string') {
          maxMessageLength = ErrorConstructor;
          ErrorConstructor = CError;
        }
      }

      if (!isOkToUseOtherErrors || !$isErrorTypeConstructor(ErrorConstructor)) {
        ErrorConstructor = CError;
      }

      return makeCustomError(name, ErrorConstructor, maxMessageLength);
    };
  }());

  /**
   * Swap places of 2 item values on an object's properties.
   *
   * @function module:util-x~exports.Object.swapItems
   * @param {Object} object
   * @param {module:util-x~NumberLike} prop1
   * @param {module:util-x~NumberLike} prop2
   * @return {Object}
   */
  exports.Object.swapItems = function (object, prop1, prop2) {
    $throwIfIsPrimitive(object);
    prop1 = $toString(prop1);
    prop2 = $toString(prop2);

    var temp1,
      temp2,
      num,
      cond1,
      cond2,
      len1,
      len2;

    if (prop1 !== prop2) {
      temp1 = exports.Object.getOwnPropertyDescriptor(object, prop1) || {};
      temp2 = exports.Object.getOwnPropertyDescriptor(object, prop2) || {};
      num = $toLength(prop2);
      cond1 = $hasOwnValidLength(object) && !$isFunction(object) && $toString(num) === prop2;
      if (!$isPlainObject(temp1) || !$call(pHasOwn, temp1, 'value')) {
        if (cond1) {
          len1 = $toLength(object.length) - 1;
          if (num === len1) {
            object.length = len1;
          }
        }

        $deleteProperty(object, prop2);
      } else {
        if (cond1) {
          len1 = $toLength(object.length);
          if (num === len1) {
            object.length = len1 + 1;
          }
        }

        $defineProperty(object, prop2, temp1);
      }

      num = $toLength(prop1);
      cond2 = $hasOwnValidLength(object) && !$isFunction(object) && $toString(num) === prop1;
      if (!$isPlainObject(temp2) || !$call(pHasOwn, temp2, 'value')) {
        if (cond2) {
          len2 = $toLength(object.length) - 1;
          if (num === len2) {
            object.length = len2;
          }
        }

        $deleteProperty(object, prop1);
      } else {
        $defineProperty(object, prop1, temp2);
        if (cond2) {
          len2 = $toLength(object.length);
          if (num === len2) {
            object.length = len2 + 1;
          }
        }

        $defineProperty(object, prop1, temp2);
      }
    }

    return object;
  };

  /**
   * This method performs Fisher-Yates shuffle for randomly shuffling a set.
   *
   * @function module:util-x~exports.Array.proto.shuffle
   * @this {module:util-x~ArrayLike}
   * @throws {TypeError} If array is null or undefined
   * @param {module:util-x~NumberLike} [rounds]
   * @return {Array}
   * @see http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
   */
  exports.Array.proto.shuffle = function (rounds) {
    var object = $toObject(this),
      isString,
      inLen,
      outLen,
      inIndex,
      outIndex,
      rand,
      tempVal,
      hasItem;

    if ($hasOwnValidLength(object) && !$isFunction(object)) {
      inLen = $toLength(object.length);
      isString = $isString(object);
      if (isString) {
        tempVal = {};
        for (inIndex = 0; inIndex < inLen; inIndex += 1) {
          tempVal[inIndex] = $getItem(object, inIndex, true);
        }

        object = tempVal;
      }

      object.length = inLen;
      if (inLen > 1) {
        outLen = $min($max($toInteger(rounds), 1), MAX_SAFE_INTEGER);
        for (outIndex = 0; outIndex < outLen; outIndex += 1) {
          for (inIndex = 0; inIndex < inLen; inIndex += 1) {
            rand = $randomInt(inIndex);
            hasItem = $call(pHasOwn, object, inIndex);
            tempVal = object[inIndex];
            if ($call(pHasOwn, object, rand)) {
              object[inIndex] = object[rand];
            } else {
              $deleteProperty(object, inIndex);
            }

            if (hasItem) {
              object[rand] = tempVal;
            } else {
              $deleteProperty(object, rand);
            }
          }
        }
      }

      if (isString) {
        tempVal = '';
        for (inIndex = 0; inIndex < inLen; inIndex += 1) {
          tempVal += object[inIndex];
        }

        object = $toObject(tempVal);
      }
    }

    return object;
  };

  /**
   * This {@link module:util-x~boundPrototypalFunction method} performs Fisher-Yates shuffle for randomly shuffling a set.
   *
   * @function module:util-x~exports.Array.shuffle
   * @param {module:util-x~ArrayLike} array
   * @throws {TypeError} If array is null or undefined
   * @param {module:util-x~NumberLike} [rounds]
   * @return {Array}
   * @see http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
   */
  exports.Array.shuffle = $toMethod(exports.Array.proto.shuffle);

  /**
   *  This function returns an ISO 8601 representation of the instance in time
   *  represented by this Date object.
   *
   * @function module:util-x~exports.Date.proto.toISOString
   * @this {Date}
   * @throws {RangeError} If not a valid date.
   * @return {string} An ISO 8601 representation of the date.
   */
  exports.Date.proto.toISOString = $decide(
    // test
    function () {
      $affirmBasic(base.Date.toISOString)();

      $affirm.throws(function () {
        $call(base.Date.toISOString, null);
      }, CTypeError, 'Throws if not date object');

      $affirm.throws(function () {
        $call(base.Date.toISOString, new CDate(MAX_VALUE));
      }, CRangeError, 'Throws on invalid date');

      var value;

      $affirm.doesNotThrow(function () {
        value = $call(base.Date.toISOString, new CDate(-8.64e15));
      }, 'test1');

      // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
      // serialize extended years.
      $affirm.strictEqual(value, '-271821-04-20T00:00:00.000Z', 'test2');

      $affirm.doesNotThrow(function () {
        value = $call(base.Date.toISOString, new CDate(8.64e15));
      }, 'test3');

      // The milliseconds are optional in ES 5, but required in 5.1.
      $affirm.strictEqual(value, '+275760-09-13T00:00:00.000Z', 'test4');

      $affirm.doesNotThrow(function () {
        value = $call(base.Date.toISOString, new CDate(-621987552e5));
      }, 'test5');

      // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
      // four-digit years instead of six-digit years. Credits: @Yaffle.
      $affirm.strictEqual(value, '-000001-01-01T00:00:00.000Z', 'test6');

      $affirm.doesNotThrow(function () {
        value = $call(base.Date.toISOString, new CDate(-1));
      }, 'test7');

      // Safari <= 5.1.7 and Opera >= 10.53 incorrectly serialize millisecond
      // values less than 1000. Credits: @Yaffle.
      $affirm.strictEqual(value, '1969-12-31T23:59:59.999Z', 'test8');
    },

    // pass
    function () {
      return base.Date.toISOString;
    },

    // fail
    function () {
      var pGetUTCFullYear = base.Date.proto.getUTCFullYear,
        pGetUTCMonth = base.Date.proto.getUTCMonth,
        pGetUTCDate = base.Date.proto.getUTCDate,
        pGetUTCHours = base.Date.proto.getUTCHours,
        pGetUTCMinutes = base.Date.proto.getUTCMinutes,
        pGetUTCSeconds = base.Date.proto.getUTCSeconds,
        pGetUTCMilliseconds = base.Date.proto.getUTCMilliseconds;

      return function () {
        if (!exports.Date.isDate(this)) {
          throw new CTypeError('this is not a Date object.');
        }

        if (!exports.Date.isValid(this)) {
          throw new CRangeError('Invalid time value');
        }

        var result,
          index,
          length,
          value,
          year,
          month,
          date,
          time,
          sign;

        year = $call(pGetUTCFullYear, this);
        month = $call(pGetUTCMonth, this);
        year += $floor(month / 12);
        month = (month % 12 + 12) % 12;

        result = [
          month + 1,
          $call(pGetUTCDate, this),
          $call(pGetUTCHours, this),
          $call(pGetUTCMinutes, this),
          $call(pGetUTCSeconds, this)
        ];

        if (year < 0) {
          sign = '-';
        } else if (year > 9999) {
          sign = '+';
        } else {
          sign = '';
        }

        if (0 <= year && year <= 9999) {
          length = -4;
        } else {
          length = -6;
        }

        year = sign + $sSlice('00000' + $abs(year), length);
        length = $toLength(result.length);
        for (index = 0; index < length; index += 1) {
          value = result[index];
          if (value < 10) {
            result[index] = '0' + value;
          }
        }

        // pad milliseconds to have three digits.
        date = year + '-' + $join($slice(result, 0, 2), '-');
        time = $join($slice(result, 2), ':') + '.' + $sSlice('000' + $call(pGetUTCMilliseconds, this), -3);

        return date + 'T' + time + 'Z';
      };
    },

    // message
    'Date.toISOString shim'
  );

  /**
   *  This function returns an ISO 8601 representation of the instance in time
   *  represented by this Date object.
   *
   * @function module:util-x~exports.Date.toISOString
   * @param {Date} date A Javascript Date object.
   * @throws {RangeError} If not a valid date.
   * @return {string} An ISO 8601 representation of the date.
   */
  exports.Date.toISOString = $toMethod(exports.Date.proto.toISOString);

  /**
   * Create date object with .toISOString and .toJSON methods attached.
   * Used for testing Date.prototype.toJSON and JSON.stringify
   *
   * @private
   * @function module:util-x~$makeDate
   * @param {*} inputArg Value to be passed to the Date constructor
   * @return {date} A date object with .toISOString and .toJSON
   */
  function $makeDate(inputArg) {
    var date = new CDate(inputArg);

    date.toISOString = exports.Date.proto.toISOString;
    date.toJSON = exports.Date.proto.toJSON;

    return date;
  }

  /**
   *  This function returns an ISO 8601 representation of the instance in time
   *  represented by this Date object.
   *
   * @function module:util-x~exports.Date.proto.toJSON
   * @this {Date}
   * @param {*} [key] Ignored
   * @throws {RangeError} If not a valid date.
   * @return {string} An ISO 8601 representation of the date.
   */
  exports.Date.proto.toJSON = $decide(
    // test
    function () {
      $affirmBasic(base.Date.toJSON)();

      var zero = 0,
        value;

      $affirm.throws(function () {
        value = $call(base.Date.toJSON, $makeDate(-8.64e15));
        value.toISOString = null;
      }, CTypeError, 'Throw if toISOString is not a function');

      $affirm.doesNotThrow(function () {
        value = $call(base.Date.toJSON, $makeDate(-8.64e15));
      }, 'test1');

      $affirm.strictEqual(value, '-271821-04-20T00:00:00.000Z', 'test2');

      $affirm.doesNotThrow(function () {
        value = $call(base.Date.toJSON, $makeDate(8.64e15));
      }, 'test3');

      $affirm.strictEqual(value, '+275760-09-13T00:00:00.000Z', 'test4');

      $affirm.doesNotThrow(function () {
        value = $call(base.Date.toJSON, $makeDate(-621987552e5));
      }, 'test5');

      $affirm.strictEqual(value, '-000001-01-01T00:00:00.000Z', 'test6');

      $affirm.doesNotThrow(function () {
        value = $call(base.Date.toJSON, $makeDate(-1));
      }, 'test7');

      $affirm.strictEqual(value, '1969-12-31T23:59:59.999Z', 'test8');

      $affirm.doesNotThrow(function () {
        value = $call(base.Date.toJSON, NaN);
      }, 'test9');

      $affirm.strictEqual(value, null, 'test10');

      $affirm.doesNotThrow(function () {
        value = $call(base.Date.toJSON, INFINITY);
      }, 'test11');

      $affirm.strictEqual(value, null, 'test12');

      $affirm.doesNotThrow(function () {
        value = $call(base.Date.toJSON, 1 / -zero);
      }, 'test13');

      $affirm.strictEqual(value, null, 'test14');

      $affirm.doesNotThrow(function () {
        value = $call(base.Date.toJSON, $makeDate(MAX_VALUE));
      }, 'test15');

      $affirm.strictEqual(value, null, 'test16');
    },

    // pass
    function () {
      return base.Date.toJSON;
    },

    // fail
    function () {
      return function () {
        var object = $toObject(this),
          tv = $toPrimitive(object, hintNumber),
          rtn;

        if (typeof tv === 'number' && !$isFinite(tv)) {
          rtn = null;
        } else {
          rtn = $throwIfNotFunction(object.toISOString).call(object);
        }

        return rtn;
      };
    },

    // message
    'Date.toJSON shim'
  );

  /**
   *  This function returns an ISO 8601 representation of the instance in time
   *  represented by this Date object.
   *
   * @function module:util-x~exports.Date.toJSON
   * @param {Date} date A Javascript Date object.
   * @throws {RangeError} If not a valid date.
   * @return {string} An ISO 8601 representation of the date.
   */
  exports.Date.toJSON = $toMethod(exports.Date.proto.toJSON);

  /**
   * Return a JSON string corresponding to the specified value, optionally including only certain properties
   * or replacing property values in a user-defined manner.
   *
   * @function module:util-x~exports.JSON.stringify
   * @param {*} value
   * @param {(Function|Array)} replacer
   * @param {number} space
   * @return {string}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify
   */
  exports.JSON.stringify = (function (mStringify) {
    return $decide(
      //test
      function () {
        $affirmBasic(mStringify)();

        function customJSON() {
          return 1;
        }

        customJSON.toJSON = customJSON;

        /*jslint newcap: true */
        $affirm.strictEqual(mStringify(CNumber(1)), '1', 'test1');
        $affirm.strictEqual(mStringify(CBoolean(true)), 'true', 'test2');
        $affirm.strictEqual(mStringify(CString('abc')), '"abc"', 'test3');
        /*jslint newcap: false */

        // Firefox 3.1b1 and b2 serialize string, number, and boolean
        // primitives as object literals.
        $affirm.strictEqual(mStringify(0), '0', 'test4');
        // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
        // literals.
        $affirm.strictEqual(mStringify(new CNumber()), '0', 'test5');
        $affirm.strictEqual(mStringify(new CString()), '""', 'test6');
        // FF 3.1b1, 2 throw an error if the toJSON is `null`, `undefined`, or
        // does not define a canonical JSON representation (this applies to
        // objects with `toJSON` properties as well, *unless* they are nested
        // within an object or array).
        $affirm.doesNotThrow(function () {
          mStringify(noop);
        }, 'should not throw');
        $affirm.ok(typeof mStringify(noop) === 'undefined', 'test7');
        // IE 8 serializes `undefined` as `"undefined"`. Safari 5.1.7 and FF
        // 3.1b3 pass this test.
        $affirm.ok(typeof mStringify(Undefined) === 'undefined', 'test8');
        // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
        // respectively, if the toSON is omitted entirely.
        $affirm.doesNotThrow(function () {
          mStringify();
        }, 'test9');
        $affirm.ok(typeof mStringify() === 'undefined', 'test10');
        // FF 3.1b1, 2 throw an error if the given testTemp.a is not a number,
        // string, array, object, Boolean, or `null` literal. This applies to
        // objects with custom `toJSON` methods as well, unless they are nested
        // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
        // methods entirely.
        $affirm.doesNotThrow(function () {
          mStringify(customJSON);
          mStringify([customJSON]);
        }, 'test11');
        $affirm.strictEqual(mStringify(customJSON), '1', 'test12');
        $affirm.strictEqual(mStringify([customJSON]), '[1]', 'test13');
        // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
        // `"[null]"`.
        $affirm.strictEqual(mStringify([Undefined]), '[null]', 'test14');
        // YUI 3.0.0b1 fails to serialize `null` literals.
        $affirm.strictEqual(mStringify(null), 'null', 'test15');
        // FF 3.1b1, 2 halts serialization if an array contains a function:
        // `[1, true, noop, 1]` serializes as "[1,true,],". These versions
        // of Firefox also allow trailing commas in JSON objects and arrays.
        // FF 3.1b3 elides non-JSON values from objects and arrays, unless they
        // define custom `toJSON` methods.
        $affirm.strictEqual(mStringify([Undefined, noop, null]), '[null,null,null]', 'test16');
        // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
        // where character escape codes are expected (e.g., `\b` => `\u0008`).
        // Removed test for '\0' => '\\'u0000'as Chrome 10 fails in 'use strict' mode with
        // Error: Uncaught SyntaxError: Octal literals are not allowed in strict mode.
        $affirm.doesNotThrow(function () {
          mStringify({
            'A': [customJSON, true, false, null, '\b\n\f\r\t']
          });
        }, 'test17');
        $affirm.strictEqual(mStringify({
          'A': [customJSON, true, false, null, '\b\n\f\r\t']
        }), '{"A":[1,true,false,null,"\\b\\n\\f\\r\\t"]}', 'test18');
        // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
        //mStringify(null, testTemp.customJSON) === '"1"' &&
        $affirm.strictEqual(mStringify([1, 2], null, 1), '[\n 1,\n 2\n]', 'test19');

        var date = $makeDate(-8.64e15);

        $affirm.strictEqual(mStringify(date), '"-271821-04-20T00:00:00.000Z"', 'test20');
        date = $makeDate(8.64e15);
        $affirm.strictEqual(mStringify(date), '"+275760-09-13T00:00:00.000Z"', 'test21');
        date = $makeDate(-621987552e5);
        $affirm.strictEqual(mStringify(date), '"-000001-01-01T00:00:00.000Z"', 'test22');
        date = $makeDate(-1);
        $affirm.strictEqual(mStringify(date), '"1969-12-31T23:59:59.999Z"', 'test22');

        date.toJSON = undefined;
        $affirm.strictEqual(mStringify(date), '{}', 'test23');
      },

      // pass
      function () {
        return mStringify;
      },

      // fail
      function () {
        var sfyEscapable = new CRegExp('[\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-' +
            '\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-' +
            '\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]', 'g'),
          sfyMeta = {
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"': '\\"',
            '\\': '\\\\'
          },
          sfyIndent,
          sfyGap,
          sfyReplacer;

        /**
         * @private
         * @function
         */
        function stringifyQuote(string) {
          var result = '"',
            hex;

          sfyEscapable.lastIndex = 0;
          if ($test(sfyEscapable, string)) {
            result += $replace(string, sfyEscapable, function (a) {
              var c = sfyMeta[a],
                r;

              if (typeof c === 'string') {
                r = c;
              } else {
                hex = $toString($call(pCharCodeAt, a, 0), 16);
                r = '\\u' + $sSlice('0000', 0, -hex.length) + hex;
              }

              return r;
            });
          } else {
            result += string;
          }

          return result + '"';
        }

        /**
         * @private
         * @function
         */
        function stringifyToString(key, holder, circular) {
          if (!$isArray(circular)) {
            circular = [];
          }

          var member,
            mind = sfyGap,
            partial,
            value = holder[key],
            element,
            theGap,
            length,
            index,
            keys,
            v;

          /*jslint eqeq:true */
          /*jshint eqnull:true */
          if (value != null && $isFunction(value.toJSON)) {
            value = value.toJSON(key);
          }

          if ($isFunction(sfyReplacer)) {
            value = $call(sfyReplacer, holder, key, value);
          }

          if (!$isPrimitive(value) && ($isString(value) || $isNumber(value) || $isBoolean(value))) {
            value = $toPrimitive(value, hintNumber);
          }

          switch ($typeOf(value)) {
          case 'string':
            return stringifyQuote(value);
          case 'number':
            if (value !== INFINITY && value !== NEGATIVE_INFINITY) {
              return $toString(value);
            }

            return 'null';
          case 'boolean':
          case 'null':
            return $toString(value);
          case 'object':
            if (value === null) {
              return $toString(value);
            }

            length = $toLength(circular.length);
            for (index = 0; index < length; index += 1) {
              if (value === circular[index]) {
                throw new CTypeError('Converting circular structure to JSON');
              }
            }

            circular.length = length + 1;
            circular[length] = value;
            sfyGap += sfyIndent;
            partial = [];
            if ($isArray(value)) {
              length = $toLength(value.length);
              for (index = 0; index < length; index += 1) {
                $push(partial, stringifyToString(index, value, circular) || 'null');
              }

              if (!$toLength(partial.length)) {
                member = '[]';
              } else if (typeof sfyGap === 'string' && sfyGap !== '') {
                member = '[\n' + sfyGap + $join(partial, ',\n' + sfyGap) + '\n' + mind + ']';
              } else {
                member = '[' + $join(partial, ',') + ']';
              }

              sfyGap = mind;

              return member;
            }

            if (typeof sfyGap === 'string' && sfyGap !== '') {
              theGap = ': ';
            } else {
              theGap = ':';
            }

            if ($isArray(sfyReplacer)) {
              length = $toLength(sfyReplacer.length);
              for (index = 0; index < length; index += 1) {
                element = sfyReplacer[index];
                if (typeof element === 'string') {
                  v = stringifyToString(element, value, circular);
                  if (typeof v !== 'undefined') {
                    $push(partial, stringifyQuote(element) + theGap + v);
                  }
                }
              }
            } else {
              keys = $objectKeys(value);
              length = $toLength(keys.length);
              for (index = 0; index < length; index += 1) {
                element = keys[index];
                v = stringifyToString(element, value, circular);
                if (typeof v !== 'undefined') {
                  $push(partial, stringifyQuote(element) + theGap + v);
                }
              }
            }

            if (!$toLength(partial.length)) {
              member = '{}';
            } else if (typeof sfyGap === 'string' && sfyGap !== '') {
              member = '{\n' + sfyGap + $join(partial, ',\n' + sfyGap) + '\n' + mind + '}';
            } else {
              member = '{' + $join(partial, ',') + '}';
            }

            sfyGap = mind;

            return member;
          }

          return Undefined;
        }

        return function (value, replacer, space) {
          sfyGap = '';

          var type = typeof space;

          if (type === 'number') {
            sfyIndent = $repeat(' ', space);
          } else if (type === 'string') {
            sfyIndent = space;
          } else {
            sfyIndent = '';
          }

          sfyReplacer = replacer;
          /*jslint eqeq:true */
          /*jshint eqnull:true */
          if (replacer != null && !$isFunction(replacer) && !$isArray(replacer)) {
            throw new CError('JSON.stringify');
          }

          return stringifyToString('', {
            '': value
          });
        };
      },

      // message
      'JSON.stringify shim'
    );
  }(base.JSON.stringify));

  /**
   * Parse a string as JSON, optionally transform the produced value and its properties, and return the value.
   *
   * @private
   * @function module:util-x~mParse
   * @param {string} text
   * @param {(Function|Array)} reviver
   * @return {Object}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse
   */
  exports.JSON.parse = (function (mParse) {
    return $decide(
      //test
      function () {
        $affirmBasic(mParse)();

        // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
        // Conforming implementations should also coerce the initial argument to
        // a string prior to parsing.
        $affirm.strictEqual(mParse('0'), 0, 'test1');
        $affirm.strictEqual(mParse(false), false, 'test2');

        var parseSimple;

        $affirm.doesNotThrow(function () {
          parseSimple = mParse('{\"A\":[1,true,false,null,\"\\u0000\\b\\n\\f\\r\\t\"]}');
        }, 'test3');

        $affirm.strictEqual(parseSimple.A.length, 5, 'test4');
        $affirm.strictEqual(parseSimple.A[0], 1, 'test5');
        // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in string.
        $affirm.throws(function () {
          mParse('"\t"');
        }, CSyntaxError, 'test6');

        // FF 4.0 and 4.0.1 allow leading `+` signs, and leading and
        // trailing decimal points. FF 4.0, 4.0.1, and IE 9-10 also
        // allow certain octal literals.
        $affirm.throws(function () {
          mParse('01');
        }, CSyntaxError, 'test7');
      },

      // pass
      function () {
        return $decide(
          // test
          function () {
            $affirm.throws(function () {
              mParse();
            }, CSyntaxError, 'test8');
          },

          // pass
          function () {
            return mParse;
          },

          // fail
          function () {
            return function (text, reviver) {
              if (typeof text === 'undefined') {
                throw new CSyntaxError('JSON.parse');
              }

              return mParse(text, reviver);
            };
          },

          // message
          'JSON.parse patch'
        );
      },

      //fail
      function () {
        var parseProtect1 = new CRegExp('^[\\],:{}\\s]*$'),
          parseProtect2 = new CRegExp('\\\\(?:["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})', 'g'),
          parseProtect3 = new CRegExp('"[^"\\\\\\n\\r]*"|true|false|null|' +
            '-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?', 'g'),

          parseProtect4 = new CRegExp('(?:^|:|,)(?:\\s*\\[)+', 'g'),
          parseCharacterTest = new CRegExp('[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5' +
            '\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff' +
            '\\ufff0-\\uffff]', 'g');

        /** function */
        function walk(holder, key, reviver) {
          var value = holder[key],
            keys,
            length,
            index,
            k,
            v;

          if (!$isPrimitive(value) && $typeOf(value) === 'object') {
            keys = $objectKeys(value);
            length = $toLength(keys.length);
            for (index = 0; index < length; index += 1) {
              k = keys[index];
              v = walk(value, k);
              if (typeof v !== 'undefined') {
                value[k] = v;
              } else {
                $deleteProperty(value, k);
              }
            }
          }

          return $call(reviver, holder, key, value);
        }

        return function (text, reviver) {
          var j;

          text = $toString(text);
          parseCharacterTest.lastIndex = 0;
          if ($test(parseCharacterTest, text)) {
            text = $replace(text, parseCharacterTest, function (a) {
              var hex = $toString($call(pCharCodeAt, a, 0), 16);

              return '\\u' + $sSlice('0000', 0, -hex.length) + hex;
            });
          }

          if ($test(parseProtect1, $replace($replace($replace(text, parseProtect2, '@'), parseProtect3, ']'), parseProtect4, ''))) {
            /*jslint evil: true */
            j = eval('(' + text + ')');
            /*jslint evil: false */

            if ($isFunction(reviver)) {
              return walk({
                '': j
              }, '', reviver);
            }

            return j;
          }

          throw new CSyntaxError('JSON.parse');
        };
      },

      // message
      'JSON.parse shim'
    );
  }(base.JSON.parse));

  /**
   * Return a JSON string corresponding to the specified value, optionally including only certain properties
   * or replacing property values in a user-defined manner.
   *
   * @private
   * @function module:util-x~$stringify
   * @param {*} value
   * @param {(Function|Array)} replacer
   * @param {number} space
   * @return {string}
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify
   */
  $stringify = exports.JSON.stringify;

  /**
   * The substr method takes two arguments, start and length, and returns a substring of the result
   * of converting the this object to a String, starting from character position start and running
   * for length characters (or through the end of the String if length is undefined). If start is
   * negative, it is treated as (sourceLength+start) where sourceLength is the length of the String.
   *
   * @function module:util-x~exports.String.proto.substr
   * @this {string}
   * @param {number} start
   * @param {number} length
   * @return {string}
   * @see https://people.mozilla.org/~jorendorff/es6-draft.html#sec-string.prototype.substr
   */
  exports.String.proto.substr = (function () {
    return $decide(
      // test
      function () {
        $affirmBasic(base.String.substr)();
        $affirm.strictEqual($call(base.String.substr, '0b', -1), 'b', 'negative substr bug');
        $affirm.strictEqual($call(base.String.substr, 'abcdef', 1, Undefined), 'bcdef', 'stop is undefined bug');
      },

      // pass
      function () {
        return base.String.substr;
      },

      // fail
      function () {
        var pSSlice = exports.String.proto.slice;

        return function (start, length) {
          var object = $onlyCoercibleToString(this),
            size = $toLength(object.length),
            intStart = $toInteger(start),
            end;

          if (intStart < 0) {
            intStart = $max(size + intStart, 0);
          }

          if (typeof length === 'undefined') {
            end = INFINITY;
          } else {
            end = $toInteger(length);
          }

          return $call(pSSlice, object, intStart, intStart + $min($max(end, 0), size - intStart));
        };
      },

      // message
      'String.substr shim'
    );
  }());

  /**
   * The substr method takes two arguments, start and length, and returns a substring of the result
   * of converting the this object to a String, starting from character position start and running
   * for length characters (or through the end of the String if length is undefined). If start is
   * negative, it is treated as (sourceLength+start) where sourceLength is the length of the String.
   *
   * @function module:util-x~exports.String.substr
   * @param {string} object
   * @param {number} start
   * @param {number} length
   * @return {string}
   * @see http://www.ecma-international.org/ecma-262/5.1/#sec-B.2.3
   */
  exports.String.substr = $toMethod(exports.String.proto.substr);

  /**
   * The substr method takes two arguments, start and length, and returns a substring of the result
   * of converting the this object to a String, starting from character position start and running
   * for length characters (or through the end of the String if length is undefined). If start is
   * negative, it is treated as (sourceLength+start) where sourceLength is the length of the String.
   *
   * @private
   * @function module:util-x~$substr
   * @param {string} object
   * @param {number} start
   * @param {number} length
   * @return {string}
   * @see http://www.ecma-international.org/ecma-262/5.1/#sec-B.2.3
   */
  $substr = exports.String.substr;

  /**
   * This method calculates the Power Set of the array.
   * Sparseness is ignored.
   *
   * @function module:util-x~exports.Array.proto.powerSet
   * @this {(ArrayLike|string)}
   * @throws {TypeError} If array is null or undefined
   * @return {Array.<Array>}
   * @see http://en.wikipedia.org/wiki/Power_set
   */
  exports.Array.proto.powerSet = (function () {
    var pPowerSet = function () {
      var thisObj = $toObject(this),
        val = [],
        object,
        lastElement,
        pSet,
        len,
        idx,
        it;

      if ($hasOwnValidLength(thisObj) && !$isFunction(thisObj)) {
        len = $toLength(thisObj.length);
        if (len < 1) {
          $push(val, []);
        } else {
          if ($isString(thisObj)) {
            lastElement = $getItem(thisObj, len - 1, true);
            object = $sSlice(thisObj, 0, -1);
          } else {
            object = $slice(thisObj);
            lastElement = $pop(object);
          }

          pSet = $call(pPowerSet, object);
          len = pSet.length;
          for (idx = 0; idx < len; idx += 1) {
            it = pSet[idx];
            $push(val, it);
            pSet[idx] = it = $slice(it);
            $push(it, lastElement);
            $push(val, it);
          }
        }
      } else {
        $push(val, []);
      }

      val.length = $toLength(val.length);

      return val;
    };

    return pPowerSet;
  }());

  /**
   * This {@link module:util-x~boundPrototypalFunction method} calculates the Power Set of a given array.
   *
   * @function module:util-x~exports.Array.powerSet
   * @param {(ArrayLike|string)} array
   * @throws {TypeError} If array is null or undefined
   * @return {Array.<Array>}
   * @see http://en.wikipedia.org/wiki/Power_set
   */
  exports.Array.powerSet = $toMethod(exports.Array.proto.powerSet);

  /**
   * Convert an array to a plain object representation.
   *
   * @function module:util-x~exports.Array.proto.toObject
   * @this {module:util-x~ArrayLike}
   * @return {Object}
   */
  exports.Array.proto.toObject = function () {
    var object = $toObject(this),
      accumulator = {},
      isString,
      length,
      index;

    if ($hasOwnValidLength(object) && !$isFunction(object)) {
      isString = length && $isString(object);
      accumulator.length = length = $toLength(object.length);
      for (index = 0; index < length; index += 1) {
        if ($hasItem(object, index, isString)) {
          accumulator[index] = $getItem(object, index, isString);
        }
      }
    } else {
      accumulator.length = 0;
    }

    return accumulator;
  };

  /**
   * Convert an array to a plain object representation.
   *
   * @function module:util-x~exports.Array.toObject
   * @param {module:util-x~ArrayLike} array
   * @return {Object}
   */
  exports.Array.toObject = $toMethod(exports.Array.proto.toObject);

  /**
   * Determines if the supplied object is an instance of a particular constructor or
   * if the supplied object has the matching 'classId' on its constructor property.
   *
   * @private
   * @function module:util-x~$isInstance
   * @param {*} object The object to be tested.
   * @param {Function} Ctor The constructor to test the object against.
   * @throws {TypeError} If Ctor is not a constructor.
   * @return {boolean} True if object is an instance of Ctor or
   *                    has the matching `classId` otherwise false.
   */
  function $isInstance(object, Ctor) {
    if (!$isFunction(Ctor)) {
      throw new CTypeError('Ctor is not a constructor.');
    }

    var rtn = false;

    /*jslint eqeq:true */
    /*jshint eqnull:true */
    if (object != null) {
      if ($instanceOf(object, Ctor)) {
        rtn = true;
      } else if (!$isPrimitive(object) && !$isPlainObject(object) && !$isFunction(object) && typeof object.classId === 'string') {
        // this could be more robust
        rtn = object.classId === Ctor.prototype.classId;
      }
    }

    return rtn;
  }

  // Big closure
  (function () {
    /**
     * A Big number instance used for arbitrary-precision decimal arithmetic.
     *
     * @typedef {Object} module:util-x~bigobject
     * @property {number} s Sign. -1 or 1.
     * @property {number} e Exponent. Integer, -1e+6 to 1e+6 inclusive.
     * @property {Array.<number>} c Coefficient. Array of single digits.
     * @see http://mikemcl.github.io/big.js/
     */

    /**
     * A BigError instance.
     *
     * @typedef {Object} module:util-x~bigerror
     * @property {string} message Human readable error message.
     * @property {string} name 'BigError'.
     */

    /**
     * An object with a value that {@link Big} accepts as a valid numeric value.<br/>
     * <br/>
     * A decimal value.<br/>
     * <br/>
     * String values may be in exponential, as well as normal (non-exponential) notation.<br/>
     * <br/>
     * There is no limit to the number of digits of a string value (other than that of Javascript's
     * maximum array size 2^32-1), but the largest recommended exponent magnitude is 1e+6.<br/>
     * <br/>
     * INFINITY, NaN and hexadecimal literal strings, e.g. '0xff', are not valid.<br/>
     * <br/>
     * String values in octal literal form will be interpreted as decimals, e.g. '011' is 11, not 9.<br/>
     *<br/>
     * Any object where the `valueOf` gives a valid number or string value, as above.
     *
     * @typedef {*} module:util-x~validNumeric
     */

    // Declare variables used globally within this scope.

    var
    /***************************** START EDITABLE DEFAULTS ******************************/

    // The default values below must be integers within the stated ranges.

    /**
     * The maximum number of decimal places of the results of operations
     * involving division: div and sqrt, and pow with negative exponents.
     * The maximum value of DP and Big.DP. 0 to MAX_DP
     *
     * @private
     * @const
     * @type {number}
     * @default 20
     */
      DP = 20,

      /**
       * The rounding mode used when rounding to the above decimal places.<br/>
       * <br/>
       * 0 Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)<br/>
       * 1 To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)<br/>
       * 2 To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)<br/>
       * 3 Away from zero.                                  (ROUND_UP)<br/>
       *
       * @private
       * @const
       * @type {number}
       * @default
       */
      RM = 1,

      /**
       * The maximum value of DP and Big.DP. 0 to 1000000
       *
       * @private
       * @const
       * @type {number}
       * @default 1E6
       */
      MAX_DP = 1E6,

      /**
       * The maximum magnitude of the exponent argument to the pow method. 0 to 1000000
       *
       * @private
       * @const
       * @type {number}
       * @default 1E6
       */
      MAX_POWER = 1E6,

      /**
       * The exponent value at and beneath which toString returns exponential
       * notation. 0 to -1000000
       * <br/>
       * -1000000 is the minimum recommended exponent value of a Big.
       *
       * @private
       * @const
       * @type {number}
       * @default -7
       */
      TO_EXP_NEG = -7,

      /**
       * The exponent value at and above which toString returns exponential
       * notation. 0 to 1000000
       * <br/>
       * 1000000 is the maximum recommended exponent value of a Big.
       * (This limit is not enforced or checked.)
       *
       * @private
       * @const
       * @type {number}
       * @default 21
       */
      TO_EXP_POS = 21,

      /***************************** END EDITABLE DEFAULTS ******************************/

      /**
       * @private
       * @constructor
       * @param {*} [message] Human-readable description of the error.
       * @return {Function}
       */
      BigError = exports.customError('BigError', CError),

      /**
       * The string to be used for identifying Big instances.
       *
       * @private
       * @const
       * @type {string}
       * @default '[object Big]'
       */
      bigClassID = '[object Big]',

      /**
       * The regular expression used for validating the argument of a new Big.
       *
       * @private
       * @const
       * @type {RegExp}
       * @default /^-?(\d+(\.\d*)?|\.\d+)(e[+\-]?\d+)?$/i
       */
      isValid = /^-?(\d+(\.\d*)?|\.\d+)(e[+\-]?\d+)?$/i,

      /**
       * Variable used for a function expression.
       * Primarily to keep jslint happy when a function can not
       * be defined before it is used.
       */
      plus,

      /**
       * Variable used for a function expression.
       * Primarily to keep jslint happy when a function can not
       * be defined before it is used.
       */
      minus;

    /**
     * @private
     * @readonly
     * @name BigNumber.version
     * @type {string}
     */
    $defineProperty(BigError, 'version', $assign({
      value: '0.2.0'
    }, propConstant));

    $defineProperties(BigError.prototype, {
      /**
       * @private
       * @readonly
       * @name BigNumber.prototype.classId
       * @type {string}
       */
      classId: $assign({
        value: '[object BigError]'
      }, propConstant),

      /**
       * @private
       * @readonly
       * @name BigNumber.prototype.version
       * @type {string}
       */
      version: $assign({
        value: '0.2.0'
      }, propConstant)
    });

    /******************************************************************************/

    /*
     * Private functions
     */

    /**
     * Determines if the supplied object is a sibling big object (duck typed).
     *
     * @private
     * @function isBigDuck
     * @param {*} [object] The object to be tested.
     * @return {boolean} True if object possitively duck types.
     * @see https://github.com/MikeMcl/bignumber.js/
     * @see https://github.com/MikeMcl/decimal.js/
     */
    function isBigDuck(object) {
      var rtn = false,
        testType;

      /* What's goin on here?
       * We test if the argument is an object, but not null, a function or a plain object.
       * If we have an object (class) then we check the properties to make sure that they match
       * the properties and their types that we would expect from a sibling library's object.
       * If they match then we check for a couple of methods that we expect the object to have.
       * If all of these pass then we can be fairly sure that it's a sibling object.
       */
      if (object) {
        testType = typeof object;
        if (testType === 'object' &&
            !$isFunction(object) &&
            object.constructor.prototype !== protoObject &&
            (object.s === null || object.s === 1 || object.s === -1) &&
            (object.c === null || $isArray(object.c)) &&
            (object.e === null || typeof object.e === 'number') &&
            $isFunction(object.plus) &&
            $isFunction(object.minus)) {

          rtn = true;
        }
      }

      return rtn;
    }

    /**
     * The function evaluates the passed value and tests that it is an integer and is in the specified range.
     *
     * @private
     * @function isIntegerInRange
     * @param {*} [val]
     * @param {number} Integer, min
     * @param {number} Integer, max
     * @throws {TypeError} If min is not an integer.
     * @throws {TypeError} If max is not an integer.
     * @return {boolean}
     */
    function isIntegerInRange(val, min, max) {
      if (!$isInteger(min)) {
        throw new CTypeError('min is not an integer: ' + $toString($toPrimitive(min, hintString)));
      }

      if (!$isInteger(max)) {
        throw new CTypeError('max is not an integer: ' + $toString($toPrimitive(max, hintString)));
      }

      return $isInteger(val) && $inRange(val, min, max);
    }

    /**
     * For executing methods that take a variable number of arguments.
     *
     * @private
     * @function forArgs
     * @params {arguments.<module:util-x~bigobject>} args Arguments to be executed.
     * @params {Function} fn Function to execute the arguments against.
     * @params {module:util-x~bigobject} thisArg The initial this value.
     * @throws {module:util-x~bigerror} Any BigError encountered by executing fn.
     * @return {module:util-x~bigobject}
     */
    function forArgs(args, fn, thisArg) {
      var length = $toLength(args.length),
        index = 0;

      do {
        thisArg = $call(fn, thisArg, args[index]);
        index += 1;
      } while (index < length);

      return thisArg;
    }

    /**
     * Returns a {@link module:util-x~bigobject Big number} whose value is the value of this
     * {@link module:util-x~bigobject Big number} rounded using rounding mode rm to a maximum of
     * dp decimal places.<br/>
     * <br/>
     * Called by {@link Big#div}, {@link Big#sqrt}
     * and {@link Big#round}.
     *
     * @private
     * @function rnd
     * @this module:util-x~bigobject
     * @param {number} dp Integer, 0 to 1e+6 inclusive.
     * @param {number} rm 0, 1, 2 or 3 (ROUND_DOWN, ROUND_HALF_UP, ROUND_HALF_EVEN, ROUND_UP)
     * @param {boolean} [more] Whether the result of division was truncated.
     * @throws {module:util-x~bigerror} !Big.RM! if rm is invalid.
     * @return {module:util-x~bigobject} A rounded value of this.
     *
     * @example <caption>Example usage.</caption>
     * x = 123.45
     * Math.round(x)              // 123
     * y = new Big(x)
     * $call(rnd, y, 1, 0)              // '123.4'
     * $call(rnd, y, 1, 1)              // '123.5'
     * $call(rnd, y, 1, 2)              // '123.4'
     * $call(rnd, y, 1, 3)              // '123.5'
     * y                              // '123.45'
     */
    function rnd(dp, rm, more) {
      /*jshint validthis:true */
      var xc = this.c,
        i = this.e + dp + 1;

      if (rm === 1) {
        // xc[i] is the digit after the digit that may be rounded up.
        more = xc[i] >= 5;
      } else if (rm === 2) {
        /*jslint bitwise:true */
        more = xc[i] > 5 || (xc[i] === 5 && (more || i < 0 || typeof xc[i + 1] !== 'undefined' || xc[i - 1] & 1));
        /*jslint bitwise:true */
      } else if (rm === 3) {
        more = more || typeof xc[i] !== 'undefined' || i < 0;
      } else {
        more = false;
        if (rm !== 0) {
          throw new BigError('!Big.RM!');
        }
      }

      if (i < 1 || !xc[0]) {
        if (more) {
          // 1, 0.1, 0.01, 0.001, 0.0001 etc.
          this.e = -dp;
          this.c = [1];
        } else {
          // Zero.
          this.e = 0;
          this.c = [0];
        }
      } else {
        // Remove any digits after the required decimal places.
        xc.length = i;
        i -= 1;
        // Round up?
        if (more) {
          // Rounding up may mean the previous digit has to be rounded up.
          for (xc[i] += 1; xc[i] > 9; xc[i] += 1) {
            xc[i] = 0;
            if (!i) {
              this.e += 1;
              $unshift(xc, 1);
            }

            i -= 1;
          }
        }

        // Remove trailing zeros.
        for (i = $toLength(xc.length) - 1; !xc[i]; i -= 1) {
          $pop(xc);
        }
      }

      return this;
    }

    /**
     * Returns a string representing the value of this {@link module:util-x~bigobject Big number}.<br/>
     * <br/>
     * If this {@link module:util-x~bigobject Big number} has a positive exponent that is equal to or
     * greater than 21, or a negative exponent equal to or less than -7,
     * then exponential notation is returned.<br/>
     * <br/>
     * The point at which {@link Big#toString} returns exponential rather than normal
     * notation can be adjusted by changing the value of TO_EXP_POS and TO_EXP_NEG in the
     * EDITABLE DEFAULTS section at the top of the source code file. By default,
     * {@link module:util-x~bigobject Big numbers} correspond to {@link number Javascript's number type}
     * in this regard.
     *
     * @private
     * @function bigToString
     * @this module:util-x~bigobject
     * @param {?boolean} valueof Don't avoid -0 if true.
     * @param {boolean} [preventExp] Prevent exponential representation.
     * @return {string} A string representation of this.
     *
     * @example <caption>Example usage.</caption>
     * x = new Big('9.99e+20')
     * $call(bigToString, x)               // '999000000000000000000'
     * y = new Big('1E21')
     * $call(bigToString, y)               // '1e+21'
     * z = new Big('1E21')
     * $call(bigToString, y, true)         //100000000000000000000
     */
    function bigToString(valueof, preventExp) {
      /*jshint validthis:true */
      var e = this.e,
        strT = $join(this.c, ''),
        strL = strT.length,
        str;

      // Exponential notation?
      if (!preventExp && (e <= TO_EXP_NEG || e >= TO_EXP_POS)) {
        str = $getItem(strT, 0, stringTagString);
        if (strL > 1) {
          str += '.' + $sSlice(strT, 1);
        }

        if (e < 0) {
          str += 'e';
        } else {
          str += 'e+';
        }

        str += e;
        // Negative exponent?
      } else if (e < 0) {
        str = strT;
        // Prepend zeros.
        for (e += 1; e; e += 1) {
          str = '0' + str;
        }

        str = '0.' + str;
        // Positive exponent?
      } else if (e > 0) {
        str = strT;
        e += 1;
        if (e > strL) {
          // Append zeros.
          for (e -= strL; e; e -= 1) {
            str += '0';
          }
        } else if (e < strL) {
          str = $sSlice(strT, 0, e) + '.' + $sSlice(strT, e);
        }
        // Exponent zero.
      } else if (strL > 1) {
        str = $getItem(strT, 0, stringTagString) + '.' + $sSlice(strT, 1);
      } else {
        str = strT;
      }

      // Avoid '-0'
      if (valueof === true) {
        if (this.s < 0) {
          str = '-' + str;
        }
      } else if (this.s < 0 && this.c[0]) {
        str = '-' + str;
      }

      return str;
    }

    /*
     ***************************************************************************
     * If toExponential, toFixed, toPrecision and format are not required they
     * can safely be commented-out or deleted. No redundant code will be left.
     * format is used only by toExponential, toFixed and toPrecision.
     ***************************************************************************
     */

    /**
     * Return a string representing the value of Big x in normal or exponential
     * notation to dp fixed decimal places or significant digits.
     *
     * @private
     * @function format
     * @this module:util-x~bigobject
     * @param {number} dp Integer, 0 to MAX_DP inclusive.
     * @param {number} toE 0, 1, 2 or 3 (DOWN, HALF_UP, HALF_EVEN, UP)
     * @param {boolean} [preventExp] Prevent exponential representation.
     * @return {string}
     */
    function format(dp, toE, preventExp) {
      /*jshint validthis:true */
      // The index (normal notation) of the digit that may be rounded up.
      var x = new this.constructor(this),
        i = dp - x.e,
        c = x.c,
        str;

      // Round?
      dp += 1;
      if ($toLength(c.length) > dp) {
        $call(rnd, x, i, this.constructor.RM);
      }

      if (!c[0]) {
        i += 1;
      } else if (toE) {
        i = dp;
        // toFixed
      } else {
        c = x.c;
        // Recalculate i as x.e may have changed if value rounded up.
        i = x.e + i + 1;
      }

      // Append zeros?
      while ($toLength(c.length) < i) {
        $push(c, 0);
      }

      i = x.e;
      /*
       * toPrecision returns exponential notation if the number of
       * significant digits specified is less than the number of digits
       * necessary to represent the integer part of the value in normal
       * notation.
       */
      if (!preventExp && (toE === 1 || (toE && (dp <= i || i <= TO_EXP_NEG)))) {
        // Exponential notation.
        str = '';
        if (x.s < 0 && c[0]) {
          str += '-';
        }

        str += c[0];
        if (c.length > 1) {
          str += '.' + $sSlice($join(c, ''), 1);
        }

        str += 'e';
        if (i >= 0) {
          str += '+';
        }

        str += i;
      } else {
        // Normal notation.
        str = $call(bigToString, x, false, preventExp);
      }

      return str;
    }

    /**
     * Parse the number or string value passed to a Big constructor.
     *
     * @private
     * @function parse
     * @this module:util-x~bigobject
     * @param {module:util-x~validNumeric} n A numeric value.
     * @throws {module:util-x~bigerror} If n coerced to a string does not pass the RegExp test.
     */
    function parse(n) {
      /*jshint validthis:true */
      var e,
        i,
        nL;

      // Minus zero?
      if (n === 0 && 1 / n === NEGATIVE_INFINITY) {
        n = '-0';
      } else {
        // Ensure n is string and check validity.
        n = $toString(n);
      }

      if (!$test(isValid, n)) {
        throw new BigError(NaN);
      }

      // Determine sign.
      if ($getItem(n, 0, stringTagString) === '-') {
        n = $sSlice(n, 1);
        this.s = -1;
      } else {
        this.s = 1;
      }

      // Decimal point?
      e = $call(pSIndexOf, n, '.');
      if (e > -1) {
        n = $call(pReplace, n, '.', '');
      }

      // Exponential form?
      i = $call(pSearch, n, /e/i);
      if (i > 0) {
        // Determine exponent.
        if (e < 0) {
          e = i;
        }

        e += $toNumber($sSlice(n, i + 1));
        n = $substr(n, 0, i);
      } else if (e < 0) {
        // Integer.
        e = $toLength(n.length);
      }

      // Determine leading zeros.
      i = 0;
      while ($getItem(n, i, stringTagString) === '0') {
        i += 1;
      }

      nL = $toLength(n.length);
      if (i === nL) {
        // Zero.
        this.e = 0;
        this.c = [0];
      } else {
        // Determine trailing zeros.
        nL -= 1;
        while ($getItem(n, nL, stringTagString) === '0') {
          nL -= 1;
        }

        this.e = e - i - 1;
        this.c = [];
        // Convert string to array of digits without leading/trailing zeros.
        for (e = 0; i <= nL; i += 1, e += 1) {
          this.c[e] = $toNumber($getItem(n, i, stringTagString));
        }
      }
    }

    /**
     * Returns a {@link module:util-x~bigobject Big number} whose value is the value of
     * this {@link module:util-x~bigobject Big number} divided by y.<br/>
     * <br/>
     * If the result has more fraction digits than is specified by {@link Big.DP},
     * it will be rounded to {@link Big.DP} decimal places using rounding mode
     * {@link Big.RM}.<br/>
     *
     * @private
     * @function div
     * @this module:util-x~bigobject
     * @param {module:util-x~validNumeric} y A numeric value.
     * @param {number} dp Integer, 0 to MAX_DP inclusive.
     * @param {number} rm 0, 1, 2 or 3 (DOWN, HALF_UP, HALF_EVEN, UP)
     * @throws {module:util-x~bigerror} NaN if y is invalid.
     * @throws {module:util-x~bigerror} INFINITY on division by zero.
     * @throws {module:util-x~bigerror} NaN on division of zero by zero.
     * @throws {module:util-x~bigerror} '!Big.DP!' if dp not an integer or not in integer range.
     * @return {module:util-x~bigobject} {@link module:util-x~bigobject this} / y.
     *
     * @example <caption>Example usage.</caption>
     * x = new Big(355)
     * y = new Big(113)
     * $call(div, x, y)             // '3.14159292035398230088'
     * Big.DP = 2
     * $call(div, x, y)             // '3.14'
     * $call(div, x, 5)             // '71'
     */
    function div(y, dp, rm) {
      /*jshint validthis:true */
      // dividend
      var dvd = this.c,
        //divisor
        dvs,
        s,
        dvsT,
        next,
        cmp,
        remI,
        dvsZ,
        dvsL,
        dvdI,
        dvdL,
        // remainder
        rem,
        remL,
        // quotient
        q,
        qc,
        qi,
        digits,
        length = $toLength(arguments.length);

      if (length < 2) {
        dp = this.constructor.DP;
      }

      if (!isIntegerInRange(dp, 0, MAX_DP)) {
        throw new BigError('!Big.DP!');
      }

      if (length < 3) {
        rm = this.constructor.RM;
      }

      y = new this.constructor(y);
      dvs = y.c;
      if (this.s === y.s) {
        s = 1;
      } else {
        s = -1;
      }

      // Either 0?
      if (!dvd[0] || !dvs[0]) {
        // If both are 0, throw NaN
        if (dvd[0] === dvs[0]) {
          throw new BigError(NaN);
        }

        // If dvs is 0, throw +-INFINITY.
        if (!dvs[0]) {
          throw new BigError(s / POSITIVE_ZERO);
        }

        // dvd is 0, return +-0.
        return new this.constructor(s * POSITIVE_ZERO);
      }

      dvsZ = $slice(dvs);
      dvsL = $toLength(dvs.length);
      dvdI = dvsL;
      dvdL = $toLength(dvd.length);
      // remainder
      rem = dvd.slice(0, dvsL);
      remL = $toLength(rem.length);
      // quotient
      q = y;
      qi = 0;
      qc = q.c = [];
      q.e = this.e - y.e;
      digits = dp + q.e + 1;
      q.s = s;
      if (digits < 0) {
        s = 1;
      } else {
        s = digits + 1;
      }

      // Create version of divisor with leading zero.
      $unshift(dvsZ, 0);
      // Add zeros to make remainder as long as divisor.
      while (remL < dvsL) {
        $push(rem, 0);
        remL += 1;
      }

      do {
        // 'next' is how many times the divisor goes into current remainder.
        for (next = 0; next < 10; next += 1) {
          // Compare divisor and remainder.
          remL = $toLength(rem.length);
          if (dvsL !== remL) {
            if (dvsL > remL) {
              cmp = 1;
            } else {
              cmp = -1;
            }
          } else {
            cmp = 0;
            for (remI = 0; remI < dvsL; remI += 1) {
              if (dvs[remI] !== rem[remI]) {
                if (dvs[remI] > rem[remI]) {
                  cmp = 1;
                } else {
                  cmp = -1;
                }


                break;
              }
            }
          }

          // If divisor < remainder, subtract divisor from remainder.
          if (cmp < 0) {
            // Remainder can't be more than 1 digit longer than divisor.
            // Equalise lengths using divisor with extra leading zero?
            if (remL === dvsL) {
              dvsT = dvs;
            } else {
              dvsT = dvsZ;
            }

            while (remL) {
              remL -= 1;
              if (rem[remL] < dvsT[remL]) {
                for (remI = remL - 1; remI >= 0 && !rem[remI]; remI -= 1) {
                  rem[remI] = 9;
                }

                rem[remI] -= 1;
                rem[remL] += 10;
              }

              rem[remL] -= dvsT[remL];
            }

            while (!rem[0]) {
              $shift(rem);
            }
          } else {
            break;
          }
        }

        // Add the 'next' digit to the result array.
        if (!cmp) {
          next += 1;
        }

        qc[qi] = next;
        qi += 1;
        // Update the remainder.
        if (rem[0] && cmp) {
          rem[remL] = dvd[dvdI] || 0;
        } else {
          rem = [dvd[dvdI]];
        }

        dvdI += 1;
        s -= 1;
      } while ((dvdI < dvdL || typeof rem[0] !== 'undefined') && s);

      // Leading zero? Do not remove if result is simply zero (qi == 1).
      if (!qc[0] && qi !== 1) {
        // There can't be more than one zero.
        $shift(qc);
        q.e -= 1;
      }

      // Round?
      if (qi > digits) {
        $call(rnd, q, dp, rm, typeof rem[0] !== 'undefined');
      }

      return q;
    }

    /**
     * Returns a new {@link module:util-x~bigobject Big number} whose value is the value of this
     * {@link module:util-x~bigobject Big number} times the value of y.
     *
     * @private
     * @function times
     * @this module:util-x~bigobject
     * @param {module:util-x~validNumeric} y A numeric value.
     * @throws {Error} NaN if y is invalid.
     * @return {module:util-x~bigobject} {@link module:util-x~bigobject this} * y
     *
     * @example <caption>Example usage.</caption>
     * 0.6 * 3                         // 1.7999999999999998
     * x = new Big(0.6)
     * y= $call(times, x, 3)             // '1.8'
     * $call(times, Big('7e+500', y)     // '1.26e+501'
     */
    function times(y) {
      /*jshint validthis:true */
      y = new this.constructor(y);

      var c,
        xc = this.c,
        yc = y.c,
        a,
        b,
        i,
        j;

      // Determine sign of result.
      if (this.s === y.s) {
        y.s = 1;
      } else {
        y.s = -1;
      }

      // Return signed 0 if either 0.
      if (!xc[0] || !yc[0]) {
        if (y.s === -1) {
          a = -0;
        } else {
          a = 0;
        }

        return new this.constructor(a);
      }

      a = $toLength(xc.length);
      b = $toLength(yc.length);
      i = this.e;
      j = y.e;
      // Initialise exponent of result as x.e + y.e.
      y.e = i + j;
      // If array xc has fewer digits than yc, swap xc and yc, and lengths.
      if (a < b) {
        c = xc;
        xc = yc;
        yc = c;
        j = a;
        a = b;
        b = j;
      }

      // Initialise coefficient array of result with zeros.
      c = [];
      for (c.length = j = a + b; j; c[j] = 0) {
        j -= 1;
      }

      // Multiply.

      // i is initially xc.length.
      i = b;
      while (i) {
        i -= 1;
        b = 0;
        // a is yc.length.
        j = a + i;
        while (j > i) {
          // Current sum of products at this digit position, plus carry.
          b = c[j] + yc[i] * xc[j - i - 1] + b;
          c[j] = b % 10;
          j -= 1;
          // carry
          /*jslint bitwise: true */
          b = b / 10 | 0;
          /*jslint bitwise: false */
        }

        c[j] = (c[j] + b) % 10;
      }

      // Increment result exponent if there is a final carry.
      if (b) {
        y.e += 1;
      }

      // Remove any leading zero.
      if (!c[0]) {
        $shift(c);
      }

      // Remove trailing zeros.
      for (i = $toLength(c.length) - 1; !c[i]; i -= 1) {
        $pop(c);
      }

      y.c = c;

      return y;
    }

    /**
     * Returns a {@link module:util-x~bigobject Big number} whose value is the value of this
     * {@link module:util-x~bigobject Big number} minus y.
     *
     * @private
     * @function minus
     * @this module:util-x~bigobject
     * @param {module:util-x~validNumeric} y A numeric value.
     * @throws {Error} NaN if y is invalid.
     *
     * @example <caption>Example usage.</caption>
     * 0.3 - 0.1                  // 0.19999999999999998
     * x = new Big(0.3)
     * $call(minus, x, 0.1)         // '0.2'
     */
    minus = function (y) {
      /*jshint validthis:true */
      y = new this.constructor(y);

      var i,
        j,
        t,
        xLTy,
        a = this.s,
        b = y.s,
        xc,
        xe,
        xcL,
        ycL,
        yc,
        ye,
        rtn;

      // Signs differ?
      if (a !== b) {
        y.s = -b;

        return $call(plus, this, y);
      }

      xc = $slice(this.c);
      xe = this.e;
      yc = y.c;
      ye = y.e;
      // Either zero?
      if (!xc[0] || !yc[0]) {
        // y is non-zero? x is non-zero? Or both are zero.
        if (yc[0]) {
          y.s = -b;

          rtn = y;
        } else if (xc[0]) {
          rtn = new this.constructor(this);
        } else {
          rtn = new this.constructor(0);
        }

        return rtn;
      }

      // Determine which is the bigger number.
      // Prepend zeros to equalise exponents.
      a = xe - ye;
      if (a) {
        xLTy = a < 0;
        if (xLTy) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        $reverse(t);
        for (b = a; b; b -= 1) {
          $push(t, 0);
        }

        $reverse(t);
      } else {
        // Exponents equal. Check digit by digit.
        xcL = $toLength(xc.length);
        ycL = $toLength(yc.length);
        xLTy = xcL < ycL;
        if (xLTy) {
          j = xcL;
        } else {
          j = ycL;
        }

        for (a = b = 0; b < j; b += 1) {
          if (xc[b] !== yc[b]) {
            xLTy = xc[b] < yc[b];

            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) {
        t = xc;
        xc = yc;
        yc = t;
        y.s = -y.s;
      }

      /*
       * Append zeros to xc if shorter. No need to add zeros to yc if shorter
       * as subtraction only needs to start at yc.length.
       */
      i = $toLength(xc.length);
      j = $toLength(yc.length);
      b = j - i;
      if (b > 0) {
        while (b) {
          xc[i] = 0;
          i += 1;
          b -= 1;
        }
      }

      // Subtract yc from xc.
      b = i - 1;
      while (j > a) {
        j -= 1;
        if (xc[j] < yc[j]) {
          for (i = j - 1; i && !xc[i]; i -= 1) {
            xc[i] = 9;
          }

          xc[i] -= 1;
          xc[j] += 10;
        }

        xc[j] -= yc[j];
      }

      // Remove trailing zeros.
      while (xc[b] === 0) {
        $pop(xc);
        b -= 1;
      }

      // Remove leading zeros and adjust exponent accordingly.
      while (xc[0] === 0) {
        $shift(xc);
        ye -= 1;
      }

      if (!xc[0]) {
        // n - n = +0
        y.s = 1;
        // Result must be zero.
        ye = 0;
        xc = [0];
      }

      y.c = xc;
      y.e = ye;

      return y;
    };

    /**
     * Returns a {@link module:util-x~bigobject Big number} whose value is the value of this
     * {@link module:util-x~bigobject Big number} plus y
     *
     * @private
     * @function plus
     * @this module:util-x~bigobject
     * @param {module:util-x~validNumeric} y A numeric value.
     * @throws {Error} NaN if y is invalid.
     * @return {module:util-x~bigobject} {@link module:util-x~bigobject this} + y
     *
     * @example <caption>Example usage.</caption>
     * 0.1 + 0.2                              // 0.30000000000000004
     * x = new Big(0.1)
     * y = $call(plus, x, 0.2)                  // '0.3'
     * $call(plus, $call(plus, Big(0.7), x), y)   // '1'
     */
    plus = function (y) {
      /*jshint validthis:true */
      y = new this.constructor(y);

      var t,
        a = this.s,
        b = y.s,
        xe,
        xc,
        ye,
        yc,
        rtn;

      // Signs differ?
      if (a !== b) {
        y.s = -b;

        return $call(minus, this, y);
      }

      xc = this.c;
      yc = y.c;
      // Either zero?
      if (!xc[0] || !yc[0]) {
        // y is non-zero? x is non-zero? Or both are zero.
        if (yc[0]) {
          rtn = y;
        } else if (xc[0]) {
          rtn = new this.constructor(this);
        } else {
          rtn = new this.constructor(a * POSITIVE_ZERO);
        }

        return rtn;
      }

      xc = $slice(xc);
      // Prepend zeros to equalise exponents.
      // Note: Faster to use reverse then do unshifts.
      xe = this.e;
      ye = y.e;
      a = xe - ye;
      if (a) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        $reverse(t);
        while (a) {
          $push(t, 0);
          a -= 1;
        }

        $reverse(t);
      }

      // Point xc to the longer array.
      if ($toLength(xc.length) - $toLength(yc.length) < 0) {
        t = yc;
        yc = xc;
        xc = t;
      }

      a = $toLength(yc.length);
      /*
       * Only start adding at yc.length - 1 as the further digits of xc can be
       * left as they are.
       */
      b = 0;
      while (a) {
        a -= 1;
        xc[a] = xc[a] + yc[a] + b;
        /*jslint bitwise: true */
        b = xc[a] / 10 | 0;
        /*jslint bitwise: false */
        xc[a] %= 10;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0

      if (b) {
        $unshift(xc, b);
        ye += 1;
      }

      // Remove trailing zeros.
      for (a = $toLength(xc.length) - 1; xc[a] === 0; a -= 1) {
        $pop(xc);
      }

      y.c = xc;
      y.e = ye;

      return y;
    };

    /**
     * Performs a comparison of this {@link module:util-x~bigobject Big number} and the value of y.<br/>
     * <br/>
     * <style>
     *   table, th, td {
     *     border-style: solid;
     *     border-width: 1px;
     *     text-align: left;
     *   }
     * </style>
     * <table>
     * <tbody><tr>
     *   <th>Returns</th>
     *   <th colspan="2">&nbsp;</th>
     * </tr>
     * <tr>
     *   <td class="centre">1</td>
     *   <td>
     *     If the value of this {@link module:util-x~bigobject Big number} is greater than the value of
     *     <code>n</code>
     *   </td>
     * </tr>
     * <tr>
     *   <td class="centre">-1</td>
     *   <td>
     *     If the value of this {@link module:util-x~bigobject Big number} is less than the value of
     *     <code>n</code>
     *   </td>
     * </tr>
     * <tr>
     *   <td class="centre">0</td>
     *   <td>If this {@link module:util-x~bigobject Big number} and <code>n</code> have the same value</td>
     * </tr>
     * </tbody></table>
     *
     * @private
     * @function cmp
     * @this module:util-x~bigobject
     * @param {module:util-x~validNumeric} y A numeric value.
     * @throws {Error} NaN if y is invalid.
     * @return {number} One of these values: -1, 0, 1
     *
     * @example <caption>Example usage.</caption>
     * x = new Big(6)
     * y = new Big(5)
     * $call(cmp, x, y)                   // 1
     * $call(cmp, y, x.minus(1))          // 0
     */
    function cmp(y) {
      /*jshint validthis:true */
      y = new this.constructor(y);

      var xNeg,
        xc = this.c,
        yc = y.c,
        i = this.s,
        j = y.s,
        k = this.e,
        l = y.e,
        test,
        rtn;

      // Either zero?
      if (!xc[0] || !yc[0]) {
        if (!xc[0]) {
          if (!yc[0]) {
            rtn = 0;
          } else {
            rtn = -j;
          }
        } else {
          rtn = i;
        }

        return rtn;
      }

      // Signs differ?
      if (i !== j) {
        return i;
      }

      xNeg = i < 0;
      // Compare exponents.
      if (k !== l) {
        /*jslint bitwise:true */
        test = k > l ^ xNeg;
        /*jslint bitwise:false */
        if (test) {
          rtn = 1;
        } else {
          rtn = -1;
        }

        return rtn;
      }

      k = $toLength(xc.length);
      l = $toLength(yc.length);
      if (k < l) {
        j = k;
      } else {
        j = l;
      }

      // Compare digit by digit.
      for (i = 0; i < j; i += 1) {
        if (xc[i] !== yc[i]) {
          /*jslint bitwise: true */
          test = xc[i] > yc[i] ^ xNeg;
          /*jslint bitwise: false */
          if (test) {
            rtn = 1;
          } else {
            rtn = -1;
          }

          return rtn;
        }
      }

      // Compare lengths.
      if (k === l) {
        rtn = 0;
      } else {
        /*jslint bitwise: true */
        test = k > l ^ xNeg;
        /*jslint bitwise: false */
        if (test) {
          rtn = 1;
        } else {
          rtn = -1;
        }
      }

      return rtn;
    }

    /**
     * Returns a {@link module:util-x~bigobject Big number} whose value is the value of this
     * {@link module:util-x~bigobject Big number} modulo y, i.e. the integer remainder of dividing this
     * {@link module:util-x~bigobject Big number} by y.<br/>
     * <br/>
     * The result will have the same sign as this {@link module:util-x~bigobject Big number},
     *  and it will match that of
     * {@link http://www.ecma-international.org/ecma-262/5.1/#sec-11.5.3 Javascript's % operator}
     * (within the limits of its precision) and BigDecimal's remainder method.
     *
     * @private
     * @function mod
     * @this module:util-x~bigobject
     * @param {module:util-x~validNumeric} y A numeric value.
     * @throws {module:util-x~bigerror} NaN if y is negative or otherwise invalid.
     * @return {module:util-x~bigobject} {@link module:util-x~bigobject this} % y
     *
     * @example <caption>Example usage.</caption>
     * 1 % 0.9                    // 0.09999999999999998
     * x = new Big(1)
     * $call(mod, x, 0.9)           // '0.1'
     */
    function mod(y) {
      /*jshint validthis:true */
      y = new this.constructor(y);

      var yGTx,
        a = this.s,
        b = y.s,
        x,
        rtn;

      if (!y.c[0]) {
        throw new BigError(NaN);
      }

      this.s = y.s = 1;
      yGTx = $call(cmp, y, this) === 1;
      this.s = a;
      y.s = b;
      if (yGTx) {
        rtn = new this.constructor(this);
      } else {
        x = $call(div, this, y, 0, 0);
        rtn = $call(minus, this, $call(times, x, y));
      }

      return rtn;
    }

    /******************************************************************************/

    //Factory and Big constructor.

    /**
     * Create and return an independant copy of the {@link Big} constructor.
     *
     * @private
     * @function bigFactory
     * @return {Big} An independant copy of the {@link Big} constructor.
     */
    function bigFactory() {
      /**
       * Used to create a new a {@link module:util-x~bigobject Big number}
       * or new independant {@link Big} constructor.
       *
       * @constructor Big
       *
       * @param {module:util-x~validNumeric} [n] A decimal value.
       * @throws {Error} Throws NaN on an invalid value.
       * @return {(module:util-x~bigobject|Big)}
       *
       * @example <caption>Example usage.</caption>
       * x = new Big(9)                       // '9'
       * y = new Big(x)                       // '9'
       * Big(435.345)                         // 'new' is optional
       * new Big('5032485723458348569331745.33434346346912144534543')
       * new Big('4.321e+4')                  // '43210'
       * new Big('-735.0918e-430')            // '-7.350918e-428'
       * Big1 = Big()                         // Creates a new and independant constructor
       */
      function Big(n) {
        var rtn;

        // Enable constructor usage without new.
        if (!$isInstance(this, Big)) {
          if ($toLength(arguments.length) === 0) {
            return bigFactory();
          }

          rtn = new Big(n);
        } else {
          // set the attributes of the properties on this {@link module:util-x~bigobject}
          $defineProperty(this, 's', {
            writable: true,
            configurable: true,
            enumerable: false
          });

          $defineProperty(this, 'e', {
            writable: true,
            configurable: true,
            enumerable: false
          });

          $defineProperty(this, 'c', {
            writable: true,
            configurable: true,
            enumerable: false
          });

          // set the values of the properties on this {@link module:util-x~bigobject}
          if ($isInstance(n, Big) || isBigDuck(n)) {
            // Duplicate.
            this.s = n.s;
            this.e = n.e;
            if (n.c === null) {
              this.c = n.c;
            } else {
              this.c = n.c.slice();
            }
          } else {
            $call(parse, this, n);
          }
        }

        return rtn;
      }

      /**
       * Returns a new {@link module:util-x~bigobject Big number} whose value is the absolute value,
       * i.e. the magnitude, of this {@link module:util-x~bigobject Big number}
       *
       * @memberOf Big.prototype
       * @name abs
       * @function
       * @return {module:util-x~bigobject} The absolute value of {@link module:util-x~bigobject this}.
       *
       * @example <caption>Example usage.</caption>
       * x = new Big(-0.8)
       * x.abs()                     // '0.8'
       */
      $defineProperty(Big.prototype, 'abs', {
        value: function () {
          var x = new this.constructor(this);

          x.s = 1;

          return x;
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * Performs a comparison of this {@link module:util-x~bigobject Big number} and the value of y.<br/>
       * <br/>
       * <style>
       *   table, th, td {
       *     border-style: solid;
       *     border-width: 1px;
       *     text-align: left;
       *   }
       * </style>
       * <table>
       * <tbody><tr>
       *   <th>Returns</th>
       *   <th colspan="2">&nbsp;</th>
       * </tr>
       * <tr>
       *   <td class="centre">1</td>
       *   <td>
       *     If the value of this {@link module:util-x~bigobject Big number} is greater than the value of
       *     <code>n</code>
       *   </td>
       * </tr>
       * <tr>
       *   <td class="centre">-1</td>
       *   <td>
       *     If the value of this {@link module:util-x~bigobject Big number} is less than the value of
       *     <code>n</code>
       *   </td>
       * </tr>
       * <tr>
       *   <td class="centre">0</td>
       *   <td>If this {@link module:util-x~bigobject Big number} and <code>n</code> have the same value</td>
       * </tr>
       * </tbody></table>
       *
       * @memberOf Big.prototype
       * @name cmp
       * @function
       * @param {module:util-x~validNumeric} y A numeric value.
       * @throws {Error} NaN if y is invalid.
       * @return {number} One of these values: -1, 0, 1
       *
       * @example <caption>Example usage.</caption>
       * x = new Big(6)
       * y = new Big(5)
       * x.cmp(y)                   // 1
       * y.cmp(x.minus(1))          // 0
       */
      $defineProperty(Big.prototype, 'cmp', {
        value: function (y) {
          return $call(cmp, this, y);
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * Returns a {@link module:util-x~bigobject Big number} whose value is the value of
       * this {@link module:util-x~bigobject Big number} divided by y.<br/>
       * <br/>
       * If the result has more fraction digits than is specified by {@link Big.DP},
       * it will be rounded to {@link Big.DP} decimal places using rounding mode
       * {@link Big.RM}.<br/
       *
       * @memberOf Big.prototype
       * @name div
       * @function
       * @param {...module:util-x~validNumeric} y A numeric value.
       * @throws {Error} NaN if y is invalid.
       * @throws {Error} INFINITY on division by zero.
       * @throws {Error} NaN on division of zero by zero.
       * @throws {Error} '!Big.DP!' if {@link Big.DP} not an integer or not in integer range
       * @return {module:util-x~bigobject} {@link module:util-x~bigobject this} / y.
       *
       * @example <caption>Example usage.</caption>
       * x = new Big(355)
       * y = new Big(113)
       * x.div(y)                   // '3.14159292035398230088'
       * Big.DP = 2
       * x.div(y)                   // '3.14'
       * x.div(5)                   // '71'
       */
      $defineProperty(Big.prototype, 'div', {
        value: function () {
          return forArgs(arguments, div, this);
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * Returns true if the value of this {@link module:util-x~bigobject Big number}
       * equals the value of y, otherwise returns false.
       *
       * @memberOf Big.prototype
       * @name eq
       * @function
       * @param {module:util-x~validNumeric} y A numeric value.
       * @throws {Error} NaN if y is invalid.
       * @return {boolean} {@link module:util-x~bigobject this} === y
       *
       * @example <caption>Example usage.</caption>
       * 0 === 1e-324               // true
       * x = new Big(0)
       * x.eq('1e-324')             // false
       * Big(-0).eq(x)              // true  ( -0 === 0 )
       */
      $defineProperty(Big.prototype, 'eq', {
        value: function (y) {
          return !$call(cmp, this, y);
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * Returns true if the value of this {@link module:util-x~bigobject Big number} is
       * greater than the value of y, otherwise returns false.
       *
       * @memberOf Big.prototype
       * @name gt
       * @function
       * @param {module:util-x~validNumeric} y A numeric value.
       * @throws {Error} NaN if y is invalid.
       * @return {boolean} {@link module:util-x~bigobject this} > y
       *
       * @example <caption>Example usage.</caption>
       * 0.1 > 0.3 - 0.2              // true
       * x = new Big(0.1)
       * x.gt(Big(0.3).minus(0.2))    // false
       * Big(0).gt(x)                 // false
       */
      $defineProperty(Big.prototype, 'gt', {
        value: function (y) {
          return $call(cmp, this, y) > 0;
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * Returns true if the value of this {@link module:util-x~bigobject Big number} is
       * greater than or equal to the value of y, otherwise returns false.
       *
       * @memberOf Big.prototype
       * @name gte
       * @function
       * @param {module:util-x~validNumeric} y A numeric value.
       * @throws {Error} NaN if y is invalid.
       * @return {boolean} {@link module:util-x~bigobject this} >= y
       *
       * @example <caption>Example usage.</caption>
       * 0.3 - 0.2 >= 0.1               // false
       * x = new Big(0.3).minus(0.2)
       * x.gte(0.1)                     // true
       * Big(1).gte(x)                  // true
       */
      $defineProperty(Big.prototype, 'gte', {
        value: function (y) {
          return $call(cmp, this, y) > -1;
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * Returns true if the value of this {@link module:util-x~bigobject Big number} is less than the value of y,
       * otherwise returns false.
       *
       * @memberOf Big.prototype
       * @name lt
       * @function
       * @param {module:util-x~validNumeric} y A numeric value.
       * @throws {Error} NaN if y is invalid.
       * @return {boolean} {@link module:util-x~bigobject this} < y
       *
       * @example <caption>Example usage.</caption>
       * 0.3 - 0.2 < 0.1                // true
       * x = new Big(0.3).minus(0.2)
       * x.lt(0.1)                      // false
       * Big(0).lt(x)                   // true
       */
      $defineProperty(Big.prototype, 'lt', {
        value: function (y) {
          return $call(cmp, this, y) < 0;
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * Returns true if the value of this {@link module:util-x~bigobject Big number} is
       * less than or equal to the value of y, otherwise returns false.
       *
       * @memberOf Big.prototype
       * @name lte
       * @function
       * @param {module:util-x~validNumeric} y A numeric value.
       * @throws {Error} NaN if y is invalid.
       * @return {boolean} {@link module:util-x~bigobject this} <= y
       *
       * @example <caption>Example usage.</caption>
       * 0.1 <= 0.3 - 0.2               // false
       * x = new Big(0.1)
       * x.lte(Big(0.3).minus(0.2))     // true
       * Big(-1).lte(x)                 // true
       */
      $defineProperty(Big.prototype, 'lte', {
        value: function (y) {
          return $call(cmp, this, y) < 1;
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * Returns a {@link module:util-x~bigobject Big number} whose value is the value of this
       * {@link module:util-x~bigobject Big number} minus y.
       *
       * @memberOf Big.prototype
       * @name minus
       * @function
       * @param {...module:util-x~validNumeric} y A numeric value.
       * @throws {Error} NaN if y is invalid.
       * @return {module:util-x~bigobject} {@link module:util-x~bigobject this} - y
       *
       * @example <caption>Example usage.</caption>
       * 0.3 - 0.1                  // 0.19999999999999998
       * x = new Big(0.3)
       * x.minus(0.1)               // '0.2'
       */
      $defineProperty(Big.prototype, 'minus', {
        value: function () {
          return forArgs(arguments, minus, this);
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * An alias for {@link Big#minus}
       * @memberOf Big.prototype
       * @name sub
       * @function
       * @borrows Big#minus as sub
       */
      $defineProperty(Big.prototype, 'sub', {
        value: function () {
          return $apply(Big.prototype.minus, this, arguments);
        },
        writable: false,
        configurable: false,
        enumerable: false
      });

      /**
       * Returns a {@link module:util-x~bigobject Big number} whose value is the value of this
       * {@link module:util-x~bigobject Big number} modulo y, i.e. the integer remainder of dividing this
       * {@link module:util-x~bigobject Big number} by y.<br/>
       * <br/>
       * The result will have the same sign as this {@link module:util-x~bigobject Big number},
       * and it will match that of
       * {@link http://www.ecma-international.org/ecma-262/5.1/#sec-11.5.3 Javascript's % operator}
       * (within the limits of its precision) and BigDecimal's remainder method.
       *
       * @memberOf Big.prototype
       * @name mod
       * @function
       * @param {...module:util-x~validNumeric} y A numeric value.
       * @throws {Error} NaN if y is negative or otherwise invalid.
       * @return {module:util-x~bigobject} {@link module:util-x~bigobject this} % y
       *
       * @example <caption>Example usage.</caption>
       * 1 % 0.9                    // 0.09999999999999998
       * x = new Big(1)
       * x.mod(0.9)                 // '0.1'
       */
      $defineProperty(Big.prototype, 'mod', {
        value: function () {
          return forArgs(arguments, mod, this);
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * Returns a {@link module:util-x~bigobject Big number} whose value is the value of this
       * {@link module:util-x~bigobject Big number} plus y.
       *
       * @memberOf Big.prototype
       * @name plus
       * @function
       * @param {...module:util-x~validNumeric} y A numeric value.
       * @throws {Error} NaN if y is invalid.
       * @return {module:util-x~bigobject} {@link module:util-x~bigobject this} + y
       *
       * @example <caption>Example usage.</caption>
       * 0.1 + 0.2                  // 0.30000000000000004
       * x = new Big(0.1)
       * y = x.plus(0.2)            // '0.3'
       * Big(0.7).plus(x).plus(y)   // '1'
       */
      $defineProperty(Big.prototype, 'plus', {
        value: function () {
          return forArgs(arguments, plus, this);
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * An alias for {@link Big#plus}
       * @memberOf Big.prototype
       * @name add
       * @function
       * @borrows Big#plus as add
       */
      $defineProperty(Big.prototype, 'add', {
        value: function () {
          return $apply(Big.prototype.plus, this, arguments);
        },
        writable: false,
        configurable: false,
        enumerable: false
      });

      /**
       * Returns a {@link module:util-x~bigobject Big number} whose value is the value of this
       * {@link module:util-x~bigobject Big number} raised to the power exp.<br/>
       * <br/>
       * If exp is negative and the result has more fraction digits than is specified
       * by {@link Big.DP}, it will be rounded to {@link Big.DP} decimal places using
       * rounding mode {@link Big.RM}.<br/>
       * <br/>
       * Note: High value exponents may cause this method to be slow to return.
       *
       * @memberOf Big.prototype
       * @name pow
       * @function
       * @param {number} exp Integer, Negative -1e+6 to positive 1e+6 inclusive.
       * @throws {module:util-x~bigerror} !pow! if exp is invalid.
       * @return {module:util-x~bigobject} {@link module:util-x~bigobject this} ^ y
       *
       * @example <caption>Example usage.</caption>
       * Math.pow(0.7, 2)           // 0.48999999999999994
       * x = new Big(0.7)
       * x.pow(2)                   // '0.49'
       * Big.DP = 20
       * Big(3).pow(-2)             // '0.11111111111111111111'
       * new Big(123.456).pow(1000).toString().length     // 5099
       * new Big(2).pow(1e+6)       // Time taken (Node.js): 9 minutes 34 secs.
       */
      $defineProperty(Big.prototype, 'pow', {
        value: function (exp) {
          var x = this,
            one = new this.constructor(1),
            y = one,
            isNeg = exp < 0,
            test;

          if (!isIntegerInRange(exp, -MAX_POWER, MAX_POWER)) {
            throw new BigError('!pow!');
          }

          if (isNeg) {
            exp = -exp;
          }

          do {
            /*jslint bitwise: true */
            test = exp & 1;
            /*jslint bitwise: false */
            if (test) {
              y = $call(times, y, x);
            }

            /*jslint bitwise: true */
            exp >>= 1;
            /*jslint bitwise: false */
            if (exp) {
              x = $call(times, x, x);
            }
          } while (exp);

          if (isNeg) {
            return $call(div, one, y);
          }

          return y;
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * Returns a {@link module:util-x~bigobject Big number} whose value is the value of this
       * {@link module:util-x~bigobject Big number} rounded using rounding mode rm to a maximum of
       * dp decimal places.<br/>
       * <br/>
       * If dp is omitted or is null,
       * the return {@link module:util-x~bigobject Big number} is rounded to a whole number.
       * <br/>
       * If rm is omitted, the current {@link Big.RM} setting is used.
       *
       * @memberOf Big.prototype
       * @name round
       * @function
       * @param {?number} [dp] Integer, 0 to 1e+6 inclusive.
       * @param {number} [rm] 0, 1, 2 or 3 (ROUND_DOWN, ROUND_HALF_UP, ROUND_HALF_EVEN, ROUND_UP)
       * @throws {module:util-x~bigerror} !round! if dp is invalid.
       * @throws {module:util-x~bigerror} !Big.RM! if rm is invalid.
       * @return {module:util-x~bigobject} A rounded value of this.
       *
       * @example <caption>Example usage.</caption>
       * x = 123.45
       * Math.round(x)              // 123
       * y = new Big(x)
       * y.round()                  // '123'
       * y.round(2)                 // '123.45'
       * y.round(10)                // '123.45'
       * y.round(1, 0)              // '123.4'
       * y.round(1, 1)              // '123.5'
       * y.round(1, 2)              // '123.4'
       * y.round(1, 3)              // '123.5'
       * y                          // '123.45'
       */
      $defineProperty(Big.prototype, 'round', {
        value: function (dp, rm) {
          var length = $toLength(arguments.length);

          if (length === 0 || dp === null) {
            dp = 0;
          } else if (!isIntegerInRange(dp, 0, MAX_DP)) {
            throw new BigError('!round!');
          }

          if (length < 2) {
            rm = this.constructor.RM;
          }

          return $call(rnd, new this.constructor(this), dp, rm);
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * Returns a {@link module:util-x~bigobject Big number} whose value is the square root
       * of this {@link module:util-x~bigobject Big number}.<br/>
       * <br/>
       * If the result has more fraction digits than is specified by {@link Big.DP},
       * it will be rounded to {@link Big.DP} decimal places using rounding mode
       * {@link Big.RM}.
       *
       * @memberOf Big.prototype
       * @name sqrt
       * @function
       * @throws {module:util-x~bigerror} NaN if this {@link module:util-x~bigobject Big number} is negative.
       * @return {module:util-x~bigobject} The square root of this.
       *
       * @example <caption>Example usage.</caption>
       * x = new Big(16)
       * x.sqrt()                   // '4'
       * y = new Big(3)
       * y.sqrt()                   // '1.73205080756887729353'
       */
      $defineProperty(Big.prototype, 'sqrt', {
        value: function () {
          var estimate,
            r,
            approx,
            xc = this.c,
            i,
            e,
            half,
            test,
            dp;

          // Zero?
          if (!xc[0]) {
            return new this.constructor(this);
          }

          i = this.s;
          // If negative, throw NaN.
          if (i < 0) {
            throw new BigError(NaN);
          }

          // Estimate.
          i = $sqrt($call(bigToString, this));
          // Math.sqrt underflow/overflow?
          // Pass x to Math.sqrt as integer, then adjust the result exponent.
          if (i === 0 || i === INFINITY) {
            estimate = $join(xc, '');
            /*jslint bitwise: true */
            test = estimate.length + e & 1;
            /*jslint bitwise: false */
            if (!test) {
              estimate += '0';
            }

            r = new this.constructor($toString($sqrt(estimate)));
            e = this.e;
            /*jslint bitwise: true */
            r.e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
            /*jslint bitwise: false */
          } else {
            r = new this.constructor($toString(i));
          }

          dp = this.constructor.DP + 4;
          i = r.e + dp;
          half = new this.constructor('0.5');
          // Newton-Raphson iteration.
          do {
            approx = r;
            r = $call(times, half, $call(plus, approx, $call(div, this, approx, dp)));
          } while ($join($slice(approx.c, 0, i), '') !== $join($slice(r.c, 0, i), ''));

          return $call(rnd, r, this.constructor.DP, this.constructor.RM);
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * Returns a new {@link module:util-x~bigobject Big number} whose value is the value of this
       * {@link module:util-x~bigobject Big number} times the value of y.
       *
       * @memberOf Big.prototype
       * @name times
       * @function
       * @param {...module:util-x~validNumeric} y A numeric value.
       * @throws {Error} NaN if y is invalid.
       * @return {module:util-x~bigobject} {@link module:util-x~bigobject this} * y
       *
       * @example <caption>Example usage.</caption>
       * 0.6 * 3                    // 1.7999999999999998
       * x = new Big(0.6)
       * y = x.times(3)             // '1.8'
       * Big('7e+500').times(y)     // '1.26e+501'
       */
      $defineProperty(Big.prototype, 'times', {
        value: function () {
          return forArgs(arguments, times, this);
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * An alias for {@link Big#times}
       * @memberOf Big.prototype
       * @name mul
       * @function
       * @borrows Big#times as mul
       */
      $defineProperty(Big.prototype, 'mul', {
        value: function () {
          return $apply(Big.prototype.times, this, arguments);
        },
        writable: false,
        configurable: false,
        enumerable: false
      });

      /**
       * Returns a string representing the value of this {@link module:util-x~bigobject Big number}.<br/>
       * <br/>
       * If this {@link module:util-x~bigobject Big number} has a positive exponent that is equal to or
       * greater than 21, or a negative exponent equal to or less than -7,
       * then exponential notation is returned.<br/>
       * <br/>
       * The point at which {@link Big#toString} returns exponential rather than normal
       * notation can be adjusted by changing the value of TO_EXP_POS and TO_EXP_NEG in the
       * EDITABLE DEFAULTS section at the top of the source code file. By default,
       * {@link module:util-x~bigobject Big numbers} correspond to {@link number Javascript's number type}
       * in this regard.
       *
       * @memberOf Big.prototype
       * @name toString
       * @function
       * @return {string} A string representation of this.
       *
       * @example <caption>Example usage.</caption>
       * x = new Big('9.99e+20')
       * x.toString()               // '999000000000000000000'
       * y = new Big('1E21')
       * y.toString()               // '1e+21'
       */
      $defineProperty(Big.prototype, 'toString', {
        value: function () {
          return $call(bigToString, this);
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * Returns a string representing the value of this {@link module:util-x~bigobject Big number}.<br/>
       * <br/>
       * If this {@link module:util-x~bigobject Big number} has a positive exponent that is equal to or
       * greater than 21, or a negative exponent equal to or less than -7,
       * then exponential notation is returned.<br/>
       * <br/>
       * The point at which {@link Big#toString} returns exponential rather than normal
       * notation can be adjusted by changing the value of TO_EXP_POS and TO_EXP_NEG in the
       * EDITABLE DEFAULTS section at the top of the source code file. By default,
       * {@link module:util-x~bigobject Big numbers} correspond to {@link number Javascript's number type}
       * in this regard, except a minus zero will be represented as '-0'.
       *
       * @memberOf Big.prototype
       * @name valueOf
       * @function
       * @return {string} A string representation of this.
       *
       * @example <caption>Example usage.</caption>
       * x = new Big('177.7e+457')
       * x.valueOf()                // '1.777e+459'
       */
      $defineProperty(Big.prototype, 'valueOf', {
        value: function () {
          return $call(bigToString, this, true);
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * Returns a string representing the value of this {@link module:util-x~bigobject Big number}.<br/>
       * <br/>
       * If this {@link module:util-x~bigobject Big number} has a positive exponent that is equal to or
       * greater than 21, or a negative exponent equal to or less than -7,
       * then exponential notation is returned.<br/>
       * <br/>
       * The point at which {@link Big#toString} returns exponential rather than normal
       * notation can be adjusted by changing the value of TO_EXP_POS and TO_EXP_NEG in the
       * EDITABLE DEFAULTS section at the top of the source code file. By default,
       * {@link module:util-x~bigobject Big numbers} correspond to {@link number Javascript's number type}
       * in this regard, except a minus zero will be represented as '-0'.
       *
       * @memberOf Big.prototype
       * @name toJSON
       * @function
       * @return {string} A string representation of this.
       *
       * @example <caption>Example usage.</caption>
       * x = new Big('177.7e+457')
       * y = new Big(235.4325)
       * z = new Big('0.0098074')
       * str = JSON.stringify( [x, y, z] )
       * JSON.parse( str, function ( k, v ) { return k === '' ? v : new Big(v) } )
       * // Returns an array of three Big numbers.
       */
      $defineProperty(Big.prototype, 'toJSON', {
        value: function () {
          return $call(bigToString, this, true);
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /*
       ***************************************************************************
       * If toExponential, toFixed, toPrecision and format are not required they
       * can safely be commented-out or deleted. No redundant code will be left.
       * format is used only by toExponential, toFixed and toPrecision.
       ***************************************************************************
       */

      /**
       * Integer, 0 to 1e+6 inclusive<br/>
       * <br/>
       * Returns a string representing the value of this {@link module:util-x~bigobject Big number}
       * in exponential notation to a fixed number of decimal places dp.<br/>
       * <br/>
       * If the value of this {@link module:util-x~bigobject Big number} in exponential notation has
       * more digits to the right of the decimal point than is specified by dp, the return
       * value will be rounded to dp decimal places using rounding mode {@link Big.RM}.<br/>
       * <br/>
       * If the value of this {@link module:util-x~bigobject Big number} in exponential notation
       * has fewer digits to the right of the decimal point than is specified by dp, the
       * return value will be appended with zeros accordingly.<br/>
       * <br/>
       * If dp is omitted, the number of digits after the decimal
       * point defaults to the minimum number of digits necessary to represent the value
       * exactly.
       *
       * @memberOf Big.prototype
       * @name toExponential
       * @function
       * @param {number} [dp] Integer, 0 to 1e+6 inclusive.
       * @throws {module:util-x~bigerror} !toExp! if dp is invalid.
       * @return {string} A string representation of this.
       *
       * @example <caption>Example usage.</caption>
       * x = 45.6
       * y = new Big(x)
       * x.toExponential()          // '4.56e+1'
       * y.toExponential()          // '4.56e+1'
       * x.toExponential(0)         // '5e+1'
       * y.toExponential(0)         // '5e+1'
       * x.toExponential(1)         // '4.6e+1'
       * y.toExponential(1)         // '4.6e+1'
       * x.toExponential(3)         // '4.560e+1'
       * y.toExponential(3)         // '4.560e+1'
       */
      $defineProperty(Big.prototype, 'toExponential', {
        value: function (dp) {
          if ($toLength(arguments.length) === 0) {
            dp = $toLength(this.c.length) - 1;
          } else if (!isIntegerInRange(dp, 0, MAX_DP)) {
            throw new BigError('!toExp!');
          }

          return $call(format, this, dp, 1);
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * Integer, 0 to 1e+6 inclusive<br/>
       * <br/>
       * Returns a string representing the value of this {@link module:util-x~bigobject Big number}
       * in normal notation to a fixed number of decimal places dp.<br/>
       * <br/>
       * If the value of this {@link module:util-x~bigobject Big number} in normal notation has more
       * digits to the right of the decimal point than is specified by dp, the return value
       * will be rounded to dp decimal places using rounding mode {@link Big.RM}.<br/>
       * <br/>
       * If the value of this {@link module:util-x~bigobject Big number} in normal notation has fewer
       * fraction digits then is specified by dp, the return value will be appended with zeros
       * accordingly.<br/>
       * <br/>
       * Unlike
       * {@link http://www.ecma-international.org/ecma-262/5.1/#sec-15.7.4.5 Number.prototype.toFixed},
       * which returns exponential notation if a number is
       * greater or equal to 1021, this method will always return normal notation.<br/>
       * <br/>
       * If dp is omitted, then the return value is simply the value
       * in normal notation. This is also unlike
       * {@link http://www.ecma-international.org/ecma-262/5.1/#sec-15.7.4.5 Number.prototype.toFixed},
       * which returns the value to zero decimal places.
       *
       * @memberOf Big.prototype
       * @name toFixed
       * @function
       * @param {number} [dp] Integer, 0 to 1e+6 inclusive.
       * @throws {module:util-x~bigerror} !toFix! if dp is invalid.
       * @return {string} A string representation of this.
       *
       * @example <caption>Example usage.</caption>
       * x = 45.6
       * y = new Big(x)
       * x.toFixed()                // '46'
       * y.toFixed()                // '45.6'
       * y.toFixed(0)               // '46'
       * x.toFixed(3)               // '45.600'
       * y.toFixed(3)               // '45.600'
       */
      $defineProperty(Big.prototype, 'toFixed', {
        value: function (dp) {
          var preventExp = true,
            str;

          // Prevent the possibility of exponential notation.
          if ($toLength(arguments.length) === 0) {
            str = $call(bigToString, this, false, preventExp);
          } else if (isIntegerInRange(dp, 0, MAX_DP)) {
            str = $call(format, this, this.e + dp, null, preventExp);
            // (-0).toFixed() is '0', but (-0.1).toFixed() is '-0'.
            // (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
            if (this.s < 0 && this.c[0] && $call(pSIndexOf, str, '-') < 0) {
              //E.g. -0.5 if rounded to -0 will cause toString to omit the minus sign.
              str = '-' + str;
            }
          }

          if (!str) {
            throw new BigError('!toFix!');
          }

          return str;
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * Integer, 1 to 1e+6 inclusive<br/>
       * <br/>
       * Returns a string representing the value of this {@link module:util-x~bigobject Big number}
       * to the specified number of significant digits sd.<br/>
       * <br/>
       * If the value of this {@link module:util-x~bigobject Big number} has more digits than is
       * specified by sd, the return value will be rounded to sd significant digits using
       * rounding mode {@link Big.RM}.<br/>
       * <br/>
       * If the value of this {@link module:util-x~bigobject Big number} has fewer digits than is specified by sd,
       * the return value will be appended with zeros accordingly.<br/>
       * <br/>
       * If sd is less than the number of digits necessary to represent the integer part
       * of the value in normal notation, then exponential notation is used.<br/>
       * <br/>
       * If sd is omitted, then the return value is the same as {@link Big#toString}.
       *
       * @memberOf Big.prototype
       * @name toPrecision
       * @function
       * @param {number} sd Integer, 1 to MAX_DP inclusive.
       * @throws {module:util-x~bigerror} !toPre! if sd is invalid.
       * @return {string} A string representation of this.
       *
       * @example <caption>Example usage.</caption>
       * x = 45.6
       * y = new Big(x)
       * x.toPrecision()            // '45.6'
       * y.toPrecision()            // '45.6'
       * x.toPrecision(1)           // '5e+1'
       * y.toPrecision(1)           // '5e+1'
       * x.toPrecision(5)           // '45.600'
       * y.toPrecision(5)           // '45.600'
       */
      $defineProperty(Big.prototype, 'toPrecision', {
        value: function (sd) {
          if ($toLength(arguments.length) === 0) {
            return $call(bigToString, this);
          }

          if (!isIntegerInRange(sd, 1, MAX_DP)) {
            throw new BigError('!toPre!');
          }

          return $call(format, this, sd - 1, 2);
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * Read only member (in ECMA5 environment) with the value '[object Big]'.<br/>
       * <br/>
       * Used by {@link Big.isBig} to determine if the object is
       * a {@link module:util-x~bigobject Big number}.
       *
       * @memberOf Big.prototype
       * @readonly
       * @name classId
       * @type {string}
       */
      $defineProperty(Big.prototype, 'classId', {
        value: bigClassID,
        writable: false,
        configurable: false,
        enumerable: false
      });

      /**
       * The maximum number of decimal places of the results of operations involving division.<br/>
       * It is relevant only to the {@link Big#div} and {@link Big#sqrt} methods,
       * and the {@link Big#pow} method when the exponent is negative.<br/>
       * <br/>
       * Integer, 0 to 1e+6 inclusive<br/>
       * <br/>
       * Default value: 20<br/>
       * <br/>
       * The value will be checked for validity when one of the above methods is called.<br/>
       * <br/>
       * !Big.DP! will be thrown if the value is found to be invalid.
       *
       * @memberOf Big
       * @name DP
       * @type {number}
       *
       * @example <caption>Example usage.</caption>
       * Big.DP = 40
       */
      $defineProperty(Big, 'DP', {
        value: DP,
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * The rounding mode used in the above operations and by {@link Big#round},
       * {@link Big#toExponential}, {@link Big#toFixed}
       * and {@link Big#toPrecision}.<br/>
       * <br/>
       * 0, 1, 2 or 3<br/>
       * <br/>
       * Default value: 1<br/>
       * <br/>
       * <style>
       *   table, th, td {
       *     border-style: solid;
       *     border-width: 1px;
       *     text-align: left;
       *   }
       * </style>
       * <table>
       * <tbody><tr>
       *   <th>Value</th>
       *   <th>Description</th>
       *   <th>BigDecimal equivalent</th>
       * </tr>
       * <tr>
       *   <td class="centre">0</td>
       *   <td>
       *     Rounds towards zero.<br>
       *     I.e. truncate, no rounding.
       *   </td>
       *   <td id="round-down">ROUND_DOWN</td>
       * </tr>
       * <tr>
       *   <td class="centre">1</td>
       *   <td>
       *     Rounds towards nearest neighbour.<br>
       *     If equidistant, rounds away from zero.
       *   </td>
       *   <td id="round-half-up">ROUND_HALF_UP</td>
       * </tr>
       * <tr>
       *   <td class="centre">2</td>
       *   <td>
       *     Rounds towards nearest neighbour.<br>
       *     If equidistant, rounds towards even neighbour.
       *   </td>
       *   <td id="round-half-even">ROUND_HALF_EVEN</td>
       * </tr>
       * <tr>
       *   <td class="centre">3</td>
       *   <td>Rounds away from zero.</td>
       *   <td id="round-up">ROUND_UP</td>
       * </tr>
       * </tbody></table>
       * <br/>
       * The value will be checked for validity when one of the above methods is called.<br/>
       * <br/>
       * !Big.RM! will be thrown if the value is found to be invalid.
       *
       * @memberOf Big
       * @name RM
       * @type {number}
       *
       * @example <caption>Example usage.</caption>
       * Big.RM = 0
       */
      $defineProperty(Big, 'RM', {
        value: RM,
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * Read only member (in ECMA5 environment) for use in identifying the
       * source version number of {@link Big} constructors.
       * @memberOf Big
       * @readonly
       * @name version
       * @type {string}
       * @default '0.2.0'
       *
       * @example <caption>Example usage.</caption>
       * log(Big.version);             // Displays: '0.2.0'
       */
      $defineProperty(Big, 'version', {
        value: '0.2.0',
        writable: false,
        configurable: false,
        enumerable: false
      });

      /**
       * Read only member (in ECMA5 environment) for use in identifying the
       * source version number of {@link Big} constructors.
       * @memberOf Big.prototype
       * @readonly
       * @name version
       * @type {string}
       * @default '0.2.0'
       *
       * @example <caption>Example usage.</caption>
       * var y = new Big('Hello');
       * log(y.constructor.version);   // Displays: '0.2.0'
       */
      $defineProperty(Big.prototype, 'version', {
        value: '0.2.0',
        writable: false,
        configurable: false,
        enumerable: false
      });

      /**
       * Determines if an object is a {@link module:util-x~bigobject Big number}.
       *
       * @memberOf Big
       * @name isBig
       * @function
       * @param {*} inputArg The argument to be tested to see if it is a {@link module:util-x~bigobject Big number}.
       * @return {boolean} True if inputArg is a {@link module:util-x~bigobject Big number} otherwise false.
       *
       * @example <caption>Example usage.</caption>
       * Big1 = Big()
       * x = 123
       * y = new Big1(x)
       * Big.isBig(x)                         // false
       * Big.isBig(y)                         // true
       * Big.isBigSibling(new BigNumber(1))   // false
       * Big.isBigSibling(new Decimal(1))     // false
       */
      $defineProperty(Big, 'isBig', {
        value: function (inputArg) {
          return $isInstance(inputArg, Big);
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * Determines if an object is a an object created by one of its sibling libraries.
       *
       * @memberOf Big
       * @name isBigSibling
       * @function
       * @param {*} inputArg The argument to be tested to see if it is a sibling object.
       * @return {boolean} True if inputArg is a sibling object, otherwise false.
       *
       * @example <caption>Example usage.</caption>
       * Big1 = Big()
       * x = 123
       * y = new Big1(x)
       * Big.isBigSibling(x)                  // false
       * Big.isBigSibling(y)                  // false
       * Big.isBigSibling(new BigNumber(1))   // true
       * Big.isBigSibling(new Decimal(1))     // true
       *
       * @see https://github.com/MikeMcl/bignumber.js/
       * @see https://github.com/MikeMcl/decimal.js/
       */
      $defineProperty(Big, 'isBigSibling', {
        value: function (inputArg) {
          return !$isInstance(inputArg, Big) && isBigDuck(inputArg);
        },
        writable: true,
        configurable: true,
        enumerable: false
      });

      /**
       * The custom error constructor.
       *
       * @memberOf Big
       * @constructor BigError
       * @readonly
       * @param {*} [message] Human-readable description of the error.
       * @return {module:util-x~bigerror}
       *
       * @example <caption>Example usage.</caption>
       * try {
       *     throw new Big.BigError('Test');
       * } catch (e) {
       *     // e.name = 'BigError'
       *     // e.message = 'Test'
       * }
       *
       * try {
       *     throw new Big.BigError(NaN);
       * } catch (e) {
       *     // e.name = 'BigError'
       *     // e.message = '"NaN"'
       * }
       */
      $defineProperty(Big, 'BigError', {
        value: BigError,
        writable: false,
        configurable: false,
        enumerable: false
      });

      return Big;
    }

    /**
     * Internal copy of {@link Big}
     *
     * @private
     * @constructor
     * @augments Big
     */
    BigNum = bigFactory();
  }());

  (function () {
    var maxMessageLength = 128,
      assertCustomError = exports.customError('AssertionError', maxMessageLength),
      assertClassId = '[object AssertionError]';

    /**
     * The AssertionError constructor.
     *
     * @constructor module:util-x~AssertionError
     * @augments CustomError
     * @param {object} opts
     */
    function AssertionError(opts) {
      var rtn;

      // Enable constructor usage without new.
      if (!$isInstance(this, AssertionError)) {
        rtn = new AssertionError(opts);
      } else {
        if (!$isPlainObject(opts)) {
          opts = {};
        }

        if (typeof opts.message !== 'string') {
          opts.message = '';
        }

        if (typeof opts.operator !== 'string') {
          opts.operator = '';
        }

        if (!$isFunction(opts.stackStartFn)) {
          opts.stackStartFn = AssertionError;
        }

        $call(assertCustomError, this, opts.message, opts.stackStartFn);
        $defineProperties(this, {
          actual: $assign({
            value: opts.actual
          }, propNotEnumerable),

          expected: $assign({
            value: opts.expected
          }, propNotEnumerable),

          operator: $assign({
            value: opts.operator
          }, propNotEnumerable)
        });
      }

      return rtn;
    }

    $defineProperties(AssertionError, {
      /**
       * @name module:util-x~AssertionError.version
       * @readonly
       * @const
       * @type {string}
       */
      version: $assign({
        value: '0.2.0'
      }, propConstant)
    });

    $inherits(AssertionError, assertCustomError);

    $defineProperties(AssertionError.prototype, {
      /**
       * @name module:util-x~AssertionError.prototype.classId
       * @readonly
       * @const
       * @type {string}
       */
      classId: $assign({
        value: assertClassId
      }, propConstant),

      /**
       * @name module:util-x~AssertionError.prototype.version
       * @readonly
       * @const
       * @type {string}
       */
      version: $assign({
        value: '0.2.0'
      }, propConstant),

      /**
       * @function module:util-x~AssertionError.prototype.toString
       * @return {string}
       */
      toString: $assign({
        value: function () {
          var theString;

          if (typeof this.message === 'string' && this.message.length) {
            theString = this.name + ': ' + $truncate(this.message, maxMessageLength);
          } else if ($isInstance(this, AssertionError)) {
            theString = this.name + ': ';
            theString += $truncate($stringify(this.actual, exports.customErrorReplacer), maxMessageLength) + ' ';
            theString += this.operator + ' ';
            theString += exports.String.truncate($stringify(this.expected, exports.customErrorReplacer), maxMessageLength);
          }

          return theString;
        }
      }, propNotEnumerable)
    });

    /**
     * Returns whether an exception is expected. Used by throws.
     *
     * @private
     * @function module:util-x~expectedException
     * @param {*} actual
     * @param {*} expected
     * @return {boolean}
     */
    function expectedException(actual, expected) {
      var storeState,
        val;

      /*jslint eqeq:true */
      /*jshint eqnull:true */
      if (actual == null) {
        return false;
      }

      /*jslint eqeq:true */
      /*jshint eqnull:true */
      if (expected == null) {
        return false;
      }

      if ($isRegExp(expected) && $instanceOf(actual, CError)) {
        storeState = exports.normaliseErrorIEToStringState();
        if (storeState === false) {
          exports.normaliseErrorIEToStringOn();
        }

        val = $toString(actual);
        if (storeState === false) {
          exports.normaliseErrorIEToStringOff();
        }

        return $test(expected, val);
      }

      if ($instanceOf(actual, expected)) {
        return true;
      }

      if ($isFunction(expected)) {
        storeState = exports.normaliseErrorIEToStringState();
        if (storeState === false) {
          exports.normaliseErrorIEToStringOn();
        }

        val = $call(expected, {}, actual);
        if (storeState === false) {
          exports.normaliseErrorIEToStringOff();
        }

        if (val === true) {
          return true;
        }
      }

      return false;
    }

    /**
     * Throws an exception that displays the values for actual and expected separated by the provided operator.
     *
     * @private
     * @function module:util-x~throwAssertionError
     * @param {*} actual
     * @param {*} expected
     * @param {string} message
     * @param {string} operator
     * @param {Function} [stackStartFn]
     * @return {undefined}
     */
    function throwAssertionError(actual, expected, message, operator, stackStartFn) {
      if (!$isFunction(stackStartFn)) {
        stackStartFn = throwAssertionError;
      }

      throw new AssertionError({
        message: message,
        actual: actual,
        expected: expected,
        operator: operator,
        stackStartFn: stackStartFn
      });
    }

    /**
     * Returns whether an exception is expected. Used by assert.throws and assert.doesNotThrow.
     *
     * @private
     * @function module:util-x~throws
     * @param {boolean} shouldThrow
     * @param {Function} block
     * @param {*} expected
     * @param {string} [message]
     * @param {Function} [stackStartFn]
     * @return {undefined}
     */
    function throws(shouldThrow, block, expected, message, stackStartFn) {
      var wasExceptionExpected,
        actual;

      if (!$isFunction(stackStartFn)) {
        if ($isFunction(message)) {
          stackStartFn = message;
          message = Undefined;
        } else {
          stackStartFn = throws;
        }
      }

      if ((typeof message !== 'string' || !message.length) && typeof expected === 'string') {
        message = expected;
        expected = null;
      }

      try {
        block();
      } catch (e) {
        actual = e;
      }

      wasExceptionExpected = expectedException(actual, expected);
      if (message) {
        message = ' ' + $toString(message);
      } else {
        message = '.';
      }

      if (expected && typeof expected.name === 'string' && !expected.name.length) {
        message = ' (' + expected.name + ').' + message;
      } else {
        message = '.' + message;
      }

      if (shouldThrow === true && !actual) {
        throwAssertionError(actual, expected, 'Missing expected exception' + message, Undefined, stackStartFn);
      }

      if (shouldThrow === false && wasExceptionExpected === true) {
        throwAssertionError(actual, expected, 'Got unwanted exception' + message, Undefined, stackStartFn);
      }

      if ((shouldThrow === true && actual && expected && wasExceptionExpected === false) || (shouldThrow === false && actual)) {
        throw actual;
      }
    }

    function assertFactory() {
      var assert = {};

      $defineProperties(assert, {
        AssertionError: $assign({
          /**
           * The AssertionError constructor.
           *
           * @constructor module:util-x~exports.assert.AssertionError
           * @augments CustomError
           * @readonly
           * @const
           * @param {object} opts
           */
          value: AssertionError
        }, propConstant),

        factory: $assign({
          /**
           * Create and return an independant copy of the {@link module:util-x~exports.assert} object.
           *
           * @function module:util-x~exports.assert.assertFactory
           * @readonly
           * @const
           * @return {object}
           */
          value: assertFactory
        }, propConstant),

        /**
         * Tests if value is truthy, it is equivalent to assert.equal(!!value, true, message);
         *
         * @function module:util-x~exports.assert.fail
         * @param {*} value
         * @param {string} message
         * @param {Function} [stackStartFn]
         * @return {undefined}
         */
        fail: $assign({
          value: function (actual, expected, message, stackStartFn) {
            throwAssertionError(actual, expected, message, 'fail', stackStartFn);
          }
        }, propNotEnumerable),

        /**
         * Tests if value is truthy, it is equivalent to assert.equal(!!value, true, message);
         *
         * @function module:util-x~exports.assert.ok
         * @param {*} value
         * @param {string} message
         * @param {Function} [stackStartFn]
         * @return {undefined}
         */
        ok: $assign({
          value: function (value, message, stackStartFn) {
            var pass = !!value;

            if (!pass) {
              throwAssertionError(pass, true, message, 'ok', stackStartFn);
            }
          }
        }, propNotEnumerable),

        /**
         * Tests if value is truthy, it is equivalent to assert.equal(!value, true, message);
         *
         * @function module:util-x~exports.assert.notOk
         * @param {*} value
         * @param {string} message
         * @param {Function} [stackStartFn]
         * @return {undefined}
         */
        notOk: $assign({
          value: function (value, message, stackStartFn) {
            var pass = !!value;

            if (pass) {
              throwAssertionError(pass, true, message, 'notOk', stackStartFn);
            }
          }
        }, propNotEnumerable),

        /**
         * Tests shallow, coercive equality with the equal comparison operator ( == ).
         *
         * @function module:util-x~exports.assert.equal
         * @param {*} actual
         * @param {*} expected
         * @param {string} message
         * @param {Function} [stackStartFn]
         * @return {undefined}
         */
        equal: $assign({
          value: function (actual, expected, message, stackStartFn) {
            /*jslint eqeq: true */
            if (actual != expected) {
              throwAssertionError(actual, expected, message, '==', stackStartFn);
            }
          }
        }, propNotEnumerable),

        /**
         * Tests shallow, coercive non-equality with the not equal comparison operator ( != ).
         *
         * @function module:util-x~exports.assert.notEqual
         * @param {*} actual
         * @param {*} expected
         * @param {string} message
         * @param {Function} [stackStartFn]
         * @return {undefined}
         */
        notEqual: $assign({
          value: function (actual, expected, message, stackStartFn) {
            /*jslint eqeq:true */
            if (actual == expected) {
              throwAssertionError(actual, expected, message, '!=', stackStartFn);
            }
          }
        }, propNotEnumerable),

        /**
         * Tests strict equality, as determined by the strict equality operator ( === ).
         *
         * @function module:util-x~exports.assert.strictEqual
         * @param {*} actual
         * @param {*} expected
         * @param {string} message
         * @param {Function} [stackStartFn]
         * @return {undefined}
         */
        strictEqual: $assign({
          value: function (actual, expected, message, stackStartFn) {
            if (actual !== expected) {
              throwAssertionError(actual, expected, message, '===', stackStartFn);
            }
          }
        }, propNotEnumerable),

        /**
         * Tests strict non-equality, as determined by the strict not equal operator ( !== ).
         *
         * @function module:util-x~exports.assert.notStrictEqual
         * @param {*} actual
         * @param {*} expected
         * @param {string} message
         * @param {string} operator
         * @param {Function} [stackStartFn]
         * @return {undefined}
         */
        notStrictEqual: $assign({
          value: function (actual, expected, message, stackStartFn) {
            if (actual === expected) {
              throwAssertionError(actual, expected, message, '!==', stackStartFn);
            }
          }
        }, propNotEnumerable),

        /**
         * Expects block to throw an error. error can be constructor, regexp or validation function.
         *
         * @function module:util-x~exports.assert.throws
         * @param {Function} block
         * @param {constructor|regexp|function} error
         * @param {string} message
         * @param {Function} [stackStartFn]
         * @return {undefined}
         */
        throws: $assign({
          value: function (block, error, message, stackStartFn) {
            throws(true, block, error, message, stackStartFn);
          }
        }, propNotEnumerable),

        /**
         * Expects block not to throw an error, see assert.throws for details.
         *
         * @function module:util-x~exports.assert.doesNotThrow
         * @param {Function} block
         * @param {string} message
         * @param {Function} [stackStartFn]
         * @return {undefined}
         */
        doesNotThrow: $assign({
          value: function (block, message, stackStartFn) {
            throws(false, block, message, stackStartFn);
          }
        }, propNotEnumerable),

        /**
         * Tests if value is not a falsy value, throws if it is a truthy value.
         * Useful when testing the first argument, error in callbacks.
         *
         * @function module:util-x~exports.assert.ifError
         * @param {*} err
         * @return {undefined}
         */
        ifError: $assign({
          value: function (err) {
            if (err) {
              throw err;
            }
          }
        }, propNotEnumerable),

        /**
         * Tests for deep equality, coercive equality with the equal comparison operator ( == ) and equivalent.
         *
         * @function module:util-x~exports.assert.deepEqual
         * @param {*} actual
         * @param {*} expected
         * @param {string} message
         * @param {Function} [stackStartFn]
         * @return {undefined}
         */
        deepEqual: $assign({
          value: function (actual, expected, message, stackStartFn) {
            if (!$deepEqual(actual, expected)) {
              throwAssertionError(actual, expected, message, 'deeptEqual', stackStartFn);
            }
          }
        }, propNotEnumerable),

        /**
         * Tests for deep inequality, coercive inequality with the not equal comparison operator ( != ) and equivalent.
         *
         * @function module:util-x~exports.assert.notDeepEqual
         * @param {*} actual
         * @param {*} expected
         * @param {string} message
         * @param {Function} [stackStartFn]
         * @return {undefined}
         */
        notDeepEqual: $assign({
          value: function (actual, expected, message, stackStartFn) {
            if ($deepEqual(actual, expected)) {
              throwAssertionError(actual, expected, message, 'notDeepEqual', stackStartFn);
            }
          }
        }, propNotEnumerable),

        /**
         * Tests for deep strict equality, equality with the strict equal comparison operator
         * ( === ) and equivalent.
         *
         * @function module:util-x~exports.assert.deepStrictEqual
         * @param {*} actual
         * @param {*} expected
         * @param {string} message
         * @param {Function} [stackStartFn]
         * @return {undefined}
         */
        deepStrictEqual: $assign({
          value: function (actual, expected, message, stackStartFn) {
            if (!$deepStrictEqual(actual, expected)) {
              throwAssertionError(actual, expected, message, 'deepStrictEqual', stackStartFn);
            }
          }
        }, propNotEnumerable),

        /**
         * Tests for deep strict inequality, inequality with the strict not equal comparison operator
         * ( !== ) and equivalent.
         *
         * @function module:util-x~exports.assert.notDeepStrictEqual
         * @param {*} actual
         * @param {*} expected
         * @param {string} message
         * @param {Function} [stackStartFn]
         * @return {undefined}
         */
        notDeepStrictEqual: $assign({
          value: function (actual, expected, message, stackStartFn) {
            if ($deepStrictEqual(actual, expected)) {
              throwAssertionError(actual, expected, message, 'notDeepStrictEqual', stackStartFn);
            }
          }
        }, propNotEnumerable)
      });

      return assert;
    }

    /**
     * @name module:util-x~exports.assert
     * @namespace
     */
    exports.assert = assertFactory();
  }());

  /**
   * Applies utilx to the native objects.
   *
   * @function module:util-x~exports.goNative
   */
  exports.goNative = function () {
    var utilx = exports.factory();

    $forEach($objectKeys(exports), function (key1) {
      if (key1 === 'Big' || key1 === 'assert') {
        return;
      }

      if ($isPlainObject(utilx[key1])) {
        $forEach($objectKeys(exports[key1]), function (key2) {
          if (!$isPlainObject(exports[key1][key2])) {
            if (exports[key1][key2] !== base[key1][key2]) {
              if (!(exports.Number.isNaN(utilx[key1][key2]) && exports.Number.isNaN(base[key1][key2]))) {
                $conlog(key1 + '.' + key2);
                $defineProperty(global[key1], key2, $assign({
                  value: utilx[key1][key2]
                }, propNotEnumerable));
              }
            }
          }

          if ($isPlainObject(exports[key1][key2])) {
            $forEach($objectKeys(exports[key1][key2]), function (key3) {
              if (!$isPlainObject(exports[key1][key2][key3]) && exports[key1][key2][key3] !== base[key1][key2][key3]) {
                if (key2 === 'proto') {
                  $conlog(key1, key1 + '.prototype.' + key3);
                  $defineProperty(global[key1].prototype, key3, $assign({
                    value: utilx[key1][key2][key3]
                  }, propNotEnumerable));
                } else {
                  $conlog(key1, key1 + '.' + key2 + '.' + key3);
                  $defineProperty(global[key1][key2], key3, $assign({
                    value: utilx[key1][key2][key3]
                  }, propNotEnumerable));
                }
              }
            });
          }
        });
      }
    });

    /*jslint newcap: true */
    $defineProperty(global, 'Big', $assign({
      value: BigNum()
    }, propNotEnumerable));
    /*jslint newcap: false */

    $defineProperty(global, 'assert', $assign({
      value: exports.assert.factory()
    }, propNotEnumerable));
  };

  /**
   * @private
   * @function module:util-x~addMethodsList
   * @param {Object} object
   * @param {String} key
   */
  function defineItem(to, key, value) {
    var item;

    if (!$isPrimitive(item) && $isPlainObject(item)) {
      item = {};
    } else {
      item = value;
    }

    $defineProperty(to, key, $assign({
      value: item
    }, propNotEnumerable));
  }

  /**
   * @private
   * @function module:util-x~addMethodsList
   * @param {Object} object
   */
  function addMethodsList(object) {
    if (!$call(pHasOwn, object, 'methods')) {
      defineItem(object, 'methods', []);
    }
  }

  /**
   * Creates an copy of utilx from the internal $ object.
   *
   * @function module:util-x~exports.factory
   * @return {Object}
   */
  exports.factory = function () {
    var utilx = {};

    $forEach($objectKeys(exports), function (key1) {
      if (key1 === 'Big' || key1 === 'assert') {
        return;
      }

      addMethodsList(utilx);
      defineItem(utilx, key1, exports[key1]);
      if ($isPlainObject(exports[key1])) {
        addMethodsList(utilx[key1]);
        $forEach($objectKeys(exports[key1]), function (key2) {
          defineItem(utilx[key1], key2, exports[key1][key2]);
          if ($isPlainObject(exports[key1][key2])) {
            addMethodsList(utilx[key1][key2]);
            $forEach($objectKeys(exports[key1][key2]), function (key3) {
              defineItem(utilx[key1][key2], key3, exports[key1][key2][key3]);
              $push(utilx[key1][key2].methods, key3);
            });
          } else {
            $push(utilx[key1].methods, key2);
          }
        });
      } else {
        $push(utilx.methods, key1);
      }
    });

    /*jslint newcap: true */
    $defineProperty(utilx, 'Big', $assign({
      value: BigNum()
    }, propNotEnumerable));
    /*jslint newcap: false */

    $defineProperty(utilx, 'assert', $assign({
      value: exports.assert.factory()
    }, propNotEnumerable));

    $defineProperty(utilx, 'version', propConstant);

    $defineProperties(utilx.Number, {
      POSITIVE_ZERO: propConstant,

      NEGATIVE_ZERO: propConstant,

      UNSAFE_INTEGER: propConstant,

      WORD8: propConstant,

      UWORD8: propConstant,

      WORD16: propConstant,

      UWORD16: propConstant,

      WORD32: propConstant,

      UWORD32: propConstant,

      MAX_UINT32: propConstant,

      MAX_INT32: propConstant,

      MIN_INT32: propConstant,

      MAX_UINT16: propConstant,

      MAX_INT16: propConstant,

      MIN_INT16: propConstant,

      MAX_UINT8: propConstant,

      MAX_INT8: propConstant,

      MIN_INT8: propConstant,

      MAX_SAFE_INTEGER: propConstant,

      MIN_SAFE_INTEGER: propConstant,

      MAX_VALUE: propConstant,

      MIN_VALUE: propConstant,

      EPSILON: propConstant,

      NaN: propConstant,

      POSITIVE_INFINITY: propConstant,

      NEGATIVE_INFINITY: propConstant
    });

    return utilx;
  };

  /******************************************************************************/

  //Code to export the public utilx object to different environments.

  if ($typeOf(global) !== 'object') {
    throw new CTypeError('Invalid global context');
  }

  if (module && module.exports) {
    /**
     * Node and other CommonJS-like environments that support "module.exports".
     */
    module.exports = exports.factory();
  } else if (define && define.amd) {
    define(function () {
      /**
       * Asynchronous Module Definition-like environments that support "define".
       *
       * @name module:util-x
       */
      return exports.factory();
    });
  } else {
    /**
     * Without module support. Defines "utilx"
     * on the reference to the "global this" if it doesn't already exist.
     *
     * @global
     * @name utilx
     */
    $defineProperty(global, 'utilx', $assign({
      value: exports.factory()
    }, propNotEnumerable));
  }
}(((typeof window === 'function' || typeof window === 'object') && window) ||
  (typeof self === 'object' && self) ||
  (typeof global === 'object' && global) ||
  (typeof this === 'object' && this) || {},
  typeof module === 'object' && module, (typeof define === 'function' || false) && define));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],2:[function(require,module,exports){
(function (global){
/**
 * @file {@link http://xotic750.github.io/util-x/ util-x}. A Javascript utility library..
 * @version 0.2.0
 * @author Graham Fairweather <xotic750@gmail.com>
 * @copyright Copyright (c) 2013 Graham Fairweather
 * @license {@link <http://www.gnu.org/licenses/gpl-3.0.html> GPL3}
 * @module util-x
 */
!function(global,module,define,Undefined){"use strict";function $firstArg(){return arguments[0]}function $returnArgs(){return arguments}function $strictEqual(a,b){return a===b}function $isUndefined(a){return"undefined"==typeof a}function $toString(a){var b,c;if(null===a)c="null";else if(b=typeof a,"string"===b)c=a;else if("undefined"===b)c=b;else{if("symbol"===b)throw new CTypeError("Cannot convert symbol to string");c=$String(a)}return c}function $requireObjectCoercible(a){if(null==a)throw new CTypeError("Cannot convert argument to object: "+a);return a}function $isPrimitive(a){var b;return null==a?!0:(b=typeof a,"boolean"===b||"string"===b||"number"===b||"symbol"===b)}function $toObject(a){var b;return b=$isPrimitive($requireObjectCoercible(a))?$Object(a):a}function $toPrimitive(a){var b,c,d,e,f;if(!$isPrimitive(a)){for(f=typeof arguments[1],b="string"===f||"number"!==f&&$isDate(a)?["toString","valueOf"]:["valueOf","toString"],d=0;2>d;d+=1)if(c=b[d],$isFunction(a[c])&&(e=a[c](),$isPrimitive(e)))return e;throw new CTypeError("ordinaryToPrimitive returned an object")}return e=a}function $toInteger(a){var b=$toNumber(a),c=0;return b===b&&(c=b&&b!==INFINITY&&b!==NEGATIVE_INFINITY?(b>0||-1)*$floor($abs(b)):b),c}function $toLength(a){return $min($max($toInteger(a),0),MAX_SAFE_INTEGER)}function $isLength(a){return $isSafeInteger(a)&&a>=0}function $isIndex(a,b){return b=$toLength(arguments.length)>1?$toLength(b):MAX_SAFE_INTEGER-1,a=$toNumber(a),$isLength(a)&&b>a}function $hasItem(a,b,c){return c||$hasProperty(a,b)}function $getName(a,b){for(;"undefined"!=typeof a[b];)b+=$toString($toInteger(100*$random()));return b}function $toObjectThisArg(a,b){return b||(a=null==a?global:$Object(a)),a}function $throwArgsWrongType(a){if(null!=a&&($isPrimitive(a)||"number"==typeof a.length&&"charAt"in a))throw new CTypeError("Arguments list has wrong type");return a}function $evalCallApply(a,b,c,d,e){var f,g,h,i=$toLength(d.length),j=i-1,k="";for(f=e;i>f;f+=1)k+="args["+f+"]",j>f&&(k+=",");return a=$toObjectThisArg(a,!1),b=$getName(a,b),a[b]=c,h="return function () { return fn[name]("+k+"); }();",g=new CFunction("fn","name","args",h)(a,b,d),$deleteProperty(a,b),g}function $throwNotFunction(a){throw new CTypeError("Argument is not a function: "+$toString(a))}function $checkXFrame(a,b){var c;return c=supportsXFrameClass===!1?a.constructor&&$toString(a.constructor)===b:!1}function $throwIfIsPrimitive(a){if($isPrimitive(a))throw new CTypeError("called on non-object: "+$toString(a));return a}function $hasOwnValidLength(a){var b=$toObject(a);return $call(pHasOwn,b,"length")&&$isLength(b.length)||hasArrayLengthBug&&$isArray(b)}function $bindArgs(a,b){var c,d,e=$toLength(a),f="";if(e)for("string"==typeof b&&$call(pTest,/^ *, *$/,b)||(b=","),c=e-1,d=0;e>d;d+=1)f+="$"+d,c>d&&(f+=b);return f}function $throwIfNotEnoughArgs(a,b){var c=!$isPrimitive(a)&&$toLength(a.length)||0;if(c<$toLength(b))throw new CSyntaxError($toString(c)+" is not enough arguments, requires "+$toString(b));return c}function $optArgs(a,b,c,d){var e=$throwIfNotEnoughArgs(arguments,4);return a=$toLength(a),e===a?$isFunction(b)?(c=b,b="undefined"):b=$toString(b):e>a&&(b=$toString(b),$isFunction(c)||(c=d)),{message:b,stackStartFn:c}}function $decide(a,b,c,d){$throwIfNotEnoughArgs(arguments,3);var e,f,g;if($isFunction(a))try{g=a(),f=!0}catch(h){d=$toString(d),$conlog(d,h),f=!1}else f=a?!0:!1;return e=f?$isFunction(b)?b(g):b:$isFunction(c)?c(g):c}function noop(){}function $onlyCoercibleToString(a){return $toString($requireObjectCoercible(a))}function $affirmBasic(a){return function(){$affirm.ok(!testShims,"testing shim"),$affirm.ok($isNative(a),"not native")}}function $typeOf(a){var b;return b=$isPrimitive(a)?typeof a:!$isRegExp(a)&&$isFunction(a)?"function":"object"}function toInt32(a){var b=$toNumber(a),c=0;return b&&b===b&&b!==INFINITY&&b!==NEGATIVE_INFINITY&&(c=(b>0||-1)*$floor($abs(b))%UWORD32,c>MAX_INT32?c-=UWORD32:MIN_INT32>c&&(c+=UWORD32)),c}function $isUint32(a){return $isSafeInteger(a)&&a>=0&&MAX_UINT32>=a}function $ascending(a,b){var c,d=$toString(a),e=$toString(b);return c=d===e?0:e>d?-1:1}function $descending(a,b){var c,d=$toString(a),e=$toString(b);return c=d===e?0:e>d?1:-1}function $specialToObject(a){var b=$toObject(a);if(!$hasOwnValidLength(b))throw new CTypeError("invalid length property: "+$toString(b));if($isFunction(a))throw new CTypeError("argument is a function: "+$toString(b));return b}function $testV8StrictBug(a){var b=!1;return isStrictMode&&$affirm.doesNotThrow(function(){$call(a,[1],function(){b="object"===$typeOf(this)},"foo")},"should not throw when calling function"),b}function $affirmArrayMethodTestsBasic(a){return function(){$affirmBasic(a)(),$affirm.ok(!$testV8StrictBug(a),"V8 bug")}}function $affirmArrayMethodTestsObject(a){return function(){$affirmArrayMethodTestsBasic(a)();var b;$affirm.doesNotThrow(function(){$call(a,"foo",function(){b=arguments[$toLength(arguments.length)-1]})},"should not throw when calling function"),$affirm.strictEqual($typeOf(b),"object","is object"),$affirm.ok($isString(b),"is string")}}function clampSafeInt(a){return $min($max($toInteger(a),MIN_SAFE_INTEGER),MAX_SAFE_INTEGER)}function $makeDate(a){var b=new CDate(a);return b.toISOString=exports.Date.proto.toISOString,b.toJSON=exports.Date.proto.toJSON,b}function $isInstance(a,b){if(!$isFunction(b))throw new CTypeError("Ctor is not a constructor.");var c=!1;return null!=a&&($instanceOf(a,b)?c=!0:$isPrimitive(a)||$isPlainObject(a)||$isFunction(a)||"string"!=typeof a.classId||(c=a.classId===b.prototype.classId)),c}function defineItem(a,b,c){var d;d=!$isPrimitive(d)&&$isPlainObject(d)?{}:c,$defineProperty(a,b,$assign({value:d},propNotEnumerable))}function addMethodsList(a){$call(pHasOwn,a,"methods")||defineItem(a,"methods",[])}var base,testShims=!1,enableLog=!0,$conlog,$affirm,POSITIVE_ZERO=0,NEGATIVE_ZERO=-0,WORD8=128,UWORD8=256,WORD16=32768,UWORD16=65536,WORD32=2147483648,UWORD32=4294967296,MAX_UINT32=4294967295,MAX_INT32=2147483647,MIN_INT32=-2147483648,MAX_UINT16=65535,MAX_INT16=32767,MIN_INT16=-32768,MAX_UINT8=255,MAX_INT8=127,MIN_INT8=-128,MAX_SAFE_INTEGER=9007199254740991,MIN_SAFE_INTEGER=-9007199254740991,UNSAFE_INTEGER=9007199254740992,MAX_VALUE=1.7976931348623157e308,MIN_VALUE=5e-324,EPSILON=2.220446049250313e-16,INFINITY=1/POSITIVE_ZERO,NEGATIVE_INFINITY=1/NEGATIVE_ZERO,stringTagArguments="[object Arguments]",stringTagFunction="[object Function]",stringTagObject="[object Object]",stringTagUndefined="[object Undefined]",stringTagNull="[object Null]",stringTagError="[object Error]",stringTagRegExp="[object RegExp]",stringTagArray="[object Array]",stringTagDate="[object Date]",stringTagString="[object String]",stringTagBoolean="[object Boolean]",stringTagNumber="[object Number]",stringTagArrayBuffer="[object ArrayBuffer]",stringTagFloat32Array="[object Float32Array]",stringTagFloat64Array="[object Float64Array]",stringTagInt8Array="[object Int8Array]",stringTagInt16Array="[object Int16Array]",stringTagInt32Array="[object Int32Array]",stringTagUint8Array="[object Uint8Array]",stringTagUint8ClampedArray="[object Uint8ClampedArray]",stringTagUint16Array="[object Uint16Array]",stringTagUint32Array="[object Uint32Array]",stringTagHTMLCollection="[object HTMLCollection]",stringTagNodeList="[object NodeList]",hasAccessorSupport,stringProto="__proto__",stringDefineGetter="__defineGetter__",stringDefineSetter="__defineSetter__",stringLookupGetter="__lookupGetter__",stringLookupSetter="__lookupGetter__",hintString="",hintNumber=0,propConstant,propNotEnumerable,shadowed,CError,CTypeError,CSyntaxError,CRangeError,CReferenceError,CEvalError,CURIError,CNumber,CString,CDate,CRegExp,CFunction,CBoolean,CArray,protoObject,protoFunction,protoNumber,protoBoolean,protoString,protoDate,protoRegExp,protoArray,protoError,protoTypeError,protoSyntaxError,protoRangeError,protoEvalError,protoReferenceError,protoURIError,$Object,$Number,$min,$max,$floor,$abs,$ceil,$random,$sqrt,$pow,$isFunction,$throwIfNotFunction,$toStringTag,hasDontEnumBug,hasProtoEnumBug,hasEnumArgsBug,hasEnumStringBug,hasBoxedStringBug,hasArrayLengthBug,unwantedError,hasErrorProps,wspaceStrings,hasWorkingGOPD,hasProto,hasGetSet,isStrictMode,hasDeleteBug,hasCallBug,hasApplyBug,hasApplyRequiresArrayLikeBug,supportsApplyArrayLike,supportsXFrameClass,$pSlice,$pConcat,$String,pMatch,pSplit,pSearch,pCharCodeAt,pSIndexOf,pReplace,pHasOwn,pExec,pTest,$hasProperty,$getItem,$toNumber,$instanceOf,$returnThis,$unshift,$shift,$reverse,$hasOwn,$repeat,$isNumber,$isBoolean,$isString,$isError,$isDate,$isNative,$isArguments,$isArray,$isRegExp,$isSymbol,$isInteger,$isSafeInteger,$isNumeric,$inRange,$isPlainObject,$isErrorTypeConstructor,$getPrototypeOf,$modulo,$forEach,$push,$pop,$deepEqual,$deepStrictEqual,$defineProperty,$defineProperties,$assign,$create,$objectKeys,$stringify,$truncate,$inherits,$stringContains,$exec,$test,$slice,$argSlice,$split,$replace,$splice,$isDigits,$join,$parseInt,$trim,$substr,$parseFloat,$randomInt,$pApply,$pCall,$call,$apply,$isNaN,$isFinite,$sort,$defProp,$deleteProperty,$sSlice,$forKeys,$indexOf,$isCircular,$propertyIsEnumerable,$toMethod,$escapeRegex,spIndexOf,spLastIndexOf,BigNum,exports;if(exports={Boolean:{proto:{}},Number:{proto:{}},String:{proto:{}},Array:{proto:{}},Object:{proto:{}},Function:{proto:{}},Date:{proto:{}},Error:{proto:{}},RegExp:{proto:{}},Math:{},JSON:{}},unwantedError=[],propConstant={enumerable:!1,writable:!1,configurable:!1},propNotEnumerable={enumerable:!1,writable:!0,configurable:!0},shadowed=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],base={isNaN:global.isNaN,isFinite:global.isFinite,parseInt:global.parseInt,parseFloat:global.parseFloat,Math:{sign:global.Math.sign,min:global.Math.min,max:global.Math.max,floor:global.Math.floor,ceil:global.Math.ceil,abs:global.Math.abs,random:global.Math.random,pow:global.Math.pow,sqrt:global.Math.sqrt,round:global.Math.round},Object:{Ctr:global.Object,proto:global.Object.prototype,assign:global.Object.assign,create:global.Object.create,defineProperties:global.Object.defineProperties,defineProperty:global.Object.defineProperty,freeze:global.Object.freeze,getOwnPropertyDescriptor:global.Object.getOwnPropertyDescriptor,getOwnPropertyNames:global.Object.getOwnPropertyNames,getPrototypeOf:global.Object.getPrototypeOf,is:global.Object.is,isExtensible:global.Object.isExtensible,isFrozen:global.Object.isFrozen,isSealed:global.Object.isSealed,keys:global.Object.keys,preventExtensions:global.Object.preventExtensions,seal:global.Object.seal,setPrototypeOf:global.Object.setPrototypeOf,defineGetter:global.Object.prototype[stringDefineGetter],defineSetter:global.Object.prototype[stringDefineSetter],lookupGetter:global.Object.prototype[stringLookupGetter],lookupSetter:global.Object.prototype[stringLookupSetter],hasOwn:global.Object.prototype.hasOwnProperty,isPrototypeOf:global.Object.prototype.isPrototypeOf,propertyIsEnumerable:global.Object.prototype.propertyIsEnumerable,toLocaleString:global.Object.prototype.toLocaleString,toSource:global.Object.prototype.toSource,toString:global.Object.prototype.toString,unwatch:global.Object.prototype.unwatch,valueOf:global.Object.prototype.valueOf,watch:global.Object.prototype.watch},Array:{Ctr:global.Array,proto:global.Array.prototype,isArray:global.Array.isArray,of:global.Array.of,from:global.Array.from,concat:global.Array.prototype.concat,every:global.Array.prototype.every,filter:global.Array.prototype.filter,find:global.Array.prototype.find,findIndex:global.Array.prototype.findIndex,forEach:global.Array.prototype.forEach,indexOf:global.Array.prototype.indexOf,join:global.Array.prototype.join,lastIndexOf:global.Array.prototype.lastIndexOf,map:global.Array.prototype.map,pop:global.Array.prototype.pop,push:global.Array.prototype.push,reduce:global.Array.prototype.reduce,reduceRight:global.Array.prototype.reduceRight,reverse:global.Array.prototype.reverse,shift:global.Array.prototype.shift,slice:global.Array.prototype.slice,some:global.Array.prototype.some,sort:global.Array.prototype.sort,splice:global.Array.prototype.splice,toString:global.Array.prototype.toString,unshift:global.Array.prototype.unshift},String:{Ctr:global.String,proto:global.String.prototype,fromCharCode:global.String.fromCharCode,fromCodePoint:global.String.fromCodePoint,anchor:global.String.prototype.anchor,charAt:global.String.prototype.charAt,charCodeAt:global.String.prototype.charCodeAt,codePointAt:global.String.prototype.codePointAt,concat:global.String.prototype.concat,contains:global.String.prototype.contains,endsWith:global.String.prototype.endsWith,indexOf:global.String.prototype.indexOf,lastIndexOf:global.String.prototype.lastIndexOf,link:global.String.prototype.link,localeCompare:global.String.prototype.localeCompare,match:global.String.prototype.match,normalize:global.String.prototype.normalize,repeat:global.String.prototype.repeat,replace:global.String.prototype.replace,search:global.String.prototype.search,slice:global.String.prototype.slice,split:global.String.prototype.split,startsWith:global.String.prototype.startsWith,substr:global.String.prototype.substr,substring:global.String.prototype.substring,toLocaleLowerCase:global.String.prototype.toLocaleLowerCase,toLocaleUpperCase:global.String.prototype.toLocaleUpperCase,toLowerCase:global.String.prototype.toLowerCase,toString:global.String.prototype.toString,toUpperCase:global.String.prototype.toUpperCase,trim:global.String.prototype.trim,trimLeft:global.String.prototype.trimLeft,trimRight:global.String.prototype.trimRight,valueOf:global.String.prototype.valueOf},Number:{Ctr:global.Number,proto:global.Number.prototype,EPSILON:global.Number.EPSILON,MAX_VALUE:global.Number.MAX_VALUE,MIN_VALUE:global.Number.MIN_VALUE,MAX_SAFE_INTEGER:global.Number.MAX_SAFE_INTEGER,MIN_SAFE_INTEGER:global.Number.MIN_SAFE_INTEGER,NaN:global.Number.NaN,POSITIVE_INFINITY:global.Number.POSITIVE_INFINITY,NEGATIVE_INFINITY:global.Number.NEGATIVE_INFINITY,isFinite:global.Number.isFinite,isInteger:global.Number.isInteger,isSafeInteger:global.Number.isSafeInteger,isNaN:global.Number.isNaN,parseFloat:global.Number.parseFloat,parseInt:global.Number.parseInt,toExponential:global.Number.prototype.toExponential,toFixed:global.Number.prototype.toFixed,toLocaleString:global.Number.prototype.toLocaleString,toPrecision:global.Number.prototype.toPrecision,toString:global.Number.prototype.toString,valueOf:global.Number.prototype.valueOf},Boolean:{Ctr:global.Boolean,proto:global.Boolean.prototype,toString:global.Boolean.prototype.toString,valueOf:global.Boolean.prototype.valueOf},Function:{Ctr:global.Function,proto:global.Function.prototype,apply:global.Function.prototype.apply,bind:global.Function.prototype.bind,call:global.Function.prototype.call,toString:global.Function.prototype.toString},RegExp:{Ctr:global.RegExp,proto:global.RegExp.prototype,exec:global.RegExp.prototype.exec,test:global.RegExp.prototype.test,toString:global.RegExp.prototype.toString},Date:{Ctr:global.Date,proto:global.Date.prototype,now:global.Date.now,toJSON:global.Date.prototype.toJSON,toISOString:global.Date.prototype.toISOString,getTime:global.Date.prototype.getTime},Error:{Ctr:global.Error,proto:global.Error.prototype},TypeError:{Ctr:global.TypeError,proto:global.TypeError.prototype},SyntaxError:{Ctr:global.SyntaxError,proto:global.SyntaxError.prototype},RangeError:{Ctr:global.RangeError,proto:global.RangeError.prototype},EvalError:{Ctr:global.EvalError,proto:global.EvalError.prototype},ReferenceError:{Ctr:global.ReferenceError,proto:global.ReferenceError.prototype},URIError:{Ctr:global.URIError,proto:global.URIError.prototype}},base.JSON={},"object"==typeof global.JSON&&global.JSON?(base.JSON.parse=global.JSON.parse,base.JSON.stringify=global.JSON.stringify):(base.JSON.parse=Undefined,base.JSON.stringify=Undefined),CError=base.Error.Ctr,CTypeError=base.TypeError.Ctr,CSyntaxError=base.SyntaxError.Ctr,CRangeError=base.RangeError.Ctr,CReferenceError=base.ReferenceError.Ctr,CEvalError=base.EvalError.Ctr,CURIError=base.URIError.Ctr,CNumber=base.Number.Ctr,CString=base.String.Ctr,CDate=base.Date.Ctr,CRegExp=base.RegExp.Ctr,CFunction=base.Function.Ctr,CBoolean=base.Boolean.Ctr,CArray=base.Array.Ctr,protoObject=base.Object.proto,protoFunction=base.Function.proto,protoNumber=base.Number.proto,protoBoolean=base.Boolean.proto,protoString=base.String.proto,protoDate=base.Date.proto,protoRegExp=base.RegExp.proto,protoArray=base.Array.proto,protoError=base.Error.proto,protoTypeError=base.TypeError.proto,protoSyntaxError=base.SyntaxError.proto,protoRangeError=base.RangeError.proto,protoEvalError=base.EvalError.proto,protoReferenceError=base.ReferenceError.proto,protoURIError=base.URIError.proto,$String=base.String.Ctr,pMatch=base.String.match,pSplit=base.String.split,pCharCodeAt=base.String.charCodeAt,pSIndexOf=base.String.indexOf,pReplace=base.String.replace,pSearch=base.String.search,pHasOwn=base.Object.hasOwnProperty,pExec=base.RegExp.exec,pTest=base.RegExp.test,$parseFloat=base.parseFloat,$Object=base.Object.Ctr,$Number=base.Number.Ctr,$String=base.String.Ctr,$min=base.Math.min,$max=base.Math.max,$floor=base.Math.floor,$abs=base.Math.abs,$ceil=base.Math.ceil,$random=base.Math.random,$sqrt=base.Math.sqrt,$pow=base.Math.pow,exports.Object.isUndefined=$isUndefined,exports.Object.isNull=function(a){return null===a},exports.Object.isNil=function(a){return null==a},exports.Object.isPrimitive=$isPrimitive,$isDate=function(a){return!$isPrimitive(a)&&a.constructor&&a.constructor===CDate},$isFunction=function(a){return"function"==typeof a||!1},exports.Object.ToPrimitive=$toPrimitive,$toNumber=function(){var a,b;if(b=function(a){var c,d;if(null===a)d=0;else if(c=typeof a,"undefined"===c)d=NaN;else if("boolean"===c)d=a?1:0;else if("number"===c)d=a;else if("string"===c)d=$Number(a);else{if("symbol"===c)throw new TypeError("Can not convert symbol to a number");d=b($toPrimitive(a,hintNumber))}return d},!testShims)try{a={},a=+a,a={valueOf:""},a=+a,a={valueOf:"1"},a=+a,a={valueOf:1},a=+a,a={valueOf:1.1},a=+a,b=function(a){return+a}}catch(c){}return b}(),exports.Object.ToNumber=$toNumber,$isNaN=function(a){var b=$toNumber(a);return b!==b},$isFinite=function(a){var b=$toNumber(a);return b===b&&b!==INFINITY&&b!==NEGATIVE_INFINITY},$isInteger=function(a){return"number"==typeof a&&a!==INFINITY&&a!==NEGATIVE_INFINITY&&$toInteger(a)===a},$isSafeInteger=function(a){return"number"==typeof a&&a!==INFINITY&&a!==NEGATIVE_INFINITY&&$toInteger(a)===a&&a>=MIN_SAFE_INTEGER&&MAX_SAFE_INTEGER>=a},hasDeleteBug=function(){var a,b=[0,1,2,3];try{delete b[2],delete b[2],a=!1}catch(c){a=!0}return a}(),$deleteProperty=function(){var a;return a=hasDeleteBug?function(a,b){try{return delete a[b]}catch(c){return c}}:function(a,b){return delete a[b]}}(),$returnThis=function(){return this},isStrictMode=!$returnThis(),hasCallBug=function(){var a,b=function(){return this};try{a=!isStrictMode&&"string"==typeof $call(b,"foo")}catch(c){a=!1}return a}(),hasApplyBug=function(){var a;try{a=!isStrictMode&&"string"==typeof $returnThis.apply("foo")}catch(b){a=!1}return a}(),hasApplyRequiresArrayLikeBug=function(){var a;try{$returnThis.apply("foo"),a=!1}catch(b){a=!0}return a}(),supportsApplyArrayLike=function(){var a,b;a=function(a){return a};try{b=1===a.apply("foo",$returnArgs(1)),b=1===a.apply("foo",{0:1,length:1})}catch(c){b=!1}return b}(),hasBoxedStringBug=function(){var a=$Object("a");return"a"!==a[0]||!(0 in a)}(),$isString=function(a){return"string"==typeof a||!$isPrimitive(a)&&"number"==typeof a.length&&"charAt"in a},$isArguments=function(a){return!$isPrimitive(a)&&"number"==typeof a.length&&"callee"in a&&!("arguments"in a)},$hasProperty=function(){var a,b,c;if(hasBoxedStringBug)a=function(a,b){var c=$toString(b);return $isString(a)&&$isIndex(c,a.length)||c in $toObject(a)};else{c=0,b=$toObject("abc");try{if(!(c in b&&"charAt"in b))throw"requires toString";a=function(a,b){return b in $toObject(a)}}catch(d){a=function(a,b){return $toString(b)in $toObject(a)}}}return a}(),$pApply=function(a){var b;return b=a?testShims||hasApplyBug||hasApplyRequiresArrayLikeBug||!supportsApplyArrayLike?function(){return function(b,c){var d,e,f=$Object($throwArgsWrongType(c)),g=$toLength(f.length),h=$getName(this,"__$pApply_"),i=[];for(this[h]=a,i.length=g,d=0;g>d;d+=1)i[d]=f[d];return e=this[h]($toObjectThisArg(b,isStrictMode),i),$deleteProperty(this,h),e}}():a:function(a,b){return $evalCallApply(a,"__$pApply__",this,$Object($throwArgsWrongType(b)),0)}}(base.Function.apply),$pCall=function(a){var b;return b=a?testShims||hasCallBug?function(){return function(a){var b,c,d=$toLength(arguments.length),e=$getName(this,"__$pCall__"),f=[];for(this[e]=$pApply,f.length=d-1,b=1;d>b;b+=1)f[b-1]=arguments[b];return c=this[e]($toObjectThisArg(a,isStrictMode),f),$deleteProperty(this,e),c}}():a:function(a){return $evalCallApply(a,"__$pCall__",this,arguments,1)}}(base.Function.call),$call=function(a,b){var c,d,e=$toLength(arguments.length),f=$getName(a,"__$call__"),g=[];for(g.length=$toLength(e-2),c=2;e>c;c+=1)g[c-2]=arguments[c];return a[f]=$pApply,d=a[f](b,g),$deleteProperty(a,f),d},$apply=function(a,b,c){var d,e=$getName(a,"__$apply__");return a[e]=$pApply,d=a[e](b,c),$deleteProperty(a,e),d},$getItem=function(a){return function(b,c,d){var e;return hasBoxedStringBug&&d?e=$call(a,b,c):(e=b[c],d&&"undefined"==typeof e&&(e="")),e}}(base.String.charAt),$toStringTag=function(a){return function(b){var c;return c=null===b?stringTagNull:"undefined"==typeof b?stringTagUndefined:$call(a,b)}}(base.Object.toString),$pSlice=function(a,b){var c,d,e,f=$toObject(this),g=$toLength(f.length),h=g&&$isString(f),i=$toInteger(a),j=[],k=0;for(e=0>i?$max(g+i,0):$min(i,g),c="undefined"==typeof b?g:$toInteger(b),d=0>c?$max(g+c,0):$min(c,g),d=$toLength(d),j.length=$toLength($max(d-e,0));d>e;)$hasItem(f,e,h)&&(j[k]=$getItem(f,e,h)),k+=1,e+=1;return j},$argSlice=function(a,b,c){return $call($pSlice,a,b,c)},$slice=$argSlice,$isFunction=function(a){return $isFunction(/x/)||global.Uint8Array&&!$isFunction(global.Uint8Array)?function(b){return $call(a,b)===stringTagFunction}:$isFunction}(base.Object.toString),$throwIfNotFunction=function(a){return $isFunction(a)||$throwNotFunction(a),a},("function"==typeof window||"object"==typeof window)&&(supportsXFrameClass=isStrictMode),$isBoolean=function(a,b){var c;return $call(a,protoBoolean)!==stringTagBoolean&&(c=!0),function(d){return"boolean"==typeof d||!$isPrimitive(d)&&(c&&d===protoBoolean||$call(a,d)===stringTagBoolean||$checkXFrame(d,b))}}(base.Object.toString,$toString(CBoolean)),exports.Boolean.isBoolean=$isBoolean,$isNumber=function(a,b){var c;return $call(a,protoNumber)!==stringTagNumber&&(c=!0),function(d){return"number"==typeof d||!$isPrimitive(d)&&(c&&d===protoNumber||$call(a,d)===stringTagNumber||$checkXFrame(d,b))}}(base.Object.toString,$toString(CNumber)),exports.Number.isNumber=$isNumber,$isString=function(a,b){var c;return $call(a,protoString)!==stringTagString&&(c=!0),function(d){if("string"==typeof d)return!0;if(!$isPrimitive(d)){if(c&&d===protoString)return!0;if($call(pHasOwn,d,"length")&&($call(a,d)===stringTagString||$checkXFrame(d,b)))return!0}return!1}}(base.Object.toString,$toString(CString)),exports.String.isString=$isString,$isSymbol=function(a){return"symbol"==typeof a},exports.Object.isSymbol=$isSymbol,$isArray=function(a,b){var c;return $call(a,protoArray)!==stringTagArray&&(c=!0),function(d){if(!$isPrimitive(d)){if(c&&d===protoArray)return!0;if($call(pHasOwn,d,"length")&&!$call(pHasOwn,d,"callee")&&($call(a,d)===stringTagArray||$checkXFrame(d,b)))return!0}return!1}}(base.Object.toString,$toString(CArray)),$isArguments=function(a){function b(a){return!$isPrimitive(a)&&$call(pHasOwn,a,"length")&&$call(pHasOwn,a,"callee")&&!$call(pHasOwn,a,"arguments")}var c,d=$call(a,$returnArgs())===stringTagArguments;return c=d?function(c){return!$isPrimitive(c)&&$call(pHasOwn,c,"length")&&($call(a,c)===stringTagArguments||supportsXFrameClass===!1&&b(c))}:b}(base.Object.toString),exports.Object.isArguments=$isArguments,$isRegExp=function(a,b){var c,d,e,f,g=$call(a,new CRegExp("x")),h=g===stringTagRegExp;return h?(c="[object RegExpPrototype]",g=$call(a,protoRegExp),g===c?d=!0:g!==stringTagRegExp&&(e=!0),f=function(f){var g;if(!$isPrimitive(f)){if(g=$call(a,f),$call(pHasOwn,f,"ignoreCase")){if(g===stringTagRegExp)return!0;if(e&&f===protoRegExp)return!0;if($checkXFrame(f,b))return!0}if(d&&g===c)return!0}return!1}):f=function(a){return!$isPrimitive(a)&&$call(pHasOwn,a,"ignoreCase")&&"boolean"==typeof a.ignoreCase&&$call(pHasOwn,a,"global")&&"boolean"==typeof a.global&&$call(pHasOwn,a,"multiline")&&"boolean"==typeof a.multiline&&$call(pHasOwn,a,"source")&&"string"==typeof a.source},f}(base.Object.toString,$toString(CRegExp)),exports.RegExp.isRegExp=$isRegExp,$isError=function(a,b){var c;return $call(a,protoError)!==stringTagError&&(c=!0),function(d){if(!$isPrimitive(d)){if(c&&d===protoError)return!0;if($call(pHasOwn,d,"message")&&($call(a,d)===stringTagError||$checkXFrame(d,b)))return!0}return!1}}(base.Object.toString,$toString(CError)),exports.Error.isError=$isError,$isDate=function(a,b){var c;return $call(a,protoDate)!==stringTagArray&&(c=!0),function(d){return!$isPrimitive(d)&&(c&&d===protoDate||$call(a,d)===stringTagDate||$checkXFrame(d,b))}}(base.Object.toString,$toString(CDate)),exports.Date.isDate=$isDate,$instanceOf=function(a){return function(b,c){return $throwIfNotFunction(c),!$isPrimitive(b)&&(b instanceof c||!$isPrimitive(c.prototype)&&$call(a,c.prototype,b))}}(base.Object.isPrototypeOf),$isPlainObject=function(a){return!$isPrimitive(a)&&!$isFunction(a)&&!$isPrimitive(a.constructor)&&a.constructor.prototype===protoObject},$affirm={},$affirm.AffirmError=function(){function a(){}var b=function(a){$isPlainObject(a)||(a={}),$isFunction(a.stackStartFn)||(a.stackStartFn=$affirm.AffirmError),$call(CError,this,a.message,a.stackStartFn),this.message=a.message,this.actual=a.actual,this.expected=a.expected,this.operator=a.operator};return a.prototype=protoError,b.prototype=new a,b.prototype.name="AffirmError",b.prototype.constructor=b,b}(),$affirm.fail=function(a,b,c,d,e){throw $throwIfNotEnoughArgs(arguments,4),$isFunction(e)||(e=$affirm.fail),new $affirm.AffirmError({actual:a,expected:b,message:$toString(c),operator:$toString(d),stackStartFn:e})},$affirm.ok=function(a,b,c){$throwIfNotEnoughArgs(arguments,1);var d;a=!a,a&&(d=$optArgs(2,b,c,$affirm.ok),$affirm.fail(!a,!0,d.message,"ok",d.stackStartFn))},$affirm.equal=function(a,b,c,d){$throwIfNotEnoughArgs(arguments,2);var e;a!=b&&(e=$optArgs(3,c,d,$affirm.equal),$affirm.fail(a,b,e.message,"==",e.stackStartFn))},$affirm.notEqual=function(a,b,c,d){$throwIfNotEnoughArgs(arguments,2);var e;a==b&&(e=$optArgs(3,c,d,$affirm.notEqual),$affirm.fail(a,b,e.message,"!=",e.stackStartFn))},$affirm.strictEqual=function(a,b,c,d){$throwIfNotEnoughArgs(arguments,2);var e;a!==b&&(e=$optArgs(3,c,d,$affirm.strictEqual),$affirm.fail(a,b,e.message,"===",e.stackStartFn))},$affirm.notStrictEqual=function(a,b,c,d){$throwIfNotEnoughArgs(arguments,2);var e;a===b&&(e=$optArgs(3,c,d,$affirm.notStrictEqual),$affirm.fail(a,b,e.message,"!==",e.stackStartFn))},$affirm["throws"]=function(a,b,c,d){$throwIfNotEnoughArgs(arguments,2);var e,f,g;if($isFunction(a))try{a()}catch(h){e=h}if($isFunction(b))try{throw new b}catch(i){$instanceOf(i,CError)&&(f=b)}f||(f=CError),$instanceOf(e,f)||(g=$optArgs(3,c,d,$affirm["throws"]),$affirm.fail(e,f,g.message,"throws",g.stackStartFn))},$affirm.doesNotThrow=function(a,b,c){$throwIfNotEnoughArgs(arguments,1);var d,e;if($isFunction(a))try{a()}catch(f){d=f}"undefined"!=typeof d&&(e=$optArgs(2,b,c,$affirm.doesNotThrow),$affirm.fail(d,Undefined,e.message,"doesNotThrow",e.stackStartFn))},$affirm.ifError=function(a){if(a)throw a},$pConcat=function(){var a,b,c,d,e=$toObject(this),f=$toLength(arguments.length),g=0,h=[];for(b=-1;f>b;b+=1)if(a=-1===b?e:arguments[b],$isArray(a))for(d=0,c=$toLength(a.length);c>d;)$hasProperty(a,d)?(h[g]=a[d],d+=1):h[g]=a,g+=1;return h},$conlog=function(a){var b,c,d,e=!$isPrimitive(a)&&!$isPrimitive(a.log);if(e){b=a.log,c=["Test log",!0];try{$apply(b,a,c),c.length=1,d=function(){enableLog&&$apply(b,a,arguments)},d("Using function apply for logging")}catch(f){d=null}if(!d)try{b(c[0]),b(c[1]),d=function(){var a,c;if(enableLog)for(a=arguments.length,c=0;a>c;c+=1)b(arguments[c])},d("Using for loop for logging")}catch(g){d=null}}return d||(d=function(){}),function(){if(global.log&&global.log.debug)try{$apply(global.log.debug,global.log,arguments)}catch(a){}$apply(d,null,arguments)}}(global.console),$toStringTag=function(a){return $decide(function(){var b;$affirm.ok(!testShims,"testing shim"),$affirm.doesNotThrow(function(){b=$call(a)},"call no arg"),$affirm.strictEqual(b,stringTagUndefined,"no arg"),$affirm.doesNotThrow(function(){b=$call(a,Undefined)},"call undefined"),$affirm.strictEqual(b,stringTagUndefined,"undefined"),$affirm.doesNotThrow(function(){b=$call(a,null)},"call null"),$affirm.strictEqual(b,stringTagNull,"null"),$affirm.doesNotThrow(function(){b=$call(a,arguments)},"call arguments"),$affirm.strictEqual(b,stringTagArguments,"arguments"),$affirm.doesNotThrow(function(){b=$call(a,"abc")},"call string"),$affirm.strictEqual(b,stringTagString,"string"),$affirm.doesNotThrow(function(){b=$call(a,$Object("abc"))},"call string object"),$affirm.strictEqual(b,stringTagString,"string object"),$affirm.doesNotThrow(function(){b=$call(a,[])},"call array"),$affirm.strictEqual(b,stringTagArray,"array"),$affirm.doesNotThrow(function(){b=$call(a,function(){})},"test3"),$affirm.strictEqual(b,stringTagFunction,"function"),$affirm.doesNotThrow(function(){b=$call(a,1)},"call number"),$affirm.strictEqual(b,stringTagNumber,"number"),$affirm.doesNotThrow(function(){b=$call(a,$Object(1))},"call number object"),$affirm.strictEqual(b,stringTagNumber,"number object"),$affirm.doesNotThrow(function(){b=$call(a,!0)},"call boolean"),$affirm.strictEqual(b,stringTagBoolean,"boolean"),$affirm.doesNotThrow(function(){b=$call(a,$Object(!0))},"call boolean object"),$affirm.strictEqual(b,stringTagBoolean,"boolean object"),$affirm.doesNotThrow(function(){b=$call(a,new CRegExp(""))},"call regexp"),$affirm.strictEqual(b,stringTagRegExp,"regexp"),$affirm.doesNotThrow(function(){b=$call(a,new CDate)},"call date"),$affirm.strictEqual(b,stringTagDate,"date"),$affirm.doesNotThrow(function(){b=$call(a,new CError(""))},"call error"),$affirm.strictEqual(b,stringTagError,"error")},function(){return function(b){return $call(a,b)}},function(){return function(b){var c;return $isPrimitive(b)?null===b?c=stringTagNull:"undefined"==typeof b&&(c=stringTagUndefined):$call(pHasOwn,b,"length")?$isArguments(b)?c=stringTagArguments:$isArray(b)?c=stringTagArray:$isString(b)?c=stringTagString:$isFunction(b)&&(c=stringTagFunction):$isNumber(b)?c=stringTagNumber:$isBoolean(b)?c=stringTagBoolean:$isRegExp(b)?c=stringTagRegExp:$isDate(b)?c=stringTagDate:$isError(b)&&(c=stringTagError),c||(c=$call(a,b)),c}},"toStringTag patch")}(base.Object.toString),hasDontEnumBug=!$call(base.Object.propertyIsEnumerable,{toString:null},"toString"),hasProtoEnumBug=$call(base.Object.propertyIsEnumerable,function(){},"prototype"),hasEnumArgsBug=function(){var a,b=$returnArgs("h","e","j"),c={};for(a in b)("0"===a||"1"===a||"2"===a)&&(c[a]=b[a]);return"h"!==c[0]||"e"!==c[1]||"j"!==c[2]}(),hasEnumStringBug=!$call(pHasOwn,"x","0"),hasArrayLengthBug="number"!=typeof[].length,hasErrorProps=function(){var a,b,c,d,e=[{name:"Error",proto:protoError,unwanted:{}},{name:"TypeError",proto:protoTypeError,unwanted:{}},{name:"SyntaxError",proto:protoSyntaxError,unwanted:{}},{name:"RangeError",proto:protoRangeError,unwanted:{}},{name:"EvalError",proto:protoEvalError,unwanted:{}},{name:"ReferenceError",proto:protoReferenceError,unwanted:{}},{name:"URIError",proto:protoURIError,unwanted:{}}],f=$toLength(e.length),g=!!base.Object.defineProperty,h=!1;for(unwantedError.length=0,a=0;f>a;a+=1){b=e[a].name,d=e[a].proto;for(c in d)if($call(pHasOwn,d,c))try{if(!g)throw new CError("Still enumerable");
if(base.Object.defineProperty(d,c,propNotEnumerable),$call(base.Object.propertyIsEnumerable,d,c))throw new CError("Still enumerable");$conlog('Unwanted error prop "'+c+'": patched')}catch(i){h=!0,e[a].unwanted[c]=d[c],$conlog('Unwanted "'+b+'" prop "'+c+'": patch failed')}}return h&&(unwantedError=e),h}(),hasProto=null===protoObject[stringProto],hasGetSet=$isFunction(base.Object.lookupGetter)&&$isFunction(base.Object.lookupSetter),$toMethod=function(){function a(a,b,c,d){var e,f=$toLength(d.length),g=[];for(g.length=$toLength(f-1),e=1;f>e;e+=1)g[e-1]=d[e];return $apply(a,b(c),g)}return function(b,c){$throwIfNotFunction(b),$isFunction(c)||(c=$requireObjectCoercible);var d=$bindArgs($toLength(b.length)+1," ,"),e="return function (thisArg, "+d+") { return apply(pFn, cFn, thisArg, arguments); };";return new CFunction("pFn","cFn","apply",e)(b,c,a)}}(),$slice=$toMethod($pSlice),$conlog("+++++++++ hasDontEnumBug: "+hasDontEnumBug),$conlog("+++++++++ hasProtoEnumBug: "+hasProtoEnumBug),$conlog("+++++++++ hasEnumArgsBug: "+hasEnumArgsBug),$conlog("+++++++++ hasErrorProps: "+hasErrorProps),$conlog("+++++++++ hasBoxedStringBug: "+hasBoxedStringBug),$conlog("+++++++++ hasEnumStringBug: "+hasEnumStringBug),$conlog("+++++++++ hasArrayLengthBug: "+hasArrayLengthBug),$conlog("+++++++++ hasDeleteBug: "+hasDeleteBug),$conlog("+++++++++ hasCallBug: "+hasCallBug),$conlog("+++++++++ hasApplyBug: "+hasApplyBug),$conlog("+++++++++ hasApplyRequiresArrayLikeBug: "+hasApplyRequiresArrayLikeBug),$conlog("+++++++++ supportsApplyArrayLike: "+supportsApplyArrayLike),$conlog("+++++++++ hasProto: "+hasProto),$conlog("+++++++++ hasGetSet: "+hasGetSet),$conlog("+++++++++ isStrictMode: "+isStrictMode),exports.version="0.2.0",exports.Number.POSITIVE_ZERO=POSITIVE_ZERO,exports.Number.NEGATIVE_ZERO=NEGATIVE_ZERO,exports.Number.WORD8=WORD8,exports.Number.UWORD8=UWORD8,exports.Number.WORD16=WORD16,exports.Number.UWORD16=UWORD16,exports.Number.WORD32=WORD32,exports.Number.UWORD32=UWORD32,exports.Number.MAX_UINT32=MAX_UINT32,exports.Number.MAX_INT32=MAX_INT32,exports.Number.MIN_INT32=MIN_INT32,exports.Number.MAX_UINT16=MAX_UINT16,exports.Number.MAX_INT16=MAX_INT16,exports.Number.MIN_INT16=MIN_INT16,exports.Number.MAX_UINT8=MAX_UINT8,exports.Number.MAX_INT8=MAX_INT8,exports.Number.MIN_INT8=MIN_INT8,exports.Number.MAX_SAFE_INTEGER=MAX_SAFE_INTEGER,exports.Number.MIN_SAFE_INTEGER=MIN_SAFE_INTEGER,exports.Number.UNSAFE_INTEGER=UNSAFE_INTEGER,exports.Number.MAX_VALUE=MAX_VALUE,exports.Number.MIN_VALUE=MIN_VALUE,exports.Number.NaN=NaN,exports.Number.POSITIVE_INFINITY=INFINITY,exports.Number.NEGATIVE_INFINITY=NEGATIVE_INFINITY,exports.Number.EPSILON=EPSILON,exports.Function.noop=noop,exports.Function.returnArgs=$returnArgs,exports.Number.clamp=function(a,b,c){return $min($max(a,b),c)},exports.Number.isPositive=function(a){var b;return b="number"!=typeof a?!1:0===a?1/a===INFINITY:a>0},exports.Number.isNegative=function(a){var b;return b="number"!=typeof a?!1:0===a?1/a!==INFINITY:0>a},$toObject=$decide(function(){var a;$affirm.ok(!testShims,"testing shim"),$affirm["throws"](function(){$Object()},CTypeError,"no arguments"),$affirm["throws"](function(){$Object(Undefined)},CTypeError,"undefined"),$affirm["throws"](function(){$Object(null)},CTypeError,"null"),$affirm.doesNotThrow(function(){a=$Object(!1)},"boolean"),$affirm.strictEqual(typeof a,"object","boolean object"),$affirm.doesNotThrow(function(){a=$Object(0)},"number"),$affirm.strictEqual(typeof a,"object","number object"),$affirm.doesNotThrow(function(){a=$Object("")},"string"),$affirm.strictEqual(typeof a,"object","string")},function(){return $Object},function(){return $toObject},"ToObject patch"),$toString=$decide(function(){$affirm.ok(!testShims,"testing shim"),$affirm.doesNotThrow(function(){$String()},"test1"),$affirm.strictEqual($String(),"undefined","test2"),$affirm.doesNotThrow(function(){$String(Undefined)},"test3"),$affirm.strictEqual($String(Undefined),"undefined","test4"),$affirm.doesNotThrow(function(){$String(null)},"test5"),$affirm.strictEqual($String(null),"null","test3")},function(){return $String},function(){return $toString},"ToString patch"),exports.String.ToString=$toString,$isNumeric=function(){var a=new CRegExp("^[+\\-]?");return function(b){var c,d,e;return $isNumber(b)||$isString(b)?(d=$call(pReplace,b,a,""),e=$parseFloat(d),c=e===e&&$isFinite(d)):c=!1,c}}(),exports.Object.isNumeric=$isNumeric,exports.Number.inRange=function(a,b,c){return b=$toPrimitive(b,hintNumber),$isNumber(b)||$isNumeric(b)||(b=NaN),c=$toPrimitive(c,hintNumber),$isNumber(c)||$isNumeric(c)||(c=NaN),$toNumber(a)>=$toNumber(b)&&a<=$toNumber(c)},$inRange=exports.Number.inRange,exports.Number.outRange=function(a,b,c){return a=$toPrimitive(a,hintNumber),$isNumber(a)&&a===a||$isNumeric(a)?(b=$toPrimitive(b,hintNumber),$isNumber(b)&&b===b||$isNumeric(b)?(c=$toPrimitive(c,hintNumber),$isNumber(c)&&c===c||$isNumeric(c)?(a=$toNumber(a),a<=$toNumber(b)||a>=$toNumber(c)):!0):!0):!0},exports.Object.RequireObjectCoercible=$requireObjectCoercible,exports.Object.ToObject=$toObject,exports.Object.hasProperty=$hasProperty,function(toStringTag){function isFunctionExtended(a){return isFunctionInternal(a,!1)&&isNativeFunction(a)}var runIENativeFunction,isIENativeFunction,isNativeFunction,isFunctionInternal;try{!$isPrimitive(global)&&global.alert&&$call(base.Function.toString,global.alert),runIENativeFunction=!1}catch(eRunIENativeFunction){runIENativeFunction=!0}isIENativeFunction=function(){var a,b=runIENativeFunction&&global.alert&&typeof global.alert.toString,c=new CRegExp("^\\s*\\bfunction\\b");return a="undefined"===b&&$call(pTest,c,global.alert)?function(a){var b=typeof a.toString;return"undefined"===b&&$call(pTest,c,a)}:function(){return!1}}();try{eval("("+$call(base.Function.toString,CFunction)+")"),isNativeFunction=function(){var a=new CRegExp("^function \\S*\\(\\) \\{ (\\[native code\\]|\\/\\* source code not available \\*\\/) \\}$");return function(b){return $call(pTest,a,b)}}()}catch(eINF1){isNativeFunction=function(inputArg){var val;try{eval("("+inputArg.toString()+")"),val=!1}catch(eFnToString){val=!0}return val}}isFunctionInternal=runIENativeFunction?function(a,b){var c;return c=b?isIENativeFunction(a)||isFunctionExtended(a):$call(toStringTag,a)===stringTagFunction}:function(a,b){var c;return c=b?isFunctionExtended(a):$call(toStringTag,a)===stringTagFunction},exports.Function.isFunction=function(a){return!$isPrimitive(a)&&(isFunctionInternal(a,!1)||isFunctionInternal(a,!0))},$isFunction=exports.Function.isFunction,runIENativeFunction?exports.Function.isNativeFunction=function(a){return $isFunction(a)&&(isNativeFunction(a)||isIENativeFunction(a))}:exports.Function.isNativeFunction=function(a){return $isFunction(a)&&isNativeFunction(a)}}(base.Object.toString),$isNative=exports.Function.isNativeFunction,exports.Function.proto.call=function(){return $decide(function(){$affirm.ok($isNative(base.Function.call),"not native")},function(){return $decide(function(){$affirm.ok(!testShims,"testing patch"),$affirm.ok(!hasCallBug,"strict mode bug")},function(){return $pCall},function(){return $pCall},"Function.call patch")},function(){return $pCall},"Function.call shim")}(),exports.Function.call=$call,exports.Function.proto.apply=function(){return $decide(function(){$affirm.ok($isNative(base.Function.apply),"not native")},function(){return $decide(function(){$affirm.ok(!testShims,"testing patch"),$affirm.ok(!hasApplyBug,"strict mode bug"),$affirm.ok(!hasApplyRequiresArrayLikeBug,"correct arguments and error throwing"),$affirm.ok(supportsApplyArrayLike,"supports array like objects")},function(){return $pApply},function(){return $pApply},"Function.apply patch")},function(){return $pApply},"Function.apply shim")}(),exports.Function.apply=$apply,exports.Object.typeOf=$typeOf,exports.Object.areSameTypeOf=function(a,b){a=$typeOf(a),b=$typeOf(b);var c,d,e=a===b;if(e)for(c=$toLength(arguments.length),d=2;c>d&&(b=$typeOf(arguments[d]),e=a===b,e);d+=1);return e},exports.Object.areSameClass=function(a,b){a=$toStringTag(a);var c,d,e=a===$toStringTag(b);if(e)for(c=$toLength(arguments.length),d=2;c>d&&(e=a===$toStringTag(arguments[d]),e);d+=1);return e},exports.Object.instanceOf=$instanceOf,exports.isNaN=$decide($affirmBasic(base.isNaN),function(){return base.isNaN},function(){return $isNaN},"isNaN shim"),$isNaN=exports.isNaN,exports.isFinite=$decide($affirmBasic(base.isFinite),function(){return base.isFinite},function(){return $isFinite},"isFinite shim"),$isFinite=exports.isFinite,exports.Array.proto.slice=$decide(function(){function a(){var a,b=arguments.length,c=[];for(c.length=b,a=0;b>a;a+=1)c[a]=arguments[a];return c}function b(a,b,c){var d,e=$apply(base.Array.slice,a,b),f=$toLength(c.length),g=!0;if($toLength(e.length)!==f)g=!1;else for(d=0;f>d;d+=1)if(e[d]!==c[d]){g=!1;break}return g}$affirmBasic(base.Array.slice)(),$affirm["throws"](function(){$call(base.Array.slice)},CTypeError,"no arguments"),$affirm["throws"](function(){$call(base.Array.slice,Undefined)},CTypeError,"argument is undefined"),$affirm["throws"](function(){$call(base.Array.slice,null)},CTypeError,"argument is null");var c=$returnArgs(Undefined,null,1,"a",2,"b",null,Undefined),d=a(Undefined,null,1,"a",2,"b",null,Undefined),e={0:Undefined,1:null,2:1,3:"a",4:2,5:"b",6:null,7:Undefined,length:8},f="1234567890";$affirm.ok(b(d,[],a(Undefined,null,1,"a",2,"b",null,Undefined)),"test1"),$affirm.ok(b(d,[Undefined,Undefined],a(Undefined,null,1,"a",2,"b",null,Undefined)),"test2"),$affirm.ok(b(d,[-1],a(Undefined)),"test3"),$affirm.ok(b(d,[0],a(Undefined,null,1,"a",2,"b",null,Undefined)),"test4"),$affirm.ok(b(d,[3],a("a",2,"b",null,Undefined)),"test5"),$affirm.ok(b(d,[-1,4],[]),"test6"),$affirm.ok(b(d,[0,4],a(Undefined,null,1,"a")),"test7"),$affirm.ok(b(d,[3,6],a("a",2,"b")),"test8"),$affirm.ok(b(c,[],$returnArgs(Undefined,null,1,"a",2,"b",null,Undefined)),"test9"),$affirm.ok(b(c,[Undefined,Undefined],$returnArgs(Undefined,null,1,"a",2,"b",null,Undefined)),"test10"),$affirm.ok(b(c,[-1],$returnArgs(Undefined)),"test11"),$affirm.ok(b(c,[0],$returnArgs(Undefined,null,1,"a",2,"b",null,Undefined)),"test12"),$affirm.ok(b(c,[3],$returnArgs("a",2,"b",null,Undefined)),"test13"),$affirm.ok(b(c,[-1,4],[]),"test14"),$affirm.ok(b(c,[0,4],$returnArgs(Undefined,null,1,"a")),"test15"),$affirm.ok(b(c,[3,6],$returnArgs("a",2,"b")),"test16"),$affirm.ok(b(e,[],a(Undefined,null,1,"a",2,"b",null,Undefined)),"test17"),$affirm.ok(b(e,[Undefined,Undefined],a(Undefined,null,1,"a",2,"b",null,Undefined)),"test18"),$affirm.ok(b(e,[-1],a(Undefined)),"test19"),$affirm.ok(b(e,[0],a(Undefined,null,1,"a",2,"b",null,Undefined)),"test20"),$affirm.ok(b(e,[3],a("a",2,"b",null,Undefined)),"test21"),$affirm.ok(b(e,[-1,4],[]),"test22"),$affirm.ok(b(e,[0,4],a(Undefined,null,1,"a")),"test23"),$affirm.ok(b(e,[3,6],a("a",2,"b")),"test24"),$affirm.ok(b(f,[],a("1","2","3","4","5","6","7","8","9","0")),"test25"),$affirm.ok(b(f,[Undefined,Undefined],a("1","2","3","4","5","6","7","8","9","0")),"test26"),$affirm.ok(b(f,[-1],a("0")),"test27"),$affirm.ok(b(f,[0],a("1","2","3","4","5","6","7","8","9","0")),"test28"),$affirm.ok(b(f,[3],a("4","5","6","7","8","9","0")),"test29"),$affirm.ok(b(f,[-1,4],a()),"test30"),$affirm.ok(b(f,[0,4],a("1","2","3","4")),"test31"),$affirm.ok(b(f,[3,6],a("4","5","6")),"test32")},function(){return base.Array.slice},function(){return $pSlice},"Array.slice shim"),exports.Array.slice=$toMethod(exports.Array.proto.slice),$slice=exports.Array.slice,exports.Function.ToMethod=$toMethod,exports.Object.toStringTag=$toStringTag,exports.Function.proto.bind=$decide(function(){function a(a){this.name=a||"A"}$affirmBasic(base.Function.bind)();var b=[1,2,3],c=$call(base.Function.bind,function(){return b},null),d=new c;$affirm.strictEqual(b,d,"same array"),c=$call(base.Function.bind,a,null,"B"),d=new c,$affirm.ok(d instanceof a,"instanceof a"),$affirm.ok(d instanceof c,"instanceof b"),$affirm.strictEqual(d.name,"B","return B")},function(){return base.Function.bind},function(){function a(){}function b(a,b){return new CFunction("binder","apply","return function ("+b+") { return apply(binder, this, arguments); };")(a,$apply)}return function(c){var d=$throwIfNotFunction(this),e=$argSlice(arguments,1),f=b(function(){var a,b,g=[],h=$toLength(e.length),i=$toLength(arguments.length);for(g.length=h+i,b=0;h>b;b+=1)g[b]=e[b];for(b=0;i>b;b+=1)g[h+b]=arguments[b];return $instanceOf(this,f)?(a=$apply(d,this,g),$Object(a)===a?a:this):$apply(d,c,g)},$bindArgs(d.length-e.length));return $Object(d.prototype)===d.prototype&&(a.prototype=d.prototype,f.prototype=new a,a.prototype=protoFunction),f}},"Function.bind shim"),exports.Function.bind=$toMethod(exports.Function.proto.bind),exports.Array.isArray=$decide(function(){$affirmBasic(base.Array.isArray)(),$affirm.ok(base.Array.isArray([]),"is an array"),$affirm.ok(!base.Array.isArray({}),"is an array")},function(){return base.Array.isArray},function(){return $isArray},"Array.isArray shim"),$isArray=exports.Array.isArray,exports.Array.proto.join=function(){return $decide($affirmBasic(base.Array.join),function(){return $decide(function(){$affirm.strictEqual($call(base.Array.join,[1,2]),"1,2","defaults to comma 1"),$affirm.strictEqual($call(base.Array.join,[1,2],Undefined),"1,2","defaults to comma 2")},function(){return base.Array.join},function(){var a=base.Array.join;return function(b){return $requireObjectCoercible(this),"undefined"==typeof b&&(b=","),$call(a,this,b)}},"Array.join patch")},function(){return function(a){var b,c,d=$toObject(this),e=$toLength(d.length),f=e-1,g="";for("undefined"==typeof a&&(a=","),a=$toString(a),b=0;e>b;b+=1)c=d[b],null!=c&&(g+=$toString(c)),f>b&&(g+=a);return g}},"Array.join shim")}(),exports.Array.join=$toMethod(exports.Array.proto.join),$join=exports.Array.join,exports.Object.is=$decide(function(){$affirmBasic(base.Object.is)()},function(){return base.Object.is},function(){return function(a,b){var c;return c=a===b?0!==a||1/a===1/b:a!==a&&b!==b}},"Object.is shim"),exports.Number.isNaN=$decide(function(){$affirmBasic(base.Number.isNaN)()},function(){return base.Number.isNaN},function(){return function(a){return"number"==typeof a&&base.isNaN(a)}},"Number.isNaN shim"),exports.Number.isFinite=$decide(function(){$affirmBasic(base.Number.isFinite)()},function(){return base.Number.isFinite},function(){return function(a){return"number"==typeof a&&a===a&&a!==INFINITY&&a!==NEGATIVE_INFINITY}},"Number.isFinite shim"),exports.Math.sign=$decide(function(){$affirmBasic(base.Math.sign)()},function(){return base.Math.sign},function(){return function(a){return $toNumber(a)&&($toNumber(a>=0)||-1)}},"Math.sign shim"),exports.Number.toInteger=$toInteger,$isInteger=$decide($affirmBasic(base.Number.isInteger),function(){return base.Number.isInteger},function(){return $isInteger},"Number.isInteger shim"),exports.Number.isInteger=$isInteger,$isSafeInteger=$decide(function(){$affirmBasic(base.Number.isSafeInteger)(),$affirm.ok(!base.Number.isSafeInteger(UNSAFE_INTEGER),"max unsafe"),$affirm.ok(!base.Number.isSafeInteger(-UNSAFE_INTEGER),"min unsafe")},function(){return base.Number.isSafeInteger},function(){return $isSafeInteger},"Number.isSafeInteger shim"),exports.Number.isSafeInteger=$isSafeInteger,exports.Number.toInt32=toInt32,exports.Number.isInt32=function(a){return $isSafeInteger(a)&&a>=MIN_INT32&&MAX_INT32>=a},exports.Number.proto.modulo=function(a){return this-a*$floor(this/a)},exports.Number.modulo=$toMethod(exports.Number.proto.modulo,$firstArg),$modulo=exports.Number.modulo,exports.Number.isOdd=function(a){return $isInteger(a)&&a%2!==0},exports.Number.isEven=function(a){return $isInteger(a)&&a%2===0},exports.Number.toUint=function(a){var b=$toNumber(a),c=0;return b&&b===b&&b!==INFINITY&&b!==NEGATIVE_INFINITY&&(c=$modulo($toInteger(b),UNSAFE_INTEGER)),c},exports.Number.isUint=function(a){return $isSafeInteger(a)&&a>=0&&MAX_SAFE_INTEGER>=a},exports.Number.toLength=$toLength,exports.Number.toUint32=function(a){var b=$toNumber(a),c=0;return b&&b===b&&b!==INFINITY&&b!==NEGATIVE_INFINITY&&(c=$modulo($toInteger(b),UWORD32)),c},exports.Number.isUint32=$isUint32,exports.Number.toInt16=function(a){var b=$toNumber(a),c=0;return b&&b===b&&b!==INFINITY&&b!==NEGATIVE_INFINITY&&(c=(b>0||-1)*$floor($abs(b))%UWORD16,c>MAX_INT16?c-=UWORD16:MIN_INT16>c&&(c+=UWORD16)),c},exports.Number.isInt16=function(a){return $isSafeInteger(a)&&a>=MIN_INT16&&MAX_INT16>=a},exports.Number.toUint16=function(a){var b=$toNumber(a),c=0;return b&&b===b&&b!==INFINITY&&b!==NEGATIVE_INFINITY&&(c=$modulo($toInteger(b),UWORD16)),c},exports.Number.isUint16=function(a){return $isSafeInteger(a)&&a>=0&&MAX_UINT16>=a},exports.Number.toInt8=function(a){var b=$toNumber(a),c=0;return b&&b===b&&b!==INFINITY&&b!==NEGATIVE_INFINITY&&(c=(b>0||-1)*$floor($abs(b))%UWORD8,c>MAX_INT8?c-=UWORD8:MIN_INT8>c&&(c+=UWORD8)),c},exports.Number.isInt8=function(a){return $isSafeInteger(a)&&a>=MIN_INT8&&MAX_INT8>=a},exports.Number.toUint8=function(a){var b=$toNumber(a),c=0;return b&&b===b&&b!==INFINITY&&b!==NEGATIVE_INFINITY&&(c=$modulo($toInteger(b),UWORD8)),c},exports.Number.isUint8=function(a){return $isSafeInteger(a)&&a>=0&&MAX_UINT8>=a},exports.Array.proto.concat=$decide(function(){$affirmBasic(base.Array.concat)(),$affirm.doesNotThrow(function(){$call(base.Array.concat,[],!0)});var a,b,c=[1,2,3],d=$slice($returnArgs(1,2,3,Undefined,null,!1));for($affirm.doesNotThrow(function(){a=$call(base.Array.concat,c,$slice($returnArgs(void 0,null,!1)))}),$affirm.strictEqual(a.length,6,"array length incorrect"),b=0;b<a.length;b+=1)$affirm.ok($call(pHasOwn,a,b),"array value not set"),$affirm.strictEqual(a[b],d[b],"array wrong return value")},function(){return base.Array.concat},function(){return $pConcat},"Array.concat shim"),exports.Array.concat=$toMethod(exports.Array.proto.concat),exports.Array.proto.push=$decide(function(){$affirmBasic(base.Array.push)(),$affirm.doesNotThrow(function(){$call(base.Array.push,[],!0)});var a=[],b={};$affirm.strictEqual($call(base.Array.push,a,Undefined),1,"array wrong return count"),$affirm.strictEqual(a.length,1,"array length incorrect"),$affirm.ok($call(pHasOwn,a,0),"array value not set"),$affirm.strictEqual(a[0],Undefined,"array value incorrect"),$affirm.strictEqual($call(base.Array.push,b,Undefined),1,"object wrong return count"),$affirm.strictEqual(b.length,1,"object length incorrect"),$affirm.ok($call(pHasOwn,b,0),"object value not set"),$affirm.strictEqual(b[0],Undefined,"object value incorrect"),$affirm.strictEqual($call(base.Array.push,a,0),2,"array wrong return count"),$affirm.strictEqual(a.length,2,"array length incorrect"),$affirm.ok($call(pHasOwn,a,1),"array value not set"),$affirm.strictEqual(a[1],0,"array value incorrect"),$affirm.strictEqual($call(base.Array.push,b,0),2,"object wrong return count"),$affirm.strictEqual(b.length,2,"object length incorrect"),$affirm.ok($call(pHasOwn,b,1),"object value not set"),$affirm.strictEqual(b[1],0,"object value incorrect")},function(){return base.Array.push},function(){return function(){var a,b=$toObject(this),c=$toLength(b.length),d=$toLength(arguments.length);for(b.length=c+d,a=0;d>a;a+=1)b[c+a]=arguments[a];return b.length}},"Array.push shim"),exports.Array.push=$toMethod(exports.Array.proto.push),$push=exports.Array.push,exports.Array.proto.pop=$decide(function(){$affirmBasic(base.Array.pop)(),$affirm.doesNotThrow(function(){$call(base.Array.pop,[])});var a=[1,2,3],b={0:1,1:2,2:3,length:3};$affirm.strictEqual($call(base.Array.pop,a),3,"array wrong return value"),$affirm.strictEqual(a.length,2,"array length incorrect"),$affirm.ok(!$call(pHasOwn,a,2),"array value 2 not deleted"),$affirm.strictEqual($call(base.Array.pop,b),3,"object wrong return value"),$affirm.strictEqual(b.length,2,"object length incorrect"),$affirm.ok(!$call(pHasOwn,b,2),"object value 2 not deleted"),$affirm.strictEqual($call(base.Array.pop,a),2,"array wrong return value"),$affirm.strictEqual(a.length,1,"array length incorrect"),$affirm.ok(!$call(pHasOwn,a,1),"array value 1 not deleted"),$affirm.strictEqual($call(base.Array.pop,b),2,"object wrong return value"),$affirm.strictEqual(b.length,1,"object length incorrect"),$affirm.ok(!$call(pHasOwn,b,1),"object value 1 not deleted")},function(){return base.Array.pop},function(){return function(){var a,b,c=$toObject(this),d=$toLength(c.length);return 0===d?c.length=0:(a=d-1,b=c[a],$deleteProperty(c,a),c.length=a),b}},"Array.pop shim"),exports.Array.pop=$toMethod(exports.Array.proto.pop),$pop=exports.Array.pop,exports.Array.proto.shift=$decide(function(){$affirmBasic(base.Array.shift)(),$affirm.doesNotThrow(function(){$call(base.Array.shift,[])});var a=[1,2,3],b={0:1,1:2,2:3,length:3};$affirm.strictEqual($call(base.Array.shift,a),1,"array wrong return value"),$affirm.strictEqual(a.length,2,"array length incorrect"),$affirm.ok(!$call(pHasOwn,a,2),"array value 2 not deleted"),$affirm.strictEqual($call(base.Array.shift,b),1,"object wrong return value"),$affirm.strictEqual(b.length,2,"object length incorrect"),$affirm.ok(!$call(pHasOwn,b,2),"object value 2 not deleted"),$affirm.strictEqual($call(base.Array.shift,a),2,"array wrong return value"),$affirm.strictEqual(a.length,1,"array length incorrect"),$affirm.ok(!$call(pHasOwn,a,1),"array value 1 not deleted"),$affirm.strictEqual($call(base.Array.shift,b),2,"object wrong return value"),$affirm.strictEqual(b.length,1,"object length incorrect"),$affirm.ok(!$call(pHasOwn,b,1),"object value 1 not deleted"),b={0:Undefined,1:null,2:-1,3:0,4:1,5:!1,6:!0,7:Undefined,8:"",9:"abc",10:null,11:Undefined},$affirm.strictEqual($call(base.Array.shift,b),Undefined,"test1"),$affirm.strictEqual($call(base.Array.shift,b),Undefined,"test2"),$affirm.strictEqual($call(base.Array.shift,b),Undefined,"test3"),$affirm.strictEqual($call(base.Array.shift,b),Undefined,"test4"),$affirm.strictEqual($call(base.Array.shift,b),Undefined,"test5"),$affirm.strictEqual($call(base.Array.shift,b),Undefined,"test6"),$affirm.strictEqual($call(base.Array.shift,b),Undefined,"test7"),$affirm.strictEqual($call(base.Array.shift,b),Undefined,"test8"),$affirm.strictEqual($call(base.Array.shift,b),Undefined,"test9"),$affirm.strictEqual($call(base.Array.shift,b),Undefined,"test10"),$affirm.strictEqual($call(base.Array.shift,b),Undefined,"test11"),$affirm.strictEqual($call(base.Array.shift,b),Undefined,"test112"),$affirm.strictEqual(b[9],"abc","test13"),$affirm.strictEqual(b.length,0,"test14")},function(){return base.Array.shift},function(){return function(){var a,b,c,d=$toObject(this),e=$toLength(d.length);if(0===e)d.length=0;else{for(b=d[0],a=1;e>a;a+=1)c=a-1,$hasProperty(d,a)?d[c]=d[a]:$deleteProperty(d,c);$deleteProperty(d,e-1),d.length=e-1}return b}},"Array.shift shim"),exports.Array.shift=$toMethod(exports.Array.proto.shift),$shift=exports.Array.shift,exports.Array.proto.unshift=$decide(function(){$affirmBasic(base.Array.unshift)(),$affirm.doesNotThrow(function(){$call(base.Array.unshift,[],!0)});var a,b,c=[],d={};for($affirm.strictEqual($call(base.Array.unshift,c,Undefined),1,"array wrong return count"),$affirm.strictEqual(c.length,1,"array length incorrect"),$affirm.ok($call(pHasOwn,c,0),"array value not set"),$affirm.strictEqual(c[0],Undefined,"array value incorrect"),$affirm.strictEqual($call(base.Array.unshift,d,Undefined),1,"object wrong return count"),$affirm.strictEqual(d.length,1,"object length incorrect"),$affirm.ok($call(pHasOwn,d,0),"object value not set"),$affirm.strictEqual(d[0],Undefined,"object value incorrect"),$affirm.strictEqual($call(base.Array.unshift,c,0),2,"array wrong return count"),$affirm.strictEqual(c.length,2,"array length incorrect"),$affirm.ok($call(pHasOwn,c,0),"array value not set"),$affirm.strictEqual(c[0],0,"array value incorrect"),$affirm.strictEqual($call(base.Array.unshift,d,0),2,"object wrong return count"),$affirm.strictEqual(d.length,2,"object length incorrect"),$affirm.ok($call(pHasOwn,d,0),"object value not set"),$affirm.strictEqual(d[0],0,"object value incorrect"),a=[],a.length=12,a[0]=Undefined,a[1]=null,a[2]=-1,a[3]=0,a[4]=1,a[5]=!1,a[6]=!0,a[7]=Undefined,a[8]="",a[9]="abc",a[10]=null,a[11]=Undefined,c=[],$affirm.strictEqual($call(base.Array.unshift,c,Undefined),1,"test1"),$affirm.strictEqual($call(base.Array.unshift,c,null),2,"test2"),$affirm.strictEqual($call(base.Array.unshift,c,"abc"),3,"test3"),$affirm.strictEqual($call(base.Array.unshift,c,""),4,"test4"),$affirm.strictEqual($call(base.Array.unshift,c,Undefined),5,"test5"),$affirm.strictEqual($call(base.Array.unshift,c),5,"test6"),$affirm.strictEqual($call(base.Array.unshift,c),5,"test7"),$affirm.strictEqual($call(base.Array.unshift,c),5,"test8"),$affirm.strictEqual($call(base.Array.unshift,c),5,"test9"),$affirm.strictEqual($call(base.Array.unshift,c,!0),6,"test10"),$affirm.strictEqual($call(base.Array.unshift,c,!1),7,"test11"),$affirm.strictEqual($call(base.Array.unshift,c,1),8,"test12"),$affirm.strictEqual($call(base.Array.unshift,c,0),9,"test13"),$affirm.strictEqual($call(base.Array.unshift,c,-1),10,"test14"),$affirm.strictEqual($call(base.Array.unshift,c,null),11,"test15"),$affirm.strictEqual($call(base.Array.unshift,c,Undefined),12,"test16"),$affirm.strictEqual(c.length,a.length,"test17"),b=0;b<c.length;b+=1)$affirm.ok($call(pHasOwn,c,b),"hasOwn test"+b),$affirm.strictEqual(c[b],a[b],"strictEqual test"+b)},function(){return base.Array.unshift},function(){return function(){var a,b,c,d=$toObject(this),e=$toLength(d.length),f=e,g=$toLength(arguments.length);for(d.length=e+g,f=e;f>0;f-=1)a=f-1,b=f+g-1,$hasProperty(d,a)?d[b]=d[a]:$deleteProperty(d,b);for(c=0;g>c;c+=1)d[c]=arguments[c];return d.length}},"Array.unshift shim"),exports.Array.unshift=$toMethod(exports.Array.proto.unshift),$unshift=exports.Array.unshift,exports.Array.proto.reverse=$decide(function(){$affirmBasic(base.Array.reverse)(),$affirm.doesNotThrow(function(){$call(base.Array.reverse,1)},"number"),$affirm.doesNotThrow(function(){$call(base.Array.reverse,!0)},"boolean"),$affirm.doesNotThrow(function(){$call(base.Array.reverse,"a")},"string");var a=[];a.length=12,a[0]=Undefined,a[1]=null,a[2]=-1,a[3]=0,a[4]=1,a[5]=!1,a[6]=!0,a[8]="",a[9]="abc",a[10]=null,a[11]=Undefined,$affirm.doesNotThrow(function(){$call(base.Array.reverse,a)},"test1"),$affirm.strictEqual(a.length,12,"test2"),$affirm.strictEqual(a[11],Undefined,"test3"),$affirm.ok($call(pHasOwn,a,11),"test4"),$affirm.strictEqual(a[10],null,"test5"),$affirm.strictEqual(a[9],-1,"test6"),$affirm.strictEqual(a[8],0,"test7"),$affirm.strictEqual(a[7],1,"test8"),$affirm.strictEqual(a[6],!1,"test9"),$affirm.strictEqual(a[5],!0,"test10"),$affirm.strictEqual(a[4],Undefined,"test11"),$affirm.ok(!$call(pHasOwn,a,4),"test12"),$affirm.strictEqual(a[3],"","test13"),$affirm.strictEqual(a[2],"abc","test14"),$affirm.strictEqual(a[1],null,"test15"),$affirm.strictEqual(a[0],Undefined,"test16"),$affirm.ok($call(pHasOwn,a,0),"test17")},function(){return base.Array.reverse},function(){return function(){for(var a,b,c,d,e,f=$toObject(this),g=$toLength(f.length),h=$floor(g/2),i=0;i!==h;)e=g-i-1,a=f[i],b=f[e],c=$hasProperty(f,i),d=$hasProperty(f,e),c&&d?(f[i]=b,f[e]=a):!c&&d?(f[i]=b,$deleteProperty(f,e)):c&&!d&&(f[e]=a,$deleteProperty(f,i)),i+=1;return f}},"Array.reverse shim"),exports.Array.reverse=$toMethod(exports.Array.proto.reverse),$reverse=exports.Array.reverse,exports.Number.clampToInt=function(a,b,c){return $min($max($toInteger(a),$toInteger(b)),$toInteger(c))},exports.String.proto.slice=$decide(function(){$affirmBasic(base.String.slice)()},function(){return base.String.slice},function(){return function(a,b){var c,d,e,f,g=$onlyCoercibleToString(this),h=$toLength(g.length),i=$toInteger(a),j="";for(d="undefined"==typeof b?h:$toInteger(b),e=0>i?$max(h+i,0):$min(i,h),f=0>d?$max(h+d,0):$min(d,h),c=e;f>c;c+=1)j+=$getItem(g,c,stringTagString);return j}},["start","end"],"String.slice shim"),exports.String.slice=$toMethod(exports.String.proto.slice),$sSlice=exports.String.slice,exports.String.proto.repeat=$decide($affirmBasic(base.String.repeat),function(){return base.String.repeat},function(){function a(b,c){var d,e;return 1>c||b.length<1?e="":c%2===1?(c-=1,e=c>0?a(b,c)+b:b):(d=a(b,c/2),e=d+d),e}return function(b){var c=$onlyCoercibleToString(this);if(b=$toInteger(b),0>b)throw new CRangeError("repeat count must be non-negative");if(b===INFINITY)throw new CRangeError("repeat count must be less than infinity");return a(c,b)}},"String.repeat shim"),exports.String.repeat=$toMethod(exports.String.proto.repeat),$repeat=exports.String.repeat,exports.Object.getPrototypeOf=function(){return $decide($affirmBasic(base.Object.getPrototypeOf),function(){return $decide(function(){var a;$affirm.doesNotThrow(function(){a=base.Object.getPrototypeOf(1)},"get number literal proto"),$affirm.strictEqual(a,protoNumber,"work with number literal"),$affirm.doesNotThrow(function(){a=base.Object.getPrototypeOf(!0)},"get boolean literal proto"),$affirm.strictEqual(a,protoBoolean,"work with boolean literal"),$affirm.doesNotThrow(function(){a=base.Object.getPrototypeOf("")},"get string literal proto"),$affirm.strictEqual(a,protoString,"work with string literal")},function(){return base.Object.getPrototypeOf},function(){var a=base.Object.getPrototypeOf;return function(b){return a($toObject(b))}},"Object.getPrototypeOf primitive patch")},function(){return $decide(function(){var a;$affirm.doesNotThrow(function(){a=protoObject[stringProto]},"get __proto__"),$affirm.strictEqual(protoObject[stringProto],null,"has __proto__"),$affirm.doesNotThrow(function(){a=$toObject(1)[stringProto]},"get number literal proto"),$affirm.strictEqual(a,protoNumber,"work with number literal"),$affirm.doesNotThrow(function(){a=$toObject(!0)[stringProto]},"get boolean literal proto"),$affirm.strictEqual(a,protoBoolean,"work with boolean literal"),$affirm.doesNotThrow(function(){a=$toObject("")[stringProto]},"get string literal proto"),$affirm.strictEqual(a,protoString,"work with string literal"),$affirm.ok(!testShims,"testing shim")},function(){return function(a){return $toObject(a)[stringProto]}},function(){var a;return $returnArgs().constructor.prototype!==protoObject&&(a=!0),function(b){var c,d,e=$toObject(b);return e===protoObject?null:($isFunction(e.constructor)?c=a&&$isArguments(e)?protoObject:e.constructor.prototype:(d=e[stringProto],c=$toStringTag(d)!==stringTagObject||$isFunction(d)?protoObject:d),e===c?protoObject:c)}},"Object.getPrototypeOf full shim")},"Object.getPrototypeOf __proto__ shim")}(),$getPrototypeOf=exports.Object.getPrototypeOf,exports.Object.isPlainObject=function(a){return $toStringTag(a)===stringTagObject&&$getPrototypeOf(a)===protoObject},$isPlainObject=exports.Object.isPlainObject,exports.Object.proto.hasOwnProperty=function(a){return $decide(function(){$affirm.ok($call(a,"abc","1"),"hasStringOwnPropBug"),$affirm.ok($call(a,$Object("abc"),"1"),"hasStringOwnPropBug")},function(){return a},function(){return function(b){var c=$toObject(this),d=$toString(b);return $isString(c)&&$isIndex(d,$toLength(c.length))||$call(a,c,d)}},"Object.hasOwnProperty hasStringOwnPropBug patch")}(pHasOwn),exports.Object.hasOwnProperty=function(a,b){return pHasOwn.call(a,b)},exports.Object.hasOwnProperty=$toMethod(exports.Object.proto.hasOwnProperty),$hasOwn=exports.Object.hasOwnProperty,exports.Object.proto.propertyIsEnumerable=function(a){var b=!0;return $decide(function(){$affirmBasic(a)(),$affirm.ok($call(a,"abc","0"),"String indexes"),$affirm.ok($call(a,$toObject("abc"),"0"),"String object indexes"),b=!1,$affirm.ok(!hasDontEnumBug,"hasDontEnumBug"),$affirm.ok(!hasEnumStringBug,"hasEnumStringBug"),$affirm.ok(!hasEnumArgsBug,"hasEnumArgsBug"),$affirm.ok(!$call(a,protoObject,"toString"),"Object.prototype.toString"),$affirm.ok(!$call(a,protoObject,"toLocaleString"),"Object.prototype.toLocaleString"),$affirm.ok(!$call(a,protoObject,"valueOf"),"Object.prototype.valueOf"),$affirm.ok(!$call(a,protoObject,"hasOwnProperty"),"Object.prototype.hasOwnProperty"),$affirm.ok(!$call(a,protoObject,"isPrototypeOf"),"Object.prototype.isPrototypeOf"),$affirm.ok(!$call(a,protoObject,"propertyIsEnumerable"),"Object.prototype.propertyIsEnumerable"),
$affirm.ok(!$call(a,protoObject,"constructor"),"Object.prototype.constructor")},function(){return a},function(){var c=$toLength(shadowed.length);return function(d){var e,f,g,h,i,j,k=$toObject(this),l=$toString(d),m=$call(a,k,l);if(!m)if(((hasEnumStringBug||b)&&$isString(k)||hasEnumArgsBug&&$isArguments(k)&&$call(pHasOwn,k,l))&&$isIndex(l,$toLength(k.length)))m=!0;else if(hasDontEnumBug){for(f=0;c>f;f+=1)if(l===shadowed[f]){for(g in base)if(j=base[g],null!=j&&k===j.proto){h=!0;break}i="constructor"===l&&$hasProperty(k,"constructor")&&k.constructor.prototype!==k,i||h||($conlog("found : "+l),e=!0);break}e&&$call(pHasOwn,k,l)&&($conlog(g+" : "+l+" : "+k[l]!==base[g][l]),m=k[l]!==base[g][l])}return m}},"Object.propertyIsEnumerable patch")}(base.Object.propertyIsEnumerable),$propertyIsEnumerable=$toMethod(exports.Object.proto.propertyIsEnumerable),exports.Object.propertyIsEnumerable=$propertyIsEnumerable,exports.Object.keys=function(){return $decide(function(){$affirmBasic(base.Object.keys)();var a;$affirm.doesNotThrow(function(){a=base.Object.keys($returnArgs(1,2))},"test1"),$affirm.strictEqual(a.length,2,"works with arguments object"),$affirm.ok(!hasErrorProps,"works with error objects"),$affirm.doesNotThrow(function(){a=base.Object.keys(CError.prototype)},"test2"),$affirm.strictEqual(a.length,0,"Error prototype zero list")},function(){return $decide(function(){var a;$affirm.doesNotThrow(function(){a=base.Object.keys(1)},"number literal"),$affirm.strictEqual(a.length,0,"number literal"),$affirm.doesNotThrow(function(){a=base.Object.keys("a")},"string literal"),$affirm.strictEqual(a.length,1,"string literal"),$affirm.doesNotThrow(function(){a=base.Object.keys(!0)},"boolean literal"),$affirm.strictEqual(a.length,0,"boolean literal")},function(){return base.Object.keys},function(){var a=base.Object.keys;return function(b){return a($toObject(b))}},"Object.keys patch")},function(){var a=$toLength(shadowed.length),b=0;return hasErrorProps&&(b=$toLength(unwantedError.length)),function(c){var d,e,f,g,h,i,j=$toObject(c),k=[],l=hasEnumStringBug&&$isString(j);if(l||hasEnumArgsBug&&$isArguments(j))for(a=$toLength(j.length),g=0;a>g;g+=1)(l||$call(pHasOwn,j,g))&&$push(k,$toString(g));for(f in j)if($call(pHasOwn,j,f)){if(hasErrorProps)for(e=!1,g=0;b>g;g+=1)if(i=unwantedError[g],j===i.proto){d=i.unwanted,$call(pHasOwn,d,f)&&j[f]===d[f]&&(e=!0);break}e||$push(k,f)}if(hasDontEnumBug){for(f in base)if(i=base[f],null!=i&&j===i.proto){h=!0;break}for(e=!h&&$hasProperty(j,"constructor")&&j.constructor.prototype===j,g=0;a>g;g+=1)d=shadowed[g],$call(pHasOwn,j,d)&&(h?j[d]!==i[d]&&$push(k,d):e&&"constructor"===d||$push(k,d))}return k}},"Object.keys shim")}(),$objectKeys=exports.Object.keys,exports.Array.proto.stableSort=function(){function a(a,b){var c,d,e,f=$call(pHasOwn,a,0),g=$call(pHasOwn,b,0);return f||g?f?g?(c="undefined"==typeof a[0],d="undefined"==typeof b[0],c&&d?e=0:c?e=1:d&&(e=-1)):e=-1:e=1:e=0,e}function b(b,c,d){var e,f=[],g=0;for(f.length=$toLength($toLength(b.length)+$toLength(c.length));$toLength(b.length)&&$toLength(c.length);)e=a(b,c),"number"!=typeof e?d(b[0],c[0])<=0?($call(pHasOwn,b,0)&&(f[g]=b[0]),$shift(b)):($call(pHasOwn,c,0)&&(f[g]=c[0]),$shift(c)):0>=e?($call(pHasOwn,b,0)&&(f[g]=b[0]),$shift(b)):($call(pHasOwn,c,0)&&(f[g]=c[0]),$shift(c)),g+=1;for(;$toLength(b.length);)$call(pHasOwn,b,0)&&(f[g]=b[0]),$shift(b),g+=1;for(;$toLength(c.length);)$call(pHasOwn,c,0)&&(f[g]=c[0]),$shift(c),g+=1;return f}function c(a,d){var e,f,g,h,i=$toLength(a.length);return 2>i?h=$slice(a):(e=$ceil(i/2),f=$slice(a,0,e),g=$slice(a,e),h=b(c(f,d),c(g,d),d)),h}return function(a){var b,d,e=$toObject(this),f=$toLength(e.length);if("undefined"==typeof a&&(a=$ascending),$throwIfNotFunction(a),f>1)for(d=c(e,a),$isArray(e)||$isArguments(e)?e.length=0:$splice(e,0,$toLength(e.length)),e.length=$toLength(d.length),b=0;f>b;b+=1)$call(pHasOwn,d,b)&&(e[b]=d[b]);return e}}(),exports.Array.stableSort=$toMethod(exports.Array.proto.stableSort),exports.Array.proto.sort=function(){return $decide(function(){$affirmBasic(base.Array.sort)();var a,b=[];b.length=9,b[0]="f",b[1]="e",b[2]="d",b[4]=null,b[5]=Undefined,b[6]="a",b[7]="c",b[8]="b",$call(base.Array.sort,b),$affirm.strictEqual(b.length,9,"test1"),$affirm.strictEqual(b[0],"a","test2"),$affirm.strictEqual(b[1],"b","test3"),$affirm.strictEqual(b[2],"c","test4"),$affirm.strictEqual(b[3],"d","test5"),$affirm.strictEqual(b[4],"e","test6"),$affirm.strictEqual(b[5],"f","test7"),$affirm.strictEqual(b[6],null,"test8"),$affirm.strictEqual(b[7],Undefined,"test9"),$affirm.strictEqual(b[8],Undefined,"test110"),$affirm.ok($call(pHasOwn,b,7),"test11"),$affirm.ok(!$call(pHasOwn,b,8),"test12"),b.length=9,b[0]="f",b[1]="e",b[2]="d",b[3]=Undefined,b[4]=null,b[5]="a",b[6]="c",b[7]="b",$call(base.Array.sort,b,$descending),$affirm.strictEqual(b.length,9,"test13"),$affirm.strictEqual(b[0],null,"test14"),$affirm.strictEqual(b[1],"f","test15"),$affirm.strictEqual(b[2],"e","test16"),$affirm.strictEqual(b[3],"d","test17"),$affirm.strictEqual(b[4],"c","test18"),$affirm.strictEqual(b[5],"b","test19"),$affirm.strictEqual(b[6],"a","test20"),$affirm.strictEqual(b[7],Undefined,"test21"),$affirm.strictEqual(b[8],Undefined,"test22"),$affirm.ok($call(pHasOwn,b,7),"test23"),$affirm.ok(!$call(pHasOwn,b,8),"test24"),a={0:5,1:2,2:4,4:null,6:1,7:3,length:8},$call(base.Array.sort,a,$descending),$affirm.strictEqual(a.length,8,"test25"),$affirm.strictEqual(a[0],null,"test26"),$affirm.strictEqual(a[1],5,"test27"),$affirm.strictEqual(a[2],4,"test28"),$affirm.strictEqual(a[3],3,"test29"),$affirm.strictEqual(a[4],2,"test30"),$affirm.strictEqual(a[5],1,"test31"),$affirm.strictEqual(a[6],Undefined,"test32"),$affirm.strictEqual(a[7],Undefined,"test33"),$affirm.ok(!$call(pHasOwn,a,6),"test34"),$affirm.ok(!$call(pHasOwn,a,7),"test35")},function(){return $decide(function(){$affirm.doesNotThrow(function(){$call(base.Array.sort,[])},"no compare argument"),$affirm.doesNotThrow(function(){$call(base.Array.sort,[],Undefined)},"undefined compare argument"),$affirm["throws"](function(){$call(base.Array.sort,[],null)},CTypeError,"null compare argument"),$affirm["throws"](function(){$call(base.Array.sort,[],1)},CTypeError,"number compare argument"),$affirm["throws"](function(){$call(base.Array.sort,[],!0)},CTypeError,"boolean compare argument"),$affirm["throws"](function(){$call(base.Array.sort,[],"a")},CTypeError,"string compare argument"),$affirm["throws"](function(){$call(base.Array.sort,[],{})},CTypeError,"object compare argument"),$affirm["throws"](function(){$call(base.Array.sort,[],[])},CTypeError,"array compare argument")},function(){return base.Array.sort},function(){var a=base.Array.sort;return function(b){return"undefined"==typeof b&&(b=$ascending),$call(a,$requireObjectCoercible(this),$throwIfNotFunction(b))}},"Array.sort patch")},function(){return exports.Array.proto.stableSort},"Array.sort shim")}(),exports.Array.sort=$toMethod(exports.Array.proto.sort),$sort=exports.Array.sort,exports.Array.proto.indexOf=$decide(function(){$affirmBasic(base.Array.indexOf)();var a;$affirm.doesNotThrow(function(){a=$call(base.Array.indexOf,[0,1],1,2)},"test1"),$affirm.strictEqual(a,-1,"item not found")},function(){return base.Array.indexOf},function(){return function(a,b){var c,d=$toObject(this),e=$toLength(d.length),f=e&&$isString(d),g=-1;if(e&&(b=arguments.length>1?$toInteger(b):0,e>b))for(0>b&&(b=e-$abs(b),0>b&&(b=0)),c=b;e>c;c+=1)if($hasItem(d,c,f)&&a===$getItem(d,c,f)){g=c;break}return g}},"Array.indexOf shim"),exports.Array.indexOf=$toMethod(exports.Array.proto.indexOf),$indexOf=exports.Array.indexOf,exports.Array.proto.contains=function(a){return function(){return-1!==$apply(a,this,arguments)}}(exports.Array.proto.indexOf),exports.Array.contains=$toMethod(exports.Array.proto.contains),exports.Object.deepEqual=function(){var a=function(b,c,d){if(b===c)return!0;var e,f,g,h,i,j,k,l,m,n,o,p,q,r,s;if($isDate(b)&&$isDate(c))return $toPrimitive(b,hintString)===$toPrimitive(c,hintString);if($isRegExp(b)&&$isRegExp(c))return b.source===c.source&&b.global===c.global&&b.multiline===c.multiline&&b.lastIndex===c.lastIndex&&b.ignoreCase===c.ignoreCase&&b.sticky===c.sticky;if(k=$isPrimitive(b),l=$isPrimitive(c),(k||$isFunction(b))&&(l||$isFunction(c)))return b==c;if(k||l)return b===c;if(b.prototype!==c.prototype)return!1;if(-1===$indexOf(d.a,b)?$push(d.a,b):m=!0,-1===$indexOf(d.b,c)?$push(d.b,c):n=!0,m&&n?d.cnt+=1:d.cnt=0,d.cnt>200)throw new CRangeError("Circular reference limit exceeded");if(i=$isArguments(b),j=$isArguments(c),i&&!j||!i&&j)return!1;if(i)return a($slice(b),$slice(c),d);if(o=$objectKeys(b),p=$objectKeys(c),q=$toLength(o.length),q!==$toLength(p.length)){if(!$isArray(b)||!$isArray(c))return!1;if(b.length!==c.length)return!1}else for($sort(o),$sort(p),r=0;q>r;r+=1)if(o[r]!==p[r])return!1;for(e=$isString(b),f=$isString(c),r=0;q>r;r+=1)if(s=o[r],!a($getItem(b,s,e),$getItem(c,s,f),d))return!1;return g=typeof b,h=typeof c,g===h};return function(b,c){return a(b,c,{a:[],b:[],cnt:0})}}(),$deepEqual=exports.Object.deepEqual,$affirm.deepEqual=function(a,b,c,d){$throwIfNotEnoughArgs(arguments,2);var e;$deepEqual(a,b)||(e=$optArgs(3,c,d,$affirm.deepEqual),$affirm.fail(a,b,e.message,"deepEqual",e.stackStartFn))},exports.Object.deepStrictEqual=function(){var a=function(b,c,d){if(b===c)return!0;var e,f,g,h,i,j,k,l,m,n,o,p,q,r,s;if($isDate(b)&&$isDate(c))return $toPrimitive(b,hintString)===$toPrimitive(c,hintString);if($isRegExp(b)&&$isRegExp(c))return b.source===c.source&&b.global===c.global&&b.multiline===c.multiline&&b.lastIndex===c.lastIndex&&b.ignoreCase===c.ignoreCase&&b.sticky===c.sticky;if(k=$isPrimitive(b),l=$isPrimitive(c),(k||$isFunction(b))&&($isPrimitive(c)||$isFunction(c)))return b===c;if(k||l)return b===c;if($getPrototypeOf(b)!==$getPrototypeOf(c))return!1;if(-1===$indexOf(d.a,b)?$push(d.a,b):m=!0,-1===$indexOf(d.b,c)?$push(d.b,c):n=!0,m&&n?d.cnt+=1:d.cnt=0,d.cnt>200)throw new CRangeError("Circular reference limit exceeded");if(i=$isArguments(b),j=$isArguments(c),i&&!j||!i&&j)return!1;if(i)return a($slice(b),$slice(c),d);if(o=$objectKeys(b),p=$objectKeys(c),q=$toLength(o.length),q!==$toLength(p.length)){if(!$isArray(b)||!$isArray(c))return!1;if(b.length!==c.length)return!1}else for($sort(o),$sort(p),r=0;q>r;r+=1)if(o[r]!==p[r])return!1;for(e=$isString(b),f=$isString(c),r=0;q>r;r+=1)if(s=o[r],!a($getItem(b,s,e),$getItem(c,s,f),d))return!1;return g=typeof b,h=typeof c,g===h};return function(b,c){return a(b,c,{a:[],b:[],cnt:0})}}(),$deepStrictEqual=exports.Object.deepStrictEqual,function(){function a(a){if(!$isRegExp(a))throw new CTypeError("Type RegExp expected: "+$toString(a));return a}function b(a,b){var d;return $isPlainObject(b)||(b={}),d=$onlyCoercibleToString($call(pExec,h,$toString(a))[1]),b.add&&(d=$call(pReplace,d+b.add,c,"")),b.remove&&(d=$call(pReplace,d,new CRegExp("["+b.remove+"]+","g"),"")),new CRegExp(a.source,d)}var c=new CRegExp("([\\s\\S])(?=[\\s\\S]*\\1)","g"),d=typeof $call(pExec,new CRegExp("()??"),"")[1],e=new CRegExp("[\\[\\](){}?*+\\^$\\\\.|]","g"),f="undefined"===d,g=new CRegExp("\\$(?:\\{(\\$+)\\}|(\\d\\d?|[\\s\\S]))","g"),h=new CRegExp("\\/([a-z]*)$","i"),i="test"===$join($call(pSplit,"test",/(?:)/,-1),"")&&"a"===$join($call(pSplit,"a b c d",/ /,-(UWORD32-1)),"")&&"a"===$join($call(pSplit,"a b c d",/ /,UWORD32+1),"")&&""===$join($call(pSplit,"a b c d",/ /,INFINITY),"");exports.String.proto.escapeRegex=function(){return $call(pReplace,$onlyCoercibleToString(this),e,"\\$&")},$escapeRegex=$toMethod(exports.String.proto.escapeRegex),exports.String.escapeRegex=$escapeRegex,exports.String.clipDuplicates=function(a){return $call(pReplace,$onlyCoercibleToString(a),c,"")},exports.RegExp.proto.exec=$decide(function(){$affirmBasic(pExec)(),$affirm["throws"](function(){$call(pExec)},CTypeError,"should throw if no arguments"),$affirm["throws"](function(){$call(pExec,Undefined)},CTypeError,"should throw if argument is undefined"),$affirm["throws"](function(){$call(pExec,null)},CTypeError,"should throw if argument is null"),$affirm.doesNotThrow(function(){$call(pExec,/x/)},"should not throw if no string argument"),$affirm.doesNotThrow(function(){$call(pExec,/x/,Undefined)},"should not throw if string argument is undefined"),$affirm.doesNotThrow(function(){$call(pExec,/x/,null)},"should not throw if string argument is null");var a,b=/x/;b.lastIndex=4,$affirm.deepEqual($slice($call(pExec,b,"123x5")),["x"],"should ignore lastIndex and set the search start position at 0 for a nonglobal regex"),b=/x/g,b.lastIndex=4,$affirm.strictEqual($call(pExec,b,"123x5"),null,"should use lastIndex to set the search start position for a global regex"),b.lastIndex=2,$affirm.deepEqual($slice($call(pExec,b,"123x5")),["x"],"should use lastIndex to set the search start position for a global regex"),b=/x/g,b.lastIndex="3",$affirm.deepEqual($slice($call(pExec,b,"123x5")),["x"],"should type convert lastIndex when setting the search start position"),b.lastIndex="4",$affirm.strictEqual($call(pExec,b,"123x5"),null,"should type convert lastIndex when setting the search start position"),b=/\b/g,a=$call(pExec,b,"1,2"),$affirm.deepEqual(a[0].length,0,"should not increment index on zero length mathces"),$affirm.deepEqual(b.lastIndex,a.index,"should not increment index on zero length mathces"),b=/x/,$call(pExec,b,"123x5"),$affirm.strictEqual(b.lastIndex,0,"should not increment lastIndex non global")},function(){return pExec},function(){return function(c){var d,e,g,h=$toNumber(a(this).lastIndex),i=$apply(pExec,this,arguments);if($isArray(i)){if(e=$toLength(i.length),!f&&e>1){for(g=0;e>g;g+=1)if(""===i[g]){d=!0;break}d&&$call(pReplace,$sSlice($toString(c),$toNumber(i.index)),b(this,{remove:"g"}),function(){var a,b,c=$toLength(arguments.length)-2;for(a=1;c>a;a+=1)b=arguments[a],$isUndefined(b)&&(i[a]=b)})}this.global&&!$toLength(i[0].length)&&$toNumber(this.lastIndex)>$toNumber(i.index)&&(this.lastIndex=$toNumber(i.index))}return this.global||(this.lastIndex=h),i}},"RegExp.exec patch"),exports.RegExp.exec=$toMethod(exports.RegExp.proto.exec),$exec=exports.RegExp.exec,exports.RegExp.proto.test=$decide(function(){$affirmBasic(pTest)(),$affirm.strictEqual(exports.RegExp.proto.exec,pExec,"RegExp.exec was patched"),$affirm["throws"](function(){$call(pTest)},CTypeError,"should throw if no arguments"),$affirm["throws"](function(){$call(pTest,Undefined)},CTypeError,"should throw if argument is undefined"),$affirm["throws"](function(){$call(pTest,null)},CTypeError,"should throw if argument is null"),$affirm.doesNotThrow(function(){$call(pTest,/x/)},"should not throw if no string argument"),$affirm.doesNotThrow(function(){$call(pTest,/x/,Undefined)},"should not throw if string argument is undefined"),$affirm.doesNotThrow(function(){$call(pTest,/x/,null)},"should not throw if string argument is null");var a=/x/;a.lastIndex=4,$affirm.ok($call(pTest,a,"123x5"),"should ignore lastIndex and set the search start position at 0 for a nonglobal regex"),a=/x/g,a.lastIndex=4,$affirm.ok(!$call(pTest,a,"123x5"),"should use lastIndex to set the search start position for a global regex"),a.lastIndex=2,$affirm.ok($call(pTest,a,"123x5"),"should use lastIndex to set the search start position for a global regex"),a=/x/g,a.lastIndex="3",$affirm.ok($call(pTest,a,"123x5"),"should type convert lastIndex when setting the search start position"),a.lastIndex="4",$affirm.ok(!$call(pTest,a,"123x5"),"should type convert lastIndex when setting the search start position"),a=/x/g,$affirm.ok(!$call(pTest,a),"should type no argument to string"),$affirm.ok(!$call(pTest,a,void 0),"should type undefined to string"),$affirm.ok(!$call(pTest,a,null),"should type null to string"),$affirm.ok(!$call(pTest,a,1),"should type 1 to string"),$affirm.ok(!$call(pTest,a,!0),"should type true to string"),$affirm.ok(!$call(pTest,a,{}),"should type {} to string"),$affirm.ok(!$call(pTest,a,[]),"should type [] to string")},function(){return pTest},function(){return function(a){return!!$exec(this,a)}},"RegExp.test shim"),exports.RegExp.test=$toMethod(exports.RegExp.proto.test),$test=exports.RegExp.test,exports.String.proto.isBytestring=function(){return $test(/^[\x00-\xFF]*$/,$onlyCoercibleToString(this))},exports.String.isBytestring=$toMethod(exports.String.proto.isBytestring),exports.String.proto.search=$decide(function(){$affirmBasic(pSearch)();var a,b=new CRegExp("c"),c=new CRegExp("c","gmi"),d="abcdefgabcdefg";$affirm.doesNotThrow(function(){a=$call(pSearch,d,b)},"should not throw performing search rx1"),$affirm.strictEqual(a,2,"rx1 gives correct index"),$affirm.strictEqual(b.source,"c","rx1 source should be unchanged"),$affirm.strictEqual(b.global,!1,"rx1 global should be unchanged"),$affirm.strictEqual(b.ignoreCase,!1,"rx1 ignoreCase should be unchanged"),$affirm.strictEqual(b.multiline,!1,"rx1 multiline should be unchanged"),$affirm.strictEqual(b.lastIndex,0,"rx1 lastIndex should be unchanged"),$affirm.doesNotThrow(function(){a=$call(pSearch,d,c)},"should not throw performing search rx2"),$affirm.strictEqual(a,2,"rx2 gives correct index"),$affirm.strictEqual(c.source,"c","rx2 source should be unchanged"),$affirm.strictEqual(c.global,!1,"rx2 global should be unchanged"),$affirm.strictEqual(c.ignoreCase,!1,"rx2 ignoreCase should be unchanged"),$affirm.strictEqual(c.multiline,!1,"rx2 multiline should be unchanged"),$affirm.strictEqual(c.lastIndex,0,"rx2 lastIndex should be unchanged")},function(){return pSearch},function(){return function(a){var c,d,e=$onlyCoercibleToString(this),f=-1;return $isRegExp(a)?d=b(a,{remove:"gy"}):("undefined"==typeof a&&(a=""),d=new CRegExp($toString(a))),c=$exec(d,e),c&&(f=$toNumber(c.index)),f}},"String.search shim"),exports.String.search=$toMethod(exports.String.proto.search),exports.String.proto.indexOf=base.String.indexOf,spIndexOf=exports.String.proto.indexOf,exports.String.indexOf=$toMethod(exports.String.proto.indexOf),exports.String.proto.lastIndexOf=base.String.lastIndexOf,spLastIndexOf=exports.String.proto.lastIndexOf,exports.String.lastIndexOf=$toMethod(exports.String.proto.lastIndexOf),exports.String.proto.searchOf=function(a){var c,d,e,f=$onlyCoercibleToString(this),g=-1;return $isRegExp(a)?(e=b(a,{add:"g",remove:"y"}),$toLength(arguments.length)>1?(c=$toNumber(arguments[1]),0>c&&(c=0)):c=0,c>=$toLength(f.length)?g:(e.lastIndex=c,d=$exec(e,f),d&&(g=$toNumber(d.index)),g)):$apply(spIndexOf,f,arguments)},exports.String.searchOf=$toMethod(exports.String.proto.searchOf),exports.String.proto.searchLastOf=function(a){var c,d,e,f,g,h,i,j=$onlyCoercibleToString(this),k=-1;if(!$isRegExp(a))return $apply(spLastIndexOf,j,arguments);for(i=b(a,{add:"g",remove:"y"}),c=arguments[1],d=$toNumber(c),f=$toLength(j.length),e=d!==d?f:$toLength(arguments.length)>1?$toInteger(c):f-1,e=e>=0?$min(e,f-1):0,h=0;e>=h&&(i.lastIndex=h,g=$exec(i,j));)h=$toNumber(g.index),e>=h&&(k=h),h+=1;return k},exports.String.searchLastOf=$toMethod(exports.String.proto.searchLastOf),exports.String.proto.chunk=function(a){var b,c,d,e,f,g=$onlyCoercibleToString(this),h=$toInteger(a),i=[];if(1>h)return i;for(c=$toLength(g.length),b=$ceil(c/h),d=0,e=0,f=h,i.length=b;b>d;)i[d]=$sSlice(g,e,f),e=f,f+=h,d+=1;return i},exports.String.chunk=$toMethod(exports.String.proto.chunk),exports.String.proto.split=$decide(function(){$affirmBasic(pSplit)(),$affirm["throws"](function(){$call(pSplit)},CTypeError,"should throw if no arguments"),$affirm["throws"](function(){$call(pSplit,Undefined)},CTypeError,"should throw if argument is undefined"),$affirm["throws"](function(){$call(pSplit,null)},CTypeError,"should throw if argument is null"),$affirm.deepEqual($call(pSplit,"abcdef",""),["a","b","c","d","e","f"],"should not throw on basic tests"),$affirm.deepEqual($call(pSplit,"abcdefabcdefabcdef","c"),["ab","defab","defab","def"],"should not throw on basic tests"),$affirm.deepEqual($call(pSplit,"abcdefabcdefabcdef",new CRegExp("c")),["ab","defab","defab","def"],"should not throw on basic tests"),$affirm.deepEqual($call(pSplit,"ab"),["ab"],'If "separator" is undefined must return Array with one String - "this" string'),$affirm.deepEqual($call(pSplit,"ab",Undefined),["ab"],'If "separator" is undefined must return Array with one String - "this" string'),$affirm.deepEqual($call(pSplit,""),[""],"('') results in ['']"),$affirm.deepEqual($call(pSplit,"",new CRegExp(".")),[""],"('', /./) results in ['']"),$affirm.deepEqual($call(pSplit,"",new CRegExp(".?")),[],"('', /.?/) results in []"),$affirm.deepEqual($call(pSplit,"",new CRegExp(".??")),[],"('', /.??/) results in []"),$affirm.deepEqual($call(pSplit,"ab",/a*/),["","b"],"('ab', /a*/) results in ['', 'b']"),$affirm.deepEqual($call(pSplit,"ab",/a*?/),["a","b"],"('ab', /a*?/) results in ['a', 'b']"),$affirm.deepEqual($call(pSplit,"ab",/(?:ab)/),["",""],"('ab', /(?:ab)/) results in ['', '']"),$affirm.deepEqual($call(pSplit,"ab",/(?:ab)*/),["",""],"('ab', /(?:ab)*/) results in ['', '']"),$affirm.deepEqual($call(pSplit,"ab",/(?:ab)*?/),["a","b"],"('ab', /(?:ab)*?/) results in ['a', 'b']"),$affirm.deepEqual($call(pSplit,"test",""),["t","e","s","t"],"('test', '') results in ['t', 'e', 's', 't']"),$affirm.deepEqual($call(pSplit,"test"),["test"],"('test', ) results in ['test']"),$affirm.deepEqual($call(pSplit,"111",1),["","","",""],"('111', 1) results in ['', '', '', '']"),$affirm.deepEqual($call(pSplit,"test",/(?:)/,2),["t","e"],"('test', /(?:)/, 2) results in ['t', 'e']"),$affirm.deepEqual($call(pSplit,"test",/(?:)/,-1),[],"('test', /(?:)/, -1) results in []"),$affirm.deepEqual($call(pSplit,"test",/(?:)/,Undefined),["t","e","s","t"],"('test', /(?:)/, undefined) results in ['t', 'e', 's', 't']"),$affirm.deepEqual($call(pSplit,"test",/(?:)/,null),[],"('test', /(?:)/, null) results in []"),$affirm.deepEqual($call(pSplit,"test",/(?:)/,NaN),[],"('test', /(?:)/, NaN) results in []"),$affirm.deepEqual($call(pSplit,"test",/(?:)/,!0),["t"],"('test', /(?:)/, true) results in ['t']"),$affirm.deepEqual($call(pSplit,"test",/(?:)/,"2"),["t","e"],"('test', /(?:)/, '2') results in ['t', 'e']"),$affirm.deepEqual($call(pSplit,"test",/(?:)/,"two"),[],"('test', /(?:)/, 'two') results in []"),$affirm.deepEqual($call(pSplit,"a",/-/),["a"],"('a', /-/) results in ['a']"),$affirm.deepEqual($call(pSplit,"a",/-?/),["a"],"('a', /-?/) results in ['a']"),$affirm.deepEqual($call(pSplit,"a",/-??/),["a"],"('a', /-??/) results in ['a']"),$affirm.deepEqual($call(pSplit,"a",/a/),["",""],"('a', /a/) results in ['', '']"),$affirm.deepEqual($call(pSplit,"a",/a?/),["",""],"('a', /a?/) results in ['', '']"),$affirm.deepEqual($call(pSplit,"a",/a??/),["a"],"('a', /a??/) results in ['a']"),$affirm.deepEqual($call(pSplit,"ab",/-/),["ab"],"('ab', /-/) results in ['ab']"),$affirm.deepEqual($call(pSplit,"ab",/-?/),["a","b"],"('ab', /-?/) results in ['a', 'b']"),$affirm.deepEqual($call(pSplit,"ab",/-??/),["a","b"],"('ab', /-??/) results in ['a', 'b']"),$affirm.deepEqual($call(pSplit,"a-b",/-/),["a","b"],"('a-b', /-/) results in ['a', 'b']"),$affirm.deepEqual($call(pSplit,"a-b",/-?/),["a","b"],"('a-b', /-?/) results in ['a', 'b']"),$affirm.deepEqual($call(pSplit,"a-b",/-??/),["a","-","b"],"('a-b', /-??/) results in ['a', '-', 'b']"),$affirm.deepEqual($call(pSplit,"a--b",/-/),["a","","b"],"('a--b', /-/) results in ['a', '', 'b']"),$affirm.deepEqual($call(pSplit,"a--b",/-?/),["a","","b"],"('a--b', /-?/) results in ['a', '', 'b']"),$affirm.deepEqual($call(pSplit,"a--b",/-??/),["a","-","-","b"],"('a--b', /-??/) results in ['a', '-', '-', 'b']"),$affirm.deepEqual($call(pSplit,"",/()()/),[],"('', /()()/) results in []"),$affirm.deepEqual($call(pSplit,".",/()()/),["."],"('.', /()()/) results in ['.']"),$affirm.deepEqual($call(pSplit,".",new CRegExp("(.?)(.?)")),["",".","",""],"('.', /(.?)(.?)/) results in ['', '.', '', '']"),$affirm.deepEqual($call(pSplit,".",new CRegExp("(.??)(.??)")),["."],"('.', /(.??)(.??)/) results in ['.']");var a=[];a.length=4,a[0]="",a[1]=".",a[2]=Undefined,a[3]="",$affirm.deepEqual($call(pSplit,".",new CRegExp("(.)?(.)?")),a,"('.', /(.)?(.)?/) results in ['', '.', undefined, '']"),a=[],a.length=13,a[0]="A",a[1]=Undefined,a[2]="B",a[3]="bold",a[4]="/",a[5]="B",a[6]="and",a[7]=Undefined,a[8]="CODE",a[9]="coded",a[10]="/",a[11]="CODE",a[12]="",$affirm.deepEqual($call(pSplit,"A<B>bold</B>and<CODE>coded</CODE>"),a,"('A<B>bold</B>and<CODE>coded</CODE>', /<(\\/)?([^<>]+)>/) results in ['A', undefined, 'B', 'bold', '/', 'B', 'and', undefined, 'CODE', 'coded', '/', 'CODE', '']"),a=[],a.length=5,a[0]="t",a[1]=Undefined,a[2]="e",a[3]="s",a[4]="e",$affirm.deepEqual($call(pSplit,"tesst",/(s)*/),a,"('test', /(s)*/) results in ['t', undefined, 'e', 's', 't']"),a=[],a.length=7,a[0]="t",a[1]=Undefined,a[2]="e",a[3]=Undefined,a[4]="s",a[5]=Undefined,a[6]="e",$affirm.deepEqual($call(pSplit,"tesst",/(s)*?/),a,"('test', /(s)*?/) results in ['t', undefined, 'e', undefined, 's', undefined, 's', undefined, 't']"),$affirm.deepEqual($call(pSplit,"tesst",/(s*)/),["t","","e","ss","t"],"('test', /(s*)/) results in ['t', '', 'e', 'ss', 't']"),$affirm.deepEqual($call(pSplit,"tesst",/(s*?)/),["t","","e","","s","","s","","t"],"('test', /(s*?)/) results in ['t', '', 'e', '', 's', '', 's', '', 't']"),$affirm.deepEqual($call(pSplit,"tesst",/(?:s)*/),["t","e","t"],"('test', /(?:s)*/) results in ['t', 'e', 't']"),$affirm.deepEqual($call(pSplit,"tesst",/(?=s+)/),["te","s","st"],"('test', /(?=s+)/) results in ['te', 's', 'st']"),$affirm.deepEqual($call(pSplit,"test","t"),["","es",""],"('test', 't') results in ['', 'es', '']"),$affirm.deepEqual($call(pSplit,"test","es"),["t","t"],"('test', 'es') results in ['t', 't']"),$affirm.deepEqual($call(pSplit,"test",/t/),["","es",""]),$affirm.deepEqual($call(pSplit,"test",/es/),["t","t"],"('test', /es/) results in ['t', 't']"),$affirm.deepEqual($call(pSplit,"test",/(t)/),["","t","es","t",""],"('test', /(t)/) results in ['', 't', 'es', 't', '']"),$affirm.deepEqual($call(pSplit,"test",/(es)/),["t","es","t"],"('test', /(es)/) results in ['t', 'es', 't']"),$affirm.deepEqual($call(pSplit,"test",/(t)(e)(s)(t)/),["","t","e","s","t",""],"('test', /(t)(e)(s)(t)/) results in ['',  't', 'e', 's', 't', '']"),$affirm.deepEqual($call(pSplit,".",new CRegExp("(((.((.??)))))")),["",".",".",".","","",""],"('.', /(((.((.??)))))/) results in ['', '.', '.', '.', '', '', '']"),$affirm.deepEqual($call(pSplit,".",new CRegExp("(((((.??)))))")),["."],"('.', /(((((.??)))))/) results in ['.']"),$affirm.deepEqual($call(pSplit,"a b c d",/ /,-($pow(2,32)-1)),[],"('a b c d', / /, -(Math.pow(2, 32) - 1)) results in []"),$affirm.deepEqual($call(pSplit,"a b c d",/ /,$pow(2,32)+1),["a","b","c","d"],"('a b c d', / /, Math.pow(2, 32) + 1) results in []"),$affirm.deepEqual($call(pSplit,"a b c d",/ /,INFINITY),["a","b","c","d"],"('a b c d', / /, INFINITY) results in []")},function(){return $decide(function(){$affirm.deepEqual($call(pSplit,"ab",Undefined,0),[],'If "separator" is undefined and "limit" set to 0 must return Array[]')},function(){return pSplit},function(){return function(a,b){var c,d;return"undefined"==typeof a&&0===b?d=[]:(c="undefined"==typeof b,b=i?c?MAX_UINT32:$min($toLength(b),MAX_UINT32):c?MAX_SAFE_INTEGER:$toLength(b),d=$call(pSplit,$onlyCoercibleToString(this),a,b)),d}},"String.split patch 2")},function(){function a(a,c,d){var e,f=b(c,{add:"g",remove:"y"});return f.lastIndex=d,e=$exec(f,a),c.global&&(e?c.lastIndex=$toNumber(f.lastIndex):c.lastIndex=0),e}return function(b,c){var d,e,f,g,h,j,k,l,m,n,o,p,q=$onlyCoercibleToString(this);if("undefined"==typeof b&&0===c)e=[];else if(d="undefined"==typeof c,c=i?d?MAX_UINT32:$min($toLength(c),MAX_UINT32):d?MAX_SAFE_INTEGER:$toLength(c),$isRegExp(b)){for(e=[],f=$toNumber(b.lastIndex),g=0,k=$toLength(q.length),j=a(q,b,0);j;){if(l=$toNumber(j.index),m=$toLength(j[0].length),l+m>g){if($push(e,$sSlice(q,g,l)),$toLength(j.length)>1&&k>l)for(n=$slice(j,1),p=$toLength(n.length),o=0;p>o;o+=1)$hasProperty(n,o)?$push(e,n[o]):e.length+=1;h=m,g=l+h}j=a(q,b,l+(m||1))}g===k?(!$test(b,"")||h)&&$push(e,""):$push(e,$sSlice(q,g)),b.lastIndex=f,$toLength(e.length)>c&&(e=$slice(e,0,c))}else e=$call(pSplit,q,b,c);return e}},"String.split patch 1"),exports.String.split=$toMethod(exports.String.proto.split),$split=exports.String.split,exports.String.proto.replace=$decide(function(){$affirmBasic(pReplace)(),$affirm["throws"](function(){$call(pReplace)},CTypeError,"should throw if no arguments"),$affirm["throws"](function(){$call(pReplace,Undefined)},CTypeError,"should throw if argument is undefined"),$affirm["throws"](function(){$call(pReplace,null)},CTypeError,"should throw if argument is null"),$affirm.strictEqual($call(pReplace,"aaa",/a/,"b"),"baa","should replace the first match only when given a nonglobal regex"),$affirm.strictEqual($call(pReplace,"aaa",/a/g,"b"),"bbb","should replace all matches when given a global regex"),$affirm.strictEqual($call(pReplace,"aaa","a","b"),"baa","should replace the first match only when given a string as the search pattern"),$affirm.strictEqual($call(pReplace,"aaa","a(a)","b"),"aaa","should not type convert a string search pattern to a regex"),$affirm.strictEqual($call(pReplace,"a(a)a","a(a)","b"),"ba","should not type convert a string search pattern to a regex"),$affirm.strictEqual($call(pReplace,"aaa",/a(a)/,"$1b","should handle single-digit backreference $1 in the replacement string"),"aba"),$affirm.strictEqual($call(pReplace,"test",/t|(e)/g,"$1"),"es","should handle single-digit backreference $1 in the replacement string"),$affirm.strictEqual($call(pReplace,"aaa",/a(a)/,"$01b"),"aba","should handle double-digit backreferences $01, $10, and $99 in the replacement string"),$affirm.strictEqual($call(pReplace,"aaa",new CRegExp("a"+$repeat("()",9)+"(a)"),"$10b"),"aba","should handle double-digit backreferences $01, $10, and $99 in the replacement string"),$affirm.strictEqual($call(pReplace,"aaa",new CRegExp("a"+$repeat("()",98)+"(a)"),"$99b"),"aba","should handle double-digit backreferences $01, $10, and $99 in the replacement string"),$affirm.strictEqual($call(pReplace,"aaa",new CRegExp("a"+$repeat("()",99)+"(a)"),"$100b"),"0ba","should end backreferences in the replacement string after two digits"),$affirm.strictEqual($call(pReplace,"aaa",/aa/,"$&b"),"aaba","should handle backreference $& in the replacement string"),$affirm.strictEqual($call(pReplace,"aaa","aa","$&b"),"aaba","should handle backreference $& in the replacement string"),$affirm.strictEqual($call(pReplace,"aaa",/aa/,"$'b"),"aba","should handle right context token $' in the replacement string"),$affirm.strictEqual($call(pReplace,"aaa","aa","$'b"),"aba","should handle right context token $' in the replacement string"),$affirm.strictEqual($call(pReplace,"xaaa",/aa/,"$`b"),"xxba","should handle left context token $` in the replacement string"),$affirm.strictEqual($call(pReplace,"xaaa","aa","$`b"),"xxba","should handle left context token $` in the replacement string"),$affirm.strictEqual($call(pReplace,"aaa",/aa/,"$$b"),"$ba","should handle token $$ in the replacement string"),$affirm.strictEqual($call(pReplace,"aaa","aa","$$b"),"$ba","should handle token $$ in the replacement string"),$affirm.strictEqual($call(pReplace,"aaa",/a/,function(){return"b"}),"baa","should allow a function to generate the replacement"),$affirm.strictEqual($call(pReplace,"aaa",/a/g,function(){return"b"}),"bbb","should allow a function to generate the replacement"),$affirm.strictEqual($call(pReplace,"aaa","a",function(){return"b"}),"baa","should allow a function to generate the replacement"),$affirm.strictEqual($call(pReplace,"aaa",/aa/,function(a){return a+"b"}),"aaba","should allow using backreferences with replacement functions"),$affirm.strictEqual($call(pReplace,"aaa",/a(a)/,function(a,b){return b+"b"}),"aba","should allow using backreferences with replacement functions"),$affirm.strictEqual($call(pReplace,"aaa","aa",function(a){return a+"b"}),"aaba","should allow using backreferences with replacement functions"),$affirm.strictEqual($call(pReplace,"aaa",/a(a)/,function(a,b){return"$1"}),"$1a","should not substitute tokens returned by replacement functions"),$affirm.strictEqual($call(pReplace,"aaa",/a/,function(){
return"$&"}),"$&aa","should not substitute tokens returned by replacement functions"),$affirm.strictEqual($call(pReplace,"xaaa",/a/,function(a,b){return $toString(b)}),"x1aa","should allow using the match position within replacement functions"),$affirm.strictEqual($call(pReplace,"xaaa",/a/g,function(a,b){return $toString(b)}),"x123","should allow using the match position within replacement functions"),$affirm.strictEqual($call(pReplace,"xaaa",/(a)/g,function(a,b,c){return $toString(c)}),"x123","should allow using the match position within replacement functions"),$affirm.strictEqual($call(pReplace,"xaaa","a",function(a,b){return $toString(b)}),"x1aa","should allow using the match position within replacement functions"),$affirm.strictEqual($call(pReplace,"xaaa",/a/,function(a,b,c){return c}),"xxaaaaa","should allow using the source string within replacement functions"),$affirm.strictEqual($call(pReplace,"xaaa",/(a)/,function(a,b,c,d){return d}),"xxaaaaa","should allow using the source string within replacement functions"),$affirm.strictEqual($call(pReplace,"xaaa","a",function(a,b,c){return c}),"xxaaaaa","should allow using the source string within replacement functions"),$affirm.strictEqual($call(pReplace,"100",/0/,function(a,b,c){return typeof c}),"1string0","should return string as the typeof the last argument in replacement functions"),$affirm.strictEqual($call(pReplace,new CString("100"),/0/,function(a,b,c){return typeof c}),"1string0","should return string as the typeof the last argument in replacement functions"),$affirm.strictEqual($call(pReplace,100,/0/,function(a,b,c){return typeof c}),"1string0","should return string as the typeof the last argument in replacement functions"),$affirm.strictEqual($call(pReplace,0,/^/,"$`"),"0","should handle nonstring context when using a replacement text token that references the subject text");var a,b,c,d,e,f=/x/;for($call(pReplace,"123x567",f,"_"),$affirm.strictEqual(f.lastIndex,0,"should not modify the lastIndex of a nonglobal regex"),f.lastIndex=1,$call(pReplace,"123x567",f,"_"),$affirm.strictEqual(f.lastIndex,1,"should not modify the lastIndex of a nonglobal regex"),$call(pReplace,"nomatch",f,"_"),$affirm.strictEqual(f.lastIndex,1,"should not modify the lastIndex of a nonglobal regex"),f=/x/g,f.lastIndex=1,$call(pReplace,"123x567",f,"_"),$affirm.strictEqual(f.lastIndex,0,"should reset the lastIndex of a global regex to 0"),f.lastIndex=1,$call(pReplace,"nomatch",f,"_"),$affirm.strictEqual(f.lastIndex,0,"should reset the lastIndex of a global regex to 0"),f=/x/,f.lastIndex=5,$affirm.strictEqual($call(pReplace,"123x567",f,"_"),"123_567","should ignore lastIndex when setting the search start position"),f=/x/g,f.lastIndex=5,$affirm.strictEqual($call(pReplace,"123x567",f,"_"),"123_567","should ignore lastIndex when setting the search start position"),f=/x/g,a=0,$call(pReplace,"1x2",f,function(){a=f.lastIndex}),$affirm.strictEqual(a,2,"should update lastIndex during replacement iterations"),b=[{target:"10x10",search:10,replacement:"x",expected:"xx10"},{target:"xaaa,ba,b",search:["a","b"],replacement:"x",expected:"xaaxa,b"},{target:"undefined",search:void 0,replacement:"x",expected:"x"}],d=$toLength(b.length),e=0;d>e;e+=1)c=b[e],$affirm.strictEqual($call(pReplace,c.target,c.search,c.replacement),c.expected,"should convert any provided nonstring search to a string");for($affirm.strictEqual($call(pReplace,"undefined"),"undefined","should convert any provided nonstring search to a string"),b=[{target:"xaaa",search:/a/g,replacement:1.1,expected:"x1.11.11.1"},{target:"xaaa",search:/a/g,replacement:["a","b"],expected:"xa,ba,ba,b"},{target:"x",search:/x/,replacement:/x/,expected:"/x/"},{target:"xaaa",search:/a/,replacement:void 0,expected:"xundefinedaa"}],d=$toLength(b.length),e=0;d>e;e+=1)c=b[e],$affirm.strictEqual($call(pReplace,c.target,c.search,c.replacement),c.expected,"should convert any provided nonstring/nonfunction replacement to a string");for($affirm.strictEqual($call(pReplace,"xaaa",/a/),"xundefinedaa","should convert any provided nonstring/nonfunction replacement to a string"),b=[100,{},!0,!1,NaN,["a"]],d=$toLength(b.length),e=0;d>e;e+=1)c=b[e],$affirm.strictEqual($call(pReplace,c,/^/,"x"),"x"+c,"should convert any nonstring context to a string (except null and undefined)")},function(){return pReplace},function(){return function(a,b){var c,d,e=$onlyCoercibleToString(this),f=$isRegExp(a);return f?c=$toNumber(a.lastIndex):a=$toString(a),d=$isFunction(b)?$call(pReplace,e,a,function(){var c=$argSlice(arguments);return c[2]=$toString(c[2]),f&&a.global&&(a.lastIndex=c[$toLength(c.length)-2]+arguments[0].length),$apply(b,Undefined,c)}):$call(pReplace,e,a,function(){var a=arguments,c=$toLength(arguments.length);return $call(pReplace,$toString(b),g,function(){var b=$toString(arguments[2]);if("$"===b)return"$";if("&"===b||0===$toNumber(b))return a[0];if("`"===b)return $sSlice(a[2],0,$toNumber(a[1]));if("'"===b)return $sSlice(a[2],$toNumber(a[1])+$toLength(a[0].length));if(b=$toNumber(b),b===b){if(b>c-3)throw new CSyntaxError("Backreference to undefined group "+$toString(arguments[0]));return a[b]||""}throw new CSyntaxError("Invalid token "+$toString(arguments[0]))})}),f&&(a.global?a.lastIndex=0:a.lastIndex=c),d}},"String.replace patch"),exports.String.replace=$toMethod(exports.String.proto.replace),$replace=exports.String.replace,exports.String.proto.replaceAll=function(a,c){return $isString(a)?a=new CRegExp($replace($onlyCoercibleToString(a),e,"\\$&"),"g"):$isRegExp(a)&&(a=b(a,{add:"g"})),c=$isString(c)||$isNumber(c)?$toString(c):"",$replace($onlyCoercibleToString(this),a,c)},exports.String.replaceAll=$toMethod(exports.String.proto.replaceAll),exports.String.proto.match=$decide(function(){$affirmBasic(pMatch)(),$affirm["throws"](function(){$call(pMatch)},CTypeError,"should throw if no arguments"),$affirm["throws"](function(){$call(pMatch,Undefined)},CTypeError,"should throw if argument is undefined"),$affirm["throws"](function(){$call(pMatch,null)},CTypeError,"should throw if argument is null"),$affirm.deepEqual($slice($call(pMatch,"4",/(?=(?:...)*$)/)),[""],'"4".match(/(?=(?:...)*$)/) == [""]'),$affirm.deepEqual($slice($call(pMatch,"a bc",/(\w)/g)),["a","b","c"],"should return an array with all matches"),$affirm.strictEqual($call(pMatch,"a bc",/x/g),null,"should return null if no match is found");var a,b,c,d,e=/x/g;for(e.lastIndex=1,$call(pMatch,"123x5",e),$affirm.strictEqual(e.lastIndex,0,"should reset lastIndex to 0 when a match is found"),e=/x/g,e.lastIndex=1,$call(pMatch,"123",e),$affirm.strictEqual(e.lastIndex,0,"should reset lastIndex to 0 when no match is found"),e=/x/g,e.lastIndex=4,$affirm.ok($call(pMatch,"123x5",e),"should start the search at the beginning of the string, ignoring lastIndex"),$affirm.deepEqual($slice($call(pMatch,11,/1/g)),["1","1"],"should convert any nonstring context to a string (except null and undefined)"),a=[{str:"12",regex:"^(1)",result:["1","1"]},{str:"",regex:"\\1",result:[""]},{str:"[obj]",regex:{},result:["o"]},{str:"null",regex:null,result:["null"]}],b=$toLength(a.length),c=0;b>c;c+=1)d=a[c],$affirm.deepEqual($slice($call(pMatch,d.str,d.regex)),d.result,"should convert any provided non RegExp object to a RegExp")},function(){return pMatch},function(){return function(a){var b,c=$onlyCoercibleToString(this);if($isRegExp(a)){if(a.global)return b=$apply(pMatch,c,arguments),a.lastIndex=0,b}else a=new CRegExp(a);return $exec(a,c)}},"String.match patch"),exports.String.match=$toMethod(exports.String.proto.match)}(),exports.String.proto.first=function(){return $getItem($onlyCoercibleToString(this),0,stringTagString)},exports.String.first=$toMethod(exports.String.proto.first),exports.String.proto.last=function(){var a=$onlyCoercibleToString(this);return $getItem(a,a.length-1,stringTagString)},exports.String.last=$toMethod(exports.String.proto.last),exports.String.proto.countCharacter=function(a){var b,c=$onlyCoercibleToString(this),d=$getItem($onlyCoercibleToString(a),0,stringTagString);return b=""===d?INFINITY:$min($max($split(c,d).length-1,0),INFINITY)},exports.String.countCharacter=$toMethod(exports.String.proto.countCharacter),exports.String.proto.padLeadingChar=function(a,b){var c=$onlyCoercibleToString(this),d=$getItem($onlyCoercibleToString(a),0,stringTagString),e=$toInteger(b)-c.length;return(0>e||e===INFINITY)&&(e=0),exports.String.repeat(d,e)+c},exports.String.padLeadingChar=$toMethod(exports.String.proto.padLeadingChar),exports.String.proto.startsWith=$decide($affirmBasic(base.String.startsWith),function(){return base.String.startsWith},function(){return function(a,b){var c=$onlyCoercibleToString(this),d=$toString(a),e=$min($max($toInteger(b),0),c.length);return $sSlice(c,e,e+d.length)===d}},"String.startsWith shim"),exports.String.startsWith=$toMethod(exports.String.proto.startsWith),exports.String.proto.endsWith=$decide($affirmBasic(base.String.endsWith),function(){return base.String.endsWith},function(){return function(a,b){var c,d,e=$onlyCoercibleToString(this),f=$toString(a),g=e.length;return b="undefined"==typeof b?g:$toInteger(b),c=$min($max(b,0),g),d=c-f.length,d>=0&&$sSlice(e,d,c)===f}},"String.endsWith shim"),exports.String.endsWith=$toMethod(exports.String.proto.endsWith),exports.String.proto.contains=$decide($affirmBasic(base.String.contains),function(){return base.String.contains},function(){return function(a,b){var c=$onlyCoercibleToString(this),d=$toString(a),e=c.length;return b="undefined"==typeof b?0:$toInteger(b),-1!==$call(pSIndexOf,c,d,$min($max(b,0),e))}},"String.contains shim"),exports.String.contains=$toMethod(exports.String.proto.contains),$stringContains=exports.String.contains,exports.Array.isEmpty=function(a){return!$specialToObject(a).length},exports.Array.proto.first=function(){var a=$specialToObject(this);return $getItem(a,0,$isString(a))},exports.Array.first=$toMethod(exports.Array.proto.first),exports.Array.proto.firstIn=function(){var a,b=$specialToObject(this),c=$toLength(b.length),d=-1;if($isString(b))d=c-1;else for(a=0;c>a;a+=1)if($hasProperty(b,a)){d=a;break}return d},exports.Array.firstIn=$toMethod(exports.Array.proto.firstIn),exports.Array.proto.last=function(){var a=$specialToObject(this);return $getItem(a,a.length-1,$isString(a))},exports.Array.last=$toMethod(exports.Array.proto.last),exports.Array.proto.lastIn=function(){var a,b=$specialToObject(this),c=$toLength(b.length)-1,d=-1;if($isString(b))d=c;else for(a=c;a>=0;a-=1)if($hasProperty(b,a)){d=a;break}return d},exports.Array.lastIn=$toMethod(exports.Array.proto.lastIn),exports.Array.proto.unique=function(){return function(a,b){var c,d,e,f,g,h,i,j,k=$toObject(this);for(f="undefined"==typeof a?$strictEqual:a,$throwIfNotFunction(f),g=[],d=$toLength(k.length),c=d&&$isString(k),e=0;d>e;e+=1)if($hasItem(k,e,c)){for(j=$getItem(k,e,c),i=!0,h=0;d>h;h+=1)if(e>h&&$hasItem(k,h,c)&&$call(f,b,j,$getItem(k,h,c))){i=!1;break}i&&$push(g,j)}return g}}(),exports.Array.unique=$toMethod(exports.Array.proto.unique),exports.Object.getOwnPropertyDescriptor=function(){return $decide(function(){$affirmBasic(base.Object.getOwnPropertyDescriptor)();var a={sentinel:null},b=[10,20,30];b[4]=Undefined,$affirm.strictEqual(base.Object.getOwnPropertyDescriptor(a,"sentinel").value,null,"test1"),$affirm.strictEqual(base.Object.getOwnPropertyDescriptor(b,2).value,30,"test2"),$affirm.strictEqual(base.Object.getOwnPropertyDescriptor(b,"2").value,30,"test3"),$affirm.ok($call(pHasOwn,base.Object.getOwnPropertyDescriptor(b,4),"value"),"test4"),$affirm.strictEqual(base.Object.getOwnPropertyDescriptor(b,4).value,Undefined,"test5"),$affirm.strictEqual(base.Object.getOwnPropertyDescriptor(b,5),Undefined,"test6")},function(){return hasWorkingGOPD=!0,$decide(function(){try{if(base.Object.getOwnPropertyDescriptor(protoFunction,"length").writable&&(base.Object.defineProperty(protoFunction,"length",propConstant),base.Object.getOwnPropertyDescriptor(protoFunction,"length").writable))throw new CError("Still writable")}catch(a){$conlog("Failed to patch Function.prototype.length",a)}$affirm.ok(!base.Object.getOwnPropertyDescriptor(function(){},"length").writable,"Function.length should be read only.")},function(){return $decide(function(){$affirm["throws"](function(){base.Object.getOwnPropertyDescriptor(Undefined,"name")},CTypeError,"undefined"),$affirm["throws"](function(){base.Object.getOwnPropertyDescriptor(null,"name")},CTypeError,"null"),$affirm.doesNotThrow(function(){base.Object.getOwnPropertyDescriptor(42,"name")},"number"),$affirm.doesNotThrow(function(){base.Object.getOwnPropertyDescriptor(!0,"name")},"boolean"),$affirm.doesNotThrow(function(){base.Object.getOwnPropertyDescriptor("a","name")},"string")},function(){return base.Object.getOwnPropertyDescriptor},function(){var a=base.Object.getOwnPropertyDescriptor;return function(b,c){return a($toObject(b),c)}},"Object.getOwnPropertyDescriptor throws patch")},function(){var a=base.Object.getOwnPropertyDescriptor;return function(b,c){var d=$toObject(b),e=a(d,c);return"length"===c&&e.writable&&$isFunction(d)&&(e.writable=!1),e}},"Object.getOwnPropertyDescriptor read only patch")},function(){var a=base.Object.lookupSetter,b=base.Object.lookupSetter;return function(c,d){var e,f,g,h,i=$toObject(c);return $hasOwn(i,d)&&(e={},e.configurable=!0,e.enumerable=!0,hasGetSet&&(f=i[stringProto],i[stringProto]=protoObject,g=$call(a,i,d),h=$call(b,i,d),"undefined"==typeof f?$deleteProperty(i,stringProto):i[stringProto]=f,($isNative(g)||$isNative(h))&&($isNative(g)&&(e.get=g),$isNative(h)&&(e.set=h))),e.value=i[d],e.writable=!0),e}},"Object.getOwnPropertyDescriptor sham")}(),exports.Array.proto.splice=function(){function a(a){var c=$toStringTag(a);if(b[c]||hasWorkingGOPD&&$call(pHasOwn,a,"length")&&!exports.Object.getOwnPropertyDescriptor(a,"length").writable)throw new CTypeError("Cannot assign to read only property 'length' of "+c);return a}var b={};return b[stringTagFunction]=!0,b[stringTagString]=!0,b[stringTagArrayBuffer]=!0,b[stringTagFloat32Array]=!0,b[stringTagFloat64Array]=!0,b[stringTagInt8Array]=!0,b[stringTagInt16Array]=!0,b[stringTagInt32Array]=!0,b[stringTagUint8Array]=!0,b[stringTagUint8ClampedArray]=!0,b[stringTagUint16Array]=!0,b[stringTagUint32Array]=!0,b[stringTagHTMLCollection]=!0,b[stringTagNodeList]=!0,$decide(function(){$affirmBasic(base.Array.splice)(),$affirm.strictEqual($call(base.Array.splice,[1,2],0).length,2,"correct length")},function(){return $decide(function(){$affirm.strictEqual($call(base.Array.splice,[1,2]).length,0,"is zero"),$affirm["throws"](function(){$call(base.Array.splice,"abc")},CTypeError,"string should throw"),$affirm["throws"](function(){$call(base.Array.splice,function(){})},CTypeError,"function should throw")},function(){return base.Array.splice},function(){var b=base.Array.splice;return function(){var c,d=a($toObject(this));return c=$toLength(arguments.length)<1?[]:$apply(b,d,arguments)}},"Array.splice patch")},function(){return function(b,c){var d,e,f,g,h,i=a($toObject(this)),j=$toLength(i.length),k=[],l=$toInteger(b),m=j&&$isString(i),n=0,o=$toLength(arguments.length),p=2,q=$max(o-p,0);if(1>o)return k;for(d=0>l?$max(j+l,0):$min(l,j),2>o&&(c=j-d),e=$min($max($toLength(c),0),j-d);e>n;)f=d+n,$hasItem(i,f,m)&&$push(k,$getItem(i,f,m)),n+=1;if(e>q){for(n=d,h=j-e;h>n;)f=n+e,g=n+q,$hasItem(i,f,m)?i[g]=$getItem(i,f,m):$deleteProperty(i,g),n+=1;for(n=j,h=j-e+q;n>h;)$deleteProperty(i,n-1),n-=1}else if(q>e)for(n=j-e;n>d;)f=n+e-1,g=n+q-1,$hasItem(i,f,m)?i[g]=$getItem(i,f,m):$deleteProperty(i,g),n-=1;for(n=d;o>p;)i[n]=arguments[p],n+=1,p+=1;return i.length=$toLength(j-e+q),k}},"Array.splice shim")}(),exports.Array.splice=$toMethod(exports.Array.proto.splice),$splice=exports.Array.splice,exports.Array.proto.forEach=$decide($affirmArrayMethodTestsObject(base.Array.forEach),function(){return base.Array.forEach},function(){return function(a,b){var c,d,e,f=$toObject(this);for($throwIfNotFunction(a),d=$toLength(f.length),c=d&&$isString(f),e=0;d>e;e+=1)$hasItem(f,e,c)&&$call(a,b,$getItem(f,e,c),e,f)}},"Array.forEach shim"),exports.Array.forEach=$toMethod(exports.Array.proto.forEach),$forEach=exports.Array.forEach,exports.Array.proto.forAll=function(a,b){var c,d,e,f,g=$toObject(this);for($throwIfNotFunction(a),d=$toLength(g.length),c=d&&$isString(g),f=!1,e=0;d>e&&!(f=!!$call(a,b,$getItem(g,e,c),e,g));e+=1);return f},exports.Array.forAll=$toMethod(exports.Array.proto.forAll),exports.Array.proto.some=$decide($affirmArrayMethodTestsObject(base.Array.some),function(){return base.Array.some},function(){return function(a,b){var c,d,e,f,g=$toObject(this);for($throwIfNotFunction(a),e=$toLength(g.length),c=e&&$isString(g),d=!1,f=0;e>f&&(!$hasItem(g,f,c)||!(d=!!$call(a,b,$getItem(g,f,c),f,g)));f+=1);return d}},"Array.some shim"),exports.Array.some=$toMethod(exports.Array.proto.some),exports.Array.proto.find=$decide(function(){$affirmArrayMethodTestsBasic(base.Array.find)();var a,b={0:1,1:2,2:3,length:-3};$affirm.doesNotThrow(function(){a=$call(base.Array.find,b,function(){throw new CError("should not reach here")})},"should not iterate object with negative length"),$affirm.strictEqual(a,-1,"object with negative length")},function(){return base.Array.find},function(){return function(a,b){var c,d,e,f,g,h=$toObject(this);for($throwIfNotFunction(a),d=$toLength(h.length),c=d&&$isString(h),e=0;d>e;e+=1)if(g=$getItem(h,e,c),$call(a,b,g,e,h)){f=g;break}return f}},"Array.find shim"),exports.Array.find=$toMethod(exports.Array.proto.find),exports.Array.proto.findIndex=$decide(function(){$affirmArrayMethodTestsBasic(base.Array.findIndex)();var a,b={0:1,1:2,2:3,length:-3};$affirm.doesNotThrow(function(){a=$call(base.Array.findIndex,b,function(){throw new CError("should not reach here")})},"should not iterate object with negative length"),$affirm.strictEqual(a,-1,"object with negative length")},function(){return base.Array.findIndex},function(){return function(a,b){var c,d,e,f,g=$toObject(this);for($throwIfNotFunction(a),e=$toLength(g.length),c=e&&$isString(g),d=-1,f=0;e>f;f+=1)if($call(a,b,$getItem(g,f,c),f,g)){d=f;break}return d}},"Array.findIndex"),exports.Array.findIndex=$toMethod(exports.Array.proto.findIndex),exports.Array.from=$decide($affirmBasic(base.Array.from),function(){return base.Array.from},function(){return function(a,b,c){var d,e,f,g,h,i,j=$toObject(a);for("undefined"!=typeof b&&(g=!!$throwIfNotFunction(b)),e=$toLength(j.length),f=$isFunction(this)?new this(e):[],f.length=e,d=e&&$isString(j),h=0;e>h;h+=1)i=$getItem(j,h,d),g&&(i=$call(b,c,i,h)),f[h]=i;return f}},"Array.from shim"),exports.Array.proto.every=$decide($affirmArrayMethodTestsObject(base.Array.every),function(){return base.Array.every},function(){return function(a,b){var c,d,e,f,g=$toObject(this);for($throwIfNotFunction(a),d=$toLength(g.length),c=d&&$isString(g),e=!0,f=0;d>f&&(!$hasItem(g,f,c)||(e=!!$call(a,b,$getItem(g,f,c),f,g),e));f+=1);return e}},"Array.every shim"),exports.Array.every=$toMethod(exports.Array.proto.every),exports.Array.proto.map=$decide($affirmArrayMethodTestsObject(base.Array.map),function(){return base.Array.map},function(){return function(a,b){var c,d,e,f,g=$toObject(this);for($throwIfNotFunction(a),e=[],e.length=d=$toLength(g.length),c=d&&$isString(g),f=0;d>f;f+=1)$hasItem(g,f,c)&&(e[f]=$call(a,b,$getItem(g,f,c),f,g));return e}},"Array.map shim"),exports.Array.map=$toMethod(exports.Array.proto.map),exports.Array.of=$decide($affirmBasic(base.Array.of),function(){return base.Array.of},function(){return function(){return $argSlice(arguments)}},"Array.of shim"),exports.Array.proto.filter=$decide($affirmArrayMethodTestsObject(base.Array.filter),function(){return base.Array.filter},function(){return function(a,b){var c,d,e,f,g,h=$toObject(this);for($throwIfNotFunction(a),d=$toLength(h.length),c=d&&$isString(h),e=[],f=0;d>f;f+=1)$hasItem(h,f,c)&&(g=$getItem(h,f,c),$call(a,b,g,f,h)&&$push(e,g));return e}},"Array.filter shim"),exports.Array.filter=$toMethod(exports.Array.proto.filter),exports.Array.proto.condense=function(){var a,b=$toObject(this),c=$toLength(b.length),d=c&&$isString(b),e=[];for(a=0;c>a;a+=1)$hasItem(b,a,d)&&$push(e,$getItem(b,a,d));return e},exports.Array.condense=$toMethod(exports.Array.proto.condense),exports.Array.proto.compact=function(){var a,b,c=$toObject(this),d=$toLength(c.length),e=d&&$isString(c),f=[];for(b=0;d>b;b+=1)$hasItem(c,b,e)&&(a=$getItem(c,b,e),a&&$push(f,a));return f},exports.Array.compact=$toMethod(exports.Array.proto.compact),exports.Array.proto.flatten=function(a){var b,c,d,e,f,g=$toObject(this),h=$toLength(g.length),i=[];if(!h||!$isArray(g))return i;b=0,a&&(c=[]);a:for(;h>b;){if($hasProperty(g,b))if(d=g[b],$isArray(d)){if(a){$push(c,{object:g,length:h,index:b}),g=d,h=$toLength(d.length),b=0;continue a}for(f=$toLength(d.length),e=0;f>e;e+=1)$hasProperty(d,e)?$push(i,d[e]):i.length+=1}else $push(i,d);else i.length+=1;b+=1,a&&b>=h&&$toLength(c.length)&&(d=$pop(c),g=d.object,h=d.length,b=d.index+1)}return i},exports.Array.flatten=$toMethod(exports.Array.proto.flatten),exports.Array.proto.reduce=$decide($affirmArrayMethodTestsObject(base.Array.reduce),function(){return base.Array.reduce},function(){var a="reduce of empty array with no initial value";return function(b,c){var d,e,f,g,h,i=$toObject(this);if($throwIfNotFunction(b),f=$toLength(i.length),!f&&1===$toLength(arguments.length))throw new CTypeError(a);if(h=0,d=f&&$isString(i),$toLength(arguments.length)>1)e=c;else{for(g=!1;!g&&f>h;)g=$hasItem(i,h,d),g&&(e=$getItem(i,h,d),h+=1);if(!g)throw new CTypeError(a)}for(;f>h;)$hasItem(i,h,d)&&(e=$call(b,Undefined,e,$getItem(i,h,d),h,i)),h+=1;return e}},"Array.reduce shim"),exports.Array.reduce=$toMethod(exports.Array.proto.reduce),exports.Array.proto.reduceRight=$decide($affirmArrayMethodTestsObject(base.Array.reduceRight),function(){return base.Array.reduceRight},function(){var a="reduceRight of empty array with no initial value";return function(b,c){var d,e,f,g,h,i=$toObject(this);if($throwIfNotFunction(b),f=$toLength(i.length),!f&&1===$toLength(arguments.length))throw new CTypeError(a);if(d=f&&$isString(i),h=f-1,$toLength(arguments.length)>1)e=c;else{for(g=!1;!g&&h>=0;)g=$hasItem(i,h,d),g&&(e=$getItem(i,h,d),h-=1);if(!g)throw new CTypeError(a)}for(;h>=0;)$hasItem(i,h,d)&&(e=$call(b,Undefined,e,$getItem(i,h,d),h,i)),h-=1;return e}},"Array.reduceRight shim"),exports.Array.reduceRight=$toMethod(exports.Array.proto.reduceRight),exports.Array.proto.chunk=function(a){var b,c,d,e,f,g=$toObject(this),h=$toInteger(a),i=[];if(1>h)return i;for(c=$toLength(g.length),b=$ceil(c/h),d=0,e=0,f=h,i.length=b;b>d;)i[d]=$slice(g,e,f),e=f,f+=h,d+=1;return i},exports.Array.chunk=$toMethod(exports.Array.proto.chunk),exports.Number.randomInt=function(a,b){if(1===$toLength(arguments.length)&&(b=a,a=0),a=clampSafeInt(a),b=clampSafeInt(b),a===b)return a;var c,d=b-a+1;return d>MAX_SAFE_INTEGER?(d=new BigNum(b).minus(a).plus(1),c=$floor(d.times($random()))+a):c=$floor($random()*d+a),c},$randomInt=exports.Number.randomInt,wspaceStrings=function(){var a,b,c=[9,10,11,12,13,32,160,5760,6158,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279],d=$toLength(c.length),e="",f="";for(a=0;d>a;a+=1)b=$call(base.Number.toString,c[a],16),e+="\\u"+$sSlice("0000",0,-$toLength(b.length))+b,f+=base.String.fromCharCode(c[a]);return{wsStr:e,trimString:f}}(),exports.String.proto.trim=$decide(function(){$affirmBasic(base.String.trim)();var a;$affirm.doesNotThrow(function(){a=$call(base.String.trim,wspaceStrings.trimString)},"test1"),$affirm.strictEqual(a.length,0,"not all whitespace trimmed"),$affirm.doesNotThrow(function(){a=$call(base.String.trim,base.String.fromCharCode(8203))},"test2"),$affirm.strictEqual(a.length,1,"trimmed 0x200b bug"),$affirm.doesNotThrow(function(){a=$call(base.String.trim,base.String.fromCharCode(133))},"test3"),$affirm.strictEqual(a.length,1,"trimmed 0x0085 bug")},function(){return base.String.trim},function(){var a=new CRegExp("^["+wspaceStrings.wsStr+"]+|["+wspaceStrings.wsStr+"]+$","g");return function(){return $replace($onlyCoercibleToString(this),a,"")}},"String.trim shim"),exports.String.trim=$toMethod(exports.String.proto.trim),$trim=exports.String.trim,exports.parseInt=$decide(function(){$affirm.ok(!testShims,"testing shim");var a;$affirm.doesNotThrow(function(){a=base.parseInt(wspaceStrings.trimString+"08"+wspaceStrings.trimString)},"test1"),$affirm.strictEqual(a,8,"test2"),$affirm.doesNotThrow(function(){a=base.parseInt(wspaceStrings.trimString+"0x16"+wspaceStrings.trimString)},"test3"),$affirm.strictEqual(a,22,"test4"),$affirm.doesNotThrow(function(){a=base.parseInt(wspaceStrings.trimString+"0x16"+wspaceStrings.trimString,10)},"test5"),$affirm.strictEqual(a,0,"test6")},function(){return base.parseInt},function(){var a=base.parseInt,b=new CRegExp("^0[xX]");return function(c,d){return c=$trim(c),"undefined"!=typeof d&&toInt32(d)||(d=$test(b,c)?16:10),10===d&&$test(b,c)?0:a(c,d)}},"parseInt patch"),$parseInt=exports.parseInt,exports.Number.parseInt=$decide(function(){$affirmBasic(base.Number.parseInt)();var a;$affirm.doesNotThrow(function(){a=base.Number.parseInt(wspaceStrings.trimString+"08"+wspaceStrings.trimString)},"test1"),$affirm.strictEqual(a,8,"test2"),$affirm.doesNotThrow(function(){a=base.Number.parseInt(wspaceStrings.trimString+"0x16"+wspaceStrings.trimString)},"test3"),$affirm.strictEqual(a,22,"test4"),$affirm.doesNotThrow(function(){a=base.Number.parseInt(wspaceStrings.trimString+"0x16"+wspaceStrings.trimString,10)},"test5"),$affirm.strictEqual(a,0,"test6")},function(){return base.Number.parseInt},function(){return function(){return $apply($parseInt,null,arguments)}},"Number.parseInt shim"),exports.parseFloat=$decide(function(){$affirm.ok(!testShims,"testing shim");var a;$affirm.doesNotThrow(function(){a=base.parseFloat(wspaceStrings.trimString+"123.45678"+wspaceStrings.trimString)},"test1"),$affirm.strictEqual(a,123.45678,"test2"),$affirm.doesNotThrow(function(){a=base.parseFloat(wspaceStrings.trimString+"0123.45678"+wspaceStrings.trimString)},"test3"),$affirm.strictEqual(a,123.45678,"test4"),$affirm.doesNotThrow(function(){a=base.parseFloat(wspaceStrings.trimString+"123.456780"+wspaceStrings.trimString)},"test5"),$affirm.strictEqual(a,123.45678,"test6")},function(){return base.parseFloat},function(){var a=base.parseFloat;return function(b){return a($trim(b))}},"parseFloat patch"),$parseFloat=exports.parseFloat,exports.Number.parseFloat=$decide(function(){$affirmBasic(base.parseFloat)();var a;$affirm.doesNotThrow(function(){a=base.parseFloat(wspaceStrings.trimString+"123.45678"+wspaceStrings.trimString)},"test1"),$affirm.strictEqual(a,123.45678,"test2"),$affirm.doesNotThrow(function(){a=base.parseFloat(wspaceStrings.trimString+"0123.45678"+wspaceStrings.trimString)},"test3"),$affirm.strictEqual(a,123.45678,"test4"),$affirm.doesNotThrow(function(){a=base.parseFloat(wspaceStrings.trimString+"123.456780"+wspaceStrings.trimString)},"test5"),$affirm.strictEqual(a,123.45678,"test6")},function(){return base.parseFloat},function(){return $parseFloat},"Number.parseFloat shim"),exports.Number.proto.toFixed=$decide(function(){$affirmBasic(base.Number.toFixed)();var a;$affirm.doesNotThrow(function(){a=$call(base.Number.toFixed,8e-5,3)},"test1"),$affirm.strictEqual(a,"0.000","test2"),$affirm.doesNotThrow(function(){a=$call(base.Number.toFixed,.9,0)},"test3"),$affirm.strictEqual(a,"1","test4"),$affirm.doesNotThrow(function(){a=$call(base.Number.toFixed,1.255,2)},"test5"),$affirm.strictEqual(a,"1.25","test6"),$affirm.doesNotThrow(function(){a=$call(base.Number.toFixed,0xde0b6b3a7640080,0)},"test7"),$affirm.strictEqual(a,"1000000000000000128","test8")},function(){return base.Number.toFixed},function(){function a(a,b){var c;for(c=0;h>c;c+=1)b+=a*g[c],g[c]=b%f,b=$floor(b/f)}function b(a){var b,c=0;for(b=i;b>=0;b-=1)c+=g[b],g[b]=$floor(c/a),c=c%a*f}function c(){var a,b,c="";for(a=i;a>=0;a-=1)b=g[a],(c||!a||b)&&(b=$toString(b),c?c+=$sSlice("0000000",0,7-b.length)+b:c=b);return c}function d(a,b,c){return b&&(c=b%2?d(a,b-1,c*a):d(a*a,b/2,c)),c}function e(a){for(var b=0;a>=4096;)b+=12,a/=4096;for(;a>=2;)b+=1,a/=2;return b}var f=1e7,g=[0,0,0,0,0,0],h=$toLength(g.length),i=h-1;return function(f){var g,h,i,j,k,l,m,n;if(g=$toNumber(f),g=g!==g?0:$floor(g),0>g||g>20)throw new CRangeError("Number.toFixed called with invalid number of decimals");if(h=$toNumber(this),h!==h||-1e21>=h||h>=1e21)return $toString(h);if(i="",0>h&&(i="-",h=-h),j="0",h>1e-21)if(k=e(h*d(2,69,1))-69,l=0>k?h*d(2,-k,1):h/d(2,k,1),l*=4503599627370496,k=52-k,k>0){for(a(0,l),m=g;m>=7;)a(1e7,0),m-=7;for(a(d(10,m,1),0),m=k-1;m>=23;)b(1<<23),m-=23;b(1<<m),a(1,1),b(2),j=c()}else a(0,l),a(1<<-k,0),j=c()+$sSlice("0.00000000000000000000",2,2+g);return g>0?(n=j.length,j=g>=n?i+$sSlice("0.0000000000000000000",0,g-n+2)+j:i+$sSlice(j,0,n-g)+"."+$sSlice(j,n-g)):j=i+j,j}},"Number.toFixed shim"),exports.Number.toFixed=$toMethod(exports.Number.proto.toFixed,$firstArg),exports.Array.proto.lastIndexOf=$decide(function(){$affirmBasic(base.Array.lastIndexOf)();var a;$affirm.doesNotThrow(function(){a=$call(base.Array.lastIndexOf,[0,1],0,-3)},"test1"),$affirm.strictEqual(a,-1,"item not found")},function(){return base.Array.lastIndexOf},function(){return function(a,b){var c,d=$toObject(this),e=$toLength(d.length),f=e&&$isString(d),g=-1;if(e)for(b=arguments.length>1?$toInteger(b):e-1,b=b>=0?$min(b,e-1):e-$abs(b),c=b;c>=0;c-=1)if($hasItem(d,c,f)&&a===$getItem(d,c,f)){g=c;break}return g}},"Array.lastIndexOf shim"),exports.Array.lastIndexOf=$toMethod(exports.Array.proto.lastIndexOf),exports.Array.proto.fill=$decide($affirmBasic(base.Array.fill),function(){return base.Array.fill},function(){return function(a,b,c){var d,e,f,g=$toObject(this),h=$toLength(g.length),i=$toInteger(b);for(i=0>b?$max(h+i,0):$min(i,h),d="undefined"==typeof c?h:$toInteger(c),e=0>d?$max(h+d,0):$min(d,h),f=i;e>f;f+=1)g[f]=a;return g}},"Array.fill shim"),exports.Array.fill=$toMethod(exports.Array.proto.fill),exports.Array.proto.copyWithin=$decide($affirmBasic(base.Array.copyWithin),function(){return base.Array.copyWithin},function(){return function(a,b,c){var d,e,f,g,h,i,j,k=$toObject(this),l=$toLength(k.length),m=$toInteger(a),n=$toInteger(b);for(e=0>m?$max(l+m,0):$min(m,l),f=0>n?$max(l+n,0):$min(n,l),d="undefined"==typeof c?l:$toInteger(c),g=0>d?$max(l+d,0):$min(d,l),h=$min(g-f,l-e),e>f&&f+h>e?(i=-1,f+=h-1,e+=h-1):i=1,j=h;j>=1;j-=1)$call(pHasOwn,k,f)?k[e]=k[f]:$deleteProperty(k,e),f+=i,e+=i;return k}},"Array.copyWithin shim"),exports.Array.copyWithin=$toMethod(exports.Array.proto.copyWithin),exports.Object.proto.forKeys=function(a,b){var c,d,e,f,g,h,i,j=$toObject(this);for($throwIfNotFunction(a),d=$objectKeys(j),e=$toLength(d.length),c=e&&$isString(j),f=!1,g=0;e>g&&(h=d[g],i=c&&$toString($toInteger(h))===h&&h>=0&&MAX_SAFE_INTEGER>=h?$getItem(j,h,!0):j[h],!(f=!!$call(a,b,i,h,j)));g+=1);return f},exports.Object.forKeys=$toMethod(exports.Object.proto.forKeys),$forKeys=exports.Object.forKeys,$isCircular=function(){var a,b;return b=function(b){return!$isPrimitive(b)&&(-1!==$indexOf(this,b)||a(b,this))},a=function(a,c){return $isPrimitive(a)?!1:($push(c,a),$forKeys(a,b,c))},function(b){return a(b,[])}}(),exports.Object.isCircular=$isCircular,exports.Object.isEmpty=function(a){return!$objectKeys(a).length},exports.String.proto.isDigits=function(){var a=new CRegExp("^\\d+$");return function(){return $test(a,$onlyCoercibleToString(this))}}(),exports.String.isDigits=$toMethod(exports.String.proto.isDigits),$isDigits=exports.String.isDigits,hasAccessorSupport=$call(pHasOwn,protoObject,stringDefineGetter),$defProp=function(a,b,c,d){return function(e,f,g){$throwIfIsPrimitive(e),g=$assign({},$throwIfIsPrimitive(g));var h,i,j=$call(pHasOwn,g,"value"),k=$call(pHasOwn,g,"get"),l=$call(pHasOwn,g,"set");if(j){if(k||l)throw new CTypeError("Invalid property. A property cannot have accessors and a value")}else $call(pHasOwn,e,f)?g.value=e[f]:k||l||(g.value=Undefined);if($call(pHasOwn,g,"value"))($isArray(e)||$isArguments(e))&&(f=$toString(f),$isDigits(f)&&"0"!==$getItem(f,0,stringTagString)&&$isIndex($toNumber(f),MAX_UINT32-1)&&(f=$toNumber(f),
i=!0)),!i&&hasAccessorSupport&&($call(a,e,f)||$call(b,e,f))?(h=e[stringProto],e[stringProto]=protoObject,$deleteProperty(e,f),e[f]=g.value,e[stringProto]=h):(i&&f>=$toLength(e.length)&&(e.length=f+1),e[f]=g.value);else{if(!hasAccessorSupport)throw new CTypeError("getters & setters can not be defined on this javascript engine");k&&$call(c,e,f,g.get),l&&$call(d,e,f,g.set)}return e}}(base.Object.lookupGetter,base.Object.lookupSetter,base.Object.defineGetter,base.Object.defineSetter),exports.Object.defineProperty=function(){return $decide(function(){$affirmBasic(base.Object.defineProperty)(),$affirm.strictEqual(base.Object.defineProperty({},"sentinel",{value:null}).sentinel,null,"test1")},function(){return $decide(function(){var a,b=[];$affirm.doesNotThrow(function(){a=base.Object.defineProperty([],"1.",{value:null})},"should not throw an error definining elements on arrays using trailing point numbers strings"),$affirm.strictEqual(a.length,0,"test1"),$affirm.strictEqual(a[1],Undefined,"test2"),$affirm.strictEqual(a["1."],null,"test3"),$affirm.doesNotThrow(function(){a=base.Object.defineProperty([],"1",{value:Undefined})},"should not throw an error definining elements on arrays using integer strings"),$affirm.strictEqual(a.length,2,"test4"),$affirm.strictEqual(a[1],Undefined,"test5"),$affirm.doesNotThrow(function(){a=base.Object.defineProperty([],"1",{value:null})},"should not throw an error definining elements on arrays using integer strings"),$affirm.strictEqual(a.length,2,"test6"),$affirm.strictEqual(a[1],null,"test7"),$affirm.doesNotThrow(function(){a=base.Object.defineProperty([],"1",{})},"should not throw an error definining elements on arrays using integer strings"),$affirm.strictEqual(a.length,2,"test8"),$affirm.strictEqual(a[1],Undefined,"test9"),$affirm.doesNotThrow(function(){a=base.Object.defineProperty([],"1",{value:null})},"should not throw an error definining elements on arrays using integer strings"),$affirm.strictEqual(a.length,2,"test10"),$affirm.strictEqual(a[1],null,"test11"),$affirm.doesNotThrow(function(){a=base.Object.defineProperty([10,20],"1",{})},"Test overwrite array properties when no value defined, no value change"),$affirm.strictEqual(a.length,2,"test12"),$affirm.strictEqual(a[1],20,"test13"),$affirm.doesNotThrow(function(){a=base.Object.defineProperty([10],"0",{enumerable:!0,writable:!0,configurable:!0})},"should not throw an error redefinining elements on arrays"),$affirm.strictEqual(a.length,1,"length after re-define"),$affirm.strictEqual(a[0],10,"value after re-define"),b=[],$affirm.doesNotThrow(function(){base.Object.defineProperty(b,"0",{value:10,enumerable:!0,writable:!0,configurable:!0})},"should not throw an error definining elements on arrays"),$affirm.doesNotThrow(function(){base.Object.defineProperty(b,"1",{value:!0,enumerable:!0,writable:!0,configurable:!0})},"should not throw an error definining elements on arrays"),$affirm.doesNotThrow(function(){base.Object.defineProperty(b,"2",{value:"x",enumerable:!0,writable:!0,configurable:!0})},"should not throw an error definining elements on arrays"),$affirm.doesNotThrow(function(){base.Object.defineProperty(b,"foo",{value:noop,enumerable:!0,writable:!0,configurable:!0})},"should not throw an error definining properties on arrays"),$affirm.strictEqual(b.length,3,"length after define"),$affirm.strictEqual(b[0],10,"first value"),$affirm.strictEqual(b[1],!0,"second value"),$affirm.strictEqual(b[2],"x","third value"),$affirm.strictEqual(b.foo,noop,"fourth value"),a=base.Object.defineProperty([],1.1,{enumerable:!0,writable:!0,configurable:!0}),$affirm.ok($call(pHasOwn,a,1.1),"have own property"),$affirm.strictEqual(a.length,0,"be zero length"),$affirm.strictEqual(a[1.1],Undefined,"value should be undefined")},function(){return base.Object.defineProperty},function(){var a=base.Object.defineProperty;return function(b,c,d){return($isArray(b)||$isArguments(b))&&(c=$toString(c),$isDigits(c)&&"0"!==$getItem(c,0,stringTagString)&&$isIndex($toNumber(c),MAX_UINT32-1)||$isNumeric(c))?$defProp(b,c,d):a(b,c,d)}},"Object.defineProperty patch")},function(){return $defProp},"Object.defineProperty sham")}(),$defineProperty=exports.Object.defineProperty,exports.Object.defineProperties=function(){function a(a){if($isString(a))throw new CTypeError("Property description must be an object: "+$toString(a));return a}var b=base.Object.defineProperties;return $decide(function(){$affirmBasic(b)(),$affirm.strictEqual($defineProperty,base.Object.defineProperty,"defineProperty was patched or shimmed")},function(){return $decide(function(){$affirm["throws"](function(){b({})},CTypeError,"no properties argument"),$affirm["throws"](function(){b({},Undefined)},CTypeError,"properties undefined"),$affirm["throws"](function(){b({},null)},CTypeError,"properties null"),$affirm.doesNotThrow(function(){b({},!0)},"boolean"),$affirm.doesNotThrow(function(){b({},1)},"properties number"),$affirm["throws"](function(){b({},"a")},CTypeError,"properties string")},function(){return b},function(){return function(c,d){return b($throwIfIsPrimitive(c),a($toObject(d)))}},"Object.defineProperties patch")},function(){return function(b,c){$throwIfIsPrimitive(b),c=a($toObject(c));var d,e,f=$objectKeys(c),g=$toLength(f.length);for(e=0;g>e;e+=1)d=f[e],$defineProperty(b,d,c[d]);return b}},"Object.defineProperties using Object.defineProperty")}(),$defineProperties=exports.Object.defineProperties,exports.Object.freeze=$decide($affirmBasic(base.Object.freeze),function(){return base.Object.freeze},function(){return function(a){return $throwIfIsPrimitive(a)}},"Object.freeze sham"),exports.Object.freeze=$decide(function(){$affirm.doesNotThrow(function(){exports.Object.freeze({noop:noop})},"does not throw an error in Rhino")},function(){return exports.Object.freeze},function(){var a=exports.Object.freeze;return function(b){var c;return c=$isFunction(b)?b:a(b)}},"Object.freeze Rhino bug patch"),exports.Object.isFrozen=$decide($affirmBasic(base.Object.isFrozen),function(){return base.Object.isFrozen},function(){return function(a){return $throwIfIsPrimitive(a),!1}},"Object.isFrozen sham"),exports.Object.deepFreeze=function(a){var b,c;exports.Object.freeze(a);for(b in a)c=$getItem(a,b,$isString(a)),$isPrimitive(c)||exports.Object.isFrozen(c)||exports.Object.deepFreeze(c);return a},exports.Object.assign=$decide($affirmBasic(base.Object.assign),function(){return base.Object.assign},function(){return function(a){var b,c,d,e,f,g,h,i,j=$toObject(a),k=$toLength(arguments.length);if(k>=2)for(d=1;k>d;d+=1)if(i=arguments[d],null!=i)for(c=$toObject(i),e=$objectKeys(c),f=$toLength(e.length),g=0;f>g;g+=1)h=e[g],b=$isString(c),$hasItem(c,h,b)&&(j[h]=$getItem(c,h,b));return j}},"Object.assign shim"),$assign=exports.Object.assign,exports.Object.create=$decide(function(){function a(){}$affirmBasic(base.Object.create)();var b=base.Object.create(a.prototype,{constructor:$assign({value:a},propNotEnumerable),foo:$assign({value:"test"},propNotEnumerable)});$affirm.strictEqual(b.foo,"test","test1")},function(){return base.Object.create},function(){function a(){}return function(b,c){a.prototype=$throwIfIsPrimitive(b);var d=new a;return $defineProperty(d,stringProto,$assign({value:b},propNotEnumerable)),$isPlainObject(c)&&$defineProperties(d,c),d}},"Object.create shim"),$create=exports.Object.create,exports.Date.proto.isValid=function(a){return function(){if(!$isDate(this))throw new CTypeError("this is not a Date object.");var b=$call(a,this);return b===b}}(base.Date.getTime),exports.Date.isValid=$toMethod(exports.Date.proto.isValid),exports.Date.now=$decide($affirmBasic(base.Date.now),function(){return base.Date.now},function(){var a=base.Date.getTime;return function(){return $call(a,new CDate)}},"Date.now shim"),exports.String.proto.wrapInChars=function(a){return a=$isString(a)||$isNumber(a)?$toString(a):"",a+$onlyCoercibleToString(this)+a},exports.String.wrapInChars=$toMethod(exports.String.proto.wrapInChars),exports.String.proto.truncate=function(a){var b=$onlyCoercibleToString(this);return a=$toNumber(a),a===a&&a>=0&&b.length>a&&(b=$sSlice(b,0,a)),b},exports.String.truncate=$toMethod(exports.String.proto.truncate),$truncate=exports.String.truncate,exports.Function.proto.inherits=function(a){$throwIfNotFunction(this),$throwIfNotFunction(a),$defineProperty(this,"superCtor",$assign({value:a},propConstant)),this.prototype=$create(a.prototype),$defineProperty(this.prototype,"constructor",$assign({value:this},propNotEnumerable))},exports.Function.inherits=$toMethod(exports.Function.proto.inherits),$inherits=exports.Function.inherits,exports.Error.isErrorTypeConstructor=function(a){var b;switch(a){case CError:case CTypeError:case CSyntaxError:case CRangeError:case CEvalError:case CReferenceError:case CURIError:b=!0;break;default:b=!1}return b},$isErrorTypeConstructor=exports.Error.isErrorTypeConstructor,exports.customErrorReplacer=function(){var a,b=arguments[1],c=typeof b;return a="string"===c?b:"undefined"===c||b===INFINITY||b===NEGATIVE_INFINITY||exports.Number.isNaN(b)||$isFunction(b)||$isRegExp(b)?$toString(b):b},function(){var a,b=!1;exports.normaliseErrorIEToStringOn=function(){var c="Should we patch IE6&7?";try{throw new CError(c)}catch(d){d.message===c&&d.toString()===stringTagError&&(a=protoError.toString,$defineProperties(protoError,{toString:$assign({value:function(){return this.name+": "+this.message}},propNotEnumerable)}),b=!0)}return b},exports.normaliseErrorIEToStringOff=function(){return b&&($defineProperties(protoError,{toString:$assign({value:a},propNotEnumerable)}),a=null,b=!1),b},exports.normaliseErrorIEToStringState=function(){return b}}(),exports.customError=function(){function a(a,b,c){var e;if("string"!=typeof a||""===a)throw new CTypeError('"name" was not a valid string: '+$toString(a));if(!$isErrorTypeConstructor(b))throw new CTypeError('"ErrorConstructor" was not an Error type');return c=+c,(c!==c||64>c)&&(c=128),e=function(a,d){var f;"string"!=typeof a&&(a=$truncate($stringify(a,exports.customErrorReplacer),c)),$defineProperty(this,"message",$assign({value:a},propNotEnumerable)),$isFunction(d)||(d=e),this.stackStartFn=d,$isFunction(b.captureStackTrace)?b.captureStackTrace(this,this.stackStartFn):(f=$call(b,this),"string"==typeof f.stack?$defineProperty(this,"stack",$assign({value:f.stack},propNotEnumerable)):"string"==typeof f.stacktrace&&$defineProperty(this,"stack",$assign({value:f.stacktrace},propNotEnumerable)))},$inherits(e,b),$defineProperties(e.prototype,{name:$assign({value:a},propNotEnumerable),toString:$assign({value:function(){var a,b,c,e=$split(this.message,d),f=this.name+": ",g=$toLength(e.length);if(g>1){for(a=[],c=0;g>c;c+=1)b=e[c],$stringContains(b,"opera:config#UserPrefs|Exceptions Have Stacktrace")||$push(a,b);f+=$join(a,"\n")}else f+=this.message;return f}},propNotEnumerable)}),e}var b,c,d=new CRegExp("\\r\\n|\\n");try{c=a("CustomSyntaxError",CSyntaxError),b=$instanceOf(new c("test"),CSyntaxError)}catch(e){b=!1}return function(c,d,e){if("string"!=typeof c)throw new CTypeError('"name" was not a string: '+$toString(c));if(""===c)throw new CSyntaxError('"name" was an empty string');if("undefined"==typeof e){var f=typeof d;("number"===f||"string"===f)&&(e=d,d=CError)}return b&&$isErrorTypeConstructor(d)||(d=CError),a(c,d,e)}}(),exports.Object.swapItems=function(a,b,c){$throwIfIsPrimitive(a),b=$toString(b),c=$toString(c);var d,e,f,g,h,i,j;return b!==c&&(d=exports.Object.getOwnPropertyDescriptor(a,b)||{},e=exports.Object.getOwnPropertyDescriptor(a,c)||{},f=$toLength(c),g=$hasOwnValidLength(a)&&!$isFunction(a)&&$toString(f)===c,$isPlainObject(d)&&$call(pHasOwn,d,"value")?(g&&(i=$toLength(a.length),f===i&&(a.length=i+1)),$defineProperty(a,c,d)):(g&&(i=$toLength(a.length)-1,f===i&&(a.length=i)),$deleteProperty(a,c)),f=$toLength(b),h=$hasOwnValidLength(a)&&!$isFunction(a)&&$toString(f)===b,$isPlainObject(e)&&$call(pHasOwn,e,"value")?($defineProperty(a,b,e),h&&(j=$toLength(a.length),f===j&&(a.length=j+1)),$defineProperty(a,b,e)):(h&&(j=$toLength(a.length)-1,f===j&&(a.length=j)),$deleteProperty(a,b))),a},exports.Array.proto.shuffle=function(a){var b,c,d,e,f,g,h,i,j=$toObject(this);if($hasOwnValidLength(j)&&!$isFunction(j)){if(c=$toLength(j.length),b=$isString(j)){for(h={},e=0;c>e;e+=1)h[e]=$getItem(j,e,!0);j=h}if(j.length=c,c>1)for(d=$min($max($toInteger(a),1),MAX_SAFE_INTEGER),f=0;d>f;f+=1)for(e=0;c>e;e+=1)g=$randomInt(e),i=$call(pHasOwn,j,e),h=j[e],$call(pHasOwn,j,g)?j[e]=j[g]:$deleteProperty(j,e),i?j[g]=h:$deleteProperty(j,g);if(b){for(h="",e=0;c>e;e+=1)h+=j[e];j=$toObject(h)}}return j},exports.Array.shuffle=$toMethod(exports.Array.proto.shuffle),exports.Date.proto.toISOString=$decide(function(){$affirmBasic(base.Date.toISOString)(),$affirm["throws"](function(){$call(base.Date.toISOString,null)},CTypeError,"Throws if not date object"),$affirm["throws"](function(){$call(base.Date.toISOString,new CDate(MAX_VALUE))},CRangeError,"Throws on invalid date");var a;$affirm.doesNotThrow(function(){a=$call(base.Date.toISOString,new CDate(-864e13))},"test1"),$affirm.strictEqual(a,"-271821-04-20T00:00:00.000Z","test2"),$affirm.doesNotThrow(function(){a=$call(base.Date.toISOString,new CDate(864e13))},"test3"),$affirm.strictEqual(a,"+275760-09-13T00:00:00.000Z","test4"),$affirm.doesNotThrow(function(){a=$call(base.Date.toISOString,new CDate(-621987552e5))},"test5"),$affirm.strictEqual(a,"-000001-01-01T00:00:00.000Z","test6"),$affirm.doesNotThrow(function(){a=$call(base.Date.toISOString,new CDate(-1))},"test7"),$affirm.strictEqual(a,"1969-12-31T23:59:59.999Z","test8")},function(){return base.Date.toISOString},function(){var a=base.Date.proto.getUTCFullYear,b=base.Date.proto.getUTCMonth,c=base.Date.proto.getUTCDate,d=base.Date.proto.getUTCHours,e=base.Date.proto.getUTCMinutes,f=base.Date.proto.getUTCSeconds,g=base.Date.proto.getUTCMilliseconds;return function(){if(!exports.Date.isDate(this))throw new CTypeError("this is not a Date object.");if(!exports.Date.isValid(this))throw new CRangeError("Invalid time value");var h,i,j,k,l,m,n,o,p;for(l=$call(a,this),m=$call(b,this),l+=$floor(m/12),m=(m%12+12)%12,h=[m+1,$call(c,this),$call(d,this),$call(e,this),$call(f,this)],p=0>l?"-":l>9999?"+":"",j=l>=0&&9999>=l?-4:-6,l=p+$sSlice("00000"+$abs(l),j),j=$toLength(h.length),i=0;j>i;i+=1)k=h[i],10>k&&(h[i]="0"+k);return n=l+"-"+$join($slice(h,0,2),"-"),o=$join($slice(h,2),":")+"."+$sSlice("000"+$call(g,this),-3),n+"T"+o+"Z"}},"Date.toISOString shim"),exports.Date.toISOString=$toMethod(exports.Date.proto.toISOString),exports.Date.proto.toJSON=$decide(function(){$affirmBasic(base.Date.toJSON)();var a,b=0;$affirm["throws"](function(){a=$call(base.Date.toJSON,$makeDate(-864e13)),a.toISOString=null},CTypeError,"Throw if toISOString is not a function"),$affirm.doesNotThrow(function(){a=$call(base.Date.toJSON,$makeDate(-864e13))},"test1"),$affirm.strictEqual(a,"-271821-04-20T00:00:00.000Z","test2"),$affirm.doesNotThrow(function(){a=$call(base.Date.toJSON,$makeDate(864e13))},"test3"),$affirm.strictEqual(a,"+275760-09-13T00:00:00.000Z","test4"),$affirm.doesNotThrow(function(){a=$call(base.Date.toJSON,$makeDate(-621987552e5))},"test5"),$affirm.strictEqual(a,"-000001-01-01T00:00:00.000Z","test6"),$affirm.doesNotThrow(function(){a=$call(base.Date.toJSON,$makeDate(-1))},"test7"),$affirm.strictEqual(a,"1969-12-31T23:59:59.999Z","test8"),$affirm.doesNotThrow(function(){a=$call(base.Date.toJSON,NaN)},"test9"),$affirm.strictEqual(a,null,"test10"),$affirm.doesNotThrow(function(){a=$call(base.Date.toJSON,INFINITY)},"test11"),$affirm.strictEqual(a,null,"test12"),$affirm.doesNotThrow(function(){a=$call(base.Date.toJSON,1/-b)},"test13"),$affirm.strictEqual(a,null,"test14"),$affirm.doesNotThrow(function(){a=$call(base.Date.toJSON,$makeDate(MAX_VALUE))},"test15"),$affirm.strictEqual(a,null,"test16")},function(){return base.Date.toJSON},function(){return function(){var a,b=$toObject(this),c=$toPrimitive(b,hintNumber);return a="number"!=typeof c||$isFinite(c)?$throwIfNotFunction(b.toISOString).call(b):null}},"Date.toJSON shim"),exports.Date.toJSON=$toMethod(exports.Date.proto.toJSON),exports.JSON.stringify=function(a){return $decide(function(){function b(){return 1}$affirmBasic(a)(),b.toJSON=b,$affirm.strictEqual(a(CNumber(1)),"1","test1"),$affirm.strictEqual(a(CBoolean(!0)),"true","test2"),$affirm.strictEqual(a(CString("abc")),'"abc"',"test3"),$affirm.strictEqual(a(0),"0","test4"),$affirm.strictEqual(a(new CNumber),"0","test5"),$affirm.strictEqual(a(new CString),'""',"test6"),$affirm.doesNotThrow(function(){a(noop)},"should not throw"),$affirm.ok("undefined"==typeof a(noop),"test7"),$affirm.ok("undefined"==typeof a(Undefined),"test8"),$affirm.doesNotThrow(function(){a()},"test9"),$affirm.ok("undefined"==typeof a(),"test10"),$affirm.doesNotThrow(function(){a(b),a([b])},"test11"),$affirm.strictEqual(a(b),"1","test12"),$affirm.strictEqual(a([b]),"[1]","test13"),$affirm.strictEqual(a([Undefined]),"[null]","test14"),$affirm.strictEqual(a(null),"null","test15"),$affirm.strictEqual(a([Undefined,noop,null]),"[null,null,null]","test16"),$affirm.doesNotThrow(function(){a({A:[b,!0,!1,null,"\b\n\f\r	"]})},"test17"),$affirm.strictEqual(a({A:[b,!0,!1,null,"\b\n\f\r	"]}),'{"A":[1,true,false,null,"\\b\\n\\f\\r\\t"]}',"test18"),$affirm.strictEqual(a([1,2],null,1),"[\n 1,\n 2\n]","test19");var c=$makeDate(-864e13);$affirm.strictEqual(a(c),'"-271821-04-20T00:00:00.000Z"',"test20"),c=$makeDate(864e13),$affirm.strictEqual(a(c),'"+275760-09-13T00:00:00.000Z"',"test21"),c=$makeDate(-621987552e5),$affirm.strictEqual(a(c),'"-000001-01-01T00:00:00.000Z"',"test22"),c=$makeDate(-1),$affirm.strictEqual(a(c),'"1969-12-31T23:59:59.999Z"',"test22"),c.toJSON=void 0,$affirm.strictEqual(a(c),"{}","test23")},function(){return a},function(){function a(a){var b,c='"';return f.lastIndex=0,c+=$test(f,a)?$replace(a,f,function(a){var c,d=g[a];return"string"==typeof d?c=d:(b=$toString($call(pCharCodeAt,a,0),16),c="\\u"+$sSlice("0000",0,-b.length)+b),c}):a,c+'"'}function b(f,g,h){$isArray(h)||(h=[]);var i,j,k,l,m,n,o,p,q=d,r=g[f];switch(null!=r&&$isFunction(r.toJSON)&&(r=r.toJSON(f)),$isFunction(e)&&(r=$call(e,g,f,r)),!$isPrimitive(r)&&($isString(r)||$isNumber(r)||$isBoolean(r))&&(r=$toPrimitive(r,hintNumber)),$typeOf(r)){case"string":return a(r);case"number":return r!==INFINITY&&r!==NEGATIVE_INFINITY?$toString(r):"null";case"boolean":case"null":return $toString(r);case"object":if(null===r)return $toString(r);for(m=$toLength(h.length),n=0;m>n;n+=1)if(r===h[n])throw new CTypeError("Converting circular structure to JSON");if(h.length=m+1,h[m]=r,d+=c,j=[],$isArray(r)){for(m=$toLength(r.length),n=0;m>n;n+=1)$push(j,b(n,r,h)||"null");return i=$toLength(j.length)?"string"==typeof d&&""!==d?"[\n"+d+$join(j,",\n"+d)+"\n"+q+"]":"["+$join(j,",")+"]":"[]",d=q,i}if(l="string"==typeof d&&""!==d?": ":":",$isArray(e))for(m=$toLength(e.length),n=0;m>n;n+=1)k=e[n],"string"==typeof k&&(p=b(k,r,h),"undefined"!=typeof p&&$push(j,a(k)+l+p));else for(o=$objectKeys(r),m=$toLength(o.length),n=0;m>n;n+=1)k=o[n],p=b(k,r,h),"undefined"!=typeof p&&$push(j,a(k)+l+p);return i=$toLength(j.length)?"string"==typeof d&&""!==d?"{\n"+d+$join(j,",\n"+d)+"\n"+q+"}":"{"+$join(j,",")+"}":"{}",d=q,i}return Undefined}var c,d,e,f=new CRegExp('[\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]',"g"),g={"\b":"\\b","	":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"};return function(a,f,g){d="";var h=typeof g;if(c="number"===h?$repeat(" ",g):"string"===h?g:"",e=f,null!=f&&!$isFunction(f)&&!$isArray(f))throw new CError("JSON.stringify");return b("",{"":a})}},"JSON.stringify shim")}(base.JSON.stringify),exports.JSON.parse=function(mParse){return $decide(function(){$affirmBasic(mParse)(),$affirm.strictEqual(mParse("0"),0,"test1"),$affirm.strictEqual(mParse(!1),!1,"test2");var a;$affirm.doesNotThrow(function(){a=mParse('{"A":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}')},"test3"),$affirm.strictEqual(a.A.length,5,"test4"),$affirm.strictEqual(a.A[0],1,"test5"),$affirm["throws"](function(){mParse('"	"')},CSyntaxError,"test6"),$affirm["throws"](function(){mParse("01")},CSyntaxError,"test7")},function(){return $decide(function(){$affirm["throws"](function(){mParse()},CSyntaxError,"test8")},function(){return mParse},function(){return function(a,b){if("undefined"==typeof a)throw new CSyntaxError("JSON.parse");return mParse(a,b)}},"JSON.parse patch")},function(){function walk(a,b,c){var d,e,f,g,h,i=a[b];if(!$isPrimitive(i)&&"object"===$typeOf(i))for(d=$objectKeys(i),e=$toLength(d.length),f=0;e>f;f+=1)g=d[f],h=walk(i,g),"undefined"!=typeof h?i[g]=h:$deleteProperty(i,g);return $call(c,a,b,i)}var parseProtect1=new CRegExp("^[\\],:{}\\s]*$"),parseProtect2=new CRegExp('\\\\(?:["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})',"g"),parseProtect3=new CRegExp('"[^"\\\\\\n\\r]*"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?',"g"),parseProtect4=new CRegExp("(?:^|:|,)(?:\\s*\\[)+","g"),parseCharacterTest=new CRegExp("[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]","g");return function(text,reviver){var j;if(text=$toString(text),parseCharacterTest.lastIndex=0,$test(parseCharacterTest,text)&&(text=$replace(text,parseCharacterTest,function(a){var b=$toString($call(pCharCodeAt,a,0),16);return"\\u"+$sSlice("0000",0,-b.length)+b})),$test(parseProtect1,$replace($replace($replace(text,parseProtect2,"@"),parseProtect3,"]"),parseProtect4,"")))return j=eval("("+text+")"),$isFunction(reviver)?walk({"":j},"",reviver):j;throw new CSyntaxError("JSON.parse")}},"JSON.parse shim")}(base.JSON.parse),$stringify=exports.JSON.stringify,exports.String.proto.substr=function(){return $decide(function(){$affirmBasic(base.String.substr)(),$affirm.strictEqual($call(base.String.substr,"0b",-1),"b","negative substr bug"),$affirm.strictEqual($call(base.String.substr,"abcdef",1,Undefined),"bcdef","stop is undefined bug")},function(){return base.String.substr},function(){var a=exports.String.proto.slice;return function(b,c){var d,e=$onlyCoercibleToString(this),f=$toLength(e.length),g=$toInteger(b);return 0>g&&(g=$max(f+g,0)),d="undefined"==typeof c?INFINITY:$toInteger(c),$call(a,e,g,g+$min($max(d,0),f-g))}},"String.substr shim")}(),exports.String.substr=$toMethod(exports.String.proto.substr),$substr=exports.String.substr,exports.Array.proto.powerSet=function(){var a=function(){var b,c,d,e,f,g,h=$toObject(this),i=[];if($hasOwnValidLength(h)&&!$isFunction(h))if(e=$toLength(h.length),1>e)$push(i,[]);else for($isString(h)?(c=$getItem(h,e-1,!0),b=$sSlice(h,0,-1)):(b=$slice(h),c=$pop(b)),d=$call(a,b),e=d.length,f=0;e>f;f+=1)g=d[f],$push(i,g),d[f]=g=$slice(g),$push(g,c),$push(i,g);else $push(i,[]);return i.length=$toLength(i.length),i};return a}(),exports.Array.powerSet=$toMethod(exports.Array.proto.powerSet),exports.Array.proto.toObject=function(){var a,b,c,d=$toObject(this),e={};if($hasOwnValidLength(d)&&!$isFunction(d))for(a=b&&$isString(d),e.length=b=$toLength(d.length),c=0;b>c;c+=1)$hasItem(d,c,a)&&(e[c]=$getItem(d,c,a));else e.length=0;return e},exports.Array.toObject=$toMethod(exports.Array.proto.toObject),function(){function a(a){var b,c=!1;return a&&(b=typeof a,"object"!==b||$isFunction(a)||a.constructor.prototype===protoObject||null!==a.s&&1!==a.s&&-1!==a.s||null!==a.c&&!$isArray(a.c)||null!==a.e&&"number"!=typeof a.e||!$isFunction(a.plus)||!$isFunction(a.minus)||(c=!0)),c}function b(a,b,c){if(!$isInteger(b))throw new CTypeError("min is not an integer: "+$toString($toPrimitive(b,hintString)));if(!$isInteger(c))throw new CTypeError("max is not an integer: "+$toString($toPrimitive(c,hintString)));return $isInteger(a)&&$inRange(a,b,c)}function c(a,b,c){var d=$toLength(a.length),e=0;do c=$call(b,c,a[e]),e+=1;while(d>e);return c}function d(a,b,c){var d=this.c,e=this.e+a+1;if(1===b)c=d[e]>=5;else if(2===b)c=d[e]>5||5===d[e]&&(c||0>e||"undefined"!=typeof d[e+1]||1&d[e-1]);else if(3===b)c=c||"undefined"!=typeof d[e]||0>e;else if(c=!1,0!==b)throw new u("!Big.RM!");if(1>e||!d[0])c?(this.e=-a,this.c=[1]):(this.e=0,this.c=[0]);else{if(d.length=e,e-=1,c)for(d[e]+=1;d[e]>9;d[e]+=1)d[e]=0,e||(this.e+=1,$unshift(d,1)),e-=1;for(e=$toLength(d.length)-1;!d[e];e-=1)$pop(d)}return this}function e(a,b){var c,d=this.e,e=$join(this.c,""),f=e.length;if(!b&&(s>=d||d>=t))c=$getItem(e,0,stringTagString),f>1&&(c+="."+$sSlice(e,1)),c+=0>d?"e":"e+",c+=d;else if(0>d){for(c=e,d+=1;d;d+=1)c="0"+c;c="0."+c}else if(d>0)if(c=e,d+=1,d>f)for(d-=f;d;d-=1)c+="0";else f>d&&(c=$sSlice(e,0,d)+"."+$sSlice(e,d));else c=f>1?$getItem(e,0,stringTagString)+"."+$sSlice(e,1):e;return a===!0?this.s<0&&(c="-"+c):this.s<0&&this.c[0]&&(c="-"+c),c}function f(a,b,c){var f,g=new this.constructor(this),h=a-g.e,i=g.c;for(a+=1,$toLength(i.length)>a&&$call(d,g,h,this.constructor.RM),i[0]?b?h=a:(i=g.c,h=g.e+h+1):h+=1;$toLength(i.length)<h;)$push(i,0);return h=g.e,!c&&(1===b||b&&(h>=a||s>=h))?(f="",g.s<0&&i[0]&&(f+="-"),f+=i[0],i.length>1&&(f+="."+$sSlice($join(i,""),1)),f+="e",h>=0&&(f+="+"),f+=h):f=$call(e,g,!1,c),f}function g(a){var b,c,d;if(a=0===a&&1/a===NEGATIVE_INFINITY?"-0":$toString(a),!$test(w,a))throw new u(NaN);for("-"===$getItem(a,0,stringTagString)?(a=$sSlice(a,1),this.s=-1):this.s=1,b=$call(pSIndexOf,a,"."),b>-1&&(a=$call(pReplace,a,".","")),c=$call(pSearch,a,/e/i),c>0?(0>b&&(b=c),b+=$toNumber($sSlice(a,c+1)),a=$substr(a,0,c)):0>b&&(b=$toLength(a.length)),c=0;"0"===$getItem(a,c,stringTagString);)c+=1;if(d=$toLength(a.length),c===d)this.e=0,this.c=[0];else{for(d-=1;"0"===$getItem(a,d,stringTagString);)d-=1;for(this.e=b-c-1,this.c=[],b=0;d>=c;c+=1,b+=1)this.c[b]=$toNumber($getItem(a,c,stringTagString))}}function h(a,c,e){var f,g,h,i,j,k,l,m,n,o,p,r,s,t,v,w,x=this.c,y=$toLength(arguments.length);if(2>y&&(c=this.constructor.DP),!b(c,0,q))throw new u("!Big.DP!");if(3>y&&(e=this.constructor.RM),a=new this.constructor(a),f=a.c,g=this.s===a.s?1:-1,!x[0]||!f[0]){if(x[0]===f[0])throw new u(NaN);if(!f[0])throw new u(g/POSITIVE_ZERO);return new this.constructor(g*POSITIVE_ZERO)}for(l=$slice(f),m=$toLength(f.length),n=m,o=$toLength(x.length),p=x.slice(0,m),r=$toLength(p.length),s=a,v=0,t=s.c=[],s.e=this.e-a.e,w=c+s.e+1,s.s=g,g=0>w?1:w+1,$unshift(l,0);m>r;)$push(p,0),r+=1;do{for(i=0;10>i;i+=1){if(r=$toLength(p.length),m!==r)j=m>r?1:-1;else for(j=0,k=0;m>k;k+=1)if(f[k]!==p[k]){j=f[k]>p[k]?1:-1;break}if(!(0>j))break;for(h=r===m?f:l;r;){if(r-=1,p[r]<h[r]){for(k=r-1;k>=0&&!p[k];k-=1)p[k]=9;p[k]-=1,p[r]+=10}p[r]-=h[r]}for(;!p[0];)$shift(p)}j||(i+=1),t[v]=i,v+=1,p[0]&&j?p[r]=x[n]||0:p=[x[n]],n+=1,g-=1}while((o>n||"undefined"!=typeof p[0])&&g);return t[0]||1===v||($shift(t),s.e-=1),v>w&&$call(d,s,c,e,"undefined"!=typeof p[0]),s}function i(a){a=new this.constructor(a);var b,c,d,e,f,g=this.c,h=a.c;if(this.s===a.s?a.s=1:a.s=-1,!g[0]||!h[0])return c=-1===a.s?-0:0,new this.constructor(c);for(c=$toLength(g.length),d=$toLength(h.length),e=this.e,f=a.e,a.e=e+f,d>c&&(b=g,g=h,h=b,f=c,c=d,d=f),b=[],b.length=f=c+d;f;b[f]=0)f-=1;for(e=d;e;){for(e-=1,d=0,f=c+e;f>e;)d=b[f]+h[e]*g[f-e-1]+d,b[f]=d%10,f-=1,d=d/10|0;b[f]=(b[f]+d)%10}for(d&&(a.e+=1),b[0]||$shift(b),e=$toLength(b.length)-1;!b[e];e-=1)$pop(b);return a.c=b,a}function j(a){a=new this.constructor(a);var b,c,d,e=this.c,f=a.c,g=this.s,h=a.s,i=this.e,j=a.e;if(!e[0]||!f[0])return d=e[0]?g:f[0]?-h:0;if(g!==h)return g;if(b=0>g,i!==j)return c=i>j^b,d=c?1:-1;for(i=$toLength(e.length),j=$toLength(f.length),h=j>i?i:j,g=0;h>g;g+=1)if(e[g]!==f[g])return c=e[g]>f[g]^b,d=c?1:-1;return i===j?d=0:(c=i>j^b,d=c?1:-1),d}function k(a){a=new this.constructor(a);var b,c,d,e=this.s,f=a.s;if(!a.c[0])throw new u(NaN);return this.s=a.s=1,b=1===$call(j,a,this),this.s=e,a.s=f,b?d=new this.constructor(this):(c=$call(h,this,a,0,0),d=$call(n,this,$call(i,c,a))),d}function l(){function s(b){var c;if($isInstance(this,s))$defineProperty(this,"s",{writable:!0,configurable:!0,enumerable:!1}),$defineProperty(this,"e",{writable:!0,configurable:!0,enumerable:!1}),$defineProperty(this,"c",{writable:!0,configurable:!0,enumerable:!1}),$isInstance(b,s)||a(b)?(this.s=b.s,this.e=b.e,null===b.c?this.c=b.c:this.c=b.c.slice()):$call(g,this,b);else{if(0===$toLength(arguments.length))return l();c=new s(b)}return c}return $defineProperty(s.prototype,"abs",{value:function(){var a=new this.constructor(this);return a.s=1,a},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s.prototype,"cmp",{value:function(a){return $call(j,this,a)},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s.prototype,"div",{value:function(){return c(arguments,h,this)},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s.prototype,"eq",{value:function(a){return!$call(j,this,a)},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s.prototype,"gt",{value:function(a){return $call(j,this,a)>0},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s.prototype,"gte",{value:function(a){return $call(j,this,a)>-1},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s.prototype,"lt",{value:function(a){return $call(j,this,a)<0},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s.prototype,"lte",{value:function(a){return $call(j,this,a)<1},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s.prototype,"minus",{value:function(){return c(arguments,n,this)},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s.prototype,"sub",{value:function(){return $apply(s.prototype.minus,this,arguments)},writable:!1,configurable:!1,enumerable:!1}),$defineProperty(s.prototype,"mod",{value:function(){return c(arguments,k,this)},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s.prototype,"plus",{value:function(){return c(arguments,m,this)},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s.prototype,"add",{value:function(){return $apply(s.prototype.plus,this,arguments)},writable:!1,configurable:!1,enumerable:!1}),$defineProperty(s.prototype,"pow",{value:function(a){var c,d=this,e=new this.constructor(1),f=e,g=0>a;if(!b(a,-r,r))throw new u("!pow!");g&&(a=-a);do c=1&a,c&&(f=$call(i,f,d)),a>>=1,a&&(d=$call(i,d,d));while(a);return g?$call(h,e,f):f},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s.prototype,"round",{value:function(a,c){var e=$toLength(arguments.length);if(0===e||null===a)a=0;else if(!b(a,0,q))throw new u("!round!");return 2>e&&(c=this.constructor.RM),$call(d,new this.constructor(this),a,c)},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s.prototype,"sqrt",{value:function(){var a,b,c,f,g,j,k,l,n=this.c;if(!n[0])return new this.constructor(this);if(f=this.s,0>f)throw new u(NaN);f=$sqrt($call(e,this)),0===f||f===INFINITY?(a=$join(n,""),k=a.length+g&1,k||(a+="0"),b=new this.constructor($toString($sqrt(a))),g=this.e,b.e=((g+1)/2|0)-(0>g||1&g)):b=new this.constructor($toString(f)),l=this.constructor.DP+4,f=b.e+l,j=new this.constructor("0.5");do c=b,b=$call(i,j,$call(m,c,$call(h,this,c,l)));while($join($slice(c.c,0,f),"")!==$join($slice(b.c,0,f),""));return $call(d,b,this.constructor.DP,this.constructor.RM)},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s.prototype,"times",{value:function(){return c(arguments,i,this)},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s.prototype,"mul",{value:function(){return $apply(s.prototype.times,this,arguments)},writable:!1,configurable:!1,enumerable:!1}),$defineProperty(s.prototype,"toString",{value:function(){return $call(e,this)},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s.prototype,"valueOf",{value:function(){return $call(e,this,!0)},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s.prototype,"toJSON",{value:function(){return $call(e,this,!0)},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s.prototype,"toExponential",{value:function(a){if(0===$toLength(arguments.length))a=$toLength(this.c.length)-1;else if(!b(a,0,q))throw new u("!toExp!");return $call(f,this,a,1)},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s.prototype,"toFixed",{value:function(a){var c,d=!0;if(0===$toLength(arguments.length)?c=$call(e,this,!1,d):b(a,0,q)&&(c=$call(f,this,this.e+a,null,d),
this.s<0&&this.c[0]&&$call(pSIndexOf,c,"-")<0&&(c="-"+c)),!c)throw new u("!toFix!");return c},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s.prototype,"toPrecision",{value:function(a){if(0===$toLength(arguments.length))return $call(e,this);if(!b(a,1,q))throw new u("!toPre!");return $call(f,this,a-1,2)},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s.prototype,"classId",{value:v,writable:!1,configurable:!1,enumerable:!1}),$defineProperty(s,"DP",{value:o,writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s,"RM",{value:p,writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s,"version",{value:"0.2.0",writable:!1,configurable:!1,enumerable:!1}),$defineProperty(s.prototype,"version",{value:"0.2.0",writable:!1,configurable:!1,enumerable:!1}),$defineProperty(s,"isBig",{value:function(a){return $isInstance(a,s)},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s,"isBigSibling",{value:function(b){return!$isInstance(b,s)&&a(b)},writable:!0,configurable:!0,enumerable:!1}),$defineProperty(s,"BigError",{value:u,writable:!1,configurable:!1,enumerable:!1}),s}var m,n,o=20,p=1,q=1e6,r=1e6,s=-7,t=21,u=exports.customError("BigError",CError),v="[object Big]",w=/^-?(\d+(\.\d*)?|\.\d+)(e[+\-]?\d+)?$/i;$defineProperty(u,"version",$assign({value:"0.2.0"},propConstant)),$defineProperties(u.prototype,{classId:$assign({value:"[object BigError]"},propConstant),version:$assign({value:"0.2.0"},propConstant)}),n=function(a){a=new this.constructor(a);var b,c,d,e,f,g,h,i,j,k,l,n=this.s,o=a.s;if(n!==o)return a.s=-o,$call(m,this,a);if(f=$slice(this.c),g=this.e,j=a.c,k=a.e,!f[0]||!j[0])return j[0]?(a.s=-o,l=a):l=f[0]?new this.constructor(this):new this.constructor(0),l;if(n=g-k){for(e=0>n,e?(n=-n,d=f):(k=g,d=j),$reverse(d),o=n;o;o-=1)$push(d,0);$reverse(d)}else for(h=$toLength(f.length),i=$toLength(j.length),e=i>h,c=e?h:i,n=o=0;c>o;o+=1)if(f[o]!==j[o]){e=f[o]<j[o];break}if(e&&(d=f,f=j,j=d,a.s=-a.s),b=$toLength(f.length),c=$toLength(j.length),o=c-b,o>0)for(;o;)f[b]=0,b+=1,o-=1;for(o=b-1;c>n;){if(c-=1,f[c]<j[c]){for(b=c-1;b&&!f[b];b-=1)f[b]=9;f[b]-=1,f[c]+=10}f[c]-=j[c]}for(;0===f[o];)$pop(f),o-=1;for(;0===f[0];)$shift(f),k-=1;return f[0]||(a.s=1,k=0,f=[0]),a.c=f,a.e=k,a},m=function(a){a=new this.constructor(a);var b,c,d,e,f,g,h=this.s,i=a.s;if(h!==i)return a.s=-i,$call(n,this,a);if(d=this.c,f=a.c,!d[0]||!f[0])return g=f[0]?a:d[0]?new this.constructor(this):new this.constructor(h*POSITIVE_ZERO);if(d=$slice(d),c=this.e,e=a.e,h=c-e){for(h>0?(e=c,b=f):(h=-h,b=d),$reverse(b);h;)$push(b,0),h-=1;$reverse(b)}for($toLength(d.length)-$toLength(f.length)<0&&(b=f,f=d,d=b),h=$toLength(f.length),i=0;h;)h-=1,d[h]=d[h]+f[h]+i,i=d[h]/10|0,d[h]%=10;for(i&&($unshift(d,i),e+=1),h=$toLength(d.length)-1;0===d[h];h-=1)$pop(d);return a.c=d,a.e=e,a},BigNum=l()}(),function(){function a(b){var c;return $isInstance(this,a)?($isPlainObject(b)||(b={}),"string"!=typeof b.message&&(b.message=""),"string"!=typeof b.operator&&(b.operator=""),$isFunction(b.stackStartFn)||(b.stackStartFn=a),$call(g,this,b.message,b.stackStartFn),$defineProperties(this,{actual:$assign({value:b.actual},propNotEnumerable),expected:$assign({value:b.expected},propNotEnumerable),operator:$assign({value:b.operator},propNotEnumerable)})):c=new a(b),c}function b(a,b){var c,d;return null==a?!1:null==b?!1:$isRegExp(b)&&$instanceOf(a,CError)?(c=exports.normaliseErrorIEToStringState(),c===!1&&exports.normaliseErrorIEToStringOn(),d=$toString(a),c===!1&&exports.normaliseErrorIEToStringOff(),$test(b,d)):$instanceOf(a,b)?!0:$isFunction(b)&&(c=exports.normaliseErrorIEToStringState(),c===!1&&exports.normaliseErrorIEToStringOn(),d=$call(b,{},a),c===!1&&exports.normaliseErrorIEToStringOff(),d===!0)?!0:!1}function c(b,d,e,f,g){throw $isFunction(g)||(g=c),new a({message:e,actual:b,expected:d,operator:f,stackStartFn:g})}function d(a,e,f,g,h){var i,j;$isFunction(h)||($isFunction(g)?(h=g,g=Undefined):h=d),"string"==typeof g&&g.length||"string"!=typeof f||(g=f,f=null);try{e()}catch(k){j=k}if(i=b(j,f),g=g?" "+$toString(g):".",g=f&&"string"==typeof f.name&&!f.name.length?" ("+f.name+")."+g:"."+g,a!==!0||j||c(j,f,"Missing expected exception"+g,Undefined,h),a===!1&&i===!0&&c(j,f,"Got unwanted exception"+g,Undefined,h),a===!0&&j&&f&&i===!1||a===!1&&j)throw j}function e(){var b={};return $defineProperties(b,{AssertionError:$assign({value:a},propConstant),factory:$assign({value:e},propConstant),fail:$assign({value:function(a,b,d,e){c(a,b,d,"fail",e)}},propNotEnumerable),ok:$assign({value:function(a,b,d){var e=!!a;e||c(e,!0,b,"ok",d)}},propNotEnumerable),notOk:$assign({value:function(a,b,d){var e=!!a;e&&c(e,!0,b,"notOk",d)}},propNotEnumerable),equal:$assign({value:function(a,b,d,e){a!=b&&c(a,b,d,"==",e)}},propNotEnumerable),notEqual:$assign({value:function(a,b,d,e){a==b&&c(a,b,d,"!=",e)}},propNotEnumerable),strictEqual:$assign({value:function(a,b,d,e){a!==b&&c(a,b,d,"===",e)}},propNotEnumerable),notStrictEqual:$assign({value:function(a,b,d,e){a===b&&c(a,b,d,"!==",e)}},propNotEnumerable),"throws":$assign({value:function(a,b,c,e){d(!0,a,b,c,e)}},propNotEnumerable),doesNotThrow:$assign({value:function(a,b,c){d(!1,a,b,c)}},propNotEnumerable),ifError:$assign({value:function(a){if(a)throw a}},propNotEnumerable),deepEqual:$assign({value:function(a,b,d,e){$deepEqual(a,b)||c(a,b,d,"deeptEqual",e)}},propNotEnumerable),notDeepEqual:$assign({value:function(a,b,d,e){$deepEqual(a,b)&&c(a,b,d,"notDeepEqual",e)}},propNotEnumerable),deepStrictEqual:$assign({value:function(a,b,d,e){$deepStrictEqual(a,b)||c(a,b,d,"deepStrictEqual",e)}},propNotEnumerable),notDeepStrictEqual:$assign({value:function(a,b,d,e){$deepStrictEqual(a,b)&&c(a,b,d,"notDeepStrictEqual",e)}},propNotEnumerable)}),b}var f=128,g=exports.customError("AssertionError",f),h="[object AssertionError]";$defineProperties(a,{version:$assign({value:"0.2.0"},propConstant)}),$inherits(a,g),$defineProperties(a.prototype,{classId:$assign({value:h},propConstant),version:$assign({value:"0.2.0"},propConstant),toString:$assign({value:function(){var b;return"string"==typeof this.message&&this.message.length?b=this.name+": "+$truncate(this.message,f):$isInstance(this,a)&&(b=this.name+": ",b+=$truncate($stringify(this.actual,exports.customErrorReplacer),f)+" ",b+=this.operator+" ",b+=exports.String.truncate($stringify(this.expected,exports.customErrorReplacer),f)),b}},propNotEnumerable)}),exports.assert=e()}(),exports.goNative=function(){var a=exports.factory();$forEach($objectKeys(exports),function(b){"Big"!==b&&"assert"!==b&&$isPlainObject(a[b])&&$forEach($objectKeys(exports[b]),function(c){$isPlainObject(exports[b][c])||exports[b][c]!==base[b][c]&&(exports.Number.isNaN(a[b][c])&&exports.Number.isNaN(base[b][c])||($conlog(b+"."+c),$defineProperty(global[b],c,$assign({value:a[b][c]},propNotEnumerable)))),$isPlainObject(exports[b][c])&&$forEach($objectKeys(exports[b][c]),function(d){$isPlainObject(exports[b][c][d])||exports[b][c][d]===base[b][c][d]||("proto"===c?($conlog(b,b+".prototype."+d),$defineProperty(global[b].prototype,d,$assign({value:a[b][c][d]},propNotEnumerable))):($conlog(b,b+"."+c+"."+d),$defineProperty(global[b][c],d,$assign({value:a[b][c][d]},propNotEnumerable))))})})}),$defineProperty(global,"Big",$assign({value:BigNum()},propNotEnumerable)),$defineProperty(global,"assert",$assign({value:exports.assert.factory()},propNotEnumerable))},exports.factory=function(){var a={};return $forEach($objectKeys(exports),function(b){"Big"!==b&&"assert"!==b&&(addMethodsList(a),defineItem(a,b,exports[b]),$isPlainObject(exports[b])?(addMethodsList(a[b]),$forEach($objectKeys(exports[b]),function(c){defineItem(a[b],c,exports[b][c]),$isPlainObject(exports[b][c])?(addMethodsList(a[b][c]),$forEach($objectKeys(exports[b][c]),function(d){defineItem(a[b][c],d,exports[b][c][d]),$push(a[b][c].methods,d)})):$push(a[b].methods,c)})):$push(a.methods,b))}),$defineProperty(a,"Big",$assign({value:BigNum()},propNotEnumerable)),$defineProperty(a,"assert",$assign({value:exports.assert.factory()},propNotEnumerable)),$defineProperty(a,"version",propConstant),$defineProperties(a.Number,{POSITIVE_ZERO:propConstant,NEGATIVE_ZERO:propConstant,UNSAFE_INTEGER:propConstant,WORD8:propConstant,UWORD8:propConstant,WORD16:propConstant,UWORD16:propConstant,WORD32:propConstant,UWORD32:propConstant,MAX_UINT32:propConstant,MAX_INT32:propConstant,MIN_INT32:propConstant,MAX_UINT16:propConstant,MAX_INT16:propConstant,MIN_INT16:propConstant,MAX_UINT8:propConstant,MAX_INT8:propConstant,MIN_INT8:propConstant,MAX_SAFE_INTEGER:propConstant,MIN_SAFE_INTEGER:propConstant,MAX_VALUE:propConstant,MIN_VALUE:propConstant,EPSILON:propConstant,NaN:propConstant,POSITIVE_INFINITY:propConstant,NEGATIVE_INFINITY:propConstant}),a},"object"!==$typeOf(global))throw new CTypeError("Invalid global context");module&&module.exports?module.exports=exports.factory():define&&define.amd?define(function(){return exports.factory()}):$defineProperty(global,"utilx",$assign({value:exports.factory()},propNotEnumerable))}(("function"==typeof window||"object"==typeof window)&&window||"object"==typeof self&&self||"object"==typeof global&&global||"object"==typeof this&&this||{},"object"==typeof module&&module,("function"==typeof define||!1)&&define);
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],3:[function(require,module,exports){

},{}],4:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  function Bar () {}
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    arr.constructor = Bar
    return arr.foo() === 42 && // typed array instances can be augmented
        arr.constructor === Bar && // constructor can be set
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  this.length = 0
  this.parent = undefined

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    array.byteLength
    that = Buffer._augment(new Uint8Array(array))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` is deprecated
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` is deprecated
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

},{"base64-js":5,"ieee754":6,"is-array":7}],5:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],6:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],7:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],8:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],9:[function(require,module,exports){
(function (Buffer){
(function (global, module) {

  var exports = module.exports;

  /**
   * Exports.
   */

  module.exports = expect;
  expect.Assertion = Assertion;

  /**
   * Exports version.
   */

  expect.version = '0.3.1';

  /**
   * Possible assertion flags.
   */

  var flags = {
      not: ['to', 'be', 'have', 'include', 'only']
    , to: ['be', 'have', 'include', 'only', 'not']
    , only: ['have']
    , have: ['own']
    , be: ['an']
  };

  function expect (obj) {
    return new Assertion(obj);
  }

  /**
   * Constructor
   *
   * @api private
   */

  function Assertion (obj, flag, parent) {
    this.obj = obj;
    this.flags = {};

    if (undefined != parent) {
      this.flags[flag] = true;

      for (var i in parent.flags) {
        if (parent.flags.hasOwnProperty(i)) {
          this.flags[i] = true;
        }
      }
    }

    var $flags = flag ? flags[flag] : keys(flags)
      , self = this;

    if ($flags) {
      for (var i = 0, l = $flags.length; i < l; i++) {
        // avoid recursion
        if (this.flags[$flags[i]]) continue;

        var name = $flags[i]
          , assertion = new Assertion(this.obj, name, this)

        if ('function' == typeof Assertion.prototype[name]) {
          // clone the function, make sure we dont touch the prot reference
          var old = this[name];
          this[name] = function () {
            return old.apply(self, arguments);
          };

          for (var fn in Assertion.prototype) {
            if (Assertion.prototype.hasOwnProperty(fn) && fn != name) {
              this[name][fn] = bind(assertion[fn], assertion);
            }
          }
        } else {
          this[name] = assertion;
        }
      }
    }
  }

  /**
   * Performs an assertion
   *
   * @api private
   */

  Assertion.prototype.assert = function (truth, msg, error, expected) {
    var msg = this.flags.not ? error : msg
      , ok = this.flags.not ? !truth : truth
      , err;

    if (!ok) {
      err = new Error(msg.call(this));
      if (arguments.length > 3) {
        err.actual = this.obj;
        err.expected = expected;
        err.showDiff = true;
      }
      throw err;
    }

    this.and = new Assertion(this.obj);
  };

  /**
   * Check if the value is truthy
   *
   * @api public
   */

  Assertion.prototype.ok = function () {
    this.assert(
        !!this.obj
      , function(){ return 'expected ' + i(this.obj) + ' to be truthy' }
      , function(){ return 'expected ' + i(this.obj) + ' to be falsy' });
  };

  /**
   * Creates an anonymous function which calls fn with arguments.
   *
   * @api public
   */

  Assertion.prototype.withArgs = function() {
    expect(this.obj).to.be.a('function');
    var fn = this.obj;
    var args = Array.prototype.slice.call(arguments);
    return expect(function() { fn.apply(null, args); });
  };

  /**
   * Assert that the function throws.
   *
   * @param {Function|RegExp} callback, or regexp to match error string against
   * @api public
   */

  Assertion.prototype.throwError =
  Assertion.prototype.throwException = function (fn) {
    expect(this.obj).to.be.a('function');

    var thrown = false
      , not = this.flags.not;

    try {
      this.obj();
    } catch (e) {
      if (isRegExp(fn)) {
        var subject = 'string' == typeof e ? e : e.message;
        if (not) {
          expect(subject).to.not.match(fn);
        } else {
          expect(subject).to.match(fn);
        }
      } else if ('function' == typeof fn) {
        fn(e);
      }
      thrown = true;
    }

    if (isRegExp(fn) && not) {
      // in the presence of a matcher, ensure the `not` only applies to
      // the matching.
      this.flags.not = false;
    }

    var name = this.obj.name || 'fn';
    this.assert(
        thrown
      , function(){ return 'expected ' + name + ' to throw an exception' }
      , function(){ return 'expected ' + name + ' not to throw an exception' });
  };

  /**
   * Checks if the array is empty.
   *
   * @api public
   */

  Assertion.prototype.empty = function () {
    var expectation;

    if ('object' == typeof this.obj && null !== this.obj && !isArray(this.obj)) {
      if ('number' == typeof this.obj.length) {
        expectation = !this.obj.length;
      } else {
        expectation = !keys(this.obj).length;
      }
    } else {
      if ('string' != typeof this.obj) {
        expect(this.obj).to.be.an('object');
      }

      expect(this.obj).to.have.property('length');
      expectation = !this.obj.length;
    }

    this.assert(
        expectation
      , function(){ return 'expected ' + i(this.obj) + ' to be empty' }
      , function(){ return 'expected ' + i(this.obj) + ' to not be empty' });
    return this;
  };

  /**
   * Checks if the obj exactly equals another.
   *
   * @api public
   */

  Assertion.prototype.be =
  Assertion.prototype.equal = function (obj) {
    this.assert(
        obj === this.obj
      , function(){ return 'expected ' + i(this.obj) + ' to equal ' + i(obj) }
      , function(){ return 'expected ' + i(this.obj) + ' to not equal ' + i(obj) });
    return this;
  };

  /**
   * Checks if the obj sortof equals another.
   *
   * @api public
   */

  Assertion.prototype.eql = function (obj) {
    this.assert(
        expect.eql(this.obj, obj)
      , function(){ return 'expected ' + i(this.obj) + ' to sort of equal ' + i(obj) }
      , function(){ return 'expected ' + i(this.obj) + ' to sort of not equal ' + i(obj) }
      , obj);
    return this;
  };

  /**
   * Assert within start to finish (inclusive).
   *
   * @param {Number} start
   * @param {Number} finish
   * @api public
   */

  Assertion.prototype.within = function (start, finish) {
    var range = start + '..' + finish;
    this.assert(
        this.obj >= start && this.obj <= finish
      , function(){ return 'expected ' + i(this.obj) + ' to be within ' + range }
      , function(){ return 'expected ' + i(this.obj) + ' to not be within ' + range });
    return this;
  };

  /**
   * Assert typeof / instance of
   *
   * @api public
   */

  Assertion.prototype.a =
  Assertion.prototype.an = function (type) {
    if ('string' == typeof type) {
      // proper english in error msg
      var n = /^[aeiou]/.test(type) ? 'n' : '';

      // typeof with support for 'array'
      this.assert(
          'array' == type ? isArray(this.obj) :
            'regexp' == type ? isRegExp(this.obj) :
              'object' == type
                ? 'object' == typeof this.obj && null !== this.obj
                : type == typeof this.obj
        , function(){ return 'expected ' + i(this.obj) + ' to be a' + n + ' ' + type }
        , function(){ return 'expected ' + i(this.obj) + ' not to be a' + n + ' ' + type });
    } else {
      // instanceof
      var name = type.name || 'supplied constructor';
      this.assert(
          this.obj instanceof type
        , function(){ return 'expected ' + i(this.obj) + ' to be an instance of ' + name }
        , function(){ return 'expected ' + i(this.obj) + ' not to be an instance of ' + name });
    }

    return this;
  };

  /**
   * Assert numeric value above _n_.
   *
   * @param {Number} n
   * @api public
   */

  Assertion.prototype.greaterThan =
  Assertion.prototype.above = function (n) {
    this.assert(
        this.obj > n
      , function(){ return 'expected ' + i(this.obj) + ' to be above ' + n }
      , function(){ return 'expected ' + i(this.obj) + ' to be below ' + n });
    return this;
  };

  /**
   * Assert numeric value below _n_.
   *
   * @param {Number} n
   * @api public
   */

  Assertion.prototype.lessThan =
  Assertion.prototype.below = function (n) {
    this.assert(
        this.obj < n
      , function(){ return 'expected ' + i(this.obj) + ' to be below ' + n }
      , function(){ return 'expected ' + i(this.obj) + ' to be above ' + n });
    return this;
  };

  /**
   * Assert string value matches _regexp_.
   *
   * @param {RegExp} regexp
   * @api public
   */

  Assertion.prototype.match = function (regexp) {
    this.assert(
        regexp.exec(this.obj)
      , function(){ return 'expected ' + i(this.obj) + ' to match ' + regexp }
      , function(){ return 'expected ' + i(this.obj) + ' not to match ' + regexp });
    return this;
  };

  /**
   * Assert property "length" exists and has value of _n_.
   *
   * @param {Number} n
   * @api public
   */

  Assertion.prototype.length = function (n) {
    expect(this.obj).to.have.property('length');
    var len = this.obj.length;
    this.assert(
        n == len
      , function(){ return 'expected ' + i(this.obj) + ' to have a length of ' + n + ' but got ' + len }
      , function(){ return 'expected ' + i(this.obj) + ' to not have a length of ' + len });
    return this;
  };

  /**
   * Assert property _name_ exists, with optional _val_.
   *
   * @param {String} name
   * @param {Mixed} val
   * @api public
   */

  Assertion.prototype.property = function (name, val) {
    if (this.flags.own) {
      this.assert(
          Object.prototype.hasOwnProperty.call(this.obj, name)
        , function(){ return 'expected ' + i(this.obj) + ' to have own property ' + i(name) }
        , function(){ return 'expected ' + i(this.obj) + ' to not have own property ' + i(name) });
      return this;
    }

    if (this.flags.not && undefined !== val) {
      if (undefined === this.obj[name]) {
        throw new Error(i(this.obj) + ' has no property ' + i(name));
      }
    } else {
      var hasProp;
      try {
        hasProp = name in this.obj
      } catch (e) {
        hasProp = undefined !== this.obj[name]
      }

      this.assert(
          hasProp
        , function(){ return 'expected ' + i(this.obj) + ' to have a property ' + i(name) }
        , function(){ return 'expected ' + i(this.obj) + ' to not have a property ' + i(name) });
    }

    if (undefined !== val) {
      this.assert(
          val === this.obj[name]
        , function(){ return 'expected ' + i(this.obj) + ' to have a property ' + i(name)
          + ' of ' + i(val) + ', but got ' + i(this.obj[name]) }
        , function(){ return 'expected ' + i(this.obj) + ' to not have a property ' + i(name)
          + ' of ' + i(val) });
    }

    this.obj = this.obj[name];
    return this;
  };

  /**
   * Assert that the array contains _obj_ or string contains _obj_.
   *
   * @param {Mixed} obj|string
   * @api public
   */

  Assertion.prototype.string =
  Assertion.prototype.contain = function (obj) {
    if ('string' == typeof this.obj) {
      this.assert(
          ~this.obj.indexOf(obj)
        , function(){ return 'expected ' + i(this.obj) + ' to contain ' + i(obj) }
        , function(){ return 'expected ' + i(this.obj) + ' to not contain ' + i(obj) });
    } else {
      this.assert(
          ~indexOf(this.obj, obj)
        , function(){ return 'expected ' + i(this.obj) + ' to contain ' + i(obj) }
        , function(){ return 'expected ' + i(this.obj) + ' to not contain ' + i(obj) });
    }
    return this;
  };

  /**
   * Assert exact keys or inclusion of keys by using
   * the `.own` modifier.
   *
   * @param {Array|String ...} keys
   * @api public
   */

  Assertion.prototype.key =
  Assertion.prototype.keys = function ($keys) {
    var str
      , ok = true;

    $keys = isArray($keys)
      ? $keys
      : Array.prototype.slice.call(arguments);

    if (!$keys.length) throw new Error('keys required');

    var actual = keys(this.obj)
      , len = $keys.length;

    // Inclusion
    ok = every($keys, function (key) {
      return ~indexOf(actual, key);
    });

    // Strict
    if (!this.flags.not && this.flags.only) {
      ok = ok && $keys.length == actual.length;
    }

    // Key string
    if (len > 1) {
      $keys = map($keys, function (key) {
        return i(key);
      });
      var last = $keys.pop();
      str = $keys.join(', ') + ', and ' + last;
    } else {
      str = i($keys[0]);
    }

    // Form
    str = (len > 1 ? 'keys ' : 'key ') + str;

    // Have / include
    str = (!this.flags.only ? 'include ' : 'only have ') + str;

    // Assertion
    this.assert(
        ok
      , function(){ return 'expected ' + i(this.obj) + ' to ' + str }
      , function(){ return 'expected ' + i(this.obj) + ' to not ' + str });

    return this;
  };

  /**
   * Assert a failure.
   *
   * @param {String ...} custom message
   * @api public
   */
  Assertion.prototype.fail = function (msg) {
    var error = function() { return msg || "explicit failure"; }
    this.assert(false, error, error);
    return this;
  };

  /**
   * Function bind implementation.
   */

  function bind (fn, scope) {
    return function () {
      return fn.apply(scope, arguments);
    }
  }

  /**
   * Array every compatibility
   *
   * @see bit.ly/5Fq1N2
   * @api public
   */

  function every (arr, fn, thisObj) {
    var scope = thisObj || global;
    for (var i = 0, j = arr.length; i < j; ++i) {
      if (!fn.call(scope, arr[i], i, arr)) {
        return false;
      }
    }
    return true;
  }

  /**
   * Array indexOf compatibility.
   *
   * @see bit.ly/a5Dxa2
   * @api public
   */

  function indexOf (arr, o, i) {
    if (Array.prototype.indexOf) {
      return Array.prototype.indexOf.call(arr, o, i);
    }

    if (arr.length === undefined) {
      return -1;
    }

    for (var j = arr.length, i = i < 0 ? i + j < 0 ? 0 : i + j : i || 0
        ; i < j && arr[i] !== o; i++);

    return j <= i ? -1 : i;
  }

  // https://gist.github.com/1044128/
  var getOuterHTML = function(element) {
    if ('outerHTML' in element) return element.outerHTML;
    var ns = "http://www.w3.org/1999/xhtml";
    var container = document.createElementNS(ns, '_');
    var xmlSerializer = new XMLSerializer();
    var html;
    if (document.xmlVersion) {
      return xmlSerializer.serializeToString(element);
    } else {
      container.appendChild(element.cloneNode(false));
      html = container.innerHTML.replace('><', '>' + element.innerHTML + '<');
      container.innerHTML = '';
      return html;
    }
  };

  // Returns true if object is a DOM element.
  var isDOMElement = function (object) {
    if (typeof HTMLElement === 'object') {
      return object instanceof HTMLElement;
    } else {
      return object &&
        typeof object === 'object' &&
        object.nodeType === 1 &&
        typeof object.nodeName === 'string';
    }
  };

  /**
   * Inspects an object.
   *
   * @see taken from node.js `util` module (copyright Joyent, MIT license)
   * @api private
   */

  function i (obj, showHidden, depth) {
    var seen = [];

    function stylize (str) {
      return str;
    }

    function format (value, recurseTimes) {
      // Provide a hook for user-specified inspect functions.
      // Check that value is an object with an inspect function on it
      if (value && typeof value.inspect === 'function' &&
          // Filter out the util module, it's inspect function is special
          value !== exports &&
          // Also filter out any prototype objects using the circular check.
          !(value.constructor && value.constructor.prototype === value)) {
        return value.inspect(recurseTimes);
      }

      // Primitive types cannot have properties
      switch (typeof value) {
        case 'undefined':
          return stylize('undefined', 'undefined');

        case 'string':
          var simple = '\'' + json.stringify(value).replace(/^"|"$/g, '')
                                                   .replace(/'/g, "\\'")
                                                   .replace(/\\"/g, '"') + '\'';
          return stylize(simple, 'string');

        case 'number':
          return stylize('' + value, 'number');

        case 'boolean':
          return stylize('' + value, 'boolean');
      }
      // For some reason typeof null is "object", so special case here.
      if (value === null) {
        return stylize('null', 'null');
      }

      if (isDOMElement(value)) {
        return getOuterHTML(value);
      }

      // Look up the keys of the object.
      var visible_keys = keys(value);
      var $keys = showHidden ? Object.getOwnPropertyNames(value) : visible_keys;

      // Functions without properties can be shortcutted.
      if (typeof value === 'function' && $keys.length === 0) {
        if (isRegExp(value)) {
          return stylize('' + value, 'regexp');
        } else {
          var name = value.name ? ': ' + value.name : '';
          return stylize('[Function' + name + ']', 'special');
        }
      }

      // Dates without properties can be shortcutted
      if (isDate(value) && $keys.length === 0) {
        return stylize(value.toUTCString(), 'date');
      }
      
      // Error objects can be shortcutted
      if (value instanceof Error) {
        return stylize("["+value.toString()+"]", 'Error');
      }

      var base, type, braces;
      // Determine the object type
      if (isArray(value)) {
        type = 'Array';
        braces = ['[', ']'];
      } else {
        type = 'Object';
        braces = ['{', '}'];
      }

      // Make functions say that they are functions
      if (typeof value === 'function') {
        var n = value.name ? ': ' + value.name : '';
        base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
      } else {
        base = '';
      }

      // Make dates with properties first say the date
      if (isDate(value)) {
        base = ' ' + value.toUTCString();
      }

      if ($keys.length === 0) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return stylize('' + value, 'regexp');
        } else {
          return stylize('[Object]', 'special');
        }
      }

      seen.push(value);

      var output = map($keys, function (key) {
        var name, str;
        if (value.__lookupGetter__) {
          if (value.__lookupGetter__(key)) {
            if (value.__lookupSetter__(key)) {
              str = stylize('[Getter/Setter]', 'special');
            } else {
              str = stylize('[Getter]', 'special');
            }
          } else {
            if (value.__lookupSetter__(key)) {
              str = stylize('[Setter]', 'special');
            }
          }
        }
        if (indexOf(visible_keys, key) < 0) {
          name = '[' + key + ']';
        }
        if (!str) {
          if (indexOf(seen, value[key]) < 0) {
            if (recurseTimes === null) {
              str = format(value[key]);
            } else {
              str = format(value[key], recurseTimes - 1);
            }
            if (str.indexOf('\n') > -1) {
              if (isArray(value)) {
                str = map(str.split('\n'), function (line) {
                  return '  ' + line;
                }).join('\n').substr(2);
              } else {
                str = '\n' + map(str.split('\n'), function (line) {
                  return '   ' + line;
                }).join('\n');
              }
            }
          } else {
            str = stylize('[Circular]', 'special');
          }
        }
        if (typeof name === 'undefined') {
          if (type === 'Array' && key.match(/^\d+$/)) {
            return str;
          }
          name = json.stringify('' + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = stylize(name, 'name');
          } else {
            name = name.replace(/'/g, "\\'")
                       .replace(/\\"/g, '"')
                       .replace(/(^"|"$)/g, "'");
            name = stylize(name, 'string');
          }
        }

        return name + ': ' + str;
      });

      seen.pop();

      var numLinesEst = 0;
      var length = reduce(output, function (prev, cur) {
        numLinesEst++;
        if (indexOf(cur, '\n') >= 0) numLinesEst++;
        return prev + cur.length + 1;
      }, 0);

      if (length > 50) {
        output = braces[0] +
                 (base === '' ? '' : base + '\n ') +
                 ' ' +
                 output.join(',\n  ') +
                 ' ' +
                 braces[1];

      } else {
        output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
      }

      return output;
    }
    return format(obj, (typeof depth === 'undefined' ? 2 : depth));
  }

  expect.stringify = i;

  function isArray (ar) {
    return Object.prototype.toString.call(ar) === '[object Array]';
  }

  function isRegExp(re) {
    var s;
    try {
      s = '' + re;
    } catch (e) {
      return false;
    }

    return re instanceof RegExp || // easy case
           // duck-type for context-switching evalcx case
           typeof(re) === 'function' &&
           re.constructor.name === 'RegExp' &&
           re.compile &&
           re.test &&
           re.exec &&
           s.match(/^\/.*\/[gim]{0,3}$/);
  }

  function isDate(d) {
    return d instanceof Date;
  }

  function keys (obj) {
    if (Object.keys) {
      return Object.keys(obj);
    }

    var keys = [];

    for (var i in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, i)) {
        keys.push(i);
      }
    }

    return keys;
  }

  function map (arr, mapper, that) {
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, mapper, that);
    }

    var other= new Array(arr.length);

    for (var i= 0, n = arr.length; i<n; i++)
      if (i in arr)
        other[i] = mapper.call(that, arr[i], i, arr);

    return other;
  }

  function reduce (arr, fun) {
    if (Array.prototype.reduce) {
      return Array.prototype.reduce.apply(
          arr
        , Array.prototype.slice.call(arguments, 1)
      );
    }

    var len = +this.length;

    if (typeof fun !== "function")
      throw new TypeError();

    // no value to return if no initial value and an empty array
    if (len === 0 && arguments.length === 1)
      throw new TypeError();

    var i = 0;
    if (arguments.length >= 2) {
      var rv = arguments[1];
    } else {
      do {
        if (i in this) {
          rv = this[i++];
          break;
        }

        // if array contains no values, no initial value to return
        if (++i >= len)
          throw new TypeError();
      } while (true);
    }

    for (; i < len; i++) {
      if (i in this)
        rv = fun.call(null, rv, this[i], i, this);
    }

    return rv;
  }

  /**
   * Asserts deep equality
   *
   * @see taken from node.js `assert` module (copyright Joyent, MIT license)
   * @api private
   */

  expect.eql = function eql(actual, expected) {
    // 7.1. All identical values are equivalent, as determined by ===.
    if (actual === expected) {
      return true;
    } else if ('undefined' != typeof Buffer
      && Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
      if (actual.length != expected.length) return false;

      for (var i = 0; i < actual.length; i++) {
        if (actual[i] !== expected[i]) return false;
      }

      return true;

      // 7.2. If the expected value is a Date object, the actual value is
      // equivalent if it is also a Date object that refers to the same time.
    } else if (actual instanceof Date && expected instanceof Date) {
      return actual.getTime() === expected.getTime();

      // 7.3. Other pairs that do not both pass typeof value == "object",
      // equivalence is determined by ==.
    } else if (typeof actual != 'object' && typeof expected != 'object') {
      return actual == expected;
    // If both are regular expression use the special `regExpEquiv` method
    // to determine equivalence.
    } else if (isRegExp(actual) && isRegExp(expected)) {
      return regExpEquiv(actual, expected);
    // 7.4. For all other Object pairs, including Array objects, equivalence is
    // determined by having the same number of owned properties (as verified
    // with Object.prototype.hasOwnProperty.call), the same set of keys
    // (although not necessarily the same order), equivalent values for every
    // corresponding key, and an identical "prototype" property. Note: this
    // accounts for both named and indexed properties on Arrays.
    } else {
      return objEquiv(actual, expected);
    }
  };

  function isUndefinedOrNull (value) {
    return value === null || value === undefined;
  }

  function isArguments (object) {
    return Object.prototype.toString.call(object) == '[object Arguments]';
  }

  function regExpEquiv (a, b) {
    return a.source === b.source && a.global === b.global &&
           a.ignoreCase === b.ignoreCase && a.multiline === b.multiline;
  }

  function objEquiv (a, b) {
    if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
      return false;
    // an identical "prototype" property.
    if (a.prototype !== b.prototype) return false;
    //~~~I've managed to break Object.keys through screwy arguments passing.
    //   Converting to array solves the problem.
    if (isArguments(a)) {
      if (!isArguments(b)) {
        return false;
      }
      a = pSlice.call(a);
      b = pSlice.call(b);
      return expect.eql(a, b);
    }
    try{
      var ka = keys(a),
        kb = keys(b),
        key, i;
    } catch (e) {//happens when one is a string literal and the other isn't
      return false;
    }
    // having the same number of owned properties (keys incorporates hasOwnProperty)
    if (ka.length != kb.length)
      return false;
    //the same set of keys (although not necessarily the same order),
    ka.sort();
    kb.sort();
    //~~~cheap key test
    for (i = ka.length - 1; i >= 0; i--) {
      if (ka[i] != kb[i])
        return false;
    }
    //equivalent values for every corresponding key, and
    //~~~possibly expensive deep test
    for (i = ka.length - 1; i >= 0; i--) {
      key = ka[i];
      if (!expect.eql(a[key], b[key]))
         return false;
    }
    return true;
  }

  var json = (function () {
    "use strict";

    if ('object' == typeof JSON && JSON.parse && JSON.stringify) {
      return {
          parse: nativeJSON.parse
        , stringify: nativeJSON.stringify
      }
    }

    var JSON = {};

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    function date(d, key) {
      return isFinite(d.valueOf()) ?
          d.getUTCFullYear()     + '-' +
          f(d.getUTCMonth() + 1) + '-' +
          f(d.getUTCDate())      + 'T' +
          f(d.getUTCHours())     + ':' +
          f(d.getUTCMinutes())   + ':' +
          f(d.getUTCSeconds())   + 'Z' : null;
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

  // If the string contains no control characters, no quote characters, and no
  // backslash characters, then we can safely slap some quotes around it.
  // Otherwise we must also replace the offending characters with safe escape
  // sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

  // Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

  // If the value has a toJSON method, call it to obtain a replacement value.

        if (value instanceof Date) {
            value = date(key);
        }

  // If we were called with a replacer function, then call the replacer to
  // obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

  // What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

  // JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

  // If the value is a boolean or null, convert it to a string. Note:
  // typeof null does not produce 'null'. The case is included here in
  // the remote chance that this gets fixed someday.

            return String(value);

  // If the type is 'object', we might be dealing with an object or an array or
  // null.

        case 'object':

  // Due to a specification blunder in ECMAScript, typeof null is 'object',
  // so watch out for that case.

            if (!value) {
                return 'null';
            }

  // Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

  // Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

  // The value is an array. Stringify every element. Use null as a placeholder
  // for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

  // Join all of the elements together, separated with commas, and wrap them in
  // brackets.

                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

  // If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

  // Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

  // Join all of the member texts together, separated with commas,
  // and wrap them in braces.

            v = partial.length === 0 ? '{}' : gap ?
                '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

  // If the JSON object does not yet have a stringify method, give it one.

    JSON.stringify = function (value, replacer, space) {

  // The stringify method takes a value and an optional replacer, and an optional
  // space parameter, and returns a JSON text. The replacer can be a function
  // that can replace values, or an array of strings that will select the keys.
  // A default replacer method can be provided. Use of the space parameter can
  // produce text that is more easily readable.

        var i;
        gap = '';
        indent = '';

  // If the space parameter is a number, make an indent string containing that
  // many spaces.

        if (typeof space === 'number') {
            for (i = 0; i < space; i += 1) {
                indent += ' ';
            }

  // If the space parameter is a string, it will be used as the indent string.

        } else if (typeof space === 'string') {
            indent = space;
        }

  // If there is a replacer, it must be a function or an array.
  // Otherwise, throw an error.

        rep = replacer;
        if (replacer && typeof replacer !== 'function' &&
                (typeof replacer !== 'object' ||
                typeof replacer.length !== 'number')) {
            throw new Error('JSON.stringify');
        }

  // Make a fake root object containing our value under the key of ''.
  // Return the result of stringifying the value.

        return str('', {'': value});
    };

  // If the JSON object does not yet have a parse method, give it one.

    JSON.parse = function (text, reviver) {
    // The parse method takes a text and an optional reviver function, and returns
    // a JavaScript value if the text is a valid JSON text.

        var j;

        function walk(holder, key) {

    // The walk method is used to recursively walk the resulting structure so
    // that modifications can be made.

            var k, v, value = holder[key];
            if (value && typeof value === 'object') {
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = walk(value, k);
                        if (v !== undefined) {
                            value[k] = v;
                        } else {
                            delete value[k];
                        }
                    }
                }
            }
            return reviver.call(holder, key, value);
        }


    // Parsing happens in four stages. In the first stage, we replace certain
    // Unicode characters with escape sequences. JavaScript handles many characters
    // incorrectly, either silently deleting them, or treating them as line endings.

        text = String(text);
        cx.lastIndex = 0;
        if (cx.test(text)) {
            text = text.replace(cx, function (a) {
                return '\\u' +
                    ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            });
        }

    // In the second stage, we run the text against regular expressions that look
    // for non-JSON patterns. We are especially concerned with '()' and 'new'
    // because they can cause invocation, and '=' because it can cause mutation.
    // But just to be safe, we want to reject all unexpected forms.

    // We split the second stage into 4 regexp operations in order to work around
    // crippling inefficiencies in IE's and Safari's regexp engines. First we
    // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
    // replace all simple value tokens with ']' characters. Third, we delete all
    // open brackets that follow a colon or comma or that begin the text. Finally,
    // we look to see that the remaining characters are only whitespace or ']' or
    // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

        if (/^[\],:{}\s]*$/
                .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                    .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                    .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

    // In the third stage we use the eval function to compile the text into a
    // JavaScript structure. The '{' operator is subject to a syntactic ambiguity
    // in JavaScript: it can begin a block or an object literal. We wrap the text
    // in parens to eliminate the ambiguity.

            j = eval('(' + text + ')');

    // In the optional fourth stage, we recursively walk the new structure, passing
    // each name/value pair to a reviver function for possible transformation.

            return typeof reviver === 'function' ?
                walk({'': j}, '') : j;
        }

    // If the text is not JSON parseable, then a SyntaxError is thrown.

        throw new SyntaxError('JSON.parse');
    };

    return JSON;
  })();

  if ('undefined' != typeof window) {
    window.expect = module.exports;
  }

})(
    this
  , 'undefined' != typeof module ? module : {exports: {}}
);

}).call(this,require("buffer").Buffer)
},{"buffer":4}],10:[function(require,module,exports){
(function (process,global){
/*global
    Array, Boolean, Date, Error, Math, Number, Object, RegExp, String, TypeError,
    isNaN, module, process, require, self, window
*/

/*properties
    Array, Assertion, Boolean, Date, MAX_INT16, MAX_INT32, MAX_INT8,
    MAX_SAFE_INTEGER, MAX_UINT16, MAX_UINT32, MAX_UINT8, MAX_VALUE, MIN_INT16,
    MIN_INT32, MIN_INT8, MIN_SAFE_INTEGER, MIN_VALUE, Max, Number, Object,
    String, ToClass, ToInteger, ToLength, ToObject, ToString, UNSAFE_INTEGER,
    UTILX_WHICH, UWORD16, UWORD32, UWORD8, Uint8Array, WORD16, WORD32, WORD8,
    abs, actual, and, appendChild, apply, array2Object, assert, assertWarn,
    bignumber, body, call, console, create, createElement, decimal, descending,
    display, document, env, expect, expected, exports, flags, floor, forEach,
    frame, frames, getElementsByTagName, global, hasOwnProperty, indexOf,
    isArguments, isArray, isFunction, isNaN, isPrimitive, isRegExp, isStrictMode,
    isUndefined, join, length, log, makeDate, max, message, min, minusZero, name,
    noop, not, obj, proto, prototype, push, replace, returnArgs, showDiff, slice,
    split, stack, stacktrace, strictEqual, style, testObject, toISOString,
    toJSON, toString, utilx, write, zero, application, Math
*/

(function (global) {
    'use strict';

    var toStringTag = Object.prototype.toString,
        indexOf = Array.prototype.indexOf,
        hasOwn = Object.prototype.hasOwnProperty,
        zero = 0,
        required = {
            expect: require('expect.js'),
            Array: {},
            log: {},
            noop: function () { return; },
            zero: zero,
            minusZero: 1 / (-1 / zero),
            WORD8: 128,
            UWORD8: 256,
            WORD16: 32768,
            UWORD16: 65536,
            WORD32: 2147483648,
            UWORD32: 4294967296,
            MAX_UINT32: 4294967295,
            MAX_INT32: 2147483647,
            MIN_INT32: -2147483648,
            MAX_UINT16: 65535,
            MAX_INT16: 32767,
            MIN_INT16: -32768,
            MAX_UINT8: 255,
            MAX_INT8: 127,
            MIN_INT8: -128,
            MAX_SAFE_INTEGER: 9007199254740991,
            MIN_SAFE_INTEGER: -9007199254740991,
            UNSAFE_INTEGER: 9007199254740992,
            MAX_VALUE: 1.7976931348623157e+308,
            MIN_VALUE: 5e-324,
            String: String,
            Object: Object,
            Number: Number,
            Boolean: Boolean,
            global: global,
            strictEqual: function (a, b) { return a === b; },
            returnArgs: function () { return arguments; },
            frame: (typeof window === 'function' || typeof window === 'object') && window.testObject,
            isPrimitive: function (inputArg) {
                var type = typeof inputArg;

                return type === 'undefined' || inputArg === null || type === 'boolean' || type === 'string' || type === 'number';
            }
        };

    if ('1' === process.env.UTILX_WHICH) {
        required.utilx = require('../lib/util-x.min');
    } else {
        required.utilx = require('../lib/util-x');
    }

    if (!(typeof window === 'function' || typeof window === 'object')) {
        required.bignumber = require('bignumber.js');
        required.decimal = require('decimal.js');
    }

    required.isUndefined = function (inputArg) {
        return required.strictEqual(typeof inputArg, 'undefined');
    };

    required.isArguments = (function () {
        var strTag = '[object Arguments]',
            isArgs = toStringTag.call(required.returnArgs()) === strTag,
            fn;

        if (isArgs) {
            fn = function (inputArg) {
                return !required.isPrimitive(inputArg) && hasOwn.call(inputArg, 'length') && toStringTag.call(inputArg) === strTag;
            };
        } else {
            fn = function (inputArg) {
                return !required.isPrimitive(inputArg) && !hasOwn.call(inputArg, 'arguments') && hasOwn.call(inputArg, 'callee') && hasOwn.call(inputArg, 'length');
            };
        }

        return fn;
    }());

    required.isArray = (function () {
        if (Array.isArray) {
            return Array.isArray;
        }

        return function (inputArg) {
            return (!required.isPrimitive(inputArg) && hasOwn.call(inputArg, 'length') && toStringTag.call(inputArg) === '[object Array]');
        };
    }());

    required.isRegExp = function (inputArg) {
        return (!required.isPrimitive(inputArg) && hasOwn.call(inputArg, 'ignoreCase') && toStringTag.call(inputArg) === '[object RegExp]');
    };

    function typeofFunction(inputArg) {
        return typeof inputArg === 'function' || false;
    }

    if (!(typeofFunction(/x/) || (typeof global.Uint8Array !== 'function' && global.Uint8Array))) {
        required.isFunction = typeofFunction;
    } else {
        required.isFunction = function (inputArg) {
            /**
             * The use of 'Object#toString' avoids issues with the 'typeof' operator
             * in older versions of Chrome and Safari which return 'function' for regexes
             * and Safari 8 equivalents which return 'object' for typed array constructors.
             */
            return toStringTag.call(inputArg) === '[object Function]';
        };
    }

    required.ToClass = function (inputArg) {
        if (inputArg === null) {
            return '[object Null]';
        }

        if (required.isUndefined(inputArg)) {
            return '[object Undefined]';
        }

        if (required.isArguments(inputArg)) {
            return '[object Arguments]';
        }

        if (required.isRegExp(inputArg)) {
            return '[object RegExp]';
        }

        if (required.isArray(inputArg)) {
            return '[object Array]';
        }

        if (required.isFunction(inputArg)) {
            return '[object Function]';
        }

        return toStringTag.call(inputArg);
    };

    function checkObjectCoercible(inputArg) {
        if (inputArg === null || required.isUndefined(inputArg)) {
            throw new TypeError('Cannot convert argument to object: ' + inputArg);
        }

        return inputArg;
    }

    required.ToObject = function (inputArg) {
        return required.Object(checkObjectCoercible(inputArg));
    };

    required.ToString = function (inputArg) {
        var val;

        if (inputArg === null) {
            val = 'null';
        } else if (required.isUndefined(inputArg)) {
            val = 'undefined';
        } else {
            val = required.String(inputArg);
        }

        return val;
    };

    required.isStrictMode = function () {
        return (function () {
            return !this;
        }());
    };

    required.ToInteger = function (inputArg) {
        var number = +inputArg,
            val = 0;

        if (!isNaN(number)) {
            if (!number || number === Infinity || number === -Infinity) {
                val = number;
            } else {
                val = (number > 0 || -1) * Math.floor(Math.abs(number));
            }
        }

        return val;
    };

    required.ToLength = function (inputArg) {
        return Math.min(Math.max(required.ToInteger(inputArg), 0), required.MAX_SAFE_INTEGER);
    };

    required.slice = function (array, start, end) {
        var object = required.ToObject(array),
            length = required.ToLength(object.length),
            relativeStart = required.ToInteger(start),
            val = [],
            next = 0,
            relativeEnd,
            finalEnd,
            k;

        if (relativeStart < 0) {
            k = Math.Max(length + relativeStart, 0);
        } else {
            k = Math.min(relativeStart, length);
        }

        if (required.isUndefined(end)) {
            relativeEnd = length;
        } else {
            relativeEnd = required.ToInteger(end);
        }

        if (relativeEnd < 0) {
            finalEnd = Math.max(length + relativeEnd, 0);
        } else {
            finalEnd = Math.min(relativeEnd, length);
        }

        val.length = Math.max(finalEnd - k, 0);
        while (k < finalEnd) {
            if (k in object) {
                val[next] = object[k];
            }

            next += 1;
            k += 1;
        }

        return val;
    };

    required.log = (function (console) {
        var log = !required.isPrimitive(console) && !required.isPrimitive(console.log) && console.log,
            fn;

        if (log) {
            fn = function () {
                var length = required.ToLength(arguments.length),
                    index;

                for (index = 0; index < length; index += 1) {
                    try {
                        log(arguments[index]);
                    } catch (ignore) {}
                }
            };
        } else {
            fn = required.noop;
        }

        return fn;
    }(global.console));

    required.create = function (varArgs) {
        var length = required.ToLength(arguments.length),
            result = [],
            sliced,
            idx,
            it;

        if (!length) {
            result.length = 0;
        } else if (length === 1) {
            if (required.ToClass(varArgs) === '[object Number]') {
                result.length = required.ToLength(varArgs);
            } else if (required.ToClass(varArgs) === '[object String]') {
                sliced = varArgs.slice(1, -1).replace(/^\s+|\s+$/g, '');
                if (sliced[required.ToLength(sliced.length) - 1] === ',') {
                    sliced = sliced.slice(0, -1);
                }

                /*jslint regexp: true */
                sliced = sliced.split(',');
                length = required.ToLength(sliced.length);
                for (idx = 0; idx < length; idx += 1) {
                    it = sliced[idx].replace(/^\s+|\s+$/g, '');
                    if (it) {
                        /*jslint evil: true */
                        result[idx] = eval(it);
                        if (idx + 1 > required.ToLength(result.length)) {
                            result.length = idx + 1;
                        }
                        /*jslint evil: false */
                    }
                }
            } else {
                result[0] = varArgs;
                result.length = 1;
            }
        } else {
            for (idx = 0; idx < length; idx += 1) {
                result[idx] = arguments[idx];
                if (idx + 1 > required.ToLength(result.length)) {
                    result.length = idx + 1;
                }
            }
        }

        return result;
    };

    required.array2Object = function (array) {
        var object = required.ToObject(array),
            accumulator = {},
            length,
            index;

        if (!required.isFunction(object)) {
            accumulator.length = length = required.ToLength(object.length);
            for (index = 0; index < length; index += 1) {
                if (index in object) {
                    accumulator[index] = object[index];
                }
            }
        } else {
            accumulator.length = 0;
        }

        return accumulator;
    };

    required.makeDate = function makeDate(inputArg) {
        var date = new Date(inputArg);

        date.toISOString = required.utilx.Date.proto.toISOString;
        date.toJSON = required.utilx.Date.proto.toJSON;

        return date;
    };

    required.ToInteger = function (inputArg) {
        var number = +inputArg,
            val = 0;

        if (required.strictEqual(number, number)) {
            if (!number || number === Infinity || number === -Infinity) {
                val = number;
            } else {
                val = (number > 0 || -1) * Math.floor(Math.abs(number));
            }
        }

        return val;
    };

    required.isNaN = function (x) {
        return typeof x === 'number' && isNaN(x);
    };

    required.indexOf = (function () {
        try {
            if (indexOf.call([0, 1], 1, 2) === -1) {
                return function (arr) {
                    indexOf.apply(arr, required.slice(arguments, 1));
                };
            }
        } catch (ignore) {}

        return function (arr, searchElement, fromIndex) {
            var object = required.ToObject(arr),
                length = required.ToLength(object.length),
                val = -1,
                index;

            if (length) {
                if (required.ToLength(arguments.length) > 1) {
                    fromIndex = required.ToInteger(fromIndex);
                } else {
                    fromIndex = 0;
                }

                if (fromIndex < length) {
                    if (fromIndex < 0) {
                        fromIndex = length - Math.abs(fromIndex);
                        if (fromIndex < 0) {
                            fromIndex = 0;
                        }
                    }

                    for (index = fromIndex; index < length; index += 1) {
                        if (index in object && searchElement === object[index]) {
                            val = index;
                            break;
                        }
                    }
                }
            }

            return val;
        };
    }());

    required.forEach = (function () {
        var isStrictMode = (function () {
                return !this;
            }()),

            hasCallBug = (function () {
                var returnThis = function () {
                    return this;
                };

                return !isStrictMode && typeof returnThis.call('foo') === 'string';
            }());

        function toObjectCallFix(inputArg) {
            var object = inputArg,
                type;

            if (hasCallBug) {
                type = typeof inputArg;
                if (type === 'boolean' || type === 'number' || type === 'string') {
                    object = required.Object(inputArg);
                }
            }

            return object;
        }

        return function (arr, fn, thisArg) {
            var object = required.ToObject(arr),
                length,
                index;

            if (!required.isFunction(fn)) {
                throw new TypeError('Argument is not a function: ' + required.ToString(fn));
            }

            length = required.ToLength(object.length);
            if (length) {
                thisArg = toObjectCallFix(thisArg);
            }

            for (index = 0; index < length; index += 1) {
                if (index in object) {
                    fn.call(thisArg, object[index], index, object);
                }
            }
        };
    }());

    required.expect.Assertion.prototype.assert = function (truth, msg, error, expected) {
        var fmsg = this.flags.not ? error : msg,
            ok = this.flags.not ? !truth : truth,
            err;

        if (!ok) {
            err = new Error(fmsg.call(this));
            if (!err.stack) {
                err.stack = err.name + ': ' + err.message;
                if (err.stacktrace) {
                    err.stack += '\n' + err.stacktrace;
                }
            }

            if (err.message.indexOf('opera:config#UserPrefs|Exceptions Have Stacktrace') !== -1) {
                err.toString = function () {
                    var arr = this.message.split(new RegExp('\\r\\n|\\n')),
                        messageToString = this.name + ': ',
                        length = required.ToLength(arr.length),
                        tempArr,
                        element,
                        index;

                    if (length > 1) {
                        for (tempArr = [], index = 0; index < length; index += 1) {
                            element = arr[index];
                            if (element.indexOf('opera:config#UserPrefs|Exceptions Have Stacktrace') !== -1) {
                                tempArr.push(element);
                            }
                        }

                        messageToString += tempArr.join('\n');
                    } else {
                        messageToString += this.message;
                    }

                    return messageToString;
                };
            }

            if (required.ToLength(arguments.length) > 3) {
                err.actual = this.obj;
                err.expected = expected;
                err.showDiff = true;
            }

            throw err;
        }

        this.and = new required.expect.Assertion(this.obj);
    };

    required.expect.Assertion.prototype.assertWarn = function (truth, msg, error, expected) {
        var fmsg = this.flags.not ? error : msg,
            ok = this.flags.not ? !truth : truth,
            err;

        if (!ok) {
            err = new Error(fmsg.call(this));
            if (!err.stack) {
                err.stack = err.name + ': ' + err.message;
                if (err.stacktrace) {
                    err.stack += '\n' + err.stacktrace;
                }
            }

            if (err.message.indexOf('opera:config#UserPrefs|Exceptions Have Stacktrace') !== -1) {
                err.toString = function () {
                    var arr = this.message.split(new RegExp('\\r\\n|\\n')),
                        messageToString = this.name + ': ',
                        length = required.ToLength(arr.length),
                        tempArr,
                        element,
                        index;

                    if (length > 1) {
                        for (tempArr = [], index = 0; index < length; index += 1) {
                            element = arr[index];
                            if (element.indexOf('opera:config#UserPrefs|Exceptions Have Stacktrace') !== -1) {
                                tempArr.push(element);
                            }
                        }

                        messageToString += tempArr.join('\n');
                    } else {
                        messageToString += this.message;
                    }

                    return messageToString;
                };
            }

            if (required.ToLength(arguments.length) > 3) {
                err.actual = this.obj;
                err.expected = expected;
                err.showDiff = true;
            }

            //throw err;
            required.log(err.stack);
        }

        this.and = new required.expect.Assertion(this.obj);
    };

    required.descending = function (left, right) {
        var leftS = required.ToString(left),
            rightS = required.ToString(right),
            val;

        if (leftS === rightS) {
            val = +0;
        } else if (leftS < rightS) {
            val = 1;
        } else {
            val = -1;
        }

        return val;
    };

    module.exports = required;
}(((typeof window === 'function' || typeof window === 'object') && window) ||
    (typeof self === 'object' && self) ||
    (typeof global === 'object' && global) ||
    (typeof this === 'object' && this) || {}));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../lib/util-x":1,"../lib/util-x.min":2,"_process":8,"bignumber.js":3,"decimal.js":3,"expect.js":9}],11:[function(require,module,exports){
/*global Array, Math, RangeError, describe, it, require */

/*properties
    '0', '01', '0x1', '1', '1.', '1.0', '10.', '2', '3', '4', '5', '6', '7', '9',
    Function, a, bail, be, call, create, eql, expect, hasOwnProperty, length, not,
    ok, pow, prototype, push, returnArgs, slice, throwException, to, unshift, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        expect = required.expect,
        utilx = required.utilx;


    describe('Native array', function () {
        this.bail(false);

        var A = Array,
            overflow = Math.pow(2, 32),
            maxLength = overflow - 1,
            maxLast = maxLength - 1,
            testSubject1,
            testSubject2,
            testSubject3,
            testValue;

        it('should not throw error when creating array using new Array(...*)', function () {
            expect(function () {
                testSubject1 = new A();
                testSubject2 = new A(5);
                testSubject3 = new A(2, 3, undefined, true, 'hej', null, false, 0, 8, 9);
            }).to.not.throwException();
        });

        it('should not throw error when creating array using the literal form [...*]', function () {
            expect(function () {
                testSubject1 = [2, 3, undefined, true, 'hej', null, false, 0, , 9];
                testSubject2 = [];
                testSubject3 = [ , , ];
            }).to.not.throwException();
        });

        it('should have length of type number', function () {
            expect(typeof testSubject1.length).to.be('number');
            expect(typeof testSubject2.length).to.be('number');
            expect(typeof testSubject3.length).to.be('number');
        });

        it('should have a correct length between 0 and ' + maxLength, function () {
            var max = [];

            expect(function () {
                max[maxLast] = 'ok';
            }).to.not.throwException();

            expect(max.length).to.be(maxLength);

            max = [];
            expect(function () {
                max.length = maxLength;
            }).to.not.throwException();

            expect(max.length).to.be(maxLength);

            testValue = 10;
            expect(testSubject1.length).to.be(testValue);

            testValue = 0;
            expect(testSubject2.length).to.be(testValue);

            testValue = 2;
            expect(testSubject3.length).to.be(testValue);
        });

        it('should throw RangeError if length is set to < 0', function () {
            expect(function () {
                var max = [];

                max.length = -1;
            }).to.throwException(function (e) {
                expect(e).to.be.a(RangeError);
            });
        });

        it('should throw RangeError if length is set to >= ' + overflow, function () {
            expect(function () {
                var max = [];

                max.length = overflow;
            }).to.throwException(function (e) {
                expect(e).to.be.a(RangeError);
            });
        });

        it('should not throw RangeError if property index < 0 is set', function () {
            expect(function () {
                var max = [];

                max[-1] = 'ok';
            }).to.not.throwException();
        });

        it('should not throw RangeError if property >= ' + maxLength + ' is set', function () {
            expect(function () {
                var max = [];

                max[maxLength] = 'ok';
            }).to.not.throwException();
        });

        it('new Array(...*) should have correct elements', function () {
            testSubject1 = new A();
            expect(testSubject1).to.eql([]);
            testSubject1 = new A(5);
            testSubject2 = [];
            testSubject2.length = 5;
            expect(testSubject1).to.eql(testSubject2);
            testSubject1 = new A(2, 3, undefined, true, 'hej', null, false, 0, 8, 9);
            testSubject2 = required.create(2, 3, undefined, true, 'hej', null, false, 0, 8, 9);
            expect(testSubject2).to.eql(required.create(2, 3, undefined, true, 'hej', null, false, 0, 8, 9));
        });

        it('[...*] should have correct elements', function () {
            testSubject1 = [];
            testSubject2 = [];
            expect(testSubject1).to.eql(testSubject2);

            testSubject1 = [ , , , , , ];
            testSubject2 = [];
            testSubject2.length = 5;
            expect(testSubject1).to.eql(testSubject2);

            testSubject1 = [2, 3, undefined, true, 'hej', null, false, 0, , 9];
            testSubject2 = required.create(2, 3, undefined, true, 'hej', null, false, 0, 8, 9);
            delete testSubject2[8];
            expect(testSubject1).to.eql(testSubject2);
        });

        it('using delete on an element should not throw an error', function () {
            expect(function () {
                delete testSubject2[1];
                delete testSubject2[8];
            }).to.not.throwException();
        });

        it('elements should give correct values when index accessed', function () {
            expect(testSubject2[0]).to.be(2);
            expect(testSubject2[1]).to.be(undefined);
            expect(testSubject2[2]).to.be(undefined);
            expect(testSubject2[3]).to.be(true);
            expect(testSubject2[4]).to.be('hej');
            expect(testSubject2[5]).to.be(null);
            expect(testSubject2[6]).to.be(false);
            expect(testSubject2[7]).to.be(0);
            expect(testSubject2[8]).to.be(undefined);
            expect(testSubject2[9]).to.be(9);
        });

        it('elements should show correctly with in', function () {
            expect(0 in testSubject2).to.be.ok();
            expect(1 in testSubject2).to.not.be.ok();
            expect(2 in testSubject2).to.be.ok();
            expect(3 in testSubject2).to.be.ok();
            expect(4 in testSubject2).to.be.ok();
            expect(5 in testSubject2).to.be.ok();
            expect(6 in testSubject2).to.be.ok();
            expect(7 in testSubject2).to.be.ok();
            expect(8 in testSubject2).to.not.be.ok();
            expect(9 in testSubject2).to.be.ok();
        });

        it('elements should show correctly with hasOwnProperty', function () {
            expect(testSubject2.hasOwnProperty(0)).to.be.ok();
            expect(testSubject2.hasOwnProperty(1)).to.not.be.ok();
            expect(testSubject2.hasOwnProperty(2)).to.be.ok();
            expect(testSubject2.hasOwnProperty(3)).to.be.ok();
            expect(testSubject2.hasOwnProperty(4)).to.be.ok();
            expect(testSubject2.hasOwnProperty(5)).to.be.ok();
            expect(testSubject2.hasOwnProperty(6)).to.be.ok();
            expect(testSubject2.hasOwnProperty(7)).to.be.ok();
            expect(testSubject2.hasOwnProperty(8)).to.not.be.ok();
            expect(testSubject2.hasOwnProperty(9)).to.be.ok();
        });

        it('assigning undefined element should create the element', function () {
            testSubject1 = [];
            testSubject1[0] = undefined;
            expect(testSubject1.hasOwnProperty(0)).to.be.ok();
            expect(testSubject1).to.eql(required.create(undefined));
        });

        it('assigning undefined element should increase the length', function () {
            testSubject1 = [];
            testSubject1[0] = undefined;
            expect(testSubject1.length).to.be(1);
        });

        it('assigning null element should create the element', function () {
            testSubject1 = [];
            testSubject1[0] = null;
            expect(testSubject1.hasOwnProperty(0)).to.be.ok();
            expect(testSubject1).to.eql(required.create(null));
        });

        it('assigning null element should increase the length', function () {
            testSubject1 = [];
            testSubject1[0] = null;
            expect(testSubject1.length).to.be(1);
        });

        it('assigning a floating property string should not affect array e.g. "1.0"', function () {
            testSubject1 = [];
            testSubject1['1.0'] = true;
            expect(testSubject1.length).to.be(0);
            expect(testSubject1['1.0']).to.be(true);
        });

        it('assigning a base number property string should not affect array e.g. "0x1"', function () {
            testSubject1 = [];
            testSubject1['0x1'] = true;
            expect(testSubject1.length).to.be(0);
            expect(testSubject1['0x1']).to.be(true);
        });

        it('assigning a number property string with leading zeros should not affect array e.g. "01"', function () {
            testSubject1 = [];
            testSubject1['01'] = true;
            expect(testSubject1.length).to.be(0);
            expect(testSubject1['01']).to.be(true);
        });

        it('assigning a property string with trailing point should not affect array e.g. "1."', function () {
            testSubject1 = [];
            testSubject1['1.'] = true;
            expect(testSubject1.length).to.be(0);
            expect(testSubject1['1.']).to.be(true);
        });

        it('push undefined element should create the element', function () {
            testSubject1 = [];
            Array.prototype.push.call(testSubject1, undefined);
            expect(testSubject1.hasOwnProperty(0)).to.be.ok();
            expect(testSubject1).to.eql(required.create(undefined));
        });

        it('push undefined element should increase the length', function () {
            testSubject1 = [];
            Array.prototype.push.call(testSubject1, undefined);
            expect(testSubject1.length).to.be(1);
        });

        it('push element should return the length', function () {
            testSubject1 = [];
            expect(Array.prototype.push.call(testSubject1, 2)).to.be(1);
        });

        it('push should work with object with length', function () {
            testSubject1 = {
                length: 0
            };

            testSubject2 = {
                0: 2,
                length: 1
            };

            Array.prototype.push.call(testSubject1, 2);
            expect(testSubject1).to.eql(testSubject2);
        });

        it('push should work with object without length', function () {
            testSubject1 = {};
            testSubject2 = {
                0: 2,
                length: 1
            };

            Array.prototype.push.call(testSubject1, 2);
            expect(testSubject1).to.eql(testSubject2);
        });

        it('push should work with arguments', function () {
            testSubject1 = utilx.Function.returnArgs();

            testSubject2 = [2];
            Array.prototype.push.call(testSubject1, 2);
            expect(testSubject1.hasOwnProperty(0)).to.be.ok();
            expect(Array.prototype.slice.call(testSubject1)).to.eql(testSubject2);
        });

        it('unshift undefined element should create the element', function () {
            testSubject1 = [];
            Array.prototype.unshift.call(testSubject1, undefined);
            expect(testSubject1.hasOwnProperty(0)).to.be.ok();
            expect(testSubject1).to.eql(required.create(undefined));
        });

        it('unshift undefined element should increase the length', function () {
            testSubject1 = [];
            Array.prototype.unshift.call(testSubject1, undefined);
            expect(testSubject1.length).to.be(1);
        });

        it('unshift element should return the length', function () {
            testSubject1 = [];
            expect(Array.prototype.unshift.call(testSubject1, 2)).to.be(1);
        });

        it('unshift should work with arguments', function () {
            testSubject1 = utilx.Function.returnArgs();

            testSubject2 = [2];
            Array.prototype.unshift.call(testSubject1, 2);
            expect(testSubject1.hasOwnProperty(0)).to.be.ok();
            expect(Array.prototype.slice.call(testSubject1)).to.eql(testSubject2);
        });

        it('unshift should work with object with length', function () {
            testSubject1 = {
                length: 0
            };

            testSubject2 = {
                0: 2,
                length: 1
            };

            Array.prototype.push.call(testSubject1, 2);
            expect(testSubject1).to.eql(testSubject2);
        });

        it('unshift should work with object without length', function () {
            testSubject1 = {};
            testSubject2 = {};
            Array.prototype.push.call(testSubject1, 2);
            expect(testSubject2).to.eql(testSubject2);
        });

        it('slice should work on array', function () {
            testSubject1 = required.create(2, 3, undefined, true, 'hej', null, false, 0, 8, 9);
            delete testSubject1[8];
            testSubject2 = Array.prototype.slice.call(testSubject1);
            expect(testSubject2).to.eql(testSubject1);
        });

        it('slice should work on object with length', function () {
            testSubject1 = {
                0: 2,
                1: 3,
                2: undefined,
                3: true,
                4: 'hej',
                5: null,
                6: false,
                7: 0,
                9: 9,
                length: 10
            };

            testSubject2 = required.create(2, 3, undefined, true, 'hej', null, false, 0, 8, 9);
            delete testSubject2[8];
            testSubject3 = Array.prototype.slice.call(testSubject1);
            expect(testSubject3).to.eql(testSubject2);
        });

        it('slice should work on object without length', function () {
            testSubject1 = {
                0: 2,
                1: 3,
                2: undefined,
                3: true,
                4: 'hej',
                5: null,
                6: false,
                7: 0,
                9: 9
            };

            testSubject2 = [];
            expect(function () {
                testSubject3 = Array.prototype.slice.call(testSubject1);
            }).to.not.throwException();

            expect(testSubject3).to.eql(testSubject2);
        });

        it('slice should work on arguments', function () {
            testSubject1 = utilx.Function.returnArgs(2, 3, undefined, true, 'hej', null, false, 0, 8, 9);
            testSubject2 = required.create(2, 3, undefined, true, 'hej', null, false, 0, 8, 9);
            testSubject3 = Array.prototype.slice.call(testSubject1);
            expect(testSubject3).to.eql(testSubject2);
        });
    });
}());

},{"../scripts/":10}],12:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        //utilx = required.utilx,
        expect = required.expect,
        dontRun = true;

    if (dontRun) {
        return;
    }

    describe('Native string', function () {
        var test,
            msg,
            temp = expect.Assertion.prototype.assert;

        it('SET TO WARNING MODE. THESE ARE FIXABLE', function () {
            expect.Assertion.prototype.assert = expect.Assertion.prototype.assertWarn;
        });

        it('characters should be accessible by index', function () {
            test = 'hej';
            expect(test[0]).to.be('h');
        });

        it('should throw if no arguments', function () {
            expect(function () {
                String.prototype.split.call();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                String.prototype.split.call(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                String.prototype.split.call(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw on basic tests', function () {
            expect(String.prototype.split.call('abcdef', '')).to.eql(['a', 'b', 'c', 'd', 'e', 'f']);
            expect(String.prototype.split.call('abcdefabcdefabcdef', 'c')).to.eql(['ab', 'defab', 'defab', 'def']);
            expect(String.prototype.split.call('abcdefabcdefabcdef', new RegExp('c')))
                                                    .to.eql(['ab', 'defab', 'defab', 'def']);
        });

        test = 'ab';

        it('If "separator" is undefined must return Array with one String - "this" string', function () {
            expect(String.prototype.split.call(test)).to.eql([test]);
            expect(String.prototype.split.call(test, undefined)).to.eql([test]);
        });

        it('If "separator" is undefined and "limit" set to 0 must return Array[]', function () {
            expect(String.prototype.split.call(test, undefined, 0)).to.eql([]);
        });

        it('(\'\') results in [\'\']', function () {
            var txt = '';

            expect(String.prototype.split.call(txt)).to.eql(['']);
        });

        it('(\'\', /./) results in [\'\']', function () {
            var txt = '',
                rx = new RegExp('.');

            expect(String.prototype.split.call(txt, rx)).to.eql(['']);
        });

        it('(\'\', /.?/) results in []', function () {
            var txt = '',
                rx = new RegExp('.?');

            expect(String.prototype.split.call(txt, rx)).to.eql([]);
        });

        it('(\'\', /.??/) results in []', function () {
            var txt = '',
                rx = new RegExp('.??');

            expect(String.prototype.split.call(txt, rx)).to.eql([]);
        });

        it('(\'ab\', /a*/) results in [\'\', \'b\']', function () {
            var txt = 'ab';

            expect(String.prototype.split.call(txt, /a*/)).to.eql(['', 'b']);
        });

        it('(\'ab\', /a*?/) results in [\'a\', \'b\']', function () {
            var txt = 'ab';

            expect(String.prototype.split.call(txt, /a*?/)).to.eql(['a', 'b']);
        });

        it('(\'ab\', /(?:ab)/) results in [\'\', \'\']', function () {
            var txt = 'ab';

            expect(String.prototype.split.call(txt, /(?:ab)/)).to.eql(['', '']);
        });

        it('(\'ab\', /(?:ab)*/) results in [\'\', \'\']', function () {
            var txt = 'ab';

            expect(String.prototype.split.call(txt, /(?:ab)*/)).to.eql(['', '']);
        });

        it('(\'ab\', /(?:ab)*?/) results in [\'a\', \'b\']', function () {
            var txt = 'ab';

            expect(String.prototype.split.call(txt, /(?:ab)*?/)).to.eql(['a', 'b']);
        });

        it('(\'test\', \'\') results in [\'t\', \'e\', \'s\', \'t\']', function () {
            var txt = 'test';

            expect(String.prototype.split.call(txt, '')).to.eql(['t', 'e', 's', 't']);
        });

        it('(\'test\', ) results in [\'test\']', function () {
            var txt = 'test';

            expect(String.prototype.split.call(txt)).to.eql(['test']);
        });

        it('(\'111\', 1) results in [\'\', \'\', \'\', \'\']', function () {
            var txt = '111';

            expect(String.prototype.split.call(txt, 1)).to.eql(['', '', '', '']);
        });

        it('(\'test\', /(?:)/, 2) results in [\'t\', \'e\']', function () {
            var txt = 'test';

            expect(String.prototype.split.call(txt, /(?:)/, 2)).to.eql(['t', 'e']);
        });

        it('(\'test\', /(?:)/, -1) results in []', function () {
            var txt = 'test';

            expect(String.prototype.split.call(txt, /(?:)/, -1)).to.eql([]);
        });

        it('(\'test\', /(?:)/, undefined) results in [\'t\', \'e\', \'s\', \'t\']', function () {
            var txt = 'test';

            expect(String.prototype.split.call(txt, /(?:)/, undefined)).to.eql(['t', 'e', 's', 't']);
        });

        it('(\'test\', /(?:)/, null) results in []', function () {
            var txt = 'test';

            expect(String.prototype.split.call(txt, /(?:)/, null)).to.eql([]);
        });

        it('(\'test\', /(?:)/, NaN) results in []', function () {
            var txt = 'test';

            expect(String.prototype.split.call(txt, /(?:)/, NaN)).to.eql([]);
        });

        it('(\'test\', /(?:)/, true) results in [\'t\']', function () {
            var txt = 'test';

            expect(String.prototype.split.call(txt, /(?:)/, true)).to.eql(['t']);
        });

        it('(\'test\', /(?:)/, \'2\') results in [\'t\', \'e\']', function () {
            var txt = 'test';

            expect(String.prototype.split.call(txt, /(?:)/, '2')).to.eql(['t', 'e']);
        });

        it('(\'test\', /(?:)/, \'two\') results in []', function () {
            var txt = 'test';

            expect(String.prototype.split.call(txt, /(?:)/, 'two')).to.eql([]);
        });

        it('(\'a\', /-/) results in [\'a\']', function () {
            var txt = 'a';

            expect(String.prototype.split.call(txt, /-/)).to.eql(['a']);
        });

        it('(\'a\', /-?/) results in [\'a\']', function () {
            var txt = 'a';

            expect(String.prototype.split.call(txt, /-?/)).to.eql(['a']);
        });

        it('(\'a\', /-??/) results in [\'a\']', function () {
            var txt = 'a';

            expect(String.prototype.split.call(txt, /-??/)).to.eql(['a']);
        });

        it('(\'a\', /a/) results in [\'\', \'\']', function () {
            var txt = 'a';

            expect(String.prototype.split.call(txt, /a/)).to.eql(['', '']);
        });

        it('(\'a\', /a?/) results in [\'\', \'\']', function () {
            var txt = 'a';

            expect(String.prototype.split.call(txt, /a?/)).to.eql(['', '']);
        });

        it('(\'a\', /a??/) results in [\'a\']', function () {
            var txt = 'a';

            expect(String.prototype.split.call(txt, /a??/)).to.eql(['a']);
        });

        it('(\'ab\', /-/) results in [\'ab\']', function () {
            var txt = 'ab';

            expect(String.prototype.split.call(txt, /-/)).to.eql(['ab']);
        });

        it('(\'ab\', /-?/) results in [\'a\', \'b\']', function () {
            var txt = 'ab';

            expect(String.prototype.split.call(txt, /-?/)).to.eql(['a', 'b']);
        });

        it('(\'ab\', /-??/) results in [\'a\', \'b\']', function () {
            var txt = 'ab';

            expect(String.prototype.split.call(txt, /-??/)).to.eql(['a', 'b']);
        });

        it('(\'a-b\', /-/) results in [\'a\', \'b\']', function () {
            var txt = 'a-b';

            expect(String.prototype.split.call(txt, /-/)).to.eql(['a', 'b']);
        });

        it('(\'a-b\', /-?/) results in [\'a\', \'b\']', function () {
            var txt = 'a-b';

            expect(String.prototype.split.call(txt, /-?/)).to.eql(['a', 'b']);
        });

        it('(\'a-b\', /-??/) results in [\'a\', \'-\', \'b\']', function () {
            var txt = 'a-b';

            expect(String.prototype.split.call(txt, /-??/)).to.eql(['a', '-', 'b']);
        });

        it('(\'a--b\', /-/) results in [\'a\', \'\', \'b\']', function () {
            var txt = 'a--b';

            expect(String.prototype.split.call(txt, /-/)).to.eql(['a', '', 'b']);
        });

        it('(\'a--b\', /-?/) results in [\'a\', \'\', \'b\']', function () {
            var txt = 'a--b';

            expect(String.prototype.split.call(txt, /-?/)).to.eql(['a', '', 'b']);
        });

        it('(\'a--b\', /-??/) results in [\'a\', \'-\', \'-\', \'b\']', function () {
            var txt = 'a--b';

            expect(String.prototype.split.call(txt, /-??/)).to.eql(['a', '-', '-', 'b']);
        });

        it('(\'\', /()()/) results in []', function () {
            var txt = '';

            expect(String.prototype.split.call(txt, /()()/)).to.eql([]);
        });

        it('(\'.\', /()()/) results in [\'.\']', function () {
            var txt = '.';

            expect(String.prototype.split.call(txt, /()()/)).to.eql(['.']);
        });

        it('(\'.\', /(.?)(.?)/) results in [\'\', \'.\', \'\', \'\']', function () {
            var txt = '.',
                rx = new RegExp('(.?)(.?)');

            expect(String.prototype.split.call(txt, rx)).to.eql(['', '.', '', '']);
        });

        it('(\'.\', /(.??)(.??)/) results in [\'.\']', function () {
            var txt = '.',
                rx = new RegExp('(.??)(.??)');

            expect(String.prototype.split.call(txt, rx)).to.eql(['.']);
        });

        it('(\'.\', /(.)?(.)?/) results in [\'\', \'.\', undefined, \'\']', function () {
            var txt = '.',
                rx = new RegExp('(.)?(.)?');

            expect(String.prototype.split.call(txt, rx)).to.eql(required.create('', '.', undefined, ''));
        });

        msg = '(\'A<B>bold</B>and<CODE>coded</CODE>\', /<(\\/)?([^<>]+)>/) results in [\'A\', undefined, ' +
            '\'B\', \'bold\', \'/\', \'B\', \'and\', undefined, \'CODE\', \'coded\', \'/\', \'CODE\', \'\']';
        it(msg, function () {
            var txt = 'A<B>bold</B>and<CODE>coded</CODE>',
                rx = new RegExp('<(\\/)?([^<>]+)>');

            expect(String.prototype.split.call(txt, rx))
                .to.eql(required.create(
                    'A',
                    undefined,
                    'B',
                    'bold',
                    '/',
                    'B',
                    'and',
                    undefined,
                    'CODE',
                    'coded',
                    '/',
                    'CODE',
                    ''
                ));
        });

        it('(\'test\', /(s)*/) results in [\'t\', undefined, \'e\', \'s\', \'t\']', function () {
            var txt = 'tesst';

            expect(String.prototype.split.call(txt, /(s)*/)).to.eql(required.create(
                't',
                undefined,
                'e',
                's',
                't'
            ));
        });

        msg = '(\'test\', /(s)*?/) results in [\'t\', undefined, \'e\',' +
            'undefined, \'s\', undefined, \'s\', undefined, \'t\']';
        it(msg, function () {
            var txt = 'tesst';

            expect(String.prototype.split.call(txt, /(s)*?/))
                .to.eql(required.create(
                    't',
                    undefined,
                    'e',
                    undefined,
                    's',
                    undefined,
                    's',
                    undefined,
                    't'
                ));
        });

        it('(\'test\', /(s*)/) results in [\'t\', \'\', \'e\', \'ss\', \'t\']', function () {
            var txt = 'tesst';

            expect(String.prototype.split.call(txt, /(s*)/)).to.eql(['t', '', 'e', 'ss', 't']);
        });


        msg = '(\'test\', /(s*?)/) results in [\'t\', \'\', \'e\', \'\', \'s\', \'\', \'s\', \'\', \'t\']';
        it(msg, function () {
            var txt = 'tesst';

            expect(String.prototype.split.call(txt, /(s*?)/)).to.eql(['t', '', 'e', '', 's', '', 's', '', 't']);
        });

        it('(\'test\', /(?:s)*/) results in [\'t\', \'e\', \'t\']', function () {
            var txt = 'tesst';

            expect(String.prototype.split.call(txt, /(?:s)*/)).to.eql(['t', 'e', 't']);
        });

        it('(\'test\', /(?=s+)/) results in [\'te\', \'s\', \'st\']', function () {
            var txt = 'tesst';

            expect(String.prototype.split.call(txt, /(?=s+)/)).to.eql(['te', 's', 'st']);
        });

        it('(\'test\', \'t\') results in [\'\', \'es\', \'\']', function () {
            var txt = 'test';

            expect(String.prototype.split.call(txt, 't')).to.eql(['', 'es', '']);
        });

        it('(\'test\', \'es\') results in [\'t\', \'t\']', function () {
            var txt = 'test';

            expect(String.prototype.split.call(txt, 'es')).to.eql(['t', 't']);
        });

        it('(\'test\', /t/) results in [\'\', \'es\', \'\']', function () {
            var txt = 'test';

            expect(String.prototype.split.call(txt, /t/)).to.eql(['', 'es', '']);
        });

        it('(\'test\', /es/) results in [\'t\', \'t\']', function () {
            var txt = 'test';

            expect(String.prototype.split.call(txt, /es/)).to.eql(['t', 't']);
        });

        it('(\'test\', /(t)/) results in [\'\', \'t\', \'es\', \'t\', \'\']', function () {
            var txt = 'test';

            expect(String.prototype.split.call(txt, /(t)/)).to.eql(['', 't', 'es', 't', '']);
        });

        it('(\'test\', /(es)/) results in [\'t\', \'es\', \'t\']', function () {
            var txt = 'test';

            expect(String.prototype.split.call(txt, /(es)/)).to.eql(['t', 'es', 't']);
        });

        it('(\'test\', /(t)(e)(s)(t)/) results in [\'\', \'t\', \'e\', \'s\', \'t\', \'\']', function () {
            var txt = 'test';

            expect(String.prototype.split.call(txt, /(t)(e)(s)(t)/)).to.eql(['', 't', 'e', 's', 't', '']);
        });

        it('(\'.\', /(((.((.??)))))/) results in [\'\', \'.\', \'.\', \'.\', \'\', \'\', \'\']', function () {
            var txt = '.',
                rx = new RegExp('(((.((.??)))))');

            expect(String.prototype.split.call(txt, rx)).to.eql(['', '.', '.', '.', '', '', '']);
        });

        it('(\'.\', /(((((.??)))))/) results in [\'.\']', function () {
            var txt = '.',
                rx = new RegExp('(((((.??)))))');

            expect(String.prototype.split.call(txt, rx)).to.eql(['.']);
        });

        it('(\'a b c d\', / /, -(Math.pow(2, 32) - 1)) results in []', function () {
            var txt = 'a b c d';

            expect(String.prototype.split.call(txt, / /, -(Math.pow(2, 32) - 1))).to.eql([]);
        });

        it('(\'a b c d\', / /, Math.pow(2, 32) + 1) results in []', function () {
            var txt = 'a b c d';

            expect(String.prototype.split.call(txt, / /, Math.pow(2, 32) + 1)).to.eql(['a', 'b', 'c', 'd']);
        });

        it('(\'a b c d\', / /, Infinity) results in []', function () {
            var txt = 'a b c d';

            expect(String.prototype.split.call(txt, / /, Infinity)).to.eql(['a', 'b', 'c', 'd']);
        });

        it('RESET TO ERROR MODE', function () {
            expect.Assertion.prototype.assert = temp;
        });
    });
}());

},{"../scripts/":10}],13:[function(require,module,exports){
/*global describe, it, require */

/*property
    Array, Object, a, be, eql, expect, returnArgs, chunk, keys, length, not,
    throwException, to, utilx, '0', '1', '2', '3', '4', '5', '6', '7'
*/


(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.chunk', function () {
        var testArr = [4, 9, -1, 8, 3, 20, -1, 7];

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.chunk();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.chunk(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.chunk(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an TypeError if argument is primitive', function () {
            var grouped;

            expect(function () {
                grouped = utilx.Array.chunk(42);
            }).to.not.throwException();

            expect(grouped.length).to.be(0);

            expect(function () {
                grouped = utilx.Array.chunk(true);
            }).to.not.throwException();

            expect(grouped.length).to.be(0);

            expect(function () {
                grouped = utilx.Array.chunk('abc');
            }).to.not.throwException();

            expect(grouped.length).to.be(0);
        });

        it('should return groups', function () {
            var grouped;

            expect(function () {
                grouped = utilx.Array.chunk(testArr);
            }).to.not.throwException();

            expect(grouped).to.eql([]);

            expect(function () {
                grouped = utilx.Array.chunk(testArr, undefined);
            }).to.not.throwException();

            expect(grouped).to.eql([]);

            expect(function () {
                grouped = utilx.Array.chunk(testArr, null);
            }).to.not.throwException();

            expect(grouped).to.eql([]);

            expect(function () {
                grouped = utilx.Array.chunk(testArr, 0);
            }).to.not.throwException();

            expect(grouped).to.eql([]);

            expect(function () {
                grouped = utilx.Array.chunk(testArr, 10);
            }).to.not.throwException();

            expect(grouped).to.eql([testArr]);

            expect(function () {
                grouped = utilx.Array.chunk(testArr, true);
            }).to.not.throwException();

            expect(grouped).to.eql([[4], [9], [-1], [8], [3], [20], [-1], [7]]);

            expect(function () {
                grouped = utilx.Array.chunk(testArr, 'abc');
            }).to.not.throwException();

            expect(grouped).to.eql([]);
        });

        it('should work with strings', function () {
            var grouped;

            expect(function () {
                grouped = utilx.Array.chunk('abcdefg', 3);
            }).to.not.throwException();

            expect(grouped).to.eql([['a', 'b', 'c'], ['d', 'e', 'f'], ['g']]);
        });

        it('should work with arguments', function () {
            var grouped;

            expect(function () {
                grouped = utilx.Array.chunk(required.returnArgs(4, 9, -1, 8, 3, 20, -1, 7), 1);
            }).to.not.throwException();

            expect(grouped).to.eql([[4], [9], [-1], [8], [3], [20], [-1], [7]]);
        });

        it('should work with objects', function () {
            var grouped;

            expect(function () {
                grouped = utilx.Array.chunk({ 0: 4, 1: 9, 2: -1, 3: 8, 4: 3, 5: 20, 6: -1, 7: 7 }, 1);
            }).to.not.throwException();

            expect(grouped).to.eql([]);

            expect(function () {
                grouped = utilx.Array.chunk({ 0: 4, 1: 9, 2: -1, 3: 8, 4: 3, 5: 20, 6: -1, 7: 7, length: 8 }, 1);
            }).to.not.throwException();

            expect(grouped).to.eql([[4], [9], [-1], [8], [3], [20], [-1], [7]]);
        });
    });
}());

},{"../scripts/":10}],14:[function(require,module,exports){
/*global TypeError, describe, it, require */

/*properties
    '0', '1', '10', '11', '2', '3', '4', '5', '6', '7', '8', '9', Array, a, be,
    call, create, eql, expect, hasOwnProperty, length, ok, prototype, concat,
    returnArgs, slice, throwException, to, utilx, not
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.concat', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.concat();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.concat(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.concat(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('array', function () {
            var arr1 = required.create(
                    undefined,
                    null,
                    -1,
                    0,
                    1,
                    false
                ),
                arr2 = required.create(
                    true,
                    undefined,
                    '',
                    'abc',
                    null,
                    undefined
                ),
                expected = required.create(
                    undefined,
                    null,
                    -1,
                    0,
                    1,
                    false,
                    true,
                    undefined,
                    '',
                    'abc',
                    null,
                    undefined
                ),
                resArr,
                index;

            expect(function () {
                resArr = utilx.Array.concat(arr1, arr2);
            }).to.not.throwException();

            expect(resArr.length).to.be(expected.length);
            for (index = 0; index < resArr.length; index += 1) {
                expect(Object.prototype.hasOwnProperty.call(resArr, index)).to.be.ok();
                expect(resArr[index]).to.be(expected[index]);
            }
        });
    });
}());

},{"../scripts/":10}],15:[function(require,module,exports){
/*global TypeError, describe, it, require */

/*properties
    Array, a, be, contains, expect, not, ok, returnArgs, throwException, to,
    utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.contains', function () {
        var arr = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ],
            arr2 = [0, 1, 2, 3, 4, 5];

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.contains();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.contains(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.contains(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should find the string in the array', function () {
            expect(utilx.Array.contains(arr, 'toString')).to.be.ok();
            expect(utilx.Array.contains(arr, 'toLocaleString')).to.be.ok();
            expect(utilx.Array.contains(arr, 'valueOf')).to.be.ok();
            expect(utilx.Array.contains(arr, 'hasOwnProperty')).to.be.ok();
            expect(utilx.Array.contains(arr, 'isPrototypeOf')).to.be.ok();
            expect(utilx.Array.contains(arr, 'propertyIsEnumerable')).to.be.ok();
            expect(utilx.Array.contains(arr, 'constructor')).to.be.ok();
        });

        it('should not find the string in the array', function () {
            expect(utilx.Array.contains(arr, 'foo')).to.not.be.ok();
            expect(utilx.Array.contains(arr, 'bar')).to.not.be.ok();
            expect(utilx.Array.contains(arr, 'fuz')).to.not.be.ok();
            expect(utilx.Array.contains(arr, 'push')).to.not.be.ok();
            expect(utilx.Array.contains(arr, 'pop')).to.not.be.ok();
        });

        it('should find the number in the array', function () {
            expect(utilx.Array.contains(arr2, 0)).to.be.ok();
            expect(utilx.Array.contains(arr2, 1)).to.be.ok();
            expect(utilx.Array.contains(arr2, 2)).to.be.ok();
            expect(utilx.Array.contains(arr2, 3)).to.be.ok();
            expect(utilx.Array.contains(arr2, 4)).to.be.ok();
            expect(utilx.Array.contains(arr2, 5)).to.be.ok();
        });

        it('should not find the number in the array', function () {
            expect(utilx.Array.contains(arr2, 6)).to.not.be.ok();
            expect(utilx.Array.contains(arr2, 7)).to.not.be.ok();
            expect(utilx.Array.contains(arr2, 8)).to.not.be.ok();
            expect(utilx.Array.contains(arr2, 9)).to.not.be.ok();
            expect(utilx.Array.contains(arr2, 10)).to.not.be.ok();
        });

        it('should iterate arguments object', function () {
            var args = required.returnArgs(1, undefined, null, 2, 3);

            expect(utilx.Array.contains(args, 1)).to.be.ok();
            expect(utilx.Array.contains(args, undefined)).to.be.ok();
            expect(utilx.Array.contains(args, null)).to.be.ok();
            expect(utilx.Array.contains(args, 2)).to.be.ok();
            expect(utilx.Array.contains(args, 3)).to.be.ok();
        });
    });
}());

},{"../scripts/":10}],16:[function(require,module,exports){
/*global TypeError, beforeEach, describe, it, require */

/*properties
    Array, Object, a, array2Object, be, copyWithin, eql, expect, isArguments,
    isPlainObject, ok, returnArgs, slice, throwException, to, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.copyWithin', function () {
        var testSubject;

        beforeEach(function () {
            testSubject = [1, 2, 3, 4, 5];
        });

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.copyWithin();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.copyWithin(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.copyWithin(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('works with 2 args', function () {
            expect(utilx.Array.copyWithin(required.slice(testSubject), 0, 3)).to.eql([4, 5, 3, 4, 5]);
            expect(utilx.Array.copyWithin(required.slice(testSubject), 1, 3)).to.eql([1, 4, 5, 4, 5]);
            expect(utilx.Array.copyWithin(required.slice(testSubject), 1, 2)).to.eql([1, 3, 4, 5, 5]);
            expect(utilx.Array.copyWithin(required.slice(testSubject), 2, 2)).to.eql([1, 2, 3, 4, 5]);
        });

        it('works with 3 args', function () {
            expect(utilx.Array.copyWithin(required.slice(testSubject), 0, 3, 4)).to.eql([4, 2, 3, 4, 5]);
            expect(utilx.Array.copyWithin(required.slice(testSubject), 1, 3, 4)).to.eql([1, 4, 3, 4, 5]);
            expect(utilx.Array.copyWithin(required.slice(testSubject), 1, 2, 4)).to.eql([1, 3, 4, 4, 5]);
        });

        it('works with negative args', function () {
            expect(utilx.Array.copyWithin(required.slice(testSubject), 0, -2)).to.eql([4, 5, 3, 4, 5]);
            expect(utilx.Array.copyWithin(required.slice(testSubject), 0, -2, -1)).to.eql([4, 2, 3, 4, 5]);
            expect(utilx.Array.copyWithin(required.slice(testSubject), -4, -3, -2)).to.eql([1, 3, 3, 4, 5]);
            expect(utilx.Array.copyWithin(required.slice(testSubject), -4, -3, -1)).to.eql([1, 3, 4, 4, 5]);
            expect(utilx.Array.copyWithin(required.slice(testSubject), -4, -3)).to.eql([1, 3, 4, 5, 5]);
        });

        it('works with arraylike objects', function () {
            var args = required.array2Object(testSubject),
                exp1 = [1, 2, 3, 1, 2],
                exp2 = required.array2Object(exp1);

            expect(utilx.Object.isPlainObject(args)).to.be.ok();
            expect(required.slice(args)).to.eql(testSubject);
            utilx.Array.copyWithin(args, -2, 0);
            expect(required.slice(args)).to.eql(exp1);
            expect(args).to.eql(exp2);
            expect(utilx.Object.isPlainObject(args)).to.be.ok();
        });

        it('works with arguments object', function () {
            var args = required.returnArgs(1, 2, 3, 4, 5),
                exp1 = [1, 2, 3, 1, 2],
                exp2 = required.array2Object(exp1);

            expect(required.isArguments(args)).to.be.ok();
            expect(required.slice(args)).to.eql(testSubject);
            utilx.Array.copyWithin(args, -2, 0);
            expect(required.slice(args)).to.eql(exp1);
            expect(required.array2Object(args)).to.eql(exp2);
            expect(required.isArguments(args)).to.be.ok();
        });
    });
}());

},{"../scripts/":10}],17:[function(require,module,exports){
/*global Date, Error, Math, RegExp, TypeError, beforeEach, describe, it, require */

/*properties
    '0', '2', '3', Array, a, be, call, create, eql, every, expect,
    isStrictMode, length, not, ok, pow, prototype, push, throwException, to,
    toString, utilx, valueOf, Object, isNaN, ToString, ToClass, charAt, global
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.every', function () {
        var lastIndex = Math.pow(2, 32) - 1,
            everyArray = required.create(0, 1, 2, 'a', 'b', 'c', [8, 9, 10], {}, true, false, undefined, null,
                                  new Date(), new Error('x'), new RegExp('t'), Infinity, -Infinity),
            testSubject,
            testIndex,
            expected,
            numberOfRuns;

        beforeEach(function () {
            testSubject = required.create(2, 3, undefined, true, 'hej', null, false, 0, 8, 9);
            delete testSubject[1];
            delete testSubject[8];
            numberOfRuns = 0;
            expected = {
                0: 2,
                2: undefined,
                3: true
            };
        });

        everyArray.length = 25;
        everyArray[24] = NaN;
        everyArray[25] = 'end';

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.every();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.every(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.every(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if function argument is not a function', function () {
            expect(function () {
                utilx.Array.every(everyArray);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.every(everyArray, undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.every(everyArray, null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            var result = utilx.Array.every(everyArray, function (element, index, array) {
                expect(array).to.be(everyArray);
                expect(typeof index === 'number').to.be.ok();
                expect(index >= 0).to.be.ok();
                expect(index <= lastIndex).to.be.ok();
                if (required.isNaN(element)) {
                    expect(required.isNaN(everyArray[index])).to.be(true);
                } else {
                    expect(element).to.be(everyArray[index]);
                }

                testIndex = index;
                if (element === 'end') {
                    return false;
                }

                return true;
            });

            expect(result).to.be(false);

            expect(testIndex).to.be(everyArray.length - 1);
        });

        it('should pass the right parameters', function () {
            var array = ['1'];

            utilx.Array.every(array, function (item, index, list) {
                expect(item).to.be('1');
                expect(index).to.be(0);
                expect(list).to.be(array);
            });
        });

        it('should not affect elements added to the array after it has begun', function () {
            var arr = [1, 2, 3],
                i = 0;

            utilx.Array.every(arr, function (a) {
                i += 1;
                arr.push(a + 3);

                return i <= 3;
            });

            expect(arr).to.eql([1, 2, 3, 4, 5, 6]);
            expect(i).to.be(3);
        });

        it('should set the right context when given none', function () {
            var context;

            utilx.Array.every([1], function () {
                context = this;
            });

            expect(context).to.be((function () {
                return function () {
                    return this;
                };
            }()).call());
        });

        it('should return true if it runs to the end', function () {
            var actual = utilx.Array.every(testSubject, function () {
                return true;
            });

            expect(actual).to.be.ok();
        });

        it('should return false if it is stopped somewhere', function () {
            var actual = utilx.Array.every(testSubject, function () {
                return false;
            });

            expect(actual).to.not.be.ok();
        });

        it('should return true if there are no elements', function () {
            var actual = utilx.Array.every([], function () {
                return true;
            });

            expect(actual).to.be.ok();
        });

        it('should stop after 3 elements', function () {
            var actual = {};

            utilx.Array.every(testSubject, function (obj, index) {
                actual[index] = obj;
                numberOfRuns += 1;
                if (numberOfRuns === 3) {
                    return false;
                }

                return true;
            });

            expect(actual).to.eql(expected);
        });

        it('should stop after 3 elements using a context', function () {
            var actual = {},
                o = {
                    a: actual
                };

            utilx.Array.every(testSubject, function (obj, index) {
                this.a[index] = obj;
                numberOfRuns += 1;
                if (numberOfRuns === 3) {
                    return false;
                }

                return true;
            }, o);

            expect(actual).to.eql(expected);
        });

        it('should stop after 3 elements in an array-like object', function () {
            var ts = required.Object(testSubject),
                actual = {};

            utilx.Array.every(ts, function (obj, index) {
                actual[index] = obj;
                numberOfRuns += 1;
                if (numberOfRuns === 3) {
                    return false;
                }

                return true;
            });

            expect(actual).to.eql(expected);
        });

        it('should stop after 3 elements in an array-like object using a context', function () {
            var ts = required.Object(testSubject),
                actual = {},
                o = {
                    a: actual
                };

            utilx.Array.every(ts, function (obj, index) {
                this.a[index] = obj;
                numberOfRuns += 1;
                if (numberOfRuns === 3) {
                    return false;
                }

                return true;
            }, o);

            expect(actual).to.eql(expected);
        });

        it('should have a boxed object as list argument of callback', function () {
            var actual;

            utilx.Array.every('foo', function (item, index, list) {
                /*jslint unparam: true */
                /*jshint unused: false */
                actual = list;
            });

            expect(typeof actual).to.be('object');
            expect(required.ToClass(actual)).to.be('[object String]');
            expect(required.ToString(actual)).to.be('foo');
            expect(actual.charAt(0)).to.be('f');
        });

        if (required.isStrictMode()) {
            it('does not autobox the content in strict mode', function () {
                var actual;

                utilx.Array.every([1], function () {
                    actual = this;
                }, 'x');

                expect(typeof actual).to.be('string');

                utilx.Array.every([1], function () {
                    actual = this;
                });

                expect(actual).to.be(undefined);

                utilx.Array.every([1], function () {
                    actual = this;
                }, undefined);

                expect(actual).to.be(undefined);

                utilx.Array.every([1], function () {
                    actual = this;
                }, null);

                expect(actual).to.be(null);
            });
        }
    });
}());

/*jslint sloppy: true */
(function () {
    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.every', function () {
        it('does autobox the content in non-strict mode', function () {
            var actual;

            utilx.Array.every([1], function () {
                actual = this;
            }, 'x');

            expect(typeof actual).to.be('object');

            utilx.Array.every([1], function () {
                actual = this;
            });

            expect(actual).to.be(required.global);

            utilx.Array.every([1], function () {
                actual = this;
            }, undefined);

            expect(actual).to.be(required.global);

            utilx.Array.every([1], function () {
                actual = this;
            }, null);

            expect(actual).to.be(required.global);
        });
    });
}());

},{"../scripts/":10}],18:[function(require,module,exports){
/*global TypeError, beforeEach, describe, it, require */

/*properties
    Array, a, length, be, create, eql, expect, fill, slice, throwException, to,
    utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.fill', function () {
        var testSubject;

        beforeEach(function () {
            testSubject = [1, 2, 3, 4, 5, 6];
        });

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.fill();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.fill(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.fill(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('works without a value', function () {
            var original = testSubject,
                filled = required.create(
                    undefined,
                    undefined,
                    undefined,
                    undefined,
                    undefined,
                    undefined
                );

            expect(utilx.Array.fill(original)).to.eql(filled);
        });

        it('works with just a value', function () {
            var original = testSubject,
                filled = [-1, -1, -1, -1, -1, -1];

            expect(utilx.Array.fill(original, -1)).to.eql(filled);
        });

        it('modifies original array', function () {
            var original = testSubject,
                filled = [-1, -1, -1, -1, -1, -1];

            utilx.Array.fill(original, -1);
            expect(original).to.eql(filled);
        });

        it('accepts a positive start index', function () {
            var original = testSubject,
                filled = [1, -1, -1, -1, -1, -1];

            expect(utilx.Array.fill(original, -1, 1)).to.eql(filled);
        });

        it('accepts a positive start and end index', function () {
            var original = testSubject,
                filled = [1, -1, -1, -1, 5, 6];

            expect(utilx.Array.fill(original, -1, 1, 4)).to.eql(filled);
        });

        it('accepts a positive start and negative end index', function () {
            var original = testSubject,
                filled = [1, -1, -1, -1, -1, 6];

            expect(utilx.Array.fill(original, -1, 1, -1)).to.eql(filled);
        });

        it('accepts a positive start and large end index', function () {
            var original = testSubject,
                filled = [1, -1, -1, -1, -1, -1];

            expect(utilx.Array.fill(original, -1, 1, 42)).to.eql(filled);
        });

        it('accepts a negative start and large positive end index', function () {
            var original = testSubject,
                filled = [1, 2, 3, -1, -1, -1];

            expect(utilx.Array.fill(original, -1, -3, 42)).to.eql(filled);
        });

        it('accepts a negative start and small positive end index', function () {
            var original = testSubject,
                filled = [1, 2, 3, -1, -1, 6];

            expect(utilx.Array.fill(original, -1, -3, 5)).to.eql(filled);
        });

        it('accepts a negative start smaller than negative end index', function () {
            var original = testSubject,
                filled = [1, 2, 3, -1, -1, 6];

            expect(utilx.Array.fill(original, -1, -3, -1)).to.eql(filled);
        });

        it('accepts a negative start larger than negative end index', function () {
            var original = testSubject,
                filled = testSubject;

            expect(utilx.Array.fill(original, -1, -1, -3)).to.eql(filled);
        });

        it('accepts a undefined start larger and positve end index', function () {
            var original = testSubject,
                filled = [-1, -1, -1, -1, 5, 6];

            expect(utilx.Array.fill(original, -1, undefined, 4)).to.eql(filled);
        });

        it('works with sparse arrays', function () {
            var original = [],
                filled;

            original.length = 6;
            original[5] = 6;
            filled = required.slice(original);
            filled[1] = -1;
            filled[2] = -1;
            expect(utilx.Array.fill(original, -1, 1, 3)).to.eql(filled);
        });

        it('empty range remains unchanged', function () {
            var original = testSubject,
                filled = testSubject;

            expect(utilx.Array.fill(original, -1, 0, 0)).to.eql(filled);
        });

        it('accepts a positive start index', function () {
            var original = testSubject,
                filled = [1, 2, 3, -1, -1, -1];

            expect(utilx.Array.fill(original, -1, 3)).to.eql(filled);
        });

        it('accepts a negative start index', function () {
            var original = testSubject,
                filled = [1, 2, 3, -1, -1, -1];

            expect(utilx.Array.fill(original, -1, -3)).to.eql(filled);
        });

        it('accepts a large start index', function () {
            var original = testSubject,
                filled = testSubject;

            expect(utilx.Array.fill(original, -1, 9)).to.eql(filled);
        });
    });
}());

},{"../scripts/":10}],19:[function(require,module,exports){
/*global Date, Error, Math, RegExp, TypeError, beforeEach, describe, it, require */

/*properties
    '0', '2', '3', Array, String, a, be, call, create, eql, expect,
    filter, isStrictMode, isString, length, ok, pow, prototype, push, slice,
    throwException, to, toString, utilx, valueOf, isNaN, ToString, ToClass, charAt, global
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.filter', function () {
        var lastIndex = Math.pow(2, 32) - 1,
            filterArray = required.create(0, 1, 2, 'a', 'b', 'c', [8, 9, 10], {}, true, false, undefined, null,
                                  new Date(), new Error('x'), new RegExp('t'), Infinity, -Infinity),
            testSubject,
            testIndex,
            filteredArray,
            callback;

        filterArray.length = 25;
        filterArray[24] = NaN;
        filterArray[25] = 'end';

        callback = function callback(o, i) {
            /*jslint unparam: true */
            /*jshint unused: false */
            return i !== 3 && i !== 5;
        };

        beforeEach(function () {
            testSubject = required.create(2, 3, undefined, true, 'hej', null, false, 0, 8, 9);
            delete testSubject[1];
            delete testSubject[8];
            filteredArray = required.create(2, undefined, 'hej', false, 0, 9);
        });

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.filter();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.filter(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.filter(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if function argument is not a function', function () {
            expect(function () {
                utilx.Array.filter(filterArray);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.filter(filterArray, undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.filter(filterArray, null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(utilx.Array.filter(filterArray, function (element, index, array) {
                expect(array).to.be(filterArray);
                expect(typeof index === 'number').to.be.ok();
                expect(index >= 0).to.be.ok();
                expect(index <= lastIndex).to.be.ok();
                if (required.isNaN(element)) {
                    expect(required.isNaN(filterArray[index])).to.be.ok();
                } else {
                    expect(element).to.be(filterArray[index]);
                }

                testIndex = index;
                if (utilx.String.isString(element)) {
                    return element;
                }

                return undefined;
            }).toString()).to.be(['a', 'b', 'c', 'end'].toString());

            expect(testIndex).to.be(filterArray.length - 1);
        });

        it('should pass the right parameters', function () {
            var array = ['1'];

            utilx.Array.filter(array, function (item, index, list) {
                expect(item).to.be('1');
                expect(index).to.be(0);
                expect(list).to.be(array);
            });
        });

        it('should not affect elements added to the array after it has begun', function () {
            var arr = [1, 2, 3],
                i = 0;

            utilx.Array.filter(arr, function (a) {
                i += 1;
                if (i <= 4) {
                    arr.push(a + 3);
                }

                return true;
            });

            expect(arr).to.eql([1, 2, 3, 4, 5, 6]);
            expect(i).to.be(3);
        });

        it('should skip non-set values', function () {
            var passedValues = {},
                expected = {
                    0: 1,
                    2: 3,
                    3: 4
                };

            testSubject = [1, 2, 3, 4];
            delete testSubject[1];
            utilx.Array.filter(testSubject, function (o, i) {
                passedValues[i] = o;

                return true;
            });

            expect(passedValues).to.eql(expected);
        });

        it('should pass the right context to the filter', function () {
            var passedValues = {},
                expected = {
                    0: 1,
                    2: 3,
                    3: 4
                };

            testSubject = [1, 2, 3, 4];
            delete testSubject[1];
            utilx.Array.filter(testSubject, function (o, i) {
                this[i] = o;

                return true;
            }, passedValues);

            expect(passedValues).to.eql(expected);
        });

        it('should set the right context when given none', function () {
            var context;

            utilx.Array.filter([1], function () {
                context = this;
            });

            expect(context).to.be((function () {
                return function () {
                    return this;
                };
            }()).call());
        });

        it('should remove only the values for which the callback returns false', function () {
            expect(utilx.Array.filter(testSubject, callback)).to.eql(filteredArray);
        });

        it('should leave the original array untouched', function () {
            var copy = required.slice(testSubject);

            utilx.Array.filter(testSubject, callback);
            expect(testSubject).to.eql(copy);
        });

        it('should have a boxed object as list argument of callback', function () {
            var actual;

            utilx.Array.filter('foo', function (item, index, list) {
                /*jslint unparam: true */
                /*jshint unused: false */
                actual = list;
            });

            expect(typeof actual).to.be('object');
            expect(required.ToClass(actual)).to.be('[object String]');
            expect(required.ToString(actual)).to.be('foo');
            expect(actual.charAt(0)).to.be('f');
        });

        it('should not be affected by same-index mutation', function () {
            var results = utilx.Array.filter([1, 2, 3], function (value, index, array) {
                /*jslint unparam: true */
                /*jshint unused: false */
                array[index] = 'a';

                return true;
            });

            expect(results).to.eql([1, 2, 3]);
        });

        if (required.isStrictMode()) {
            it('does not autobox the content in strict mode', function () {
                var actual;

                utilx.Array.filter([1], function () {
                    actual = this;
                }, 'x');

                expect(typeof actual).to.be('string');

                utilx.Array.filter([1], function () {
                    actual = this;
                });

                expect(actual).to.be(undefined);

                utilx.Array.filter([1], function () {
                    actual = this;
                }, undefined);

                expect(actual).to.be(undefined);

                utilx.Array.filter([1], function () {
                    actual = this;
                }, null);

                expect(actual).to.be(null);
            });
        }
    });
}());

/*jslint sloppy: true */
(function () {
    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.filter', function () {
        it('does autobox the content in non-strict mode', function () {
            var actual;

            utilx.Array.filter([1], function () {
                actual = this;
            }, 'x');

            expect(typeof actual).to.be('object');

            utilx.Array.filter([1], function () {
                actual = this;
            });

            expect(actual).to.be(required.global);

            utilx.Array.filter([1], function () {
                actual = this;
            }, undefined);

            expect(actual).to.be(required.global);

            utilx.Array.filter([1], function () {
                actual = this;
            }, null);

            expect(actual).to.be(required.global);
        });
    });
}());

},{"../scripts/":10}],20:[function(require,module,exports){
/*global Error, TypeError, describe, it, require */

/*properties
    '0', '1', '2', Array, Object, a, be, create, eql, expect,
    find, hasOwnProperty, isStrictMode, isUndefined, length, throwException, to,
    utilx, global, prototype, call
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.find', function () {
        var list = [5, 10, 15, 20];

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.find();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.find(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.find(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if function argument is not a function', function () {
            expect(function () {
                utilx.Array.find(list);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.find(list, undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.find(list, null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should find item by predicate', function () {
            var result = utilx.Array.find(list, function (item) {
                return item === 15;
            });

            expect(result).to.be(15);
        });

        it('should return undefined when nothing matched', function () {
            var result = utilx.Array.find(list, function (item) {
                return item === 'a';
            });

            expect(result).to.be(undefined);
        });

        it('should receive all three parameters', function () {
            var index = utilx.Array.find(list, function (value, index, arr) {
                expect(list[index]).to.be(value);
                expect(list).to.eql(arr);

                return false;
            });

            expect(index).to.be(undefined);
        });

        it('should work with the context argument', function () {
            var context = {};

            utilx.Array.find([1], function () {
                expect(this).to.be(context);
            }, context);
        });

        it('should work with an array-like object', function () {
            var obj = {
                    0: 1,
                    1: 2,
                    2: 3,
                    length: 3
                },
                found = utilx.Array.find(obj, function (item) {
                    return item === 2;
                });

            expect(found).to.be(2);
        });

        it('should work with an array-like object with negative length', function () {
            var obj = {
                    0: 1,
                    1: 2,
                    2: 3,
                    length: -3
                },
                found = utilx.Array.find(obj, function () {
                    throw new Error('should not reach here');
                });

            expect(found).to.be(undefined);
        });

        it('should work with a sparse array', function () {
            var obj = required.create(1, 2, undefined),
                seen = [],
                found,
                expected = [];

            seen.length = 3;
            delete obj[1];
            found = utilx.Array.find(obj, function (item, idx) {
                if (Object.prototype.hasOwnProperty.call(obj, idx)) {
                    seen[idx] = required.create(idx, item);

                    return required.isUndefined(item);
                }

                return false;
            });

            expected[0] = [0, 1];
            expected[2] = required.create(2, undefined);
            expect(found).to.be(undefined);
            expect(seen).to.eql(expected);
        });

        it('should work with a sparse array-like object', function () {
            var obj = {
                    0: 1,
                    2: undefined,
                    length: 3.2
                },
                seen = [],
                expected = [],
                found;

            seen.length = 3;
            found = utilx.Array.find(obj, function (item, idx) {
                if (Object.prototype.hasOwnProperty.call(obj, idx)) {
                    seen[idx] = required.create(idx, item);

                    return required.isUndefined(item);
                }

                return false;
            });

            expected.length = 3;
            expected[0] = [0, 1];
            expected[2] = required.create(2, undefined);
            expect(found).to.be(undefined);
            expect(seen).to.eql(expected);
        });

        if (required.isStrictMode()) {
            it('does not autobox the content in strict mode', function () {
                var actual;

                utilx.Array.find([1], function () {
                    actual = this;
                }, 'x');

                expect(typeof actual).to.be('string');

                utilx.Array.find([1], function () {
                    actual = this;
                });

                expect(actual).to.be(undefined);

                utilx.Array.find([1], function () {
                    actual = this;
                }, undefined);

                expect(actual).to.be(undefined);

                utilx.Array.find([1], function () {
                    actual = this;
                }, null);

                expect(actual).to.be(null);
            });
        }
    });
}());

/*jslint sloppy: true */
(function () {
    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.find', function () {
        it('does autobox the content in non-strict mode', function () {
            var actual;

            utilx.Array.find([1], function () {
                actual = this;
            }, 'x');

            expect(typeof actual).to.be('object');

            utilx.Array.find([1], function () {
                actual = this;
            });

            expect(actual).to.be(required.global);

            utilx.Array.find([1], function () {
                actual = this;
            }, undefined);

            expect(actual).to.be(required.global);

            utilx.Array.find([1], function () {
                actual = this;
            }, null);

            expect(actual).to.be(required.global);
        });
    });
}());

},{"../scripts/":10}],21:[function(require,module,exports){
/*global Error, TypeError, describe, it, require */

/*properties
    '0', '1', '2', Array, Object, a, be, create, eql, expect,
    findIndex, hasOwnProperty, isStrictMode, isUndefined, length, throwException,
    to, utilx, global, prototype, call
*/
(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.findIndex', function () {
        var list = [5, 10, 15, 20];

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.findIndex();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.findIndex(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.findIndex(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if function argument is not a function', function () {
            expect(function () {
                utilx.Array.findIndex(list);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.findIndex(list, undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.findIndex(list, null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should find item key by predicate', function () {
            var result = utilx.Array.findIndex(list, function (item) {
                return item === 15;
            });

            expect(result).to.be(2);
        });

        it('should return -1 when nothing matched', function () {
            var result = utilx.Array.findIndex(list, function (item) {
                return item === 'a';
            });

            expect(result).to.be(-1);
        });

        it('should receive all three parameters', function () {
            var index = utilx.Array.findIndex(list, function (value, index, arr) {
                expect(list[index]).to.be(value);
                expect(list).to.eql(arr);

                return false;
            });

            expect(index).to.be(-1);
        });

        it('should work with the context argument', function () {
            var context = {};

            utilx.Array.findIndex([1], function () {
                expect(this).to.be(context);
            }, context);
        });

        it('should work with an array-like object', function () {
            var obj = {
                    0: 1,
                    1: 2,
                    2: 3,
                    length: 3
                },
                foundIndex = utilx.Array.findIndex(obj, function (item) {
                    return item === 3;
                });

            expect(foundIndex).to.be(2);
        });

        it('should work with an array-like object with negative length', function () {
            var obj = {
                    0: 1,
                    1: 2,
                    2: 3,
                    length: -3
                },
                foundIndex = utilx.Array.findIndex(obj, function () {
                    throw new Error('should not reach here');
                });

            expect(foundIndex).to.be(-1);
        });

        it('should work with a sparse array', function () {
            var obj = required.create(1, 2, undefined),
                seen = [],
                foundIndex,
                expected = [];

            seen.length = 3;
            delete obj[1];
            foundIndex = utilx.Array.findIndex(obj, function (item, idx) {
                if (Object.prototype.hasOwnProperty.call(obj, idx)) {
                    seen[idx] = required.create(idx, item);

                    return required.isUndefined(item);
                }

                return false;
            });

            expected.length = 3;
            expected[0] = [0, 1];
            expected[2] = required.create(2, undefined);
            expect(foundIndex).to.be(2);
            expect(seen).to.eql(expected);
        });

        it('should work with a sparse array-like object', function () {
            var obj = {
                    0: 1,
                    2: undefined,
                    length: 3.2
                },
                seen = [],
                expected = [],
                foundIndex;

            seen.length = 3;
            foundIndex = utilx.Array.findIndex(obj, function (item, idx) {
                if (Object.prototype.hasOwnProperty.call(obj, idx)) {
                    seen[idx] = required.create(idx, item);

                    return required.isUndefined(item);
                }

                return false;
            });

            expected.length = 3;
            expected[0] = [0, 1];
            expected[2] = required.create(2, undefined);
            expect(foundIndex).to.be(2);
            expect(seen).to.eql(expected);
        });

        if (required.isStrictMode()) {
            it('does not autobox the content in strict mode', function () {
                var actual;

                utilx.Array.findIndex([1], function () {
                    actual = this;
                }, 'x');

                expect(typeof actual).to.be('string');

                utilx.Array.findIndex([1], function () {
                    actual = this;
                });

                expect(actual).to.be(undefined);

                utilx.Array.findIndex([1], function () {
                    actual = this;
                }, undefined);

                expect(actual).to.be(undefined);

                utilx.Array.findIndex([1], function () {
                    actual = this;
                }, null);

                expect(actual).to.be(null);
            });
        }
    });
}());

/*jslint sloppy: true */
(function () {
    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.findIndex', function () {
        it('does autobox the content in non-strict mode', function () {
            var actual;

            utilx.Array.findIndex([1], function () {
                actual = this;
            }, 'x');

            expect(typeof actual).to.be('object');

            utilx.Array.findIndex([1], function () {
                actual = this;
            });

            expect(actual).to.be(required.global);

            utilx.Array.findIndex([1], function () {
                actual = this;
            }, undefined);

            expect(actual).to.be(required.global);

            utilx.Array.findIndex([1], function () {
                actual = this;
            }, null);

            expect(actual).to.be(required.global);
        });
    });
}());

},{"../scripts/":10}],22:[function(require,module,exports){
/*global TypeError, describe, it, require */

/*properties
    '0', '1', '2', Array, a, be, expect, first, length, returnArgs,
    throwException, to, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.first', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.first();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.first(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.first(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(utilx.Array.first([])).to.be(undefined);
            expect(utilx.Array.first([1, 2, 3])).to.be(1);
            expect(utilx.Array.first(required.returnArgs(1, 2, 3))).to.be(1);
            expect(utilx.Array.first({
                0: 1,
                1: 2,
                2: 3,
                length: 3
            })).to.be(1);
        });
    });
}());

},{"../scripts/":10}],23:[function(require,module,exports){
/*global TypeError, describe, it, require */

/*properties
    '2', '3', '4', '5', '6', Array, a, be, expect, firstIn, length, returnArgs,
    throwException, to, utilx, prototype, call, hasOwnProperty
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.firstIn', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.firstIn();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.firstIn(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.firstIn(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            var arr = [0, 1, 2, 3, 4, 5, 6];

            delete arr[0];
            delete arr[1];

            expect(utilx.Array.firstIn(arr)).to.be(2);
        });

        it('arguments', function () {
            var args = required.returnArgs(0, 1, 2, 3, 4, 5, 6);

            // doesn't seem to work on Opera 9 or IE < 9
            delete args[0];
            delete args[1];

            if (!Object.prototype.hasOwnProperty.call(args, 0) && !Object.prototype.hasOwnProperty.call(args, 1)) {
                expect(utilx.Array.firstIn(args)).to.be(2);
            } else {
                expect(utilx.Array.firstIn(args)).to.be(0);
            }
        });

        it('object with length', function () {
            var obj = {
                    2: 2,
                    3: 3,
                    4: 4,
                    5: 5,
                    6: 6,
                    length: 7
                };

            expect(utilx.Array.firstIn(obj)).to.be(2);
        });
    });
}());

},{"../scripts/":10}],24:[function(require,module,exports){
/*global describe, it, require */

/*property
    Array, Object, a, be, eql, expect, returnArgs, flatten, keys, length, not,
    throwException, to, utilx, noop, '0'
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.flatten', function () {
        var testArr1 = [1, 2, 'z', [3, [4, {
                0: 'x',
                length: 1
            }, 'y', 5], 6, null, undefined]],
            expected1 = [1, 2, 'z', 3, [4, {
                0: 'x',
                length: 1
            }, 'y', 5], 6, null, undefined],
            expected2 = [1, 2, 'z', 3, 4, {
                0: 'x',
                length: 1
            }, 'y', 5, 6, null, undefined],
            depth = 10000,
            testArr2 = [depth - 1, [depth]],
            index;

        for (index = 0; index < depth; index += 1) {
            testArr2 = [depth - index - 1, testArr2];
        }

        delete testArr1[2];
        delete expected1[2];
        delete expected2[2];

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.flatten();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.flatten(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.flatten(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an TypeError if deep is not a boolean', function () {
            var result;

            expect(function () {
                result = utilx.Array.flatten(testArr1);
            }).to.not.throwException();

            expect(result).to.eql(expected1);

            expect(function () {
                result = utilx.Array.flatten(testArr1, undefined);
            }).to.not.throwException();

            expect(result).to.eql(expected1);

            expect(function () {
                result = utilx.Array.flatten(testArr1, null);
            }).to.not.throwException();

            expect(result).to.eql(expected1);

            expect(function () {
                result = utilx.Array.flatten(testArr1, {});
            }).to.not.throwException();

            expect(result).to.eql(expected2);

            expect(function () {
                result = utilx.Array.flatten(testArr1, []);
            }).to.not.throwException();

            expect(result).to.eql(expected2);

            expect(function () {
                result = utilx.Array.flatten(testArr1, NaN);
            }).to.not.throwException();

            expect(result).to.eql(expected1);

            expect(function () {
                result = utilx.Array.flatten(testArr1, required.noop);
            }).to.not.throwException();

            expect(result).to.eql(expected2);

            expect(function () {
                result = utilx.Array.flatten(testArr1, Infinity);
            }).to.not.throwException();

            expect(result).to.eql(expected2);

            expect(function () {
                result = utilx.Array.flatten(testArr1, -Infinity);
            }).to.not.throwException();

            expect(result).to.eql(expected2);

            expect(function () {
                result = utilx.Array.flatten(testArr1, 0);
            }).to.not.throwException();

            expect(result).to.eql(expected1);

            expect(function () {
                result = utilx.Array.flatten(testArr1, -1);
            }).to.not.throwException();

            expect(result).to.eql(expected2);

            expect(function () {
                result = utilx.Array.flatten(testArr1, '');
            }).to.not.throwException();

            expect(result).to.eql(expected1);
        });

        it('should not throw an TypeError if argument is primitive', function () {
            var expected = [],
                result;

            expect(function () {
                result = utilx.Array.flatten(42);
            }).to.not.throwException();

            expect(result).to.eql(expected);

            expect(function () {
                result = utilx.Array.flatten(true);
            }).to.not.throwException();

            expect(result).to.eql(expected);

            expect(function () {
                result = utilx.Array.flatten('abc');
            }).to.not.throwException();

            expect(result).to.eql(expected);
        });

        it('should not throw an TypeError if argument is an object', function () {
            var expected = [],
                result;

            expect(function () {
                result = utilx.Array.flatten({});
            }).to.not.throwException();

            expect(result).to.eql(expected);

            expect(function () {
                result = utilx.Array.flatten([]);
            }).to.not.throwException();

            expect(result).to.eql(expected);

            expect(function () {
                result = utilx.Array.flatten(required.noop);
            }).to.not.throwException();

            expect(result).to.eql(expected);
        });

        it('should return the correct result', function () {
            var result;

            expect(function () {
                result = utilx.Array.flatten(testArr1, false);
            }).to.not.throwException();


            expect(function () {
                result = utilx.Array.flatten(testArr1, true);
            }).to.not.throwException();

            expect(result).to.eql(expected2);
        });

        it('should not throw RangeError: Maximum call stack size exceeded', function () {
            expect(function () {
                utilx.Array.flatten(testArr2, false);
            }).to.not.throwException();

            expect(function () {
                utilx.Array.flatten(testArr2, true);
            }).to.not.throwException();
        });
    });
}());

},{"../scripts/":10}],25:[function(require,module,exports){
/*global Date, Error, Math, RegExp, TypeError, beforeEach, describe, it, require */

/*properties
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', Array, a, be, call,
    create, eql, expect, forAll, isStrictMode, length, not, ok, pow, prototype,
    push, throwException, to, toString, utilx, valueOf, Object, isNaN, ToString,
    ToClass, charAt, global
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.forAll', function () {
        var lastIndex = Math.pow(2, 32) - 1,
            forAllArray = required.create(0, 1, 2, 'a', 'b', 'c', [8, 9, 10], {}, true, false, undefined, null,
                                  new Date(), new Error('x'), new RegExp('t'), Infinity, -Infinity),
            testSubject,
            testIndex,
            expected,
            numberOfRuns;

        beforeEach(function () {
            testSubject = required.create(2, 3, undefined, true, 'hej', null, false, 0, 8, 9);
            delete testSubject[1];
            delete testSubject[8];
            numberOfRuns = 0;
            expected = {
                0: 2,
                1: undefined,
                2: undefined
            };
        });

        forAllArray.length = 25;
        forAllArray[24] = NaN;
        forAllArray[25] = 'end';

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.forAll();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.forAll(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.forAll(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if function argument is not a function', function () {
            expect(function () {
                utilx.Array.forAll(forAllArray);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.forAll(forAllArray, undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.forAll(forAllArray, null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(utilx.Array.forAll(forAllArray, function (element, index, array) {
                expect(array).to.be(forAllArray);
                expect(typeof index === 'number').to.be.ok();
                expect(index >= 0).to.be.ok();
                expect(index <= lastIndex).to.be.ok();
                if (required.isNaN(element)) {
                    expect(required.isNaN(forAllArray[index])).to.be(true);
                } else {
                    expect(element).to.be(forAllArray[index]);
                }

                testIndex = index;
                if (element === 'end') {
                    return true;
                }

                return false;
            })).to.be(true);

            expect(testIndex).to.be(forAllArray.length - 1);
        });

        it('should pass the right parameters', function () {
            var array = ['1'];

            utilx.Array.forAll(array, function (item, index, list) {
                expect(item).to.be('1');
                expect(index).to.be(0);
                expect(list).to.be(array);
            });
        });

        it('should not affect elements added to the array after it has begun', function () {
            var arr = [1, 2, 3],
                i = 0;

            utilx.Array.forAll(arr, function (a) {
                i += 1;
                arr.push(a + 3);

                return i === 3;
            });

            expect(arr).to.eql([1, 2, 3, 4, 5, 6]);
            expect(i).to.be(3);
        });

        it('should set the right context when given none', function () {
            var context;

            utilx.Array.forAll([1], function () {
                context = this;
            });

            expect(context).to.be((function () {
                return function () {
                    return this;
                };
            }()).call());
        });

        it('should return false if it runs to the end', function () {
            var actual = utilx.Array.forAll(testSubject, function () {
                return;
            });

            expect(actual).to.not.be.ok();
        });


        it('should not skip over holes', function () {
            var noHoles = {};

            utilx.Array.forAll(testSubject, function (item, idx) {
                noHoles[idx] = item;
                noHoles.length = idx + 1;
            }, noHoles);

            expect(noHoles).to.eql({
                0: 2,
                1: undefined,
                2: undefined,
                3: true,
                4: 'hej',
                5: null,
                6: false,
                7: 0,
                8: undefined,
                9: 9,
                length: 10
            });
        });

        it('should return true if it is stopped somewhere', function () {
            var actual = utilx.Array.forAll(testSubject, function () {
                return true;
            });

            expect(actual).to.be.ok();
        });

        it('should return false if there are no elements', function () {
            var actual = utilx.Array.forAll([], function () {
                return true;
            });

            expect(actual).to.not.be.ok();
        });

        it('should stop after 3 elements', function () {
            var actual = {};

            utilx.Array.forAll(testSubject, function (obj, index) {
                actual[index] = obj;
                numberOfRuns += 1;
                if (numberOfRuns === 3) {
                    return true;
                }

                return false;
            });

            expect(actual).to.eql(expected);
        });

        it('should stop after 3 elements using a context', function () {
            var actual = {},
                o = {
                    a: actual
                };

            utilx.Array.forAll(testSubject, function (obj, index) {
                this.a[index] = obj;
                numberOfRuns += 1;
                if (numberOfRuns === 3) {
                    return true;
                }

                return false;
            }, o);

            expect(actual).to.eql(expected);
        });

        it('should stop after 3 elements in an array-like object', function () {
            var ts = required.Object(testSubject),
                actual = {};

            utilx.Array.forAll(ts, function (obj, index) {
                actual[index] = obj;
                numberOfRuns += 1;
                if (numberOfRuns === 3) {
                    return true;
                }

                return false;
            });

            expect(actual).to.eql(expected);
        });

        it('should stop after 3 elements in an array-like object using a context', function () {
            var ts = required.Object(testSubject),
                actual = {},
                o = {
                    a: actual
                };

            utilx.Array.forAll(ts, function (obj, index) {
                this.a[index] = obj;
                numberOfRuns += 1;
                if (numberOfRuns === 3) {
                    return true;
                }

                return false;
            }, o);

            expect(actual).to.eql(expected);
        });

        it('should have a boxed object as list argument of callback', function () {
            var actual;

            utilx.Array.forAll('foo', function (item, index, list) {
                /*jslint unparam: true */
                /*jshint unused: true */
                actual = list;
            });

            expect(typeof actual).to.be('object');
            expect(required.ToClass(actual)).to.be('[object String]');
            expect(required.ToString(actual)).to.be('foo');
            expect(actual.charAt(0)).to.be('f');
        });

        if (required.isStrictMode()) {
            it('does not autobox the content in strict mode', function () {
                var actual;

                utilx.Array.forAll([1], function () {
                    actual = this;
                }, 'x');

                expect(typeof actual).to.be('string');

                utilx.Array.forAll([1], function () {
                    actual = this;
                });

                expect(actual).to.be(undefined);

                utilx.Array.forAll([1], function () {
                    actual = this;
                }, undefined);

                expect(actual).to.be(undefined);

                utilx.Array.forAll([1], function () {
                    actual = this;
                }, null);

                expect(actual).to.be(null);
            });
        }
    });
}());

/*jslint sloppy: true */
(function () {
    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.forAll', function () {
        it('does autobox the content in non-strict mode', function () {
            var actual;

            utilx.Array.forAll([1], function () {
                actual = this;
            }, 'x');

            expect(typeof actual).to.be('object');

            utilx.Array.forAll([1], function () {
                actual = this;
            });

            expect(actual).to.be(required.global);

            utilx.Array.forAll([1], function () {
                actual = this;
            }, undefined);

            expect(actual).to.be(required.global);

            utilx.Array.forAll([1], function () {
                actual = this;
            }, null);

            expect(actual).to.be(required.global);
        });
    });
}());

},{"../scripts/":10}],26:[function(require,module,exports){
/*global Date, Error, Math, RegExp, TypeError, beforeEach, describe, it, require */

/*properties
    '0', '1', '2', '3', '4', Array, a, array2Object, be, call, create,
    eql, expect, forEach, isStrictMode, length, ok, pow, prototype, push,
    returnArgs, throwException, to, toString, utilx, valueOf, Object, isNaN,
    ToString, ToClass, charAt, global
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.forEach', function () {
        var lastIndex = Math.pow(2, 32) - 1,
            forEachArray = required.create(0, 1, 2, 'a', 'b', 'c', [8, 9, 10], {}, true, false, undefined, null,
                new Date(), new Error('x'), new RegExp('t'), Infinity, -Infinity),
            testSubject,
            expected,
            str = 'Hello, World!',
            arrStr = ['H', 'e', 'l', 'l', 'o', ',', ' ', 'W', 'o', 'r', 'l', 'd', '!'],
            testIndex;

        forEachArray.length = 25;
        forEachArray[24] = NaN;
        forEachArray[25] = 'end';

        beforeEach(function () {
            testSubject = required.create(2, 3, undefined, true, 'hej', null, false, 0, 8, 9);
            delete testSubject[1];
            delete testSubject[8];
            expected = required.array2Object(testSubject);
        });

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.forEach();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.forEach(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.forEach(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if function argument is not a function', function () {
            expect(function () {
                utilx.Array.forEach(forEachArray);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.forEach(forEachArray, undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.forEach(forEachArray, null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(utilx.Array.forEach(forEachArray, function (element, index, array) {
                expect(array).to.be(forEachArray);
                expect(typeof index === 'number').to.be.ok();
                expect(index >= 0).to.be.ok();
                expect(index <= lastIndex).to.be.ok();
                if (required.isNaN(element)) {
                    expect(required.isNaN(forEachArray[index])).to.be(true);
                } else {
                    expect(element).to.be(forEachArray[index]);
                }

                testIndex = index;
            })).to.be(undefined);

            expect(testIndex).to.be(forEachArray.length - 1);
        });

        it('should pass the right parameters', function () {
            var array = ['1'];

            utilx.Array.forEach(array, function (item, index, list) {
                expect(item).to.be('1');
                expect(index).to.be(0);
                expect(list).to.be(array);
            });
        });

        it('should not affect elements added to the array after it has begun', function () {
            var arr = [1, 2, 3],
                i = 0;

            utilx.Array.forEach(arr, function (a) {
                i += 1;
                arr.push(a + 3);
            });

            expect(arr).to.eql([1, 2, 3, 4, 5, 6]);
            expect(i).to.be(3);
        });

        it('should set the right context when given none', function () {
            var context;

            utilx.Array.forEach([1], function () {
                context = this;
            });

            expect(context).to.be((function () {
                return function () {
                    return this;
                };
            }()).call());
        });

        it('should iterate all', function () {
            var actual = {};

            utilx.Array.forEach(testSubject, function (obj, index) {
                actual[index] = obj;
                actual.length = index + 1;
            });

            expect(actual).to.eql(expected);
        });

        it('should iterate all using a context', function () {
            var actual = {},
                o = {
                    a: actual
                };

            utilx.Array.forEach(testSubject, function (obj, index) {
                this.a[index] = obj;
                this.a.length = index + 1;
            }, o);

            expect(actual).to.eql(expected);
        });

        it('should iterate arguments object', function () {
            var actual = {};

            utilx.Array.forEach(required.returnArgs(1, undefined, null, 2, 3), function (obj, index) {
                actual[index] = obj;
            });

            expect(actual).to.eql({
                0: 1,
                1: undefined,
                2: null,
                3: 2,
                4: 3
            });
        });

        it('should iterate all in an array-like object', function () {
            var actual = {},
                ts = required.Object(testSubject);

            utilx.Array.forEach(ts, function (obj, index) {
                actual[index] = obj;
                actual.length = index + 1;
            });

            expect(actual).to.eql(expected);
        });

        it('should iterate all in an array-like object using a context', function () {
            var actual = {},
                ts = required.Object(testSubject),
                o = {
                    a: actual
                };

            utilx.Array.forEach(ts, function (obj, index) {
                this.a[index] = obj;
                this.a.length = index + 1;
            }, o);

            expect(actual).to.eql(expected);
        });

        it('should iterate all in a string', function () {
            var actual = [];

            utilx.Array.forEach(str, function (item, index) {
                actual[index] = item;
            });

            expect(actual.length).to.be(arrStr.length);
            expect(actual).to.eql(arrStr);
        });

        it('should iterate all in a string using a context', function () {
            var actual = [],
                o = {
                    a: actual
                };

            utilx.Array.forEach(str, function (item, index) {
                this.a[index] = item;
            }, o);

            expect(actual.length).to.be(arrStr.length);
            expect(actual).to.eql(arrStr);
        });

        it('should have a boxed object as list argument of callback', function () {
            var actual;

            utilx.Array.forEach('foo', function (item, index, list) {
                /*jslint unparam: true */
                /*jshint unused: true */
                actual = list;
            });

            expect(typeof actual).to.be('object');
            expect(required.ToClass(actual)).to.be('[object String]');
            expect(required.ToString(actual)).to.be('foo');
            expect(actual.charAt(0)).to.be('f');
        });

        if (required.isStrictMode()) {
            it('does not autobox the content in strict mode', function () {
                var actual;

                utilx.Array.forEach([1], function () {
                    actual = this;
                }, 'x');

                expect(typeof actual).to.be('string');

                utilx.Array.forEach([1], function () {
                    actual = this;
                });

                expect(actual).to.be(undefined);

                utilx.Array.forEach([1], function () {
                    actual = this;
                }, undefined);

                expect(actual).to.be(undefined);

                utilx.Array.forEach([1], function () {
                    actual = this;
                }, null);

                expect(actual).to.be(null);
            });
        }
    });
}());

/*jslint sloppy: true */
(function () {
    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.forEach', function () {
        it('does autobox the content in non-strict mode', function () {
            var actual;

            utilx.Array.forEach([1], function () {
                actual = this;
            }, 'x');

            expect(typeof actual).to.be('object');

            utilx.Array.forEach([1], function () {
                actual = this;
            });

            expect(actual).to.be(required.global);

            utilx.Array.forEach([1], function () {
                actual = this;
            }, undefined);

            expect(actual).to.be(required.global);

            utilx.Array.forEach([1], function () {
                actual = this;
            }, null);

            expect(actual).to.be(required.global);
        });
    });
}());

},{"../scripts/":10}],27:[function(require,module,exports){
/*global TypeError, describe, it, require */

/*properties
    Array, Object, a, be, call, create, eql, equal, expect, forEach, from,
    hasProperty, isStrictMode, length, not, ok, returnArgs, throwException, to,
    utilx, global
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.from', function () {
        it('should create correct array from iterable', function () {
            expect(utilx.Array.from(required.returnArgs(0, 1, 2))).to.eql([0, 1, 2]);

            expect(utilx.Array.from(required.create(null, undefined, 0.1248, -0, 0))).to.eql(
                required.create(null, undefined, 0.1248, -0, 0)
            );
        });

        it('should handle empty iterables correctly', function () {
            expect(utilx.Array.from(required.returnArgs())).to.eql([]);
        });

        it('should work with other constructors', function () {
            var Foo = function (length, args) {
                    /*jslint unparam: true */
                    /*jshint unused: false */
                    this.length = length;
                },
                args = ['a', 'b', 'c'],
                expected = new Foo(args.length);

            required.forEach(args, function (arg, index) {
                expected[index] = arg;
            });

            expect(utilx.Array.from.call(Foo, args)).to.eql(expected);
        });

        it('supports a from function', function () {
            var original = [1, 2, 3],
                mapper = function (item) {
                    return item * 2;
                },
                mapped = utilx.Array.from(original, mapper);

            expect(mapped).to.eql([2, 4, 6]);
        });

        it('throws when provided a nonfunction second arg', function () {
            expect(function () {
                utilx.Array.from([], false);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.from([], true);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.from([], /a/g);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.from([], {});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.from([], []);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.from([], '');
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.from([], 3);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('supports a this arg', function () {
            var original = [1, 2, 3],
                context = {},
                mapper = function (item) {
                    expect(this).to.equal(context);

                    return item * 2;
                },
                mapped = utilx.Array.from(original, mapper, context);

            expect(mapped).to.eql([2, 4, 6]);
        });

        it('throws when provided null or undefined', function () {
            expect(function () {
                utilx.Array.from();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
            expect(function () {
                utilx.Array.from(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
            expect(function () {
                utilx.Array.from(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('returns [] when given 3', function () {
            expect(utilx.Array.from(3)).to.eql([]);
        });

        it('removes holes', function () {
            var input = required.create('[0, , 2]'),
                result = utilx.Array.from(input);

            expect(utilx.Object.hasProperty(input, 1)).not.to.be.ok();
            expect(utilx.Object.hasProperty(result, 1)).to.be.ok();
            expect(result).to.eql(required.create(0, undefined, 2));
        });

        if (required.isStrictMode()) {
            it('does not autobox the content in strict mode', function () {
                var actual;

                utilx.Array.from([1], function () {
                    actual = this;
                }, 'x');

                expect(typeof actual).to.be('string');

                utilx.Array.from([1], function () {
                    actual = this;
                });

                expect(actual).to.be(undefined);

                utilx.Array.from([1], function () {
                    actual = this;
                }, undefined);

                expect(actual).to.be(undefined);

                utilx.Array.from([1], function () {
                    actual = this;
                }, null);

                expect(actual).to.be(null);
            });
        }
    });
}());

/*jslint sloppy: true */
(function () {
    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.from', function () {
        it('does autobox the content in non-strict mode', function () {
            var actual;

            utilx.Array.from([1], function () {
                actual = this;
            }, 'x');

            expect(typeof actual).to.be('object');

            utilx.Array.from([1], function () {
                actual = this;
            });

            expect(actual).to.be(required.global);

            utilx.Array.from([1], function () {
                actual = this;
            }, undefined);

            expect(actual).to.be(required.global);

            utilx.Array.from([1], function () {
                actual = this;
            }, null);

            expect(actual).to.be(required.global);
        });
    });
}());

},{"../scripts/":10}],28:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.indexOf', function () {
        var arr = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ],
            arr2 = required.create(2, 3, undefined, true, 'hej', null, 2, false, 0, 8, 9),
            arr3 = [0, 1, 2, 3, 4, 5];

        delete arr2[1];
        delete arr2[8];
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.indexOf();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.indexOf(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.indexOf(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should find the string in array', function () {
            expect(utilx.Array.indexOf(arr, 'toString')).to.be(0);
            expect(utilx.Array.indexOf(arr, 'toLocaleString')).to.be(1);
            expect(utilx.Array.indexOf(arr, 'valueOf')).to.be(2);
            expect(utilx.Array.indexOf(arr, 'hasOwnProperty')).to.be(3);
            expect(utilx.Array.indexOf(arr, 'isPrototypeOf')).to.be(4);
            expect(utilx.Array.indexOf(arr, 'propertyIsEnumerable')).to.be(5);
            expect(utilx.Array.indexOf(arr, 'constructor')).to.be(6);
        });

        it('should not find the string in array', function () {
            expect(utilx.Array.indexOf(arr, 'foo')).to.be(-1);
            expect(utilx.Array.indexOf(arr, 'bar')).to.be(-1);
            expect(utilx.Array.indexOf(arr, 'fuz')).to.be(-1);
            expect(utilx.Array.indexOf(arr, 'push')).to.be(-1);
            expect(utilx.Array.indexOf(arr, 'pop')).to.be(-1);
        });

        it('should find the number in the array', function () {
            expect(utilx.Array.indexOf(arr3, 0)).to.be(0);
            expect(utilx.Array.indexOf(arr3, 1)).to.be(1);
            expect(utilx.Array.indexOf(arr3, 2)).to.be(2);
            expect(utilx.Array.indexOf(arr3, 3)).to.be(3);
            expect(utilx.Array.indexOf(arr3, 4)).to.be(4);
            expect(utilx.Array.indexOf(arr3, 5)).to.be(5);
        });

        it('should not find the number in the array', function () {
            expect(utilx.Array.indexOf(arr3, 6)).to.be(-1);
            expect(utilx.Array.indexOf(arr3, 7)).to.be(-1);
            expect(utilx.Array.indexOf(arr3, 8)).to.be(-1);
            expect(utilx.Array.indexOf(arr3, 9)).to.be(-1);
            expect(utilx.Array.indexOf(arr3, 10)).to.be(-1);
        });

        it('should find the element', function () {
            expect(utilx.Array.indexOf(arr2, 'hej')).to.be(4);
        });

        it('should not find the element', function () {
            expect(utilx.Array.indexOf(arr2, 'mus')).to.be(-1);
        });

        it('should find undefined as well', function () {
            expect(utilx.Array.indexOf(arr2, undefined)).to.not.be(-1);
        });

        it('should skip unset indexes', function () {
            expect(utilx.Array.indexOf(arr2, undefined)).to.be(2);
        });

        it('should use a strict test', function () {
            expect(utilx.Array.indexOf(arr2, null)).to.be(5);
            expect(utilx.Array.indexOf(arr2, '2')).to.be(-1);
        });

        it('should skip the first if fromIndex is set', function () {
            expect(utilx.Array.indexOf(arr2, 2, 2)).to.be(6);
            expect(utilx.Array.indexOf(arr2, 2, 0)).to.be(0);
            expect(utilx.Array.indexOf(arr2, 2, 6)).to.be(6);
        });

        it('should work with negative fromIndex', function () {
            expect(utilx.Array.indexOf(arr2, 2, -5)).to.be(6);
            expect(utilx.Array.indexOf(arr2, 2, -11)).to.be(0);
        });

        it('should work with fromIndex being greater than the length', function () {
            expect(utilx.Array.indexOf(arr2, 0, 20)).to.be(-1);
        });

        it('should work with fromIndex being negative and greater than the length', function () {
            expect(utilx.Array.indexOf(arr2, 'hej', -20)).to.be(4);
        });
    });
}());

},{"../scripts/":10}],29:[function(require,module,exports){
/*global Array, Date, Error, RegExp, describe, it, require */

/*properties
    '0', Array, be, expect, frame, isArray, length, noop, not, ok, prototype,
    returnArgs, to, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;


    describe('Array.isArray', function () {
        it('missing, null and undefined', function () {
            expect(utilx.Array.isArray()).to.not.be.ok();
            expect(utilx.Array.isArray(undefined)).to.not.be.ok();
            expect(utilx.Array.isArray(null)).to.not.be.ok();
        });

        it('primitives', function () {
            expect(utilx.Array.isArray(1)).to.not.be.ok();
            expect(utilx.Array.isArray(true)).to.not.be.ok();
            expect(utilx.Array.isArray('')).to.not.be.ok();
        });

        it('array', function () {
            expect(utilx.Array.isArray([])).to.be.ok();
        });

        it('objects', function () {
            expect(utilx.Array.isArray(new Error('x'))).to.not.be.ok();
            expect(utilx.Array.isArray(new Date())).to.not.be.ok();
            expect(utilx.Array.isArray(new RegExp('x'))).to.not.be.ok();
            expect(utilx.Array.isArray(required.noop)).to.not.be.ok();
            expect(utilx.Array.isArray({ 0: 'a', length: 1 })).to.not.be.ok();
        });

        it('arguments', function () {
            expect(utilx.Array.isArray(required.returnArgs())).to.not.be.ok();
        });

        it('Array.prototype', function () {
            expect(utilx.Array.isArray(Array.prototype)).to.be.ok();
        });

        if (required.frame) {
            it('should work accross frames', function () {
                expect(utilx.Array.isArray(new required.frame.Array(1, 2, 3))).to.be.ok();
            });
        }
    });
}());

},{"../scripts/":10}],30:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.isEmpty', function () {
        function F() {
            return;
        }

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.isEmpty();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.isEmpty(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.isEmpty(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(function () {
                utilx.Array.isEmpty(1);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.isEmpty(true);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });


            expect(function () {
                utilx.Array.isEmpty(new Error('x'));
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.isEmpty(new Date());
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.isEmpty(new RegExp('x'));
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.isEmpty(F);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.isEmpty(new F());
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.isEmpty({});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(utilx.Array.isEmpty([])).to.be.ok();
            expect(utilx.Array.isEmpty(required.returnArgs())).to.be.ok();
            expect(utilx.Array.isEmpty([''])).to.not.be.ok();
            expect(utilx.Array.isEmpty(required.returnArgs(''))).to.not.be.ok();
            expect(utilx.Array.isEmpty('')).to.be.ok();
        });
    });
}());

},{"../scripts/":10}],31:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.join', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.join();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.join(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.join(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(utilx.Array.join([])).to.be('');
            expect(utilx.Array.join([undefined])).to.be('');
            expect(utilx.Array.join([undefined, undefined])).to.be(',');
            expect(utilx.Array.join([null, null])).to.be(',');
            expect(utilx.Array.join([1, 2, 3])).to.be('1,2,3');
            expect(utilx.Array.join([undefined, undefined], '|')).to.be('|');
            expect(utilx.Array.join([null, null], '|')).to.be('|');
            expect(utilx.Array.join([1, 2, 3], '|')).to.be('1|2|3');
            expect(utilx.Array.join([1, 2, 3], undefined)).to.be('1,2,3');
            expect(utilx.Array.join([1, 2, 3], null)).to.be('1null2null3');
            expect(utilx.Array.join([1, 2, 3], {})).to.be('1[object Object]2[object Object]3');
            expect(utilx.Array.join([1, 2, 3], '')).to.be('123');
        });
    });
}());

},{"../scripts/":10}],32:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.last', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.last();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.last(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.last(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(utilx.Array.last([])).to.be(undefined);
            expect(utilx.Array.last([1, 2, 3])).to.be(3);
            expect(utilx.Array.last(required.returnArgs(1, 2, 3))).to.be(3);
            expect(utilx.Array.last({
                0: 1,
                1: 2,
                2: 3,
                length: 3
            })).to.be(3);
        });
    });
}());

},{"../scripts/":10}],33:[function(require,module,exports){
/*global TypeError, describe, it, require */

/*properties
    '0', '1', '2', '3', '4', Array, a, be, expect, lastIn, length, returnArgs,
    throwException, to, utilx, prototype, call, hasOwnProperty
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.lastIn', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.lastIn();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.lastIn(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.lastIn(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            var arr = [0, 1, 2, 3, 4, 5, 6];

            delete arr[5];
            delete arr[6];

            expect(utilx.Array.lastIn(arr)).to.be(4);
        });

        it('arguments', function () {
            var args = required.returnArgs(0, 1, 2, 3, 4, 5, 6);

            // doesn't seem to work on Opera 9 or IE < 9
            delete args[5];
            delete args[6];

            if (!Object.prototype.hasOwnProperty.call(args, 5) && !Object.prototype.hasOwnProperty.call(args, 6)) {
                expect(utilx.Array.lastIn(args)).to.be(4);
            } else {
                expect(utilx.Array.lastIn(args)).to.be(6);
            }
        });

        it('object with length', function () {
            var obj = {
                    0: 0,
                    1: 1,
                    2: 2,
                    3: 3,
                    4: 4,
                    length: 7
                };

            expect(utilx.Array.lastIn(obj)).to.be(4);
        });
    });
}());

},{"../scripts/":10}],34:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.lastIndexOf', function () {
        var arr = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ],
            arr2 = required.create(2, 3, undefined, true, 'hej', null, 2, false, 0, 8, 9),
            arr3 = [0, 1, 2, 3, 4, 5];

        delete arr2[1];
        delete arr2[7];
        delete arr2[8];
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.lastIndexOf();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.lastIndexOf(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.lastIndexOf(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should find the string in array', function () {
            expect(utilx.Array.lastIndexOf(arr, 'toString')).to.be(0);
            expect(utilx.Array.lastIndexOf(arr, 'toLocaleString')).to.be(1);
            expect(utilx.Array.lastIndexOf(arr, 'valueOf')).to.be(2);
            expect(utilx.Array.lastIndexOf(arr, 'hasOwnProperty')).to.be(3);
            expect(utilx.Array.lastIndexOf(arr, 'isPrototypeOf')).to.be(4);
            expect(utilx.Array.lastIndexOf(arr, 'propertyIsEnumerable')).to.be(5);
            expect(utilx.Array.lastIndexOf(arr, 'constructor')).to.be(6);
        });

        it('should not find the string in array', function () {
            expect(utilx.Array.lastIndexOf(arr, 'foo')).to.be(-1);
            expect(utilx.Array.lastIndexOf(arr, 'bar')).to.be(-1);
            expect(utilx.Array.lastIndexOf(arr, 'fuz')).to.be(-1);
            expect(utilx.Array.lastIndexOf(arr, 'push')).to.be(-1);
            expect(utilx.Array.lastIndexOf(arr, 'pop')).to.be(-1);
        });

        it('should find the number in the array', function () {
            expect(utilx.Array.lastIndexOf(arr3, 0)).to.be(0);
            expect(utilx.Array.lastIndexOf(arr3, 1)).to.be(1);
            expect(utilx.Array.lastIndexOf(arr3, 2)).to.be(2);
            expect(utilx.Array.lastIndexOf(arr3, 3)).to.be(3);
            expect(utilx.Array.lastIndexOf(arr3, 4)).to.be(4);
            expect(utilx.Array.lastIndexOf(arr3, 5)).to.be(5);
        });

        it('should not find the number in the array', function () {
            expect(utilx.Array.lastIndexOf(arr3, 6)).to.be(-1);
            expect(utilx.Array.lastIndexOf(arr3, 7)).to.be(-1);
            expect(utilx.Array.lastIndexOf(arr3, 8)).to.be(-1);
            expect(utilx.Array.lastIndexOf(arr3, 9)).to.be(-1);
            expect(utilx.Array.lastIndexOf(arr3, 10)).to.be(-1);
        });

        it('should find the element', function () {
            expect(utilx.Array.lastIndexOf(arr2, 'hej')).to.be(4);
        });

        it('should not find the element', function () {
            expect(utilx.Array.lastIndexOf(arr2, 'mus')).to.be(-1);
        });

        it('should find undefined as well', function () {
            expect(utilx.Array.lastIndexOf(arr2, undefined)).to.not.be(-1);
        });

        it('should skip unset indexes', function () {
            expect(utilx.Array.lastIndexOf(arr2, undefined)).to.be(2);
        });

        it('should use a strict test', function () {
            expect(utilx.Array.lastIndexOf(arr2, null)).to.be(5);
            expect(utilx.Array.lastIndexOf(arr2, '2')).to.be(-1);
        });

        it('should skip the first if fromIndex is set', function () {
            expect(utilx.Array.lastIndexOf(arr2, 2, 2)).to.be(0);
            expect(utilx.Array.lastIndexOf(arr2, 2, 0)).to.be(0);
            expect(utilx.Array.lastIndexOf(arr2, 2, 6)).to.be(6);
        });

        it('should work with negative fromIndex', function () {
            expect(utilx.Array.lastIndexOf(arr2, 2, -3)).to.be(6);
            expect(utilx.Array.lastIndexOf(arr2, 2, -9)).to.be(0);
        });

        it('should work with fromIndex being greater than the length', function () {
            expect(utilx.Array.lastIndexOf(arr2, 2, 20)).to.be(6);
        });

        it('should work with fromIndex being negative and greater than the length', function () {
            expect(utilx.Array.lastIndexOf(arr2, 2, -20)).to.be(-1);
        });
    });
}());

},{"../scripts/":10}],35:[function(require,module,exports){
/*global Date, Error, Math, RegExp, TypeError, beforeEach, describe, it, require */

/*properties
    Array, a, be, call, create, eql, expect, isStrictMode, length, map,
    ok, pow, prototype, push, slice, throwException, to, toString, utilx,
    valueOf, isNaN, ToString, ToClass, charAt, global
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.map', function () {
        var lastIndex = Math.pow(2, 32) - 1,
            mapArray = required.create(0, 1, 2, 'a', 'b', 'c', [8, 9, 10], {}, true, false, undefined, null,
                                  new Date(), new Error('x'), new RegExp('t'), Infinity, -Infinity),
            testSubject,
            testIndex,
            callback;

        mapArray.length = 25;
        mapArray[24] = NaN;
        mapArray[25] = 'end';

        beforeEach(function () {
            var i = -1;

            testSubject = required.create(2, 3, undefined, true, 'hej', null, false, 0, 8, 9);
            delete testSubject[1];
            delete testSubject[8];
            callback = function () {
                i += 1;

                return i;
            };
        });

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.map();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.map(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.map(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if function argument is not a function', function () {
            expect(function () {
                utilx.Array.map(mapArray);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.map(mapArray, undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.map(mapArray, null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(utilx.Array.map(mapArray, function (element, index, array) {
                expect(array).to.be(mapArray);
                expect(typeof index === 'number').to.be.ok();
                expect(index >= 0).to.be.ok();
                expect(index <= lastIndex).to.be.ok();
                if (required.isNaN(element)) {
                    expect(required.isNaN(mapArray[index])).to.be(true);
                } else {
                    expect(element).to.be(mapArray[index]);
                }

                testIndex = index;

                return element;
            }).toString()).to.be(mapArray.toString());

            expect(testIndex).to.be(mapArray.length - 1);
        });

        it('should pass the right parameters', function () {
            var array = ['1'];

            utilx.Array.map(array, function (item, index, list) {
                expect(item).to.be('1');
                expect(index).to.be(0);
                expect(list).to.be(array);
            });
        });

        it('should set the context correctly', function () {
            var context = {};

            utilx.Array.map(testSubject, function (o, i) {
                this[i] = o;
            }, context);

            expect(context).to.eql(testSubject);
        });

        it('should set the right context when given none', function () {
            var context;

            utilx.Array.map([1], function () {
                context = this;
            });

            expect(context).to.be((function () {
                return function () {
                    return this;
                };
            }()).call());
        });

        it('should not change the array it is called on', function () {
            var copy = required.slice(testSubject);

            utilx.Array.map(testSubject, callback);
            expect(testSubject).to.eql(copy);
        });

        it('should only run for the number of objects in the array when it started', function () {
            var arr1 = [1, 2, 3, 4, 5],
                arr2 = [1, 2, 3, 4, 5, 4, 5, 6, 8],
                i = 0;

            delete arr1[3];
            delete arr2[3];
            utilx.Array.map(arr1, function (o) {
                arr1.push(o + 3);
                i += 1;

                return o;
            });

            expect(arr1).to.eql(arr2);
            expect(i).to.be(4);
        });

        it('should properly translate the values as according to the callback', function () {
            var result = utilx.Array.map(testSubject, callback),
                expected = [0, 0, 1, 2, 3, 4, 5, 6, 'a', 7];

            delete expected[1];
            delete expected[8];
            expect(result).to.eql(expected);
        });

        it('should skip non-existing values', function () {
            var array = [1, 2, 3, 4, 5, 6],
                i = 0;

            delete array[2];
            delete array[5];
            utilx.Array.map(array, function () {
                i += 1;
            });

            expect(i).to.be(4);
        });

        it('should have a boxed object as list argument of callback', function () {
            var actual;

            utilx.Array.map('foo', function (item, index, list) {
                /*jslint unparam: true */
                /*jshint unused: true */
                actual = list;
            });

            expect(typeof actual).to.be('object');
            expect(required.ToClass(actual)).to.be('[object String]');
            expect(required.ToString(actual)).to.be('foo');
            expect(actual.charAt(0)).to.be('f');
        });

        if (required.isStrictMode()) {
            it('does not autobox the content in strict mode', function () {
                var actual;

                utilx.Array.map([1], function () {
                    actual = this;
                }, 'x');

                expect(typeof actual).to.be('string');

                utilx.Array.map([1], function () {
                    actual = this;
                });

                expect(actual).to.be(undefined);

                utilx.Array.map([1], function () {
                    actual = this;
                }, undefined);

                expect(actual).to.be(undefined);

                utilx.Array.map([1], function () {
                    actual = this;
                }, null);

                expect(actual).to.be(null);
            });
        }
    });
}());

/*jslint sloppy: true */
(function () {
    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.map', function () {
        it('does autobox the content in non-strict mode', function () {
            var actual;

            utilx.Array.map([1], function () {
                actual = this;
            }, 'x');

            expect(typeof actual).to.be('object');

            utilx.Array.map([1], function () {
                actual = this;
            });

            expect(actual).to.be(required.global);

            utilx.Array.map([1], function () {
                actual = this;
            }, undefined);

            expect(actual).to.be(required.global);

            utilx.Array.map([1], function () {
                actual = this;
            }, null);

            expect(actual).to.be(required.global);
        });
    });
}());

},{"../scripts/":10}],36:[function(require,module,exports){
/*global require, describe, it */

/*properties
    Array, be, create, eql, expect, length, of, returnArgs, slice, to, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.of', function () {
        var test = required.create(1, null, undefined);

        /*
        it('test native slice on arguments', function () {
            var arr = Array.prototype.slice.call(required.returnArgs(1, null, undefined));

            expect(arr.length).to.be(3);
            expect(arr).to.eql(test);
        });
        */

        it('test utilx slice on arguments', function () {
            var arr = required.slice(required.returnArgs(1, null, undefined));

            expect(arr.length).to.be(3);
            expect(arr).to.eql(test);
        });

        it('test array should be length of 3 or have environment problem with array', function () {
            expect(test.length).to.be(3);
        });

        it('test arguments should be length of 3 or have environment problem with arguments', function () {
            expect(required.returnArgs(1, null, undefined).length).to.be(3);
        });

        it('test array from of should be length of 3 or possible slice problem', function () {
            expect(utilx.Array.of(1, null, undefined).length).to.be(3);
        });

        it('should create correct array of arguments equal to test array', function () {
            expect(utilx.Array.of(1, null, undefined)).to.eql(test);
        });
    });
}());

},{"../scripts/":10}],37:[function(require,module,exports){
/*global TypeError, describe, it, require */

/*properties
    '0', '1', '10', '11', '2', '3', '4', '5', '6', '7', '8', '9', Array, a, be,
    call, create, eql, expect, hasOwnProperty, length, ok, prototype, pop,
    returnArgs, slice, throwException, to, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.pop', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.pop();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.pop(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.pop(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('array', function () {
            var arrCmp = required.create(
                    undefined,
                    null,
                    -1,
                    0,
                    1,
                    false,
                    true,
                    undefined,
                    '',
                    'abc',
                    null,
                    undefined
                );

            expect(utilx.Array.pop(arrCmp)).to.be(undefined);
            expect(utilx.Array.pop(arrCmp)).to.be(null);
            expect(utilx.Array.pop(arrCmp)).to.be('abc');
            expect(utilx.Array.pop(arrCmp)).to.be('');
            expect(utilx.Array.pop(arrCmp)).to.be(undefined);
            expect(utilx.Array.pop(arrCmp)).to.be(true);
            expect(utilx.Array.pop(arrCmp)).to.be(false);
            expect(utilx.Array.pop(arrCmp)).to.be(1);
            expect(utilx.Array.pop(arrCmp)).to.be(0);
            expect(utilx.Array.pop(arrCmp)).to.be(-1);
            expect(utilx.Array.pop(arrCmp)).to.be(null);
            expect(utilx.Array.pop(arrCmp)).to.be(undefined);
            expect(arrCmp.length).to.be(0);
        });

        it('arguments', function () {
            var arrCmp = required.returnArgs(
                    undefined,
                    null,
                    -1,
                    0,
                    1,
                    false,
                    true,
                    undefined,
                    '',
                    'abc',
                    null,
                    undefined
                );

            expect(utilx.Array.pop(arrCmp)).to.be(undefined);
            expect(utilx.Array.pop(arrCmp)).to.be(null);
            expect(utilx.Array.pop(arrCmp)).to.be('abc');
            expect(utilx.Array.pop(arrCmp)).to.be('');
            expect(utilx.Array.pop(arrCmp)).to.be(undefined);
            expect(utilx.Array.pop(arrCmp)).to.be(true);
            expect(utilx.Array.pop(arrCmp)).to.be(false);
            expect(utilx.Array.pop(arrCmp)).to.be(1);
            expect(utilx.Array.pop(arrCmp)).to.be(0);
            expect(utilx.Array.pop(arrCmp)).to.be(-1);
            expect(utilx.Array.pop(arrCmp)).to.be(null);
            expect(utilx.Array.pop(arrCmp)).to.be(undefined);
            expect(arrCmp.length).to.be(0);
        });

        it('object with length', function () {
            var arrCmp = {
                    0: undefined,
                    1: null,
                    2: -1,
                    3: 0,
                    4: 1,
                    5: false,
                    6: true,
                    7: undefined,
                    8: '',
                    9: 'abc',
                    10: null,
                    11: undefined,
                    length: 12
                };

            expect(utilx.Array.pop(arrCmp)).to.be(undefined);
            expect(utilx.Array.pop(arrCmp)).to.be(null);
            expect(utilx.Array.pop(arrCmp)).to.be('abc');
            expect(utilx.Array.pop(arrCmp)).to.be('');
            expect(utilx.Array.pop(arrCmp)).to.be(undefined);
            expect(utilx.Array.pop(arrCmp)).to.be(true);
            expect(utilx.Array.pop(arrCmp)).to.be(false);
            expect(utilx.Array.pop(arrCmp)).to.be(1);
            expect(utilx.Array.pop(arrCmp)).to.be(0);
            expect(utilx.Array.pop(arrCmp)).to.be(-1);
            expect(utilx.Array.pop(arrCmp)).to.be(null);
            expect(utilx.Array.pop(arrCmp)).to.be(undefined);
            expect(arrCmp.length).to.be(0);
        });

        it('should not alter object without length', function () {
            var arrCmp = {
                    0: undefined,
                    1: null,
                    2: -1,
                    3: 0,
                    4: 1,
                    5: false,
                    6: true,
                    7: undefined,
                    8: '',
                    9: 'abc',
                    10: null,
                    11: undefined
                };

            expect(utilx.Array.pop(arrCmp)).to.be(undefined);
            expect(utilx.Array.pop(arrCmp)).to.be(undefined);
            expect(utilx.Array.pop(arrCmp)).to.be(undefined);
            expect(utilx.Array.pop(arrCmp)).to.be(undefined);
            expect(utilx.Array.pop(arrCmp)).to.be(undefined);
            expect(utilx.Array.pop(arrCmp)).to.be(undefined);
            expect(utilx.Array.pop(arrCmp)).to.be(undefined);
            expect(utilx.Array.pop(arrCmp)).to.be(undefined);
            expect(utilx.Array.pop(arrCmp)).to.be(undefined);
            expect(utilx.Array.pop(arrCmp)).to.be(undefined);
            expect(utilx.Array.pop(arrCmp)).to.be(undefined);
            expect(utilx.Array.pop(arrCmp)).to.be(undefined);
            expect(arrCmp[9]).to.be('abc');
            expect(arrCmp.length).to.be(0);
        });
    });
}());

},{"../scripts/":10}],38:[function(require,module,exports){
/*global TypeError, describe, it, require */

/*properties
    Array, Object, String, ToObject, a, array2Object, be, eql, expect, powerSet,
    returnArgs, throwException, to, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.powerSet', function () {
        var testSubject = [1, 2, 3],
            expected = [
                [],
                [ 3 ],
                [ 2 ],
                [ 2, 3 ],
                [ 1 ],
                [ 1, 3 ],
                [ 1, 2 ],
                [ 1, 2, 3 ]
            ];

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.powerSet();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.powerSet(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.powerSet(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('array', function () {
            expect(utilx.Array.powerSet(testSubject)).to.eql(expected);
        });

        it('object', function () {
            expect(utilx.Array.powerSet(required.array2Object(testSubject))).to.eql(expected);
        });

        it('arguments', function () {
            expect(utilx.Array.powerSet(required.returnArgs(1, 2, 3))).to.eql(expected);
        });

        it('string', function () {
            var a = 'abc',
                res = utilx.Array.powerSet(a);

            expected = [
                [],
                [ 'c' ],
                [ 'b' ],
                [ 'b', 'c' ],
                [ 'a' ],
                [ 'a', 'c' ],
                [ 'a', 'b' ],
                [ 'a', 'b', 'c' ]
            ];

            expect(res).to.eql(expected);
        });
    });
}());

},{"../scripts/":10}],39:[function(require,module,exports){
/*global Object, TypeError, describe, it, require */

/*properties
    '0', '1', '10', '11', '2', '3', '4', '5', '6', '7', '8', '9', Array, a, be,
    call, create, eql, expect, hasOwnProperty, length, ok, prototype, push,
    returnArgs, slice, throwException, to, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.push', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.push();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.push(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.push(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('array', function () {
            var arrCmp = required.create(
                    undefined,
                    null,
                    -1,
                    0,
                    1,
                    false,
                    true,
                    undefined,
                    '',
                    'abc',
                    null,
                    undefined
                ),
                arr = [],
                i;

            expect(utilx.Array.push(arr, undefined)).to.be(1);
            expect(utilx.Array.push(arr, null)).to.be(2);
            expect(utilx.Array.push(arr, -1)).to.be(3);
            expect(utilx.Array.push(arr, 0)).to.be(4);
            expect(utilx.Array.push(arr, 1)).to.be(5);
            expect(utilx.Array.push(arr, false)).to.be(6);
            expect(utilx.Array.push(arr, true)).to.be(7);
            expect(utilx.Array.push(arr)).to.be(7);
            expect(utilx.Array.push(arr)).to.be(7);
            expect(utilx.Array.push(arr)).to.be(7);
            expect(utilx.Array.push(arr)).to.be(7);
            expect(utilx.Array.push(arr, undefined)).to.be(8);
            expect(utilx.Array.push(arr, '')).to.be(9);
            expect(utilx.Array.push(arr, 'abc')).to.be(10);
            expect(utilx.Array.push(arr, null)).to.be(11);
            expect(utilx.Array.push(arr, undefined)).to.be(12);
            expect(arr.length).to.be(arrCmp.length);
            for (i = 0; i < arr.length; i += 1) {
                expect(Object.prototype.hasOwnProperty.call(arr, i)).to.be.ok();
                expect(arr[i]).to.be(arrCmp[i]);
            }

            expect(arr).to.eql(arrCmp);
        });

        it('arguments', function () {
            var arrCmp = required.create(
                    undefined,
                    null,
                    -1,
                    0,
                    1,
                    false,
                    true,
                    undefined,
                    '',
                    'abc',
                    null,
                    undefined
                ),
                arr = required.returnArgs(),
                i;

            expect(utilx.Array.push(arr, undefined)).to.be(1);
            expect(utilx.Array.push(arr, null)).to.be(2);
            expect(utilx.Array.push(arr, -1)).to.be(3);
            expect(utilx.Array.push(arr, 0)).to.be(4);
            expect(utilx.Array.push(arr, 1)).to.be(5);
            expect(utilx.Array.push(arr, false)).to.be(6);
            expect(utilx.Array.push(arr, true)).to.be(7);
            expect(utilx.Array.push(arr)).to.be(7);
            expect(utilx.Array.push(arr)).to.be(7);
            expect(utilx.Array.push(arr)).to.be(7);
            expect(utilx.Array.push(arr)).to.be(7);
            expect(utilx.Array.push(arr, undefined)).to.be(8);
            expect(utilx.Array.push(arr, '')).to.be(9);
            expect(utilx.Array.push(arr, 'abc')).to.be(10);
            expect(utilx.Array.push(arr, null)).to.be(11);
            expect(utilx.Array.push(arr, undefined)).to.be(12);
            expect(arr.length).to.be(arrCmp.length);
            for (i = 0; i < arr.length; i += 1) {
                expect(Object.prototype.hasOwnProperty.call(arr, i)).to.be.ok();
                expect(arr[i]).to.be(arrCmp[i]);
            }

            expect(required.slice(arr)).to.eql(arrCmp);
        });

        it('object with length', function () {
            var arrCmp = {
                    0: undefined,
                    1: null,
                    2: -1,
                    3: 0,
                    4: 1,
                    5: false,
                    6: true,
                    7: undefined,
                    8: '',
                    9: 'abc',
                    10: null,
                    11: undefined,
                    length: 12
                },
                arr = {
                    length: 0
                },
                i;

            expect(utilx.Array.push(arr, undefined)).to.be(1);
            expect(utilx.Array.push(arr, null)).to.be(2);
            expect(utilx.Array.push(arr, -1)).to.be(3);
            expect(utilx.Array.push(arr, 0)).to.be(4);
            expect(utilx.Array.push(arr, 1)).to.be(5);
            expect(utilx.Array.push(arr, false)).to.be(6);
            expect(utilx.Array.push(arr, true)).to.be(7);
            expect(utilx.Array.push(arr)).to.be(7);
            expect(utilx.Array.push(arr)).to.be(7);
            expect(utilx.Array.push(arr)).to.be(7);
            expect(utilx.Array.push(arr)).to.be(7);
            expect(utilx.Array.push(arr, undefined)).to.be(8);
            expect(utilx.Array.push(arr, '')).to.be(9);
            expect(utilx.Array.push(arr, 'abc')).to.be(10);
            expect(utilx.Array.push(arr, null)).to.be(11);
            expect(utilx.Array.push(arr, undefined)).to.be(12);
            expect(arr.length).to.be(arrCmp.length);
            for (i = 0; i < arr.length; i += 1) {
                expect(Object.prototype.hasOwnProperty.call(arr, i)).to.be.ok();
                expect(arr[i]).to.be(arrCmp[i]);
            }

            expect(arr).to.eql(arrCmp);
        });

        it('object without length', function () {
            var arrCmp = {
                    0: undefined,
                    1: null,
                    2: -1,
                    3: 0,
                    4: 1,
                    5: false,
                    6: true,
                    7: undefined,
                    8: '',
                    9: 'abc',
                    10: null,
                    11: undefined,
                    length: 12
                },
                arr = {},
                i;

            expect(utilx.Array.push(arr, undefined)).to.be(1);
            expect(utilx.Array.push(arr, null)).to.be(2);
            expect(utilx.Array.push(arr, -1)).to.be(3);
            expect(utilx.Array.push(arr, 0)).to.be(4);
            expect(utilx.Array.push(arr, 1)).to.be(5);
            expect(utilx.Array.push(arr, false)).to.be(6);
            expect(utilx.Array.push(arr, true)).to.be(7);
            expect(utilx.Array.push(arr)).to.be(7);
            expect(utilx.Array.push(arr)).to.be(7);
            expect(utilx.Array.push(arr)).to.be(7);
            expect(utilx.Array.push(arr)).to.be(7);
            expect(utilx.Array.push(arr, undefined)).to.be(8);
            expect(utilx.Array.push(arr, '')).to.be(9);
            expect(utilx.Array.push(arr, 'abc')).to.be(10);
            expect(utilx.Array.push(arr, null)).to.be(11);
            expect(utilx.Array.push(arr, undefined)).to.be(12);
            expect(arr.length).to.be(arrCmp.length);
            for (i = 0; i < arr.length; i += 1) {
                expect(Object.prototype.hasOwnProperty.call(arr, i)).to.be.ok();
                expect(arr[i]).to.be(arrCmp[i]);
            }

            expect(arr).to.eql(arrCmp);
        });
    });
}());

},{"../scripts/":10}],40:[function(require,module,exports){
/*global Error, TypeError, beforeEach, describe, it, require */

/*properties
    '1', '3', Array, a, be, call, eql, expect, join, prototype, push, reduce,
    slice, throwException, to, toString, utilx, valueOf, ToString, ToClass, charAt,
    isStrictMode, global
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.reduce', function () {
        var testSubject;

        beforeEach(function () {
            testSubject = [1, 2, 3];
        });

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.reduce();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.reduce(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.reduce(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if function argument is not a function', function () {
            expect(function () {
                utilx.Array.reduce([]);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.reduce([], undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.reduce([], null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should pass the right parameters', function () {
            var array = ['1'];

            utilx.Array.reduce(array, function (prev, item, index, list) {
                expect(prev).to.be('');
                expect(item).to.be('1');
                expect(index).to.be(0);
                expect(list).to.be(array);
            }, '');
        });

        it('should start with the right initialValue', function () {
            var array = ['1'];

            utilx.Array.reduce(array, function (prev, item, index, list) {
                expect(prev).to.be(10);
                expect(item).to.be('1');
                expect(index).to.be(0);
                expect(list).to.be(array);
            }, 10);
        });


        it('should not affect elements added to the array after it has begun', function () {
            var arr = [1, 2, 3],
                i = 0;

            utilx.Array.reduce(arr, function (a, b) {
                i += 1;
                if (i <= 4) {
                    arr.push(a + 3);
                }

                return b;
            });

            expect(arr).to.eql([1, 2, 3, 4, 5]);
            expect(i).to.be(2);
        });

        it('should work as expected for empty arrays', function () {
            expect(function () {
                utilx.Array.reduce([], function () {
                    throw new Error('function should not be called!');
                });
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should return the expected result', function () {
            expect(utilx.Array.reduce(testSubject, function (a, b) {
                return required.ToString(a || '') + required.ToString(b || '');
            })).to.eql(utilx.Array.join(testSubject, ''));
        });

        it('should not directly affect the passed array', function () {
            var copy = required.slice(testSubject);

            utilx.Array.reduce(testSubject, function (a, b) {
                return a + b;
            });

            expect(testSubject).to.eql(copy);
        });

        it('should skip non-set values', function () {
            delete testSubject[1];
            var visited = {};

            utilx.Array.reduce(testSubject, function (a, b) {
                if (a) {
                    visited[a] = true;
                }

                if (b) {
                    visited[b] = true;
                }

                return 0;
            });

            expect(visited).to.eql({
                1: true,
                3: true
            });
        });

        it('should have a boxed object as list argument of callback', function () {
            var actual;

            utilx.Array.reduce('foo', function (previous, item, index, list) {
                /*jslint unparam: true */
                /*jshint unused: true */
                actual = list;
            });

            expect(typeof actual).to.be('object');
            expect(required.ToClass(actual)).to.be('[object String]');
            expect(required.ToString(actual)).to.be('foo');
            expect(actual.charAt(0)).to.be('f');
        });

        if (required.isStrictMode()) {
            it('has the correct context ins strict mode', function () {
                var actual;

                utilx.Array.reduce([1], function () {
                    actual = this;
                });

                expect(actual).to.be(undefined);

                utilx.Array.reduce([1, 2], function () {
                    actual = this;
                });

                expect(actual).to.be(undefined);
            });
        }
    });
}());

/*jslint sloppy: true */
(function () {
    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.reduce', function () {
        it('has the correct context in non-strict mode', function () {
            var actual;

            utilx.Array.reduce([1], function () {
                actual = this;
            });

            expect(actual).to.be(undefined);

            utilx.Array.reduce([1, 2], function () {
                actual = this;
            });

            expect(actual).to.be(required.global);
        });
    });
}());

},{"../scripts/":10}],41:[function(require,module,exports){
/*global TypeError, beforeEach, describe, it, require */

/*properties
    '1', '3', Array, String, ToString, a, array2Object, be, call, eql, expect,
    not, ok, prototype, push, reduceRight, slice, throwException, to, toString,
    utilx, valueOf, ToString, ToClass, isStrictMode, global
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.reduceRight', function () {
        var testSubject,
            testSubject2;

        beforeEach(function () {
            testSubject = [1, 2, 3];
            testSubject2 = required.array2Object(testSubject);
        });

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.reduceRight();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.reduceRight(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.reduceRight(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if function argument is not a function', function () {
            expect(function () {
                utilx.Array.reduceRight([]);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.reduceRight([], undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.reduceRight([], null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should pass the correct arguments to the callback', function () {
            var array = ['1', '2', '3'],
                progress = ['321', '32', '3'],
                i = 2;

            utilx.Array.reduceRight(array, function (prev, item, index, list) {
                expect(item).to.be(array[index]);
                expect(index).to.be(i);
                i -= 1;
                expect(list).to.be(array);
                prev += item;
                expect(prev).to.be(progress[index]);

                return prev;
            }, '');
        });

        it('should start with the right initialValue', function () {
            utilx.Array.reduceRight(['1'], function (prev) {
                expect(prev).to.be(0);

                return prev;
            }, 0);
        });

        it('should not affect elements added to the array after it has begun', function () {
            var arr = [1, 2, 3],
                i = 0;

            utilx.Array.reduceRight(arr, function (a, b) {
                i += 1;
                if (i <= 4) {
                    arr.push(a + 3);
                }

                return b;
            });

            expect(arr).to.eql([1, 2, 3, 6, 5]);
            expect(i).to.be(2);
        });

        it('should work as expected for empty arrays', function () {
            var called = false;

            expect(function () {
                utilx.Array.reduceRight([], function () {
                    called = true;
                });
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(called).to.not.be.ok();
        });

        it('should work as expected for empty arrays with an initial value', function () {
            var called = false,
                result = utilx.Array.reduceRight([], function (prev) {
                    called = true;

                    return prev;
                }, '');

            expect(called).to.not.be.ok();
            expect(result).to.be('');
        });

        it('should return the expected result', function () {
            expect(utilx.Array.reduceRight(testSubject, function (a, b) {
                return required.ToString(a || '') + required.ToString(b || '');
            })).to.be('321');
        });

        it('should not directly affect the passed array', function () {
            var copy = required.slice(testSubject);

            utilx.Array.reduceRight(testSubject, function (a, b) {
                return a + b;
            });

            expect(testSubject).to.eql(copy);
        });

        it('should skip non-set values', function () {
            delete testSubject[1];

            var visited = {};

            utilx.Array.reduceRight(testSubject, function (a, b) {
                if (a) {
                    visited[a] = true;
                }

                if (b) {
                    visited[b] = true;
                }

                return 0;
            });

            expect(visited).to.eql({
                1: true,
                3: true
            });
        });

        it('should pass the correct arguments to the callback', function () {
            var array = ['1', '2', '3'],
                progress = ['321', '32', '3'],
                i = 2;

            utilx.Array.reduceRight(array, function (prev, item, index, list) {
                expect(item).to.be(array[index]);
                expect(index).to.be(i);
                i -= 1;
                expect(list).to.be(array);
                prev += item;
                expect(prev).to.be(progress[index]);

                return prev;
            }, '');
        });

        it('should start with the right initialValue', function () {
            utilx.Array.reduceRight(['1'], function (prev) {
                expect(prev).to.be(0);

                return prev;
            }, 0);
        });

        it('should not affect elements added to the array after it has begun', function () {
            var arr = [1, 2, 3],
                i = 0;

            utilx.Array.reduceRight(arr, function (a, b) {
                i += 1;
                if (i <= 4) {
                    arr.push(a + 3);
                }

                return b;
            });

            expect(arr).to.eql([1, 2, 3, 6, 5]);
            expect(i).to.be(2);
        });

        it('should work as expected for empty arrays', function () {
            var called = false;

            expect(function () {
                utilx.Array.reduceRight([], function () {
                    called = true;
                });
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(called).to.not.be.ok();
        });

        it('should work as expected for empty arrays with an initial value', function () {
            var called = false,
                result = utilx.Array.reduceRight([], function (prev) {
                    called = true;

                    return prev;
                }, '');

            expect(called).to.not.be.ok();
            expect(result).to.be('');
        });

        it('should return the expected result', function () {
            expect(utilx.Array.reduceRight(testSubject2, function (a, b) {
                return required.ToString(a || '') + required.ToString(b || '');
            })).to.be('321');
        });

        it('should not directly affect the passed array', function () {
            var copy = required.array2Object(testSubject);

            utilx.Array.reduceRight(testSubject2, function (a, b) {
                return a + b;
            });

            expect(testSubject2).to.eql(copy);
        });

        it('should skip non-set values', function () {
            delete testSubject2[1];

            var visited = {};

            utilx.Array.reduceRight(testSubject2, function (a, b) {
                if (a) {
                    visited[a] = true;
                }

                if (b) {
                    visited[b] = true;
                }

                return 0;
            });

            expect(visited).to.eql({
                1: true,
                3: true
            });
        });

        it('should have a boxed object as list argument of callback', function () {
            var actual;

            utilx.Array.reduceRight('foo', function (accumulator, item, index, list) {
                /*jslint unparam: true */
                /*jshint unused: false */
                actual = list;
            });

            expect(typeof actual).to.be('object');
            expect(required.ToClass(actual)).to.be('[object String]');
        });

        if (required.isStrictMode()) {
            it('has the correct context ins strict mode', function () {
                var actual;

                utilx.Array.reduceRight([1], function () {
                    actual = this;
                });

                expect(actual).to.be(undefined);

                utilx.Array.reduceRight([1, 2], function () {
                    actual = this;
                });

                expect(actual).to.be(undefined);
            });
        }
    });
}());

/*jslint sloppy: true */
(function () {
    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.reduceRight', function () {
        it('has the correct context in non-strict mode', function () {
            var actual;

            utilx.Array.reduceRight([1], function () {
                actual = this;
            });

            expect(actual).to.be(undefined);

            utilx.Array.reduceRight([1, 2], function () {
                actual = this;
            });

            expect(actual).to.be(required.global);
        });
    });
}());

},{"../scripts/":10}],42:[function(require,module,exports){
/*global TypeError, describe, it, require */

/*properties
    '0', '1', '10', '11', '2', '3', '4', '5', '6', '7', '8', '9', Array, a, be,
    call, create, eql, expect, hasOwnProperty, length, ok, prototype, reverse,
    returnArgs, slice, throwException, to, utilx, not
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.reverse', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.reverse();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.reverse(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.reverse(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw if argument primitive', function () {
            expect(function () {
                utilx.Array.reverse(1);
            }).to.not.throwException();

            expect(function () {
                utilx.Array.reverse(true);
            }).to.not.throwException();

            expect(function () {
                utilx.Array.reverse('a');
            }).to.not.throwException();
        });

        it('array', function () {
            var arrCmp = required.create(
                    undefined,
                    null,
                    -1,
                    0,
                    1,
                    false,
                    true,
                    undefined,
                    '',
                    'abc',
                    null,
                    undefined
                );

            expect(function () {
                utilx.Array.reverse(arrCmp);
            }).to.not.throwException();

            expect(arrCmp.length).to.be(12);
            expect(arrCmp[11]).to.be(undefined);
            expect(Object.prototype.hasOwnProperty.call(arrCmp, 11)).to.be.ok();
            expect(arrCmp[10]).to.be(null);
            expect(arrCmp[9]).to.be(-1);
            expect(arrCmp[8]).to.be(0);
            expect(arrCmp[7]).to.be(1);
            expect(arrCmp[6]).to.be(false);
            expect(arrCmp[5]).to.be(true);
            expect(arrCmp[4]).to.be(undefined);
            expect(Object.prototype.hasOwnProperty.call(arrCmp, 4)).to.be.ok();
            expect(arrCmp[3]).to.be('');
            expect(arrCmp[2]).to.be('abc');
            expect(arrCmp[1]).to.be(null);
            expect(arrCmp[0]).to.be(undefined);
            expect(Object.prototype.hasOwnProperty.call(arrCmp, 0)).to.be.ok();

            arrCmp = required.create(
                undefined,
                null,
                -1,
                0,
                1,
                false,
                true,
                undefined,
                '',
                'abc',
                null,
                undefined
            );

            delete arrCmp[7];

            expect(function () {
                utilx.Array.reverse(arrCmp);
            }).to.not.throwException();

            expect(arrCmp.length).to.be(12);
            expect(arrCmp[11]).to.be(undefined);
            expect(Object.prototype.hasOwnProperty.call(arrCmp, 11)).to.be.ok();
            expect(arrCmp[10]).to.be(null);
            expect(arrCmp[9]).to.be(-1);
            expect(arrCmp[8]).to.be(0);
            expect(arrCmp[7]).to.be(1);
            expect(arrCmp[6]).to.be(false);
            expect(arrCmp[5]).to.be(true);
            expect(arrCmp[4]).to.be(undefined);
            expect(!Object.prototype.hasOwnProperty.call(arrCmp, 4)).to.be.ok();
            expect(arrCmp[3]).to.be('');
            expect(arrCmp[2]).to.be('abc');
            expect(arrCmp[1]).to.be(null);
            expect(arrCmp[0]).to.be(undefined);
            expect(Object.prototype.hasOwnProperty.call(arrCmp, 0)).to.be.ok();
        });

        it('arguments', function () {
            var arrCmp = required.returnArgs(
                    undefined,
                    null,
                    -1,
                    0,
                    1,
                    false,
                    true,
                    undefined,
                    '',
                    'abc',
                    null,
                    undefined
                );

            expect(function () {
                utilx.Array.reverse(arrCmp);
            }).to.not.throwException();

            expect(arrCmp.length).to.be(12);
            expect(arrCmp[11]).to.be(undefined);
            expect(Object.prototype.hasOwnProperty.call(arrCmp, 11)).to.be.ok();
            expect(arrCmp[10]).to.be(null);
            expect(arrCmp[9]).to.be(-1);
            expect(arrCmp[8]).to.be(0);
            expect(arrCmp[7]).to.be(1);
            expect(arrCmp[6]).to.be(false);
            expect(arrCmp[5]).to.be(true);
            expect(arrCmp[4]).to.be(undefined);
            expect(Object.prototype.hasOwnProperty.call(arrCmp, 4)).to.be.ok();
            expect(arrCmp[3]).to.be('');
            expect(arrCmp[2]).to.be('abc');
            expect(arrCmp[1]).to.be(null);
            expect(arrCmp[0]).to.be(undefined);
            expect(Object.prototype.hasOwnProperty.call(arrCmp, 0)).to.be.ok();
        });

        it('object with length', function () {
            var arrCmp = {
                    0: undefined,
                    1: null,
                    2: -1,
                    3: 0,
                    4: 1,
                    5: false,
                    6: true,
                    7: undefined,
                    8: '',
                    9: 'abc',
                    10: null,
                    11: undefined,
                    length: 12
                };

            expect(function () {
                utilx.Array.reverse(arrCmp);
            }).to.not.throwException();

            expect(arrCmp.length).to.be(12);
            expect(arrCmp[11]).to.be(undefined);
            expect(Object.prototype.hasOwnProperty.call(arrCmp, 11)).to.be.ok();
            expect(arrCmp[10]).to.be(null);
            expect(arrCmp[9]).to.be(-1);
            expect(arrCmp[8]).to.be(0);
            expect(arrCmp[7]).to.be(1);
            expect(arrCmp[6]).to.be(false);
            expect(arrCmp[5]).to.be(true);
            expect(arrCmp[4]).to.be(undefined);
            expect(Object.prototype.hasOwnProperty.call(arrCmp, 4)).to.be.ok();
            expect(arrCmp[3]).to.be('');
            expect(arrCmp[2]).to.be('abc');
            expect(arrCmp[1]).to.be(null);
            expect(arrCmp[0]).to.be(undefined);
            expect(Object.prototype.hasOwnProperty.call(arrCmp, 0)).to.be.ok();
        });

        it('should not alter object without length', function () {
            var arrCmp = {
                    0: undefined,
                    1: null,
                    2: -1,
                    3: 0,
                    4: 1,
                    5: false,
                    6: true,
                    7: undefined,
                    8: '',
                    9: 'abc',
                    10: null,
                    11: undefined
                };

            expect(function () {
                utilx.Array.reverse(arrCmp);
            }).to.not.throwException();

            expect(arrCmp.length).to.be(undefined);
            expect(arrCmp[0]).to.be(undefined);
            expect(Object.prototype.hasOwnProperty.call(arrCmp, 11)).to.be.ok();
            expect(arrCmp[1]).to.be(null);
            expect(arrCmp[2]).to.be(-1);
            expect(arrCmp[3]).to.be(0);
            expect(arrCmp[4]).to.be(1);
            expect(arrCmp[5]).to.be(false);
            expect(arrCmp[6]).to.be(true);
            expect(arrCmp[7]).to.be(undefined);
            expect(Object.prototype.hasOwnProperty.call(arrCmp, 4)).to.be.ok();
            expect(arrCmp[8]).to.be('');
            expect(arrCmp[9]).to.be('abc');
            expect(arrCmp[10]).to.be(null);
            expect(arrCmp[11]).to.be(undefined);
            expect(Object.prototype.hasOwnProperty.call(arrCmp, 0)).to.be.ok();
        });
    });
}());

},{"../scripts/":10}],43:[function(require,module,exports){
/*global TypeError, describe, it, require */

/*properties
    '0', '1', '10', '11', '2', '3', '4', '5', '6', '7', '8', '9', Array, a, be,
    call, create, eql, expect, hasOwnProperty, length, ok, prototype, shift,
    returnArgs, slice, throwException, to, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.shift', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.shift();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.shift(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.shift(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('array', function () {
            var arrCmp = required.create(
                    undefined,
                    null,
                    -1,
                    0,
                    1,
                    false,
                    true,
                    undefined,
                    '',
                    'abc',
                    null,
                    undefined
                );

            expect(utilx.Array.shift(arrCmp)).to.be(undefined);
            expect(utilx.Array.shift(arrCmp)).to.be(null);
            expect(utilx.Array.shift(arrCmp)).to.be(-1);
            expect(utilx.Array.shift(arrCmp)).to.be(0);
            expect(utilx.Array.shift(arrCmp)).to.be(1);
            expect(utilx.Array.shift(arrCmp)).to.be(false);
            expect(utilx.Array.shift(arrCmp)).to.be(true);
            expect(utilx.Array.shift(arrCmp)).to.be(undefined);
            expect(utilx.Array.shift(arrCmp)).to.be('');
            expect(utilx.Array.shift(arrCmp)).to.be('abc');
            expect(utilx.Array.shift(arrCmp)).to.be(null);
            expect(utilx.Array.shift(arrCmp)).to.be(undefined);
            expect(arrCmp.length).to.be(0);
        });

        it('arguments', function () {
            var arrCmp = required.returnArgs(
                    undefined,
                    null,
                    -1,
                    0,
                    1,
                    false,
                    true,
                    undefined,
                    '',
                    'abc',
                    null,
                    undefined
                );

            expect(utilx.Array.shift(arrCmp)).to.be(undefined);
            expect(utilx.Array.shift(arrCmp)).to.be(null);
            expect(utilx.Array.shift(arrCmp)).to.be(-1);
            expect(utilx.Array.shift(arrCmp)).to.be(0);
            expect(utilx.Array.shift(arrCmp)).to.be(1);
            expect(utilx.Array.shift(arrCmp)).to.be(false);
            expect(utilx.Array.shift(arrCmp)).to.be(true);
            expect(utilx.Array.shift(arrCmp)).to.be(undefined);
            expect(utilx.Array.shift(arrCmp)).to.be('');
            expect(utilx.Array.shift(arrCmp)).to.be('abc');
            expect(utilx.Array.shift(arrCmp)).to.be(null);
            expect(utilx.Array.shift(arrCmp)).to.be(undefined);
            expect(arrCmp.length).to.be(0);
        });

        it('object with length', function () {
            var arrCmp = {
                    0: undefined,
                    1: null,
                    2: -1,
                    3: 0,
                    4: 1,
                    5: false,
                    6: true,
                    7: undefined,
                    8: '',
                    9: 'abc',
                    10: null,
                    11: undefined,
                    length: 12
                };

            expect(utilx.Array.shift(arrCmp)).to.be(undefined);
            expect(utilx.Array.shift(arrCmp)).to.be(null);
            expect(utilx.Array.shift(arrCmp)).to.be(-1);
            expect(utilx.Array.shift(arrCmp)).to.be(0);
            expect(utilx.Array.shift(arrCmp)).to.be(1);
            expect(utilx.Array.shift(arrCmp)).to.be(false);
            expect(utilx.Array.shift(arrCmp)).to.be(true);
            expect(utilx.Array.shift(arrCmp)).to.be(undefined);
            expect(utilx.Array.shift(arrCmp)).to.be('');
            expect(utilx.Array.shift(arrCmp)).to.be('abc');
            expect(utilx.Array.shift(arrCmp)).to.be(null);
            expect(utilx.Array.shift(arrCmp)).to.be(undefined);
            expect(arrCmp.length).to.be(0);
        });

        it('should not alter object without length', function () {
            var arrCmp = {
                    0: undefined,
                    1: null,
                    2: -1,
                    3: 0,
                    4: 1,
                    5: false,
                    6: true,
                    7: undefined,
                    8: '',
                    9: 'abc',
                    10: null,
                    11: undefined
                };

            expect(utilx.Array.shift(arrCmp)).to.be(undefined);
            expect(utilx.Array.shift(arrCmp)).to.be(undefined);
            expect(utilx.Array.shift(arrCmp)).to.be(undefined);
            expect(utilx.Array.shift(arrCmp)).to.be(undefined);
            expect(utilx.Array.shift(arrCmp)).to.be(undefined);
            expect(utilx.Array.shift(arrCmp)).to.be(undefined);
            expect(utilx.Array.shift(arrCmp)).to.be(undefined);
            expect(utilx.Array.shift(arrCmp)).to.be(undefined);
            expect(utilx.Array.shift(arrCmp)).to.be(undefined);
            expect(utilx.Array.shift(arrCmp)).to.be(undefined);
            expect(utilx.Array.shift(arrCmp)).to.be(undefined);
            expect(utilx.Array.shift(arrCmp)).to.be(undefined);
            expect(arrCmp[9]).to.be('abc');
            expect(arrCmp.length).to.be(0);
        });
    });
}());

},{"../scripts/":10}],44:[function(require,module,exports){
/*global TypeError, describe, it, require */

/*properties
    '0', '1', '2', '3', Array, a, be, concat, eql, expect, join, length,
    noop, not, returnArgs, shuffle, slice, sort, split, throwException, to,
    utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.shuffle', function () {
        it('should throw a TypeError in each case', function () {
            expect(function () {
                utilx.Array.shuffle();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.shuffle(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.shuffle(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should work with arrays', function () {
            var arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9],
                arr2 = arr1.slice(),
                arr3 = [],
                arr4,
                arr5;

            arr3.length = 1;
            arr5 = arr1.slice();
            arr5.length = arr1.length + 1;

            utilx.Array.shuffle(arr2);
            expect(arr2.length).to.be(arr1.length);
            expect(arr2).to.not.eql(arr1);
            expect(arr2.sort()).to.eql(arr1);

            arr2 = arr1.slice();
            utilx.Array.shuffle(arr2, 5);
            expect(arr2.length).to.be(arr1.length);
            expect(arr2).to.not.eql(arr1);
            expect(arr2.sort()).to.eql(arr1);

            arr2 = arr1.slice();
            utilx.Array.shuffle(arr2, '5');
            expect(arr2.length).to.be(arr1.length);
            expect(arr2).to.not.eql(arr1);
            expect(arr2.sort()).to.eql(arr1);

            arr4 = arr3.concat(arr1.slice());
            utilx.Array.shuffle(arr4);
            expect(arr4.length).to.be(arr5.length);
            expect(arr4).to.not.eql(arr5);
            expect(arr4.sort()).to.eql(arr5);

            arr4 = arr3.concat(arr1.slice());
            utilx.Array.shuffle(arr4, '5');
            expect(arr4.length).to.be(arr5.length);
            expect(arr4).to.not.eql(arr5);
            expect(arr4.sort()).to.eql(arr5);
        });

        it('should work with strings', function () {
            var arr1 = '123456789',
                arr2 = '123456789',
                arr3 = '',
                result;

            expect(function () {
                result = utilx.Array.shuffle(arr1);
            }).to.not.throwException();
            expect(result.length).to.be(arr1.length);
            expect(result).to.not.be(arr1);
            expect(result.split('').sort().join('')).to.be(arr1);

            expect(function () {
                result = utilx.Array.shuffle(arr2, 5);
            }).to.not.throwException();
            expect(result.length).to.be(arr2.length);
            expect(result).to.not.be(arr2);
            expect(result.split('').sort().join('')).to.be(arr2);

            expect(function () {
                result = utilx.Array.shuffle(arr2, '5');
            }).to.not.throwException();
            expect(result.length).to.be(arr2.length);
            expect(result).to.not.be(arr2);
            expect(result.split('').sort().join('')).to.be(arr2);

            expect(function () {
                result = utilx.Array.shuffle(arr3);
            }).to.not.throwException();
            expect(result.length).to.be(arr3.length);

            expect(function () {
                result = utilx.Array.shuffle(arr3, '5');
            }).to.not.throwException();
            expect(result.length).to.be(arr3.length);
        });

        it('should work with objects with length', function () {
            var obj1 = {
                    0: 1,
                    1: 2,
                    2: 3,
                    length: 3
                },
                obj2 = {
                    0: 1,
                    1: 2,
                    2: 3,
                    length: 3
                },
                obj3 = {
                    1: 2,
                    2: 3,
                    3: 1,
                    length: 4
                };

            utilx.Array.shuffle(obj1);
            expect(obj1.length).to.be(3);

            utilx.Array.shuffle(obj2, 5);
            expect(obj2.length).to.be(3);

            utilx.Array.shuffle(obj2, '5');
            expect(obj2.length).to.be(3);

            utilx.Array.shuffle(obj3);
            expect(obj3.length).to.be(4);

            utilx.Array.shuffle(obj3, '5');
            expect(obj3.length).to.be(4);
        });

        it('should do nothing with objects without length', function () {
            var obj1 = {
                    0: 1,
                    1: 2,
                    2: 3
                },
                obj2 = {
                    0: 1,
                    1: 2,
                    2: 3
                },
                obj3 = {
                    1: 2,
                    2: 3,
                    3: 1
                };

            utilx.Array.shuffle(obj1);
            expect(obj1).to.eql({
                0: 1,
                1: 2,
                2: 3
            });
            expect(obj1.length).to.be(undefined);

            utilx.Array.shuffle(obj2, 5);
            expect(obj2).to.eql({
                0: 1,
                1: 2,
                2: 3
            });
            expect(obj2.length).to.be(undefined);

            utilx.Array.shuffle(obj2, '5');
            expect(obj2).to.eql({
                0: 1,
                1: 2,
                2: 3
            });
            expect(obj2.length).to.be(undefined);

            utilx.Array.shuffle(obj3);
            expect(obj3).to.eql({
                1: 2,
                2: 3,
                3: 1
            });
            expect(obj3.length).to.be(undefined);

            utilx.Array.shuffle(obj3, '5');
            expect(obj3).to.eql({
                1: 2,
                2: 3,
                3: 1
            });
            expect(obj3.length).to.be(undefined);
        });

        it('should do nothing with others', function () {
            var arr1 = 123456789,
                arr2 = required.noop,
                arr3 = true;

            arr1 = utilx.Array.shuffle(arr1);
            expect(arr1).to.be(arr1);

            arr2 = utilx.Array.shuffle(arr2, 5);
            expect(arr2).to.be(arr2);

            arr2 = utilx.Array.shuffle(arr2, '5');
            expect(arr2).to.be(arr2);

            arr3 = utilx.Array.shuffle(arr3);
            expect(arr3).to.be(arr3);

            arr3 = utilx.Array.shuffle(arr3, '5');
            expect(arr3).to.be(arr3);
        });

        it('should work with arguments', function () {
            var arr1 = [1, 2, 3],
                arr2 = [1, 2, 3],
                arr3 = [0, 1, 2, 3];

            delete arr3[0];
            utilx.Array.shuffle(arr1);
            expect(arr1.length).to.be(3);

            utilx.Array.shuffle(arr2, 5);
            expect(arr2.length).to.be(3);

            utilx.Array.shuffle(arr2, '5');
            expect(arr2.length).to.be(3);

            utilx.Array.shuffle(arr3);
            expect(arr3.length).to.be(4);

            utilx.Array.shuffle(arr3, '5');
            expect(arr3.length).to.be(4);
        });
    });
}());

},{"../scripts/":10}],45:[function(require,module,exports){
/*global TypeError, describe, it, require */

/*properties
    Array, a, array2Object, be, create, eql, expect, length, returnArgs, slice,
    throwException, to, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.slice', function () {
        var arr = required.create(undefined, null, 1, 'a', 2, 'b', null, undefined),
            testValue;

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.slice();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.slice(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.slice(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(utilx.Array.slice(arr)).to.eql(arr);
            expect(utilx.Array.slice(arr, undefined, undefined)).to.eql(arr);

            testValue = required.create(undefined);
            expect(utilx.Array.slice(arr, -1)).to.eql(testValue);
            expect(utilx.Array.slice(arr, -1).length).to.be(1);
            expect(utilx.Array.slice(arr, 0)).to.eql(arr);

            testValue = required.create('a', 2, 'b', null, undefined);
            expect(utilx.Array.slice(arr, 3)).to.eql(testValue);
            expect(utilx.Array.slice(arr, -1, 4)).to.eql([]);
            expect(utilx.Array.slice(arr, -1, 4).length).to.be(0);

            testValue = required.create(undefined, null, 1, 'a');
            expect(utilx.Array.slice(arr, 0, 4)).to.eql(testValue);

            testValue = ['a', 2, 'b'];
            expect(utilx.Array.slice(arr, 3, 6)).to.eql(testValue);
        });

        it('should work with objects that have length', function () {
            var obj = required.array2Object(arr);

            expect(utilx.Array.slice(obj)).to.eql(arr);
            expect(utilx.Array.slice(obj, undefined, undefined)).to.eql(arr);

            testValue = required.create(undefined);
            expect(utilx.Array.slice(obj, -1)).to.eql(testValue);
            expect(utilx.Array.slice(obj, -1).length).to.be(1);
            expect(utilx.Array.slice(obj, 0)).to.eql(arr);

            testValue = required.create('a', 2, 'b', null, undefined);
            expect(utilx.Array.slice(obj, 3)).to.eql(testValue);
            expect(utilx.Array.slice(obj, -1, 4)).to.eql([]);
            expect(utilx.Array.slice(obj, -1, 4).length).to.be(0);

            testValue = required.create(undefined, null, 1, 'a');
            expect(utilx.Array.slice(obj, 0, 4)).to.eql(testValue);

            testValue = ['a', 2, 'b'];
            expect(utilx.Array.slice(obj, 3, 6)).to.eql(testValue);
        });

        it('should work with arguments', function () {
            var obj = required.returnArgs(undefined, null, 1, 'a', 2, 'b', null, undefined);

            expect(utilx.Array.slice(obj)).to.eql(arr);
            expect(utilx.Array.slice(obj, undefined, undefined)).to.eql(arr);

            testValue = required.create(undefined);
            expect(utilx.Array.slice(obj, -1)).to.eql(testValue);
            expect(utilx.Array.slice(obj, -1).length).to.be(1);
            expect(utilx.Array.slice(obj, 0)).to.eql(arr);

            testValue = required.create('a', 2, 'b', null, undefined);
            expect(utilx.Array.slice(obj, 3)).to.eql(testValue);
            expect(utilx.Array.slice(obj, -1, 4), []).to.eql([]);
            expect(utilx.Array.slice(obj, -1, 4).length).to.be(0);

            testValue = required.create(undefined, null, 1, 'a');
            expect(utilx.Array.slice(obj, 0, 4)).to.eql(testValue);

            testValue = ['a', 2, 'b'];
            expect(utilx.Array.slice(obj, 3, 6)).to.eql(testValue);
        });

        it('should work with string', function () {
            var obj = '1234567890';

            expect(utilx.Array.slice(obj)).to.eql(['1', '2', '3', '4', '5', '6', '7', '8', '9', '0']);
            expect(utilx.Array.slice(obj, undefined, undefined))
                    .to.eql(['1', '2', '3', '4', '5', '6', '7', '8', '9', '0']);

            expect(utilx.Array.slice(obj, -1)).to.eql(['0']);
            expect(utilx.Array.slice(obj, -1).length).to.be(1);
            expect(utilx.Array.slice(obj, 0)).to.eql(['1', '2', '3', '4', '5', '6', '7', '8', '9', '0']);

            testValue = required.create('a', 2, 'b', null, undefined);
            expect(utilx.Array.slice(obj, 3)).to.eql(['4', '5', '6', '7', '8', '9', '0']);
            expect(utilx.Array.slice(obj, -1, 4), []).to.eql([]);
            expect(utilx.Array.slice(obj, -1, 4).length).to.be(0);

            testValue = required.create(undefined, null, 1, 'a');
            expect(utilx.Array.slice(obj, 0, 4)).to.eql(['1', '2', '3', '4']);

            testValue = ['a', 2, 'b'];
            expect(utilx.Array.slice(obj, 3, 6)).to.eql(['4', '5', '6']);
        });
    });
}());

},{"../scripts/":10}],46:[function(require,module,exports){
/*global Date, Error, Math, RegExp, TypeError, beforeEach, describe, it, require */

/*properties
    '0', '2', '3', Array, a, array2Object, be, call, create, eql, expect,
    isStrictMode, length, not, ok, pow, prototype, push, some, throwException,
    to, toString, utilx, valueOf, isNaN, ToString, ToClass, charAt
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.some', function () {
        var lastIndex = Math.pow(2, 32) - 1,
            someArray = required.create(0, 1, 2, 'a', 'b', 'c', [8, 9, 10], {}, true, false, undefined, null,
                                  new Date(), new Error('x'), new RegExp('t'), Infinity, -Infinity),
            testSubject,
            testIndex,
            expected,
            numberOfRuns;

        beforeEach(function () {
            testSubject = required.create(2, 3, undefined, true, 'hej', null, false, 0, 8, 9);
            delete testSubject[1];
            delete testSubject[8];
            numberOfRuns = 0;
            expected = {
                0: 2,
                2: undefined,
                3: true
            };
        });

        someArray.length = 25;
        someArray[24] = NaN;
        someArray[25] = 'end';

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.some();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.some(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.some(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if function argument is not a function', function () {
            expect(function () {
                utilx.Array.some(someArray);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.some(someArray, undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.some(someArray, null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(utilx.Array.some(someArray, function (element, index, array) {
                expect(array).to.be(someArray);
                expect(typeof index === 'number').to.be.ok();
                expect(index >= 0).to.be.ok();
                expect(index <= lastIndex).to.be.ok();
                if (required.isNaN(element)) {
                    expect(required.isNaN(someArray[index])).to.be(true);
                } else {
                    expect(element).to.be(someArray[index]);
                }

                testIndex = index;
                if (element === 'end') {
                    return true;
                }

                return false;
            })).to.be(true);

            expect(testIndex).to.be(someArray.length - 1);
        });

        it('should pass the right parameters', function () {
            var array = ['1'];

            utilx.Array.some(array, function (item, index, list) {
                expect(item).to.be('1');
                expect(index).to.be(0);
                expect(list).to.be(array);
            });
        });

        it('should not affect elements added to the array after it has begun', function () {
            var arr = [1, 2, 3],
                i = 0;

            utilx.Array.some(arr, function (a) {
                i += 1;
                arr.push(a + 3);

                return i === 3;
            });

            expect(arr).to.eql([1, 2, 3, 4, 5, 6]);
            expect(i).to.be(3);
        });

        it('should set the right context when given none', function () {
            var context;

            utilx.Array.some([1], function () {
                context = this;
            });

            expect(context).to.be((function () {
                return function () {
                    return this;
                };
            }()).call());
        });

        it('should return false if it runs to the end', function () {
            var actual = utilx.Array.some(testSubject, function () {
                return;
            });

            expect(actual).to.not.be.ok();
        });

        it('should return true if it is stopped somewhere', function () {
            var actual = utilx.Array.some(testSubject, function () {
                return true;
            });

            expect(actual).to.be.ok();
        });

        it('should return false if there are no elements', function () {
            var actual = utilx.Array.some([], function () {
                return true;
            });

            expect(actual).to.not.be.ok();
        });

        it('should stop after 3 elements', function () {
            var actual = {};

            utilx.Array.some(testSubject, function (obj, index) {
                actual[index] = obj;
                numberOfRuns += 1;
                if (numberOfRuns === 3) {
                    return true;
                }

                return false;
            });

            expect(actual).to.eql(expected);
        });

        it('should stop after 3 elements using a context', function () {
            var actual = {},
                o = {
                    a: actual
                };

            utilx.Array.some(testSubject, function (obj, index) {
                this.a[index] = obj;
                numberOfRuns += 1;
                if (numberOfRuns === 3) {
                    return true;
                }

                return false;
            }, o);

            expect(actual).to.eql(expected);
        });

        it('should stop after 3 elements in an array-like object', function () {
            var ts = required.array2Object(testSubject),
                actual = {};

            utilx.Array.some(ts, function (obj, index) {
                actual[index] = obj;
                numberOfRuns += 1;
                if (numberOfRuns === 3) {
                    return true;
                }

                return false;
            });

            expect(actual).to.eql(expected);
        });

        it('should stop after 3 elements in an array-like object using a context', function () {
            var ts = required.array2Object(testSubject),
                actual = {},
                o = {
                    a: actual
                };

            utilx.Array.some(ts, function (obj, index) {
                this.a[index] = obj;
                numberOfRuns += 1;
                if (numberOfRuns === 3) {
                    return true;
                }

                return false;
            }, o);

            expect(actual).to.eql(expected);
        });

        it('should have a boxed object as list argument of callback', function () {
            var actual;

            utilx.Array.some('foo', function (item, index, list) {
                /*jslint unparam: true */
                /*jshint unused: true */
                actual = list;
            });

            expect(typeof actual).to.be('object');
            expect(required.ToClass(actual)).to.be('[object String]');
            expect(required.ToString(actual)).to.be('foo');
            expect(actual.charAt(0)).to.be('f');
        });

        it('does not autobox the content in strict mode', function () {
            var actual;

            utilx.Array.some([1], function () {
                actual = this;
            }, 'x');

            expect(typeof actual).to.be(required.isStrictMode() ? 'string' : 'object');
        });
    });
}());

},{"../scripts/":10}],47:[function(require,module,exports){
/*global Math, TypeError, describe, it, require */

/*properties
    '0', '1', '2', '3', '4', '5', '6', '7', Array, a, be, create, eql, expect,
    length, not, ok, push, random, slice, sort, throwException, to, toFixed,
    utilx, valueOf, descending
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.sort', function () {
        var testArray,
            testArray1 = [],
            testArray2,
            n = 100,
            i;

        for (i = 0; i < n; i += 1) {
            testArray1.push(('00' + (Math.random() * 100).toFixed(0)).slice(-3));
        }

        testArray2 = required.slice(testArray1);

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.sort();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.sort(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.sort(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(function () {
                utilx.Array.sort(1);
            }).to.not.throwException();

            expect(function () {
                utilx.Array.sort('');
            }).to.not.throwException();

            expect(function () {
                utilx.Array.sort(true);
            }).to.not.throwException();
        });

        it('requires a function or undefined', function () {
            expect(function () {
                utilx.Array.sort([]);
            }).to.not.throwException();

            expect(function () {
                utilx.Array.sort([], undefined);
            }).to.not.throwException();

            expect(function () {
                utilx.Array.sort([], null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.sort([], 1);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.sort([], '');
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.sort([], true);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('sorting [5,2,4,6,1,3] ascending should result in [1,2,3,4,5,6]', function () {
            testArray = [5, 2, 4, 6, 1, 3];
            utilx.Array.sort(testArray);
            expect(testArray).to.eql([1, 2, 3, 4, 5, 6]);
        });

        it('sorting [5,2,2,6,1,3] ascending should result in [1,2,2,3,5,6]', function () {
            testArray = [5, 2, 2, 6, 1, 3];
            utilx.Array.sort(testArray);
            expect(testArray).to.eql([1, 2, 2, 3, 5, 6]);
        });

        it('sorting [0,0,0,0,0,1] ascending should result in [0,0,0,0,0,1]', function () {
            testArray = [0, 0, 0, 0, 0, 1];
            utilx.Array.sort(testArray);
            expect(testArray).to.eql([0, 0, 0, 0, 0, 1]);
        });

        it('sorting [0,0,0,0,0,-1] ascending should result in [-1,0,0,0,0,0]', function () {
            testArray = [0, 0, 0, 0, 0, -1];
            utilx.Array.sort(testArray);
            expect(testArray).to.eql([-1, 0, 0, 0, 0, 0]);
        });

        it('sorting [f,e,d,a,c,b] ascending should result in [a,b,c,d,e,f]', function () {
            testArray = ['f', 'e', 'd', 'a', 'c', 'b'];
            utilx.Array.sort(testArray);
            expect(testArray).to.eql(['a', 'b', 'c', 'd', 'e', 'f']);
        });

        it('sorting [f,e,d,,,,a,c,b] ascending should result in [a,b,c,d,e,f,,,]', function () {
            testArray = ['f', 'e', 'd', 1, 2, 'a', 'c', 'b'];
            delete testArray[3];
            delete testArray[4];
            utilx.Array.sort(testArray);
            var expected = ['a', 'b', 'c', 'd', 'e', 'f'];
            expected.length = 8;
            expect(testArray.length).to.eql(expected.length);
            expect(testArray).to.eql(expected);
        });

        it('sorting [f,e,d,,null,,a,c,b] ascending should result in [a,b,c,d,e,f,null,,,]', function () {
            testArray = ['f', 'e', 'd', 1, null, 2, 'a', 'c', 'b'];
            delete testArray[3];
            delete testArray[5];
            utilx.Array.sort(testArray);
            var expected = ['a', 'b', 'c', 'd', 'e', 'f', null];
            expected.length = 9;
            expect(testArray.length).to.eql(expected.length);
            expect(testArray).to.eql(expected);
        });

        it('sorting [f,e,d,,null,undefined,a,c,b] ascending should result in [a,b,c,d,e,f,null,undefined,,]', function () {
            testArray = required.create('f', 'e', 'd', 1, null, undefined, 'a', 'c', 'b');
            delete testArray[3];
            utilx.Array.sort(testArray);
            var expected = required.create('a', 'b', 'c', 'd', 'e', 'f', null, undefined);
            expected.length = 9;
            expect(testArray.length).to.eql(expected.length);
            expect(testArray).to.eql(expected);
        });

        it('sorting [] ascending should result in []', function () {
            testArray = [];
            utilx.Array.sort(testArray);
            expect(testArray).to.eql([]);
        });

        it('sorting [1] ascending should result in [1]', function () {
            testArray = [1];
            utilx.Array.sort(testArray);
            expect(testArray).to.eql([1]);
        });

        it('sorted ascending result should find only greater or equal values while ascending', function () {
            utilx.Array.sort(testArray1);
            for (i = 0; i < testArray1.length - 1; i += 1) {
                expect(testArray1[i] <= testArray1[i + 1]).to.be.ok();
            }
        });

        it('sorting [5,2,4,6,1,3] required.descending should result in [6,5,4,3,2,1]', function () {
            testArray = [5, 2, 4, 6, 1, 3];
            utilx.Array.sort(testArray, required.descending);
            expect(testArray).to.eql([6, 5, 4, 3, 2, 1]);
        });

        it('sorting [5,2,2,6,1,3] required.descending should result in [6,5,4,2,2,1]', function () {
            testArray = [5, 2, 2, 6, 1, 3];
            utilx.Array.sort(testArray, required.descending);
            expect(testArray).to.eql([6, 5, 3, 2, 2, 1]);
        });

        it('sorting [0,0,0,0,0,1] required.descending should result in [1,0,0,0,0,0]', function () {
            testArray = [0, 0, 0, 0, 0, 1];
            utilx.Array.sort(testArray, required.descending);
            expect(testArray).to.eql([1, 0, 0, 0, 0, 0]);
        });

        it('sorting [0,0,0,0,0,-1] required.descending should result in [0,0,0,0,0,-1]', function () {
            testArray = [0, 0, 0, 0, 0, -1];
            utilx.Array.sort(testArray, required.descending);
            expect(testArray).to.eql([0, 0, 0, 0, 0, -1]);
        });

        it('sorting [f,e,d,a,c,b] required.descending should result in [f,e,d,c,b,a]', function () {
            testArray = ['f', 'e', 'd', 'a', 'c', 'b'];
            utilx.Array.sort(testArray, required.descending);
            expect(testArray).to.eql(['f', 'e', 'd', 'c', 'b', 'a']);
        });

        it('sorting [f,e,d,,,a,c,b] required.descending should result in [f,e,d,c,b,a,,,]', function () {
            testArray = ['f', 'e', 'd', 1, 2, 'a', 'c', 'b'];
            delete testArray[3];
            delete testArray[4];
            utilx.Array.sort(testArray, required.descending);
            var expected = ['f', 'e', 'd', 'c', 'b', 'a'];
            expected.length = 8;
            expect(testArray.length).to.eql(expected.length);
            expect(testArray).to.eql(expected);
        });

        it('sorting [f,e,d,,null,,a,c,b] required.descending should result in [null,f,e,d,c,b,a,,,]', function () {
            testArray = ['f', 'e', 'd', 1, null, 2, 'a', 'c', 'b'];
            delete testArray[3];
            delete testArray[5];
            utilx.Array.sort(testArray, required.descending);
            var expected = [null, 'f', 'e', 'd', 'c', 'b', 'a'];
            expected.length = 9;
            expect(testArray.length).to.eql(expected.length);
            expect(testArray).to.eql(expected);
        });

        it('sorting [f,e,d,undefined,null,,a,c,b] required.descending should result in [null,f,e,d,c,b,a,undefined,,]', function () {
            testArray = required.create('f', 'e', 'd', undefined, null, 2, 'a', 'c', 'b');
            delete testArray[5];
            utilx.Array.sort(testArray, required.descending);
            var expected = required.create(null, 'f', 'e', 'd', 'c', 'b', 'a', undefined);
            expected.length = 9;
            expect(testArray.length).to.eql(expected.length);
            expect(testArray).to.eql(expected);
        });

        it('sorting [] required.descending should result in []', function () {
            testArray = [];
            utilx.Array.sort(testArray, required.descending);
            expect(testArray).to.eql([]);
        });

        it('sorting [1] required.descending should result in [1]', function () {
            testArray = [1];
            utilx.Array.sort(testArray, required.descending);
            expect(testArray).to.eql([1]);
        });

        it('sorted required.descending result should find only lesser or equal values while required.descending', function () {
            utilx.Array.sort(testArray2, required.descending);
            for (i = 0; i < testArray2.length - 1; i += 1) {
                expect(testArray2[i] >= testArray2[i + 1]).to.be.ok();
            }
        });

        it('returned value should be source', function () {
            testArray = [1, 3, 2];
            expect(utilx.Array.sort(testArray)).to.be(testArray);
        });

        it('sorting should work with objects', function () {
            testArray = {
                0: 5,
                1: 2,
                2: 4,
                3: 6,
                4: 1,
                5: 3
            };

            utilx.Array.sort(testArray);
            expect(testArray).to.eql({
                0: 5,
                1: 2,
                2: 4,
                3: 6,
                4: 1,
                5: 3
            });

            testArray = {
                0: 5,
                1: 2,
                2: 4,
                3: 6,
                4: 1,
                5: 3,
                length: 6
            };

            utilx.Array.sort(testArray);
            expect(testArray).to.eql({
                0: 1,
                1: 2,
                2: 3,
                3: 4,
                4: 5,
                5: 6,
                length: 6
            });

            testArray = {
                0: 5,
                1: 2,
                2: 4,
                3: 6,
                4: 1,
                5: 3
            };

            utilx.Array.sort(testArray, required.descending);
            expect(testArray).to.eql({
                0: 5,
                1: 2,
                2: 4,
                3: 6,
                4: 1,
                5: 3
            });

            testArray = {
                0: 5,
                1: 2,
                2: 4,
                3: 6,
                4: 1,
                5: 3,
                length: 6
            };

            utilx.Array.sort(testArray, required.descending);
            expect(testArray).to.eql({
                0: 6,
                1: 5,
                2: 4,
                3: 3,
                4: 2,
                5: 1,
                length: 6
            });

            testArray = {
                0: 5,
                1: 2,
                2: 4,
                4: null,
                6: 1,
                7: 3,
                length: 8
            };

            utilx.Array.sort(testArray, required.descending);
            expect(testArray).to.eql({
                0: null,
                1: 5,
                2: 4,
                3: 3,
                4: 2,
                5: 1,
                length: 8
            });
        });
    });
}());

},{"../scripts/":10}],48:[function(require,module,exports){
/*global Array, TypeError, describe, it, require */

/*properties
    '0', '1', '2', Array, a, apply, be, eql, expect, join, length, noop, pop,
    prototype, push, returnArgs, slice, splice, throwException, to, unshift,
    utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.splice', function () {
        var b = ['b'],
            a = [1, 'a', b],
            test;

        function makeArray(l, prefix) {
            prefix = prefix || '';

            var a1 = [],
                arr = [];

            while (l) {
                a1.length = l;
                l -= 1;
                utilx.Array.unshift(arr, prefix + utilx.Array.join(a1, ' ') + l);
            }

            return arr;
        }

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.splice();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.splice(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.splice(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is a string', function () {
            expect(function () {
                utilx.Array.splice('abc');
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is a function', function () {
            expect(function () {
                utilx.Array.splice(required.noop);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('basic implementation test 1', function () {
            test = required.slice(a, 0);
            expect(utilx.Array.splice(test, 0)).to.eql(a);
        });

        it('basic implementation test 2', function () {
            test = required.slice(a, 0);
            utilx.Array.splice(test, 0, 2);
            expect(test).to.eql([b]);
        });

        it('should return right result 1', function () {

            expect((function () {
                var array = [];

                utilx.Array.splice(array, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20);
                utilx.Array.splice(array, 1, 0, 'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10',
                    'F11', 'F12', 'F13', 'F14', 'F15', 'F16', 'F17', 'F18', 'F19', 'F20',
                    'F21', 'F22', 'F23', 'F24', 'F25', 'F26');
                utilx.Array.splice(array, 5, 0, 'XXX');

                return utilx.Array.join(array, '|');
            }())).to.be('1|F1|F2|F3|F4|XXX|F5|F6|F7|F8|F9|F10|F11|F12|F13|F14|F15|F16|F17|F18|F19|F20|' +
                'F21|F22|F23|F24|F25|F26|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20');
        });

        it('should return right result 2', function () {
            expect((function () {
                var array = makeArray(6);

                utilx.Array.splice(array, array.length - 1, 1, '');
                utilx.Array.splice(array, 0, 1, 1, 2, 3, 4);
                utilx.Array.splice(array, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
                    41, 42, 43, 44, 45);

                utilx.Array.splice(array, 4, 0, '99999999999999');

                return utilx.Array.join(array, '|');
            }())).to.be('1|2|3|4|99999999999999|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|' +
                '21|22|23|24|25|26|27|28|29|30|31|32|33|34|35|36|37|38|39|40|' +
                '41|42|43|44|45|1|2|3|4| 1|  2|   3|    4|');
        });

        it('should return right result 3', function () {
            expect((function () {
                var array = [1, 2, 3],
                    tmp;

                utilx.Array.splice(array, 0);
                utilx.Array.splice(array, 0, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
                utilx.Array.splice(array, 1, 1, 'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10',
                    'F11', 'F12', 'F13', 'F14', 'F15', 'F16', 'F17', 'F18', 'F19', 'F20',
                    'F21', 'F22', 'F23', 'F24', 'F25', 'F26');
                utilx.Array.splice(array, 5, 1, 'YYY', 'XXX');
                utilx.Array.splice(array, 0, 1);
                utilx.Array.splice(array, 0, 2);
                array.pop();
                Array.prototype.push.apply(array, makeArray(10, '-'));
                utilx.Array.splice(array, array.length - 2, 10);
                utilx.Array.splice(array);
                utilx.Array.splice(array, 1, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9);
                utilx.Array.splice(array, 1, 1, 'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10',
                    'F11', 'F12', 'F13', 'F14', 'F15', 'F16', 'F17', 'F18', 'F19', 'F20',
                    'F21', 'F22', 'F23', 'F24', 'F25', 'F26', 1, 23, 4, 5, 6, 7, 8);
                utilx.Array.splice(array, 30, 10);
                utilx.Array.splice(array, 30, 1);
                utilx.Array.splice(array, 30, 0);
                utilx.Array.splice(array, 2, 5, 1, 2, 3, 'P', 'LLL', 'CCC', 'YYY', 'XXX');
                utilx.Array.push(array, 1, 2, 3, 4, 5, 6);
                utilx.Array.splice(array, 1, 6, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4, 5, 6, 7, 8, 9);
                utilx.Array.splice(array, 3, 7);
                utilx.Array.unshift(array, 7, 8, 9, 10, 11);
                array.pop();
                utilx.Array.splice(array, 5, 2);
                array.pop();
                tmp = makeArray(8, '~');
                utilx.Array.unshift(tmp, array);
                utilx.Array.unshift.apply(null, tmp);
                array.pop();
                utilx.Array.splice(array, 3, 1, 'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10',
                    'F11', 'F12', 'F13', 'F14', 'F15', 'F16', 'F17', 'F18', 'F19', 'F20',
                    'F21', 'F22', 'F23', 'F24', 'F25', 'F26', 1, 23, 4, 5, 6, 7, 8);
                utilx.Array.splice(array, 4, 5, 'P', 'LLL', 'CCC', 'YYY', 'XXX');

                return utilx.Array.join(array, '|');
            }())).to.be('~0|~ 1|~  2|F1|P|LLL|CCC|YYY|XXX|F7|F8|F9|F10|F11|F12|F13|F14|F15|F16|F17|F18|F19|F20|' +
                'F21|F22|F23|F24|F25|F26|1|23|4|5|6|7|8|~    4|~     5|~      6|~       7|' +
                '7|8|9|10|11|2|4|5|6|7|8|9|CCC|YYY|XXX|F7|F8|F9|F10|F11|F12|F13|F14|F15|F16|F17|F18|' +
                'F19|F20|F21|F22|F23|F24|F25|F26|1|23|4|9|10|1|2|3|4|5|6|7|8|9|YYY|XXX|F6|F7|F8|F9|' +
                'F10|F11|F12|F13|F14|F15|F16|F17|F18|F19|F20|F21|F22|F23|F24|F25|F26|3|4|5|6|7|8|9|' +
                '-0|- 1|-  2|-   3|-    4|-     5|-      6|-       7|1|2|3');
        });

        it('should do nothing if method called with no arguments', function () {
            test = required.slice(a, 0);
            expect(utilx.Array.splice(test)).to.eql([]);
            expect(test).to.eql(a);
        });

        it('should set first argument to 0 if first argument is set but undefined', function () {
            test = required.slice(a, 0);

            var test2 = required.slice(test, 0);

            expect(utilx.Array.splice(test, undefined, 2)).to.eql(test2.splice(0, 2));
            expect(test).to.eql(test2);
        });

        it('should deleted and return all items after "start" when second argument is undefined', function () {
            test = required.slice(a, 0);
            expect(utilx.Array.splice(test, 0)).to.eql(a);
            expect(test).to.eql([]);
        });

        it('should deleted and return all items after "start" when second argument is undefined', function () {
            test = required.slice(a, 0);
            expect(utilx.Array.splice(test, 2)).to.eql([b]);
            expect(test).to.eql([1, 'a']);
        });

        it('should work with objects - adding 1', function () {
            var obj = {};

            utilx.Array.splice(obj, 0, 0, 1, 2, 3);
            expect(obj.length).to.eql(3);
        });

        it('should work with objects - adding 2', function () {
            var obj = {
                0: 1,
                length: 1
            };

            utilx.Array.splice(obj, 1, 0, 2, 3);
            expect(obj.length).to.eql(3);
        });

        it('should work with objects - removing', function () {
            var obj = {
                0: 1,
                1: 2,
                2: 3,
                length: 3
            };

            utilx.Array.splice(obj, 0, 3);
            expect(obj.length).to.eql(0);
        });

        it('should work with objects - replacing', function () {
            var obj = {
                0: 99,
                length: 1
            };

            utilx.Array.splice(obj, 0, 1, 1, 2, 3);
            expect(obj.length).to.eql(3);
            expect(obj[0]).to.eql(1);
        });


        it('should work with arguments - adding 1', function () {
            var obj = required.returnArgs();

            utilx.Array.splice(obj, 0, 0, 1, 2, 3);
            expect(obj.length).to.eql(3);
        });

        it('should work with arguments - adding 2', function () {
            var obj = required.returnArgs(1);

            utilx.Array.splice(obj, 1, 0, 2, 3);
            expect(obj.length).to.eql(3);
        });

        it('should work with arguments - removing', function () {
            var obj = required.returnArgs(1, 2, 3);

            utilx.Array.splice(obj, 0, 3);
            expect(obj.length).to.eql(0);
        });

        it('should work with arguments - replacing', function () {
            var obj = required.returnArgs(99);

            utilx.Array.splice(obj, 0, 1, 1, 2, 3);
            expect(obj.length).to.eql(3);
            expect(obj[0]).to.eql(1);
        });
    });
}());

},{"../scripts/":10}],49:[function(require,module,exports){
/*global Math, TypeError, describe, it, require */

/*properties
    '0', '1', '2', '3', '4', '5', '6', '7', Array, a, be, create, eql, expect,
    last, length, not, ok, push, random, slice, stableSort, throwException, to,
    toFixed, toString, utilx, descending
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.stableSort', function () {
        var testArray,
            testArray1 = [],
            testArray2,
            n = 100,
            i;

        for (i = 0; i < n; i += 1) {
            testArray1.push(('00' + (Math.random() * 100).toFixed(0)).slice(-3));
        }

        testArray2 = required.slice(testArray1);

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.stableSort();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.stableSort(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.stableSort(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(function () {
                utilx.Array.stableSort(1);
            }).to.not.throwException();

            expect(function () {
                utilx.Array.stableSort('');
            }).to.not.throwException();

            expect(function () {
                utilx.Array.stableSort(true);
            }).to.not.throwException();
        });

        it('requires a function or undefined', function () {
            expect(function () {
                utilx.Array.stableSort([]);
            }).to.not.throwException();

            expect(function () {
                utilx.Array.stableSort([], undefined);
            }).to.not.throwException();

            expect(function () {
                utilx.Array.stableSort([], null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.stableSort([], 1);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.stableSort([], '');
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Array.stableSort([], true);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('sorting [5,2,4,6,1,3] ascending should result in [1,2,3,4,5,6]', function () {
            testArray = [5, 2, 4, 6, 1, 3];
            utilx.Array.stableSort(testArray);
            expect(testArray).to.eql([1, 2, 3, 4, 5, 6]);
        });

        it('sorting [5,2,2,6,1,3] ascending should result in [1,2,2,3,5,6]', function () {
            testArray = [5, 2, 2, 6, 1, 3];
            utilx.Array.stableSort(testArray);
            expect(testArray).to.eql([1, 2, 2, 3, 5, 6]);
        });

        it('sorting [0,0,0,0,0,1] ascending should result in [0,0,0,0,0,1]', function () {
            testArray = [0, 0, 0, 0, 0, 1];
            utilx.Array.stableSort(testArray);
            expect(testArray).to.eql([0, 0, 0, 0, 0, 1]);
        });

        it('sorting [0,0,0,0,0,-1] ascending should result in [-1,0,0,0,0,0]', function () {
            testArray = [0, 0, 0, 0, 0, -1];
            utilx.Array.stableSort(testArray);
            expect(testArray).to.eql([-1, 0, 0, 0, 0, 0]);
        });

        it('sorting [f,e,d,a,c,b] ascending should result in [a,b,c,d,e,f]', function () {
            testArray = ['f', 'e', 'd', 'a', 'c', 'b'];
            utilx.Array.stableSort(testArray);
            expect(testArray).to.eql(['a', 'b', 'c', 'd', 'e', 'f']);
        });

        it('sorting [f,e,d,,,,a,c,b] ascending should result in [a,b,c,d,e,f,,,]', function () {
            testArray = ['f', 'e', 'd', 1, 2, 'a', 'c', 'b'];
            delete testArray[3];
            delete testArray[4];
            utilx.Array.stableSort(testArray);
            var expected = ['a', 'b', 'c', 'd', 'e', 'f'];
            expected.length = 8;
            expect(testArray.length).to.eql(expected.length);
            expect(testArray).to.eql(expected);
        });

        it('sorting [f,e,d,,null,,a,c,b] ascending should result in [a,b,c,d,e,f,null,,,]', function () {
            testArray = ['f', 'e', 'd', 1, null, 2, 'a', 'c', 'b'];
            delete testArray[3];
            delete testArray[5];
            utilx.Array.stableSort(testArray);
            var expected = ['a', 'b', 'c', 'd', 'e', 'f', null];
            expected.length = 9;
            expect(testArray.length).to.eql(expected.length);
            expect(testArray).to.eql(expected);
        });

        it('sorting [f,e,d,,null,undefined,a,c,b] ascending should result in [a,b,c,d,e,f,null,undefined,,]', function () {
            testArray = required.create('f', 'e', 'd', 1, null, undefined, 'a', 'c', 'b');
            delete testArray[3];
            utilx.Array.stableSort(testArray);

            var expected = required.create('a', 'b', 'c', 'd', 'e', 'f', null, undefined);

            expected.length = 9;
            expect(testArray.length).to.eql(expected.length);
            expect(testArray).to.eql(expected);
        });

        it('sorting [] ascending should result in []', function () {
            testArray = [];
            utilx.Array.stableSort(testArray);
            expect(testArray).to.eql([]);
        });

        it('sorting [1] ascending should result in [1]', function () {
            testArray = [1];
            utilx.Array.stableSort(testArray);
            expect(testArray).to.eql([1]);
        });

        it('sorted ascending result should find only greater or equal values while ascending', function () {
            utilx.Array.stableSort(testArray1);
            for (i = 0; i < testArray1.length - 1; i += 1) {
                expect(testArray1[i] <= testArray1[i + 1]).to.be.ok();
            }
        });

        it('sorting [5,2,4,6,1,3] required.descending should result in [6,5,4,3,2,1]', function () {
            testArray = [5, 2, 4, 6, 1, 3];
            utilx.Array.stableSort(testArray, required.descending);
            expect(testArray).to.eql([6, 5, 4, 3, 2, 1]);
        });

        it('sorting [5,2,2,6,1,3] required.descending should result in [6,5,4,2,2,1]', function () {
            testArray = [5, 2, 2, 6, 1, 3];
            utilx.Array.stableSort(testArray, required.descending);
            expect(testArray).to.eql([6, 5, 3, 2, 2, 1]);
        });

        it('sorting [0,0,0,0,0,1] required.descending should result in [1,0,0,0,0,0]', function () {
            testArray = [0, 0, 0, 0, 0, 1];
            utilx.Array.stableSort(testArray, required.descending);
            expect(testArray).to.eql([1, 0, 0, 0, 0, 0]);
        });

        it('sorting [0,0,0,0,0,-1] required.descending should result in [0,0,0,0,0,-1]', function () {
            testArray = [0, 0, 0, 0, 0, -1];
            utilx.Array.stableSort(testArray, required.descending);
            expect(testArray).to.eql([0, 0, 0, 0, 0, -1]);
        });

        it('sorting [f,e,d,a,c,b] required.descending should result in [f,e,d,c,b,a]', function () {
            testArray = ['f', 'e', 'd', 'a', 'c', 'b'];
            utilx.Array.stableSort(testArray, required.descending);
            expect(testArray).to.eql(['f', 'e', 'd', 'c', 'b', 'a']);
        });

        it('sorting [f,e,d,,,a,c,b] required.descending should result in [f,e,d,c,b,a,,,]', function () {
            testArray = ['f', 'e', 'd', 1, 2, 'a', 'c', 'b'];
            delete testArray[3];
            delete testArray[4];
            utilx.Array.stableSort(testArray, required.descending);

            var expected = ['f', 'e', 'd', 'c', 'b', 'a'];

            expected.length = 8;
            expect(testArray.length).to.eql(expected.length);
            expect(testArray).to.eql(expected);
        });

        it('sorting [f,e,d,,null,,a,c,b] required.descending should result in [null,f,e,d,c,b,a,,,]', function () {
            testArray = ['f', 'e', 'd', 1, null, 2, 'a', 'c', 'b'];
            delete testArray[3];
            delete testArray[5];
            utilx.Array.stableSort(testArray, required.descending);

            var expected = [null, 'f', 'e', 'd', 'c', 'b', 'a'];

            expected.length = 9;
            expect(testArray.length).to.eql(expected.length);
            expect(testArray).to.eql(expected);
        });

        it('sorting [f,e,d,undefined,null,,a,c,b] required.descending should result in [null,f,e,d,c,b,a,undefined,,]', function () {
            testArray = required.create('f', 'e', 'd', undefined, null, 2, 'a', 'c', 'b');
            delete testArray[5];
            utilx.Array.stableSort(testArray, required.descending);

            var expected = required.create(null, 'f', 'e', 'd', 'c', 'b', 'a', undefined);

            expected.length = 9;
            expect(testArray.length).to.eql(expected.length);
            expect(testArray).to.eql(expected);
        });

        it('sorting [] required.descending should result in []', function () {
            testArray = [];
            utilx.Array.stableSort(testArray, required.descending);
            expect(testArray).to.eql([]);
        });

        it('sorting [1] required.descending should result in [1]', function () {
            testArray = [1];
            utilx.Array.stableSort(testArray, required.descending);
            expect(testArray).to.eql([1]);
        });

        it('sorted required.descending result should find only lesser or equal values while required.descending', function () {
            utilx.Array.stableSort(testArray2, required.descending);
            for (i = 0; i < testArray2.length - 1; i += 1) {
                expect(testArray2[i] >= testArray2[i + 1]).to.be.ok();
            }
        });

        it('returned value should be source', function () {
            testArray = [1, 3, 2];
            expect(utilx.Array.stableSort(testArray)).to.be(testArray);
        });

        it('sorting should work with objects', function () {
            testArray = {
                0: 5,
                1: 2,
                2: 4,
                3: 6,
                4: 1,
                5: 3
            };

            utilx.Array.stableSort(testArray);
            expect(testArray).to.eql({
                0: 5,
                1: 2,
                2: 4,
                3: 6,
                4: 1,
                5: 3
            });

            testArray = {
                0: 5,
                1: 2,
                2: 4,
                3: 6,
                4: 1,
                5: 3,
                length: 6
            };

            utilx.Array.stableSort(testArray);
            expect(testArray).to.eql({
                0: 1,
                1: 2,
                2: 3,
                3: 4,
                4: 5,
                5: 6,
                length: 6
            });

            testArray = {
                0: 5,
                1: 2,
                2: 4,
                3: 6,
                4: 1,
                5: 3
            };

            utilx.Array.stableSort(testArray, required.descending);
            expect(testArray).to.eql({
                0: 5,
                1: 2,
                2: 4,
                3: 6,
                4: 1,
                5: 3
            });

            testArray = {
                0: 5,
                1: 2,
                2: 4,
                3: 6,
                4: 1,
                5: 3,
                length: 6
            };

            utilx.Array.stableSort(testArray, required.descending);
            expect(testArray).to.eql({
                0: 6,
                1: 5,
                2: 4,
                3: 3,
                4: 2,
                5: 1,
                length: 6
            });

            testArray = {
                0: 5,
                1: 2,
                2: 4,
                4: null,
                6: 1,
                7: 3,
                length: 8
            };

            utilx.Array.stableSort(testArray, required.descending);
            expect(testArray).to.eql({
                0: null,
                1: 5,
                2: 4,
                3: 3,
                4: 2,
                5: 1,
                length: 8
            });
        });
    });
}());

},{"../scripts/":10}],50:[function(require,module,exports){
/*global TypeError, describe, it, require */

/*properties
    '0', '1', '2', '3', '4', Array, a, be, eql, expect, length, returnArgs,
    throwException, to, toObject, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.toObject', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.toObject();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.toObject(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.toObject(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('dense', function () {
            expect(utilx.Array.toObject([1, 2, 3, 4, 5])).to.eql({
                0: 1,
                1: 2,
                2: 3,
                3: 4,
                4: 5,
                length: 5
            });
        });

        it('sparse', function () {
            var arr = [1, 2, 3, 4, 5];

            delete arr[2];
            expect(utilx.Array.toObject(arr)).to.eql({
                0: 1,
                1: 2,
                3: 4,
                4: 5,
                length: 5
            });
        });

        it('arguments', function () {
            expect(utilx.Array.toObject(required.returnArgs(1, 2, 3, 4, 5))).to.eql({
                0: 1,
                1: 2,
                2: 3,
                3: 4,
                4: 5,
                length: 5
            });
        });

        it('object with length', function () {
            expect(utilx.Array.toObject({
                0: 1,
                1: 2,
                2: 3,
                3: 4,
                4: 5,
                length: 5
            })).to.eql({
                0: 1,
                1: 2,
                2: 3,
                3: 4,
                4: 5,
                length: 5
            });
        });

        it('object without length', function () {
            expect(utilx.Array.toObject({
                0: 1,
                1: 2,
                2: 3,
                3: 4,
                4: 5
            })).to.eql({length: 0});
        });

        it('strings', function () {
            expect(utilx.Array.toObject('12345')).to.eql({
                0: '1',
                1: '2',
                2: '3',
                3: '4',
                4: '5',
                length: 5
            });
        });
    });
}());

},{"../scripts/":10}],51:[function(require,module,exports){
/*global TypeError, describe, it, require */

/*properties
    '0', '1', '2', '3', '4', '5', Array, Object, a, be, deepEqual, eql, expect,
    is, join, length, name, returnArgs, throwException, to, unique, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.unique', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.unique();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.unique(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.unique(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('array', function () {
            var list = [1, 2, 1, 3, 1, 4];

            expect(utilx.Array.unique(list)).to.eql([1, 2, 3, 4]);

            list = [1, 1, 1, NaN, 2, 2, 3, NaN];
            expect(utilx.Array.unique(list).join(',')).to.be([1, NaN, 2, 3, NaN].join(','));

            list = [{
                name: 'moe'
            }, {
                name: 'curly'
            }, {
                name: 'larry'
            }, {
                name: 'curly'
            }];

            expect(utilx.Array.unique(list)).to.eql(list);
            expect(utilx.Array.unique(list, utilx.Object.deepEqual)).to.eql([{
                name: 'moe'
            }, {
                name: 'curly'
            }, {
                name: 'larry'
            }]);

            list = [1, 2, 2, NaN, 3, 4, NaN, 4];
            expect(utilx.Array.unique(list, utilx.Object.is).join(',')).to.be([1, 2, NaN, 3, 4].join(','));

            expect(utilx.Array.unique([])).to.eql([]);
        });

        it('arguments', function () {
            expect(utilx.Array.unique(required.returnArgs(1, 2, 1, 3, 1, 4))).to.eql([1, 2, 3, 4]);
            expect(utilx.Array.unique(required.returnArgs())).to.eql([]);
        });

        it('strings', function () {
            expect(utilx.Array.unique('121314')).to.eql([1, 2, 3, 4]);
            expect(utilx.Array.unique('')).to.eql([]);
        });

        it('object with length', function () {
            var list = {
                0: 1,
                1: 2,
                2: 2,
                3: 3,
                4: 4,
                5: 4,
                length: 6
            };

            expect(utilx.Array.unique(list)).to.eql([1, 2, 3, 4]);
            expect(utilx.Array.unique({length: 0})).to.eql([]);
        });

        it('object without length', function () {
            var list = {
                0: 1,
                1: 2,
                2: 2,
                3: 3,
                4: 4,
                5: 4
            };

            expect(utilx.Array.unique(list)).to.eql([]);
            expect(utilx.Array.unique({})).to.eql([]);
        });
    });
}());

},{"../scripts/":10}],52:[function(require,module,exports){
/*global Object, TypeError, describe, it, require */

/*properties
    '0', '1', '10', '11', '2', '3', '4', '5', '6', '7', '8', '9', Array, a, be,
    call, create, eql, expect, hasOwnProperty, last, length, ok, prototype,
    returnArgs, slice, throwException, to, unshift, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Array.unshift', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Array.last();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Array.unshift(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Array.last(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('array', function () {
            var arrCmp = required.create(
                    undefined,
                    null,
                    -1,
                    0,
                    1,
                    false,
                    true,
                    undefined,
                    '',
                    'abc',
                    null,
                    undefined
                ),
                arr = [],
                i;

            expect(utilx.Array.unshift(arr, undefined)).to.be(1);
            expect(utilx.Array.unshift(arr, null)).to.be(2);
            expect(utilx.Array.unshift(arr, 'abc')).to.be(3);
            expect(utilx.Array.unshift(arr, '')).to.be(4);
            expect(utilx.Array.unshift(arr, undefined)).to.be(5);
            expect(utilx.Array.unshift(arr)).to.be(5);
            expect(utilx.Array.unshift(arr)).to.be(5);
            expect(utilx.Array.unshift(arr)).to.be(5);
            expect(utilx.Array.unshift(arr)).to.be(5);
            expect(utilx.Array.unshift(arr, true)).to.be(6);
            expect(utilx.Array.unshift(arr, false)).to.be(7);
            expect(utilx.Array.unshift(arr, 1)).to.be(8);
            expect(utilx.Array.unshift(arr, 0)).to.be(9);
            expect(utilx.Array.unshift(arr, -1)).to.be(10);
            expect(utilx.Array.unshift(arr, null)).to.be(11);
            expect(utilx.Array.unshift(arr, undefined)).to.be(12);
            expect(arr.length).to.be(arrCmp.length);
            for (i = 0; i < arr.length; i += 1) {
                expect(Object.prototype.hasOwnProperty.call(arr, i)).to.be.ok();
                expect(arr[i]).to.be(arrCmp[i]);
            }

            expect(arr).to.eql(arrCmp);
        });

        it('arguments', function () {
            var arrCmp = required.create(
                    undefined,
                    null,
                    -1,
                    0,
                    1,
                    false,
                    true,
                    undefined,
                    '',
                    'abc',
                    null,
                    undefined
                ),
                arr = required.returnArgs(),
                i;

            expect(utilx.Array.unshift(arr, undefined)).to.be(1);
            expect(utilx.Array.unshift(arr, null)).to.be(2);
            expect(utilx.Array.unshift(arr, 'abc')).to.be(3);
            expect(utilx.Array.unshift(arr, '')).to.be(4);
            expect(utilx.Array.unshift(arr, undefined)).to.be(5);
            expect(utilx.Array.unshift(arr)).to.be(5);
            expect(utilx.Array.unshift(arr)).to.be(5);
            expect(utilx.Array.unshift(arr)).to.be(5);
            expect(utilx.Array.unshift(arr)).to.be(5);
            expect(utilx.Array.unshift(arr, true)).to.be(6);
            expect(utilx.Array.unshift(arr, false)).to.be(7);
            expect(utilx.Array.unshift(arr, 1)).to.be(8);
            expect(utilx.Array.unshift(arr, 0)).to.be(9);
            expect(utilx.Array.unshift(arr, -1)).to.be(10);
            expect(utilx.Array.unshift(arr, null)).to.be(11);
            expect(utilx.Array.unshift(arr, undefined)).to.be(12);
            expect(arr.length).to.be(arrCmp.length);
            for (i = 0; i < arr.length; i += 1) {
                expect(Object.prototype.hasOwnProperty.call(arr, i)).to.be.ok();
                expect(arr[i]).to.be(arrCmp[i]);
            }

            expect(required.slice(arr)).to.eql(arrCmp);
        });

        it('object with length', function () {
            var arrCmp = {
                    0: undefined,
                    1: null,
                    2: -1,
                    3: 0,
                    4: 1,
                    5: false,
                    6: true,
                    7: undefined,
                    8: '',
                    9: 'abc',
                    10: null,
                    11: undefined,
                    length: 12
                },
                arr = {
                    length: 0
                },
                i;

            expect(utilx.Array.unshift(arr, undefined)).to.be(1);
            expect(utilx.Array.unshift(arr, null)).to.be(2);
            expect(utilx.Array.unshift(arr, 'abc')).to.be(3);
            expect(utilx.Array.unshift(arr, '')).to.be(4);
            expect(utilx.Array.unshift(arr, undefined)).to.be(5);
            expect(utilx.Array.unshift(arr)).to.be(5);
            expect(utilx.Array.unshift(arr)).to.be(5);
            expect(utilx.Array.unshift(arr)).to.be(5);
            expect(utilx.Array.unshift(arr)).to.be(5);
            expect(utilx.Array.unshift(arr, true)).to.be(6);
            expect(utilx.Array.unshift(arr, false)).to.be(7);
            expect(utilx.Array.unshift(arr, 1)).to.be(8);
            expect(utilx.Array.unshift(arr, 0)).to.be(9);
            expect(utilx.Array.unshift(arr, -1)).to.be(10);
            expect(utilx.Array.unshift(arr, null)).to.be(11);
            expect(utilx.Array.unshift(arr, undefined)).to.be(12);
            expect(arr.length).to.be(arrCmp.length);
            for (i = 0; i < arr.length; i += 1) {
                expect(Object.prototype.hasOwnProperty.call(arr, i)).to.be.ok();
                expect(arr[i]).to.be(arrCmp[i]);
            }

            expect(arr).to.eql(arrCmp);
        });

        it('object without length', function () {
            var arrCmp = {
                    0: undefined,
                    1: null,
                    2: -1,
                    3: 0,
                    4: 1,
                    5: false,
                    6: true,
                    7: undefined,
                    8: '',
                    9: 'abc',
                    10: null,
                    11: undefined,
                    length: 12
                },
                arr = {},
                i;

            expect(utilx.Array.unshift(arr, undefined)).to.be(1);
            expect(utilx.Array.unshift(arr, null)).to.be(2);
            expect(utilx.Array.unshift(arr, 'abc')).to.be(3);
            expect(utilx.Array.unshift(arr, '')).to.be(4);
            expect(utilx.Array.unshift(arr, undefined)).to.be(5);
            expect(utilx.Array.unshift(arr)).to.be(5);
            expect(utilx.Array.unshift(arr)).to.be(5);
            expect(utilx.Array.unshift(arr)).to.be(5);
            expect(utilx.Array.unshift(arr)).to.be(5);
            expect(utilx.Array.unshift(arr, true)).to.be(6);
            expect(utilx.Array.unshift(arr, false)).to.be(7);
            expect(utilx.Array.unshift(arr, 1)).to.be(8);
            expect(utilx.Array.unshift(arr, 0)).to.be(9);
            expect(utilx.Array.unshift(arr, -1)).to.be(10);
            expect(utilx.Array.unshift(arr, null)).to.be(11);
            expect(utilx.Array.unshift(arr, undefined)).to.be(12);
            expect(arr.length).to.be(arrCmp.length);
            for (i = 0; i < arr.length; i += 1) {
                expect(Object.prototype.hasOwnProperty.call(arr, i)).to.be.ok();
                expect(arr[i]).to.be(arrCmp[i]);
            }

            expect(arr).to.eql(arrCmp);
        });
    });
}());

},{"../scripts/":10}],53:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Boolean.isBoolean', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Boolean.isBoolean(required.ToObject(true))).to.be.ok();
            expect(utilx.Boolean.isBoolean(required.ToObject(false))).to.be.ok();
            expect(utilx.Boolean.isBoolean(true)).to.be.ok();
            expect(utilx.Boolean.isBoolean(false)).to.be.ok();
            expect(utilx.Boolean.isBoolean()).to.not.be.ok();
            expect(utilx.Boolean.isBoolean(null)).to.not.be.ok();
            expect(utilx.Boolean.isBoolean('')).to.not.be.ok();
            expect(utilx.Boolean.isBoolean(0)).to.not.be.ok();
            expect(utilx.Boolean.isBoolean(1)).to.not.be.ok();
            expect(utilx.Boolean.isBoolean({})).to.not.be.ok();
            expect(utilx.Boolean.isBoolean([])).to.not.be.ok();
            expect(utilx.Boolean.isBoolean(Boolean.prototype)).to.be.ok();
        });

        if (required.frame) {
            it('should work accross frames', function () {
                expect(utilx.Boolean.isBoolean(new required.frame.Boolean(true))).to.be.ok();
            });
        }
    });
}());

},{"../scripts/":10}],54:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Date.isDate', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Date.isDate(new RegExp('test'))).to.not.be.ok();
            expect(utilx.Date.isDate(new Date())).to.be.ok();
            expect(utilx.Date.isDate(/test/)).to.not.be.ok();
            expect(utilx.Date.isDate([])).to.not.be.ok();
            expect(utilx.Date.isDate({})).to.not.be.ok();
            expect(utilx.Date.isDate('')).to.not.be.ok();
            expect(utilx.Date.isDate(1)).to.not.be.ok();
            expect(utilx.Date.isDate(true)).to.not.be.ok();
            expect(utilx.Date.isDate()).to.not.be.ok();
            expect(utilx.Date.isDate(null)).to.not.be.ok();
            expect(utilx.Date.isDate(required.noop)).to.not.be.ok();
            expect(utilx.Date.isDate(required.returnArgs())).to.not.be.ok();
            expect(utilx.Date.isDate(Date.prototype)).to.be.ok();
        });

        if (required.frame) {
            it('should work accross frames', function () {
                expect(utilx.Date.isDate(new required.frame.Date())).to.be.ok();
            });
        }
    });
}());

},{"../scripts/":10}],55:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Date.isValid', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Date.isValid(new Date())).to.be.ok();
            expect(utilx.Date.isValid(new Date(NaN))).to.not.be.ok();
        });
    });
}());

},{"../scripts/":10}],56:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Date.now', function () {
        it('should be the current time', function () {
            var before = (new Date()).getTime(),
                middle = utilx.Date.now(),
                after = (new Date()).getTime();

            expect(before <= middle).to.be.ok();
            expect(middle <= after).to.be.ok(after);
        });
    });
}());

},{"../scripts/":10}],57:[function(require,module,exports){
/*global Number, RangeError, RegExp, TypeError, describe, it, require */

/*properties
    Date, MAX_VALUE, a, be, expect, makeDate, noop, throwException, to, toISOString, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Date.toISOString', function () {
        it('exceptions', function () {
            expect(function () {
                utilx.Date.toISOString();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Date.toISOString(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Date.toISOString(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Date.toISOString(1);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Date.toISOString(true);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Date.toISOString('x');
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Date.toISOString([1, 2, 3]);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Date.toISOString({});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Date.toISOString(required.noop);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });


            expect(function () {
                utilx.Date.toISOString(new RegExp('c'));
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Date.toISOString(NaN);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Date.toISOString(Infinity);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Date.toISOString(-Infinity);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('strings should match', function () {
            expect(utilx.Date.toISOString(required.makeDate(-8.64e15))).to.be('-271821-04-20T00:00:00.000Z');
            expect(utilx.Date.toISOString(required.makeDate(8.64e15))).to.be('+275760-09-13T00:00:00.000Z');
            expect(utilx.Date.toISOString(required.makeDate(-621987552e5))).to.be('-000001-01-01T00:00:00.000Z');
            expect(utilx.Date.toISOString(required.makeDate(-1))).to.be('1969-12-31T23:59:59.999Z');
        });

        it('range error', function () {
            expect(function () {
                utilx.Date.toISOString(required.makeDate(Number.MAX_VALUE));
            }).to.throwException(function (e) {
                expect(e).to.be.a(RangeError);
            });
        });
    });
}());

},{"../scripts/":10}],58:[function(require,module,exports){
/*global Number, RegExp, TypeError, describe, it, require */

/*properties
    Date, MAX_VALUE, a, be, expect, makeDate, noop, throwException, to, toJSON,
    utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Date.toJSON', function () {
        it('exceptions', function () {
            expect(function () {
                utilx.Date.toJSON();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Date.toJSON(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Date.toJSON(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Date.toJSON(1);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Date.toJSON(true);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Date.toJSON('x');
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Date.toJSON([1, 2, 3]);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Date.toJSON({});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Date.toJSON(required.noop);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });


            expect(function () {
                utilx.Date.toJSON(new RegExp('c'));
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('oddities', function () {
            expect(utilx.Date.toJSON(NaN)).to.be(null);
            expect(utilx.Date.toJSON(Infinity)).to.be(null);
            expect(utilx.Date.toJSON(-Infinity)).to.be(null);
            expect(utilx.Date.toJSON(required.makeDate(Number.MAX_VALUE))).to.be(null);
        });

        it('strings should match', function () {
            expect(utilx.Date.toJSON(required.makeDate(-8.64e15))).to.be('-271821-04-20T00:00:00.000Z');
            expect(utilx.Date.toJSON(required.makeDate(8.64e15))).to.be('+275760-09-13T00:00:00.000Z');
            expect(utilx.Date.toJSON(required.makeDate(-621987552e5))).to.be('-000001-01-01T00:00:00.000Z');
            expect(utilx.Date.toJSON(required.makeDate(-1))).to.be('1969-12-31T23:59:59.999Z');
        });
    });
}());

},{"../scripts/":10}],59:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Error.isError', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Error.isError()).to.not.be.ok();
            expect(utilx.Error.isError(undefined)).to.not.be.ok();
            expect(utilx.Error.isError(null)).to.not.be.ok();
            expect(utilx.Error.isError(1)).to.not.be.ok();
            expect(utilx.Error.isError(true)).to.not.be.ok();
            expect(utilx.Error.isError('')).to.not.be.ok();
            expect(utilx.Error.isError(new Error('x'))).to.be.ok();
            expect(utilx.Error.isError(new SyntaxError('x'))).to.be.ok();
            expect(utilx.Error.isError(new TypeError('x'))).to.be.ok();
            expect(utilx.Error.isError(new EvalError('x'))).to.be.ok();
            expect(utilx.Error.isError(new RangeError('x'))).to.be.ok();
            expect(utilx.Error.isError(new ReferenceError('x'))).to.be.ok();
            expect(utilx.Error.isError(new URIError('x'))).to.be.ok();
            expect(utilx.Error.isError(new Date())).to.not.be.ok();
            expect(utilx.Error.isError(new RegExp('x'))).to.not.be.ok();
            expect(utilx.Error.isError(required.noop)).to.not.be.ok();
            expect(utilx.Error.isError([])).to.not.be.ok();
            expect(utilx.Error.isError({})).to.not.be.ok();
            expect(utilx.Error.isError(required.returnArgs())).to.not.be.ok();
            expect(utilx.Error.isError(Error.prototype)).to.be.ok();
        });

        if (required.frame) {
            it('should work accross frames', function () {
                expect(utilx.Error.isError(new required.frame.Error('x'))).to.be.ok();
            });
        }
    });
}());

},{"../scripts/":10}],60:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Error.isErrorTypeConstructor', function () {
        it('strict equal', function () {
            expect(utilx.Error.isErrorTypeConstructor(Error)).to.be.ok();
            expect(utilx.Error.isErrorTypeConstructor(TypeError)).to.be.ok();
            expect(utilx.Error.isErrorTypeConstructor(SyntaxError)).to.be.ok();
            expect(utilx.Error.isErrorTypeConstructor(RangeError)).to.be.ok();
            expect(utilx.Error.isErrorTypeConstructor(EvalError)).to.be.ok();
            expect(utilx.Error.isErrorTypeConstructor(ReferenceError)).to.be.ok();
            expect(utilx.Error.isErrorTypeConstructor(URIError)).to.be.ok();
            expect(utilx.Error.isErrorTypeConstructor(Array)).to.not.be.ok();
            expect(utilx.Error.isErrorTypeConstructor(Object)).to.not.be.ok();
            expect(utilx.Error.isErrorTypeConstructor(RegExp)).to.not.be.ok();
            expect(utilx.Error.isErrorTypeConstructor(Function)).to.not.be.ok();
        });
    });
}());

},{"../scripts/":10}],61:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Function.ToMethod', function () {
        it('should throw a TypeError in each case', function () {
            expect(function () {
                utilx.Function.ToMethod();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Function.ToMethod(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Function.ToMethod(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('creates a static method from a prototype method', function () {
            var toString = utilx.Function.ToMethod(Object.prototype.toString);

            expect(toString({})).to.be('[object Object]');
        });
    });
}());

},{"../scripts/":10}],62:[function(require,module,exports){
/*global Date, TypeError, describe, it, require */

/*properties
    Function, ToClass, a, be, apply, expect, isStrictMode, noop, not, throwException, to,
    utilx, global, create, returnArgs, $String
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Function.apply', function () {
        var arr = required.create(0, 1, 2, 'a', 'b', 'c', [8, 9, 10], {}, true, false, undefined, null, new Date(), new Error('x'), new RegExp('t'), Infinity, -Infinity),
            args = required.returnArgs(0, 1, 2, 'a', 'b', 'c', [8, 9, 10], {}, true, false, undefined, null, new Date(), new Error('x'), new RegExp('t'), Infinity, -Infinity);

        it('should throw a TypeError in each case', function () {
            expect(function () {
                utilx.Function.apply();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Function.apply(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Function.apply(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Function.apply({});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Function.apply({}, undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Function.apply({}, null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Function.apply({}, 'a');
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('second argument of mixed types but no third argument', function () {
            expect(function () {
                utilx.Function.apply(required.noop);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.apply(required.noop, undefined);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.apply(required.noop, null);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.apply(required.noop, 'a');
            }).to.not.throwException();

            expect(function () {
                utilx.Function.apply(required.noop, 1);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.apply(required.noop, true);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.apply(required.noop, required.noop);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.apply(required.noop, new Date());
            }).to.not.throwException();
        });

        it('should not throw a error with array', function () {
            expect(function () {
                utilx.Function.apply(required.noop, undefined, arr);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.apply(required.noop, null, arr);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.apply(required.noop, 'a', arr);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.apply(required.noop, 1, arr);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.apply(required.noop, true, arr);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.apply(required.noop, required.noop, arr);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.apply(required.noop, new Date(), arr);
            }).to.not.throwException();
        });

        it('should not throw a error with arguments', function () {
            expect(function () {
                utilx.Function.apply(required.noop, undefined, args);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.apply(required.noop, null, args);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.apply(required.noop, 'a', args);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.apply(required.noop, 1, args);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.apply(required.noop, true, args);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.apply(required.noop, required.noop, args);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.apply(required.noop, new Date(), args);
            }).to.not.throwException();
        });

        it('should throw a error with string', function () {
            expect(function () {
                utilx.Function.apply(required.noop, undefined, 'abc');
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Function.apply(required.noop, null, required.$String('abc'));
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        if (required.isStrictMode()) {
            it('should have correct context in strict mode', function () {
                var result,
                    testFn,
                    subject;

                testFn = function () {
                    return this;
                };

                expect(function () {
                    result = utilx.Function.apply(testFn);
                }).to.not.throwException();

                expect(result).to.be(undefined);

                expect(function () {
                    result = utilx.Function.apply(testFn, undefined);
                }).to.not.throwException();

                expect(result).to.be(undefined);

                expect(function () {
                    result = utilx.Function.apply(testFn, null);
                }).to.not.throwException();

                expect(result).to.be(null);

                expect(function () {
                    result = utilx.Function.apply(testFn, 'a');
                }).to.not.throwException();

                expect(result).to.be('a');

                expect(function () {
                    result = utilx.Function.apply(testFn, 1);
                }).to.not.throwException();

                expect(result).to.be(1);

                expect(function () {
                    result = utilx.Function.apply(testFn, true);
                }).to.not.throwException();

                expect(result).to.be(true);

                expect(function () {
                    result = utilx.Function.apply(testFn, testFn);
                }).to.not.throwException();

                expect(result).to.be(testFn);

                subject = new Date();
                expect(function () {
                    result = utilx.Function.apply(testFn, subject);
                }).to.not.throwException();

                expect(result).to.be(subject);
            });
        }
    });
}());

/*jslint sloppy: true */
(function () {
    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Function.apply', function () {
        it('should have correct context in non-strict mode', function () {
            var result,
                testFn,
                subject;

            testFn = function () {
                return this;
            };

            expect(function () {
                result = utilx.Function.apply(testFn);
            }).to.not.throwException();

            expect(result).to.be(required.global);

            expect(function () {
                result = utilx.Function.apply(testFn, undefined);
            }).to.not.throwException();

            expect(result).to.be(required.global);

            expect(function () {
                result = utilx.Function.apply(testFn, null);
            }).to.not.throwException();

            expect(result).to.be(required.global);

            expect(function () {
                result = utilx.Function.apply(testFn, 'a');
            }).to.not.throwException();

            expect(typeof result).to.be('object');
            expect(required.ToClass(result)).to.be('[object String]');

            expect(function () {
                result = utilx.Function.apply(testFn, 1);
            }).to.not.throwException();

            expect(typeof result).to.be('object');
            expect(required.ToClass(result)).to.be('[object Number]');

            expect(function () {
                result = utilx.Function.apply(testFn, true);
            }).to.not.throwException();

            expect(typeof result).to.be('object');
            expect(required.ToClass(result)).to.be('[object Boolean]');

            expect(function () {
                result = utilx.Function.apply(testFn, testFn);
            }).to.not.throwException();

            expect(result).to.be(testFn);

            subject = new Date();
            expect(function () {
                result = utilx.Function.apply(testFn, subject);
            }).to.not.throwException();

            expect(result).to.be(subject);
        });
    });
}());

},{"../scripts/":10}],63:[function(require,module,exports){
/*global TypeError, beforeEach, describe, it, require */

/*properties
    Array, Function, a, be, bind, call, eql, expect, forEach, func, length, name,
    not, push, slice, throwException, to, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Function.bind', function () {
        var actual, expected,
            testSubject,
            thisContext;

        testSubject = {
            push: function (o) {
                utilx.Array.push(this.a, o);
            }
        };

        thisContext = function () {
            return this;
        };

        function func() {
            /*jshint -W040 */
            required.forEach(arguments, function (a) {
                utilx.Array.push(this, a);
            }, this);

            return this;
            /*jshint +W040 */
        }

        beforeEach(function () {
            actual = [];
            testSubject.a = [];
        });

        it('should throw a TypeError in each case', function () {
            expect(function () {
                utilx.Function.bind();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Function.bind(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Function.bind(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('binds properly without a context', function () {
            var context;

            testSubject.func = utilx.Function.bind(function () {
                context = this;
            });

            testSubject.func();
            expect(context).to.be(thisContext.call());
        });

        it('binds properly without a context, and still supplies bound arguments', function () {
            var a,
                context;

            testSubject.func = utilx.Function.bind(function () {
                a = required.slice(arguments);
                context = this;
            }, undefined, 1, 2, 3);

            testSubject.func(1, 2, 3);
            expect(a).to.eql([1, 2, 3, 1, 2, 3]);
            expect(context).to.be(thisContext.call());
        });

        it('binds a context properly', function () {
            testSubject.func = utilx.Function.bind(func, actual);
            testSubject.func(1, 2, 3);
            expect(actual).to.eql([1, 2, 3]);
            expect(testSubject.a).to.eql([]);
        });

        it('binds a context and supplies bound arguments', function () {
            testSubject.func = utilx.Function.bind(func, actual, 1, 2, 3);
            testSubject.func(4, 5, 6);
            expect(actual).to.eql([1, 2, 3, 4, 5, 6]);
            expect(testSubject.a).to.eql([]);
        });

        it('returns properly without binding a context', function () {
            testSubject.func = utilx.Function.bind(function () {
                return this;
            });

            var context = testSubject.func();
            expect(context).to.be(thisContext.call());
        });

        it('returns properly without binding a context, and still supplies bound arguments', function () {
            var context;

            testSubject.func = utilx.Function.bind(function () {
                context = this;

                return required.slice(arguments);
            }, undefined, 1, 2, 3);

            actual = testSubject.func(1, 2, 3);
            expect(context).to.be(thisContext.call());

            expect(actual).to.eql([1, 2, 3, 1, 2, 3]);
        });

        it('returns properly while binding a context properly', function () {
            var ret;

            testSubject.func = utilx.Function.bind(func, actual);
            ret = testSubject.func(1, 2, 3);
            expect(ret).to.be(actual);
            expect(ret).not.to.be(testSubject);
        });

        it('returns properly while binding a context and supplies bound arguments', function () {
            var ret;

            testSubject.func = utilx.Function.bind(func, actual, 1, 2, 3);
            ret = testSubject.func(4, 5, 6);
            expect(ret).to.be(actual);
            expect(ret).not.to.be(testSubject);
        });

        it('passes the correct arguments as a constructor', function () {
            var ret;

            expected = {
                name: 'Correct'
            };

            testSubject.func = utilx.Function.bind(function (arg) {
                return arg;
            }, {
                name: 'Incorrect'
            });

            ret = new testSubject.func(expected);
            expect(ret).to.be(expected);
        });

        it('returns the return value of the bound function when called as a constructor', function () {
            var oracle = [1, 2, 3],
                Subject = utilx.Function.bind(function () {
                    return oracle;
                }, null),
                result = new Subject();

            expect(result).to.be(oracle);
        });

        it('returns the correct value if constructor returns primitive', function () {
            var oracle = [1, 2, 3],
                Subject = utilx.Function.bind(function () {
                    return oracle;
                }, null),
                result = new Subject();
            expect(result).to.be(oracle);

            oracle = {};
            result = new Subject();
            expect(result).to.be(oracle);

            oracle = function () { return; };
            result = new Subject();
            expect(result).to.be(oracle);

            oracle = 'asdf';
            result = new Subject();
            expect(result).not.to.be(oracle);

            oracle = null;
            result = new Subject();
            expect(result).not.to.be(oracle);

            oracle = true;
            result = new Subject();
            expect(result).not.to.be(oracle);

            oracle = 1;
            result = new Subject();
            expect(result).not.to.be(oracle);
        });

        it('returns the value that instance of original "class" when called as a constructor', function () {
            var ClassA = function (x) {
                    this.name = x || 'A';
                },
                ClassB = utilx.Function.bind(ClassA, null, 'B'),
                result = new ClassB(),
                isInstance;

            expect(typeof result).to.be('object');
            isInstance = result instanceof ClassA || false;
            expect(isInstance).to.be(true);
            expect(typeof isInstance).to.be('boolean');

            isInstance = result instanceof ClassB || false;
            expect(typeof isInstance).to.be('boolean');
            expect(isInstance).to.be(true);

            expect(result.name).to.be('B');
        });

        it('sets a correct length without thisArg', function () {
            var subject = utilx.Function.bind(function (a, b, c) {
                return a + b + c;
            });

            expect(subject.length).to.be(3);
        });

        it('sets a correct length with thisArg', function () {
            var subject = utilx.Function.bind(function (a, b, c) {
                return a + b + c;
            }, {});

            expect(subject.length).to.be(3);
        });

        it('sets a correct length with thisArg and first argument', function () {
            var subject = utilx.Function.bind(function (a, b, c) {
                return a + b + c;
            }, {}, 1);

            expect(subject.length).to.be(2);
        });

        it('sets a correct length without thisArg and first argument', function () {
            var subject = utilx.Function.bind(function (a, b, c) {
                return a + b + c;
            }, undefined, 1);

            expect(subject.length).to.be(2);
        });

        it('sets a correct length without thisArg and too many argument', function () {
            var subject = utilx.Function.bind(function (a, b, c) {
                return a + b + c;
            }, undefined, 1, 2, 3, 4);

            expect(subject.length).to.be(0);
        });
    });
}());

},{"../scripts/":10}],64:[function(require,module,exports){
/*global Date, TypeError, describe, it, require */

/*properties
    Function, ToClass, a, be, call, expect, isStrictMode, noop, not, throwException, to, utilx, global
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Function.call', function () {
        it('should throw a TypeError in each case', function () {
            expect(function () {
                utilx.Function.call();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Function.call(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Function.call(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Function.call({});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Function.call({}, undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Function.call({}, null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Function.call({}, 'a');
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw a error in each case', function () {
            expect(function () {
                utilx.Function.call(required.noop);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.call(required.noop, undefined);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.call(required.noop, null);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.call(required.noop, 'a');
            }).to.not.throwException();

            expect(function () {
                utilx.Function.call(required.noop, 1);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.call(required.noop, true);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.call(required.noop, required.noop);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.call(required.noop, new Date());
            }).to.not.throwException();
        });

        it('should not throw a error with additional args', function () {
            expect(function () {
                utilx.Function.call(required.noop, undefined, undefined, null, '1', 1, true, required.noop);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.call(required.noop, null, undefined, null, '1', 1, true, required.noop);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.call(required.noop, 'a', undefined, null, '1', 1, true, required.noop);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.call(required.noop, 1, undefined, null, '1', 1, true, required.noop);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.call(required.noop, true, undefined, null, '1', 1, true, required.noop);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.call(required.noop, required.noop, undefined, null, '1', 1, true, required.noop);
            }).to.not.throwException();

            expect(function () {
                utilx.Function.call(required.noop, new Date(), undefined, null, '1', 1, true, required.noop);
            }).to.not.throwException();
        });

        if (required.isStrictMode()) {
            it('should have correct context in strict mode', function () {
                var result,
                    testFn,
                    subject;

                testFn = function () {
                    return this;
                };

                expect(function () {
                    result = utilx.Function.call(testFn);
                }).to.not.throwException();

                expect(result).to.be(undefined);

                expect(function () {
                    result = utilx.Function.call(testFn, undefined);
                }).to.not.throwException();

                expect(result).to.be(undefined);

                expect(function () {
                    result = utilx.Function.call(testFn, null);
                }).to.not.throwException();

                expect(result).to.be(null);

                expect(function () {
                    result = utilx.Function.call(testFn, 'a');
                }).to.not.throwException();

                expect(result).to.be('a');

                expect(function () {
                    result = utilx.Function.call(testFn, 1);
                }).to.not.throwException();

                expect(result).to.be(1);

                expect(function () {
                    result = utilx.Function.call(testFn, true);
                }).to.not.throwException();

                expect(result).to.be(true);

                expect(function () {
                    result = utilx.Function.call(testFn, testFn);
                }).to.not.throwException();

                expect(result).to.be(testFn);

                subject = new Date();
                expect(function () {
                    result = utilx.Function.call(testFn, subject);
                }).to.not.throwException();

                expect(result).to.be(subject);
            });
        }
    });
}());

/*jslint sloppy: true */
(function () {
    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Function.call', function () {
        it('should have correct context in non-strict mode', function () {
            var result,
                testFn,
                subject;

            testFn = function () {
                return this;
            };

            expect(function () {
                result = utilx.Function.call(testFn);
            }).to.not.throwException();

            expect(result).to.be(required.global);

            expect(function () {
                result = utilx.Function.call(testFn, undefined);
            }).to.not.throwException();

            expect(result).to.be(required.global);

            expect(function () {
                result = utilx.Function.call(testFn, null);
            }).to.not.throwException();

            expect(result).to.be(required.global);

            expect(function () {
                result = utilx.Function.call(testFn, 'a');
            }).to.not.throwException();

            expect(typeof result).to.be('object');
            expect(required.ToClass(result)).to.be('[object String]');

            expect(function () {
                result = utilx.Function.call(testFn, 1);
            }).to.not.throwException();

            expect(typeof result).to.be('object');
            expect(required.ToClass(result)).to.be('[object Number]');

            expect(function () {
                result = utilx.Function.call(testFn, true);
            }).to.not.throwException();

            expect(typeof result).to.be('object');
            expect(required.ToClass(result)).to.be('[object Boolean]');

            expect(function () {
                result = utilx.Function.call(testFn, testFn);
            }).to.not.throwException();

            expect(result).to.be(testFn);

            subject = new Date();
            expect(function () {
                result = utilx.Function.call(testFn, subject);
            }).to.not.throwException();

            expect(result).to.be(subject);
        });
    });
}());

},{"../scripts/":10}],65:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect,
        Test,
        Tested;

    describe('Function.inherits', function () {
        it('setting up should not throw an error', function () {
            expect(function () {
                Test = function () {
                    return;
                };

                utilx.Object.defineProperties(Test.prototype, {
                    foo: {
                        value: '123'
                    },

                    bar: {
                        value: required.noop
                    },

                    flum: {
                        value: new Date()
                    },

                    wiz: {
                        value: new RegExp('x'),
                        writable: true,
                        enumerable: true,
                        configurable: true
                    }
                });

                Tested = function () {
                    return;
                };

                utilx.Function.inherits(Tested, Test);
            }).to.not.throwException();
        });

        it('should not throw an error in each case', function () {
            expect(Tested.prototype).not.to.be(Test.prototype);
            expect(Tested.prototype.foo).to.be(Test.prototype.foo);
            expect(Tested.prototype.bar).to.be(Test.prototype.bar);
            expect(Tested.prototype.flum).to.be(Test.prototype.flum);
            expect(Tested.prototype.wiz).to.be(Test.prototype.wiz);
            expect(Tested.prototype.constructor).to.be(Tested);
        });
    });
}());

},{"../scripts/":10}],66:[function(require,module,exports){
/*global Boolean, Date, Error, Function, Number, Object, RegExp, String, describe, isFinite, isNaN, it, require */

/*properties
    Function, alert, be, expect, global, isFunction, noop, not, ok, returnArgs,
    setInterval, to, utilx, frame, Array, prototype
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Function.isFunction', function () {
        it('non functions should be not ok in each case', function () {
            expect(utilx.Function.isFunction()).to.not.be.ok();
            expect(utilx.Function.isFunction(undefined)).to.not.be.ok();
            expect(utilx.Function.isFunction(null)).to.not.be.ok();
            expect(utilx.Function.isFunction(1)).to.not.be.ok();
            expect(utilx.Function.isFunction(true)).to.not.be.ok();
            expect(utilx.Function.isFunction('')).to.not.be.ok();
            expect(utilx.Function.isFunction(new Error('x'))).to.not.be.ok();
            expect(utilx.Function.isFunction(new Date())).to.not.be.ok();
            expect(utilx.Function.isFunction(new RegExp('x'))).to.not.be.ok();
            expect(utilx.Function.isFunction([])).to.not.be.ok();
            expect(utilx.Function.isFunction({})).to.not.be.ok();
            expect(utilx.Function.isFunction(required.returnArgs())).to.not.be.ok();
            expect(utilx.Function.isFunction(Function.prototype)).to.be.ok();
        });

        it('user functions should not ok in each case', function () {
            expect(utilx.Function.isFunction(required.noop)).to.be.ok();
            expect(utilx.Function.isFunction(describe)).to.be.ok();
            expect(utilx.Function.isFunction(expect)).to.be.ok();
            expect(utilx.Function.isFunction(it)).to.be.ok();
        });

        it('Error constructor should be ok', function () {
            expect(utilx.Function.isFunction(Error)).to.be.ok();
        });

        it('Date constructor should be ok', function () {
            expect(utilx.Function.isFunction(Date)).to.be.ok();
        });

        it('RegExp constructor should be ok', function () {
            expect(utilx.Function.isFunction(RegExp)).to.be.ok();
        });

        it('Function constructor should be ok', function () {
            expect(utilx.Function.isFunction(Function)).to.be.ok();
        });

        it('Boolean constructor should be ok', function () {
            expect(utilx.Function.isFunction(Boolean)).to.be.ok();
        });

        it('Number constructor should be ok', function () {
            expect(utilx.Function.isFunction(Number)).to.be.ok();
        });

        it('String constructor should be ok', function () {
            expect(utilx.Function.isFunction(String)).to.be.ok();
        });

        it('Object constructor should be ok', function () {
            expect(utilx.Function.isFunction(Object)).to.be.ok();
        });

        it('isNaN should be ok', function () {
            expect(utilx.Function.isFunction(isNaN)).to.be.ok();
        });

        it('isFinite should be ok', function () {
            expect(utilx.Function.isFunction(isFinite)).to.be.ok();
        });

        if (required.global.alert) {
            it('alert should be ok', function () {
                expect(utilx.Function.isFunction(required.global.alert)).to.be.ok();
            });
        }

        if (required.global.setInterval) {
            it('setInterval should be ok', function () {
                expect(utilx.Function.isFunction(required.global.setInterval)).to.be.ok();
            });
        }

        if (required.frame) {
            it('should work accross frames', function () {
                expect(utilx.Function.isFunction(required.frame.Array)).to.be.ok();
            });
        }
    });
}());

},{"../scripts/":10}],67:[function(require,module,exports){
/*global Boolean, Date, Error, Function, Number, Object, RegExp, String, describe, isFinite, isNaN, it, require, window */

/*properties
    Function, alert, be, expect, global, isFunction, isNativeFunction, noop, not,
    ok, returnArgs, setInterval, to, utilx, frame, Array, prototype
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Function.isNativeFunction', function () {
        it('non functions should be not ok in each case', function () {
            expect(utilx.Function.isNativeFunction()).to.not.be.ok();
            expect(utilx.Function.isNativeFunction(undefined)).to.not.be.ok();
            expect(utilx.Function.isNativeFunction(null)).to.not.be.ok();
            expect(utilx.Function.isNativeFunction(1)).to.not.be.ok();
            expect(utilx.Function.isNativeFunction(true)).to.not.be.ok();
            expect(utilx.Function.isNativeFunction('')).to.not.be.ok();
            expect(utilx.Function.isNativeFunction(new Error('x'))).to.not.be.ok();
            expect(utilx.Function.isNativeFunction(new Date())).to.not.be.ok();
            expect(utilx.Function.isNativeFunction(new RegExp('x'))).to.not.be.ok();
            expect(utilx.Function.isNativeFunction([])).to.not.be.ok();
            expect(utilx.Function.isNativeFunction({})).to.not.be.ok();
            expect(utilx.Function.isNativeFunction(required.returnArgs())).to.not.be.ok();
        });

        it('user functions should be not ok in each case', function () {
            expect(utilx.Function.isNativeFunction(required.noop)).to.not.be.ok();
            expect(utilx.Function.isNativeFunction(describe)).to.not.be.ok();
            expect(utilx.Function.isNativeFunction(expect)).to.not.be.ok();
            expect(utilx.Function.isNativeFunction(it)).to.not.be.ok();
        });

        it('Error constructor should be ok', function () {
            expect(utilx.Function.isNativeFunction(Error)).to.be.ok();
        });

        it('Date constructor should be ok', function () {
            expect(utilx.Function.isNativeFunction(Date)).to.be.ok();
        });

        it('RegExp constructor should be ok', function () {
            expect(utilx.Function.isNativeFunction(RegExp)).to.be.ok();
        });

        it('Function constructor should be ok', function () {

            expect(utilx.Function.isNativeFunction(Function)).to.be.ok();
        });

        it('Boolean constructor should be ok', function () {
            expect(utilx.Function.isNativeFunction(Boolean)).to.be.ok();
        });

        it('Number constructor should be ok', function () {
            expect(utilx.Function.isNativeFunction(Number)).to.be.ok();
        });

        it('String constructor should be ok', function () {
            expect(utilx.Function.isNativeFunction(String)).to.be.ok();
        });

        it('Object constructor should be ok', function () {
            expect(utilx.Function.isNativeFunction(Object)).to.be.ok();
        });

        it('isNaN should be ok', function () {
            expect(utilx.Function.isNativeFunction(isNaN)).to.be.ok();
        });

        it('isFinite should be ok', function () {
            expect(utilx.Function.isNativeFunction(isFinite)).to.be.ok();
        });

        if (required.global.alert) {
            it('alert should be ok', function () {
                expect(utilx.Function.isNativeFunction(required.global.alert)).to.be.ok();
            });
        }

        // on node, setInterval is not a native function
        if (required.global.setInterval) {
            if (typeof window === 'object' || typeof window === 'function') {
                it('setInterval should be ok', function () {
                    expect(utilx.Function.isNativeFunction(required.global.setInterval)).to.be.ok();
                });
            } else {
                it('setInterval on node should not be ok', function () {
                    expect(utilx.Function.isNativeFunction(required.global.setInterval)).to.not.be.ok();
                });
            }
        }

        it('only user functions should be ok in each case', function () {
            expect(utilx.Function.isFunction(required.noop) &&
                    !utilx.Function.isNativeFunction(required.noop)).to.be.ok();

            expect(utilx.Function.isFunction(describe) && !utilx.Function.isNativeFunction(describe)).to.be.ok();
            expect(utilx.Function.isFunction(expect) && !utilx.Function.isNativeFunction(expect)).to.be.ok();
            expect(utilx.Function.isFunction(it) && !utilx.Function.isNativeFunction(it)).to.be.ok();
        });

        it('only native functions should not be ok in each case', function () {
            expect(utilx.Function.isFunction(Error) && !utilx.Function.isNativeFunction(Error)).to.not.be.ok();
            expect(utilx.Function.isFunction(Date) && !utilx.Function.isNativeFunction(Date)).to.not.be.ok();
            expect(utilx.Function.isFunction(RegExp) && !utilx.Function.isNativeFunction(RegExp)).to.not.be.ok();
            expect(utilx.Function.isFunction(Function) && !utilx.Function.isNativeFunction(Function)).to.not.be.ok();
            if (required.global.alert) {
                expect(utilx.Function.isFunction(required.global.alert) &&
                        !utilx.Function.isNativeFunction(required.global.alert)).to.not.be.ok();
            }

            // on node, setInterval is not a native function
            if (required.global.setInterval) {
                if (typeof window === 'object' || typeof window === 'function') {
                    expect(utilx.Function.isFunction(required.global.setInterval) &&
                            !utilx.Function.isNativeFunction(required.global.setInterval)).to.not.be.ok();
                } else {
                    expect(utilx.Function.isFunction(required.global.setInterval) &&
                            !utilx.Function.isNativeFunction(required.global.setInterval)).to.be.ok();
                }
            }
        });

        if (required.frame) {
            it('should work accross frames', function () {
                expect(utilx.Function.isNativeFunction(required.frame.Array)).to.be.ok();
            });
        }
    });
}());

},{"../scripts/":10}],68:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Function.noop', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Function.noop()).to.be(undefined);
            expect(utilx.Function.noop(1, 2, 3)).to.be(undefined);
            expect(utilx.Function.isFunction(utilx.Function.noop)).to.be.ok();
        });
    });
}());

},{"../scripts/":10}],69:[function(require,module,exports){
/*global require, describe, it */

/*properties
    Function, Object, be, eql, expect, isArguments, noop, ok, returnArgs, slice,
    to, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Function.returnArgs', function () {
        it('should not throw an error in each case', function () {
            expect(required.isArguments(utilx.Function.returnArgs())).to.be.ok();
            expect(required.slice(utilx.Function.returnArgs())).to.eql([]);
            expect(required.slice(utilx.Function.returnArgs(1, 2, 3))).to.eql([1, 2, 3]);
            expect(required.slice(utilx.Function.returnArgs(required.noop))).to.eql([required.noop]);
        });
    });
}());

},{"../scripts/":10}],70:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('JSON.parse', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.JSON.parse(null)).to.be(null);
            expect(utilx.JSON.parse('-1')).to.be(-1);
            expect(utilx.JSON.parse('0')).to.be(0);
            expect(utilx.JSON.parse('1')).to.be(1);
            expect(utilx.JSON.parse(false)).to.be(false);
            expect(utilx.JSON.parse(true)).to.be(true);
            expect(utilx.JSON.parse('null')).to.be(null);

            expect(function () {
                utilx.JSON.parse();
            }).to.throwException(function (e) {
                expect(e).to.be.a(SyntaxError);
            });

            expect(function () {
                utilx.JSON.parse(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(SyntaxError);
            });

            expect(function () {
                utilx.JSON.parse('');
            }).to.throwException(function (e) {
                expect(e).to.be.a(SyntaxError);
            });

            expect(function () {
                utilx.JSON.parse('{"A": undefined}');
            }).to.throwException(function (e) {
                expect(e).to.be.a(SyntaxError);
            });

            expect(utilx.JSON.parse('{"A":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}')).to.eql({
                'A': [1, true, false, null, '\u0000\b\n\f\r\t']
            });
        });
    });
}());

},{"../scripts/":10}],71:[function(require,module,exports){
/*global Boolean, Number, TypeError, describe, it, require */

/*properties
    A, B, JSON, Number, String, a, be, expect, makeDate, noop, not, stringify,
    throwException, to, toJSON, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('JSON.stringify', function () {
        it('cyclic should throw a TypeError', function () {
            var a = [];

            a[0] = a;

            expect(function () {
                utilx.JSON.stringify(a);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('basic', function () {
            expect(utilx.JSON.stringify(null)).to.be('null');
            expect(utilx.JSON.stringify(-1)).to.be('-1');
            expect(utilx.JSON.stringify(0)).to.be('0');
            expect(utilx.JSON.stringify(1)).to.be('1');
            expect(utilx.JSON.stringify(Number(1))).to.be('1');
            expect(utilx.JSON.stringify(false)).to.be('false');
            expect(utilx.JSON.stringify(true)).to.be('true');
            expect(utilx.JSON.stringify(Boolean(true))).to.be('true');
            expect(utilx.JSON.stringify()).to.be(undefined);
            expect(utilx.JSON.stringify(undefined)).to.be(undefined);
            expect(utilx.JSON.stringify('')).to.be('""');
            expect(utilx.JSON.stringify('abc')).to.be('"abc"');
            expect(utilx.JSON.stringify(required.String('abc'))).to.be('"abc"');
        });

        it('known issues', function () {
            function customJSON() {
                return 1;
            }

            customJSON.toJSON = customJSON;

            // Firefox 3.1b1 and b2 serialize string, number, and boolean
            // primitives as object literals.
            expect(utilx.JSON.stringify(0)).to.be('0');
            // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
            // literals.
            expect(utilx.JSON.stringify(new required.Number())).to.be('0');
            expect(utilx.JSON.stringify(new required.String())).to.be('""');
            // FF 3.1b1, 2 throw an error if the toJSON is `null`, `undefined`, or
            // does not define a canonical JSON representation (this applies to
            // objects with `toJSON` properties as well, *unless* they are nested
            // within an object or array).
            expect(function () {
                utilx.JSON.stringify(required.noop);
            }).to.not.throwException();
            expect(typeof utilx.JSON.stringify(required.noop)).to.be('undefined');
            // IE 8 serializes `undefined` as `"undefined"`. Safari 5.1.7 and FF
            // 3.1b3 pass this test.
            expect(typeof utilx.JSON.stringify(undefined)).to.be('undefined');
            // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
            // respectively, if the toSON is omitted entirely.
            expect(function () {
                utilx.JSON.stringify();
            }).to.not.throwException();
            expect(typeof utilx.JSON.stringify()).to.be('undefined');
            // FF 3.1b1, 2 throw an error if the given testTemp.a is not a number,
            // string, array, object, Boolean, or `null` literal. This applies to
            // objects with custom `toJSON` methods as well, unless they are nested
            // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
            // methods entirely.
            expect(function () {
                utilx.JSON.stringify(customJSON);
                utilx.JSON.stringify([customJSON]);
            }).to.not.throwException();
            expect(utilx.JSON.stringify(customJSON)).to.be('1');
            expect(utilx.JSON.stringify([customJSON])).to.be('[1]');
            // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
            // `"[null]"`.
            expect(utilx.JSON.stringify([undefined])).to.be('[null]');
            // YUI 3.0.0b1 fails to serialize `null` literals.
            expect(utilx.JSON.stringify(null)).to.be('null');
            // FF 3.1b1, 2 halts serialization if an array contains a function:
            // `[1, true, noop, 1]` serializes as "[1,true,],". These versions
            // of Firefox also allow trailing commas in JSON objects and arrays.
            // FF 3.1b3 elides non-JSON values from objects and arrays, unless they
            // define custom `toJSON` methods.
            expect(utilx.JSON.stringify([undefined, required.noop, null])).to.be('[null,null,null]');
            // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
            // where character escape codes are expected (e.g., `\b` => `\u0008`).
            // Removed test for '\0' => '\\'u0000'as Chrome 10 fails in 'use strict' mode with
            // Error: Uncaught SyntaxError: Octal literals are not allowed in strict mode.
            expect(function () {
                utilx.JSON.stringify({
                    'A': [customJSON, true, false, null, '\b\n\f\r\t']
                });
            }).to.not.throwException();
            expect(utilx.JSON.stringify({
                'A': [customJSON, true, false, null, '\b\n\f\r\t']
            })).to.be('{"A":[1,true,false,null,"\\b\\n\\f\\r\\t"]}');
            // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
            //utilx.JSON.stringify(null, testTemp.customJSON) === '"1"' &&
            expect(utilx.JSON.stringify([1, 2], null, 1)).to.be('[\n 1,\n 2\n]');
        });

        it('extra', function () {
            expect(utilx.JSON.stringify({
                'A': undefined,
                'B': null
            })).to.be('{"B":null}');

            expect(utilx.JSON.stringify({
                'A': [1, true, false, null, '\u0000\b\n\f\r\t']
            })).to.be('{"A":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}');
        });

        it('date toJSON', function () {
            var date1 = required.makeDate(-8.64e15),
                date2 = required.makeDate(8.64e15),
                date3 = required.makeDate(-621987552e5),
                date4 = required.makeDate(-1);

            expect(utilx.JSON.stringify(date1)).to.be('"-271821-04-20T00:00:00.000Z"');
            expect(utilx.JSON.stringify(date2)).to.be('"+275760-09-13T00:00:00.000Z"');
            expect(utilx.JSON.stringify(date3)).to.be('"-000001-01-01T00:00:00.000Z"');
            expect(utilx.JSON.stringify(date4)).to.be('"1969-12-31T23:59:59.999Z"');

            date1.toJSON = undefined;
            expect(utilx.JSON.stringify(date1)).to.be('{}');
        });
    });
}());

},{"../scripts/":10}],72:[function(require,module,exports){
/*global Date, Error, RegExp, describe, it, require */

/*properties
    Array, Math, be, expect, forEach, isNaN, noop, ok, sign, to, toString, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Math.sign', function () {
        it('should not throw an error in each case', function () {
            var x = utilx.Math.sign();

            expect(required.isNaN(x)).to.be.ok();
            x = utilx.Math.sign(undefined);
            expect(required.isNaN(utilx.Math.sign(undefined))).to.be.ok();
            x = utilx.Math.sign(null);
            expect(typeof x === 'number' && x === 0 && 1 / x === Infinity).to.be.ok();

            expect(utilx.Math.sign(-1)).to.be(-1);

            x = utilx.Math.sign(+0);
            expect(typeof x === 'number' && x === 0 && 1 / x === Infinity).to.be.ok();
            x = utilx.Math.sign('0');
            expect(typeof x === 'number' && x === 0 && 1 / x === Infinity).to.be.ok();
            x = utilx.Math.sign('+0');
            expect(typeof x === 'number' && x === 0 && 1 / x === Infinity).to.be.ok();
            x = utilx.Math.sign(-0);
            expect(typeof x === 'number' && x === 0 && 1 / x === -Infinity).to.be.ok();
            x = utilx.Math.sign('-0');
            expect(typeof x === 'number' && x === 0 && 1 / x === -Infinity).to.be.ok();

            expect(utilx.Math.sign(1)).to.be(1);
            expect(utilx.Math.sign(Infinity)).to.be(1);
            expect(utilx.Math.sign(-Infinity)).to.be(-1);

            x = utilx.Math.sign(NaN);
            expect(required.isNaN(x)).to.be.ok();
            x = utilx.Math.sign('NaN');
            expect(required.isNaN(x)).to.be.ok();
            x = utilx.Math.sign('');
            expect(typeof x === 'number' && x === 0 && 1 / x === Infinity).to.be.ok();
            x = utilx.Math.sign(' ');
            expect(typeof x === 'number' && x === 0 && 1 / x === Infinity).to.be.ok();

            expect(utilx.Math.sign(true)).to.be(1);

            x = utilx.Math.sign(false);
            expect(typeof x === 'number' && x === 0 && 1 / x === Infinity).to.be.ok();
            x = utilx.Math.sign(required.noop);
            expect(required.isNaN(x)).to.be.ok();
            x = utilx.Math.sign({});
            expect(required.isNaN(x)).to.be.ok();
            x = utilx.Math.sign([]);
            expect(typeof x === 'number' && x === 0 && 1 / x === Infinity).to.be.ok();
            x = utilx.Math.sign(new RegExp('c'));
            expect(required.isNaN(x)).to.be.ok();

            expect(utilx.Math.sign(new Date(2013, 11, 11))).to.be(1);

            x = utilx.Math.sign(new Error('x'));
            expect(required.isNaN(x)).to.be.ok();

            // we also verify that [[ToNumber]] is being called
            required.forEach([Infinity, 1], function (value) {
                expect(utilx.Math.sign(value)).to.be(1);
                expect(utilx.Math.sign(value.toString())).to.be(1);
            });

            expect(utilx.Math.sign(true)).to.be(1);
            required.forEach([-Infinity, -1], function (value) {
                expect(utilx.Math.sign(value)).to.be(-1);
                expect(utilx.Math.sign(value.toString())).to.be(-1);
            });
        });
    });
}());

},{"../scripts/":10}],73:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.clamp', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Number.clamp(-10, -5, 5)).to.be(-5);
            expect(utilx.Number.clamp(10, -5, 5)).to.be(5);
            expect(utilx.Number.clamp(-5, -5, 5)).to.be(-5);
            expect(utilx.Number.clamp(5, -5, 5)).to.be(5);
        });
    });
}());

},{"../scripts/":10}],74:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.clampToInt', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Number.clampToInt(-10, -5, 5)).to.be(-5);
            expect(utilx.Number.clampToInt(10, -5, 5)).to.be(5);
            expect(utilx.Number.clampToInt(-5, -5, 5)).to.be(-5);
            expect(utilx.Number.clampToInt(5, -5, 5)).to.be(5);
            expect(utilx.Number.clampToInt(-10.5, -5, 5)).to.be(-5);
            expect(utilx.Number.clampToInt(10.5, -5, 5)).to.be(5);
            expect(utilx.Number.clampToInt(-4.6, -5, 5)).to.be(-4);
            expect(utilx.Number.clampToInt(4.6, -5, 5)).to.be(4);
            expect(utilx.Number.clampToInt(-4.5, -5, 5)).to.be(-4);
            expect(utilx.Number.clampToInt(4.5, -5, 5)).to.be(4);
            expect(utilx.Number.clampToInt(-4.4, -5, 5)).to.be(-4);
            expect(utilx.Number.clampToInt(4.4, -5, 5)).to.be(4);
        });
    });
}());

},{"../scripts/":10}],75:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.constants', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Number.POSITIVE_ZERO).to.be(0);
            expect(utilx.Number.NEGATIVE_ZERO).to.be(0);
            expect(1 / utilx.Number.POSITIVE_ZERO).to.be(Infinity);
            expect(1 / utilx.Number.NEGATIVE_ZERO).to.be(-Infinity);
            expect(utilx.Number.WORD8).to.be(128);
            expect(utilx.Number.UWORD8).to.be(256);
            expect(utilx.Number.WORD16).to.be(32768);
            expect(utilx.Number.UWORD16).to.be(65536);
            expect(utilx.Number.WORD32).to.be(2147483648);
            expect(utilx.Number.UWORD32).to.be(4294967296);
            expect(utilx.Number.MAX_UINT32).to.be(4294967295);
            expect(utilx.Number.MAX_INT32).to.be(2147483647);
            expect(utilx.Number.MIN_INT32).to.be(-2147483648);
            expect(utilx.Number.MAX_UINT16).to.be(65535);
            expect(utilx.Number.MAX_INT16).to.be(32767);
            expect(utilx.Number.MIN_INT16).to.be(-32768);
            expect(utilx.Number.MAX_UINT8).to.be(255);
            expect(utilx.Number.MAX_INT8).to.be(127);
            expect(utilx.Number.MIN_INT8).to.be(-128);
            expect(utilx.Number.MAX_SAFE_INTEGER).to.be(9007199254740991);
            expect(utilx.Number.MIN_SAFE_INTEGER).to.be(-9007199254740991);
            expect(utilx.Number.UNSAFE_INTEGER).to.be(9007199254740992);
            expect(utilx.Number.POSITIVE_INFINITY).to.be(Infinity);
            expect(utilx.Number.NEGATIVE_INFINITY).to.be(-Infinity);
            expect(utilx.Number.MAX_VALUE).to.be(1.7976931348623157e+308);
            expect(utilx.Number.MIN_VALUE).to.be(5e-324);
            expect(utilx.Number.NaN !== utilx.Number.NaN).to.be.ok();
            expect(utilx.Number.EPSILON).to.be(2.220446049250313e-16);
        });
    });
}());

},{"../scripts/":10}],76:[function(require,module,exports){
/*global require, describe, it */

/*properties
    Number, be, expect, inRange, to, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.inRange', function () {
        it('arguments should be coerced to a number', function () {
            expect(utilx.Number.inRange()).to.be(false);
            expect(utilx.Number.inRange(undefined)).to.be(false);
            expect(utilx.Number.inRange(null)).to.be(false);
            expect(utilx.Number.inRange(10)).to.be(false);
            expect(utilx.Number.inRange(0)).to.be(false);
            expect(utilx.Number.inRange(-10, -5, '5')).to.be(false);
            expect(utilx.Number.inRange(-10, '-5', 5)).to.be(false);
            expect(utilx.Number.inRange(-10, -5, [])).to.be(false);
            expect(utilx.Number.inRange(-10, {}, 5)).to.be(false);
            expect(utilx.Number.inRange(-10, [], [])).to.be(false);
            expect(utilx.Number.inRange(-10, {}, {})).to.be(false);
            expect(utilx.Number.inRange([], [], [])).to.be(false);
            expect(utilx.Number.inRange({}, {}, {})).to.be(false);
            expect(utilx.Number.inRange(-10, '1', '1')).to.be(false);
            expect(utilx.Number.inRange(-10, 1, 1)).to.be(false);
            expect(utilx.Number.inRange(NaN, -Infinity, Infinity)).to.be(false);
            expect(utilx.Number.inRange(-10, NaN, 1)).to.be(false);
            expect(utilx.Number.inRange(-10, -1, NaN)).to.be(false);
            expect(utilx.Number.inRange(NaN, -1, 1)).to.be(false);
            expect(utilx.Number.inRange('x', 'a', 'a')).to.be(false);
            expect(utilx.Number.inRange(0, 1, -1)).to.be(false);
        });

        it('number literals should not throw an error in each case', function () {
            expect(utilx.Number.inRange(-10, -5, 5)).to.be(false);
            expect(utilx.Number.inRange(10, -5, 5)).to.be(false);
            expect(utilx.Number.inRange(-5, -5, 5)).to.be(true);
            expect(utilx.Number.inRange(5, -5, 5)).to.be(true);
            expect(utilx.Number.inRange(0, -5, 5)).to.be(true);
            expect(utilx.Number.inRange(+0, -5, 5)).to.be(true);
            expect(utilx.Number.inRange(-0, -5, 5)).to.be(true);
            expect(utilx.Number.inRange(0, -Infinity, Infinity)).to.be(true);
            expect(utilx.Number.inRange(-Infinity, -5, 5)).to.be(false);
            expect(utilx.Number.inRange(Infinity, -5, 5)).to.be(false);
            expect(utilx.Number.inRange(NaN, -5, 5)).to.be(false);
        });

        it('string literals should not throw an error in each case', function () {
            expect(utilx.Number.inRange('.', 'a', 'z')).to.be(false);
            expect(utilx.Number.inRange('a', 'a', 'z')).to.be(false);
            expect(utilx.Number.inRange('h', 'a', 'z')).to.be(false);
            expect(utilx.Number.inRange('z', 'a', 'z')).to.be(false);
            expect(utilx.Number.inRange('', 'a', 'z')).to.be(false);
            expect(utilx.Number.inRange('?', 'a', 'z')).to.be(false);
        });
    });
}());

},{"../scripts/":10}],77:[function(require,module,exports){
/*global require, describe, it */

/*properties
    Number, Object, ToObject, UNSAFE_INTEGER, be, expect, isEven, not, ok, to,
    utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.isEven', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Number.isEven(-3.5)).to.not.be.ok();
            expect(utilx.Number.isEven(-3)).to.not.be.ok();
            expect(utilx.Number.isEven(-2.5)).to.not.be.ok();
            expect(utilx.Number.isEven(-2)).to.be.ok();
            expect(utilx.Number.isEven(-1.5)).to.not.be.ok();
            expect(utilx.Number.isEven(-1)).to.not.be.ok();
            expect(utilx.Number.isEven(-0.5)).to.not.be.ok();
            expect(utilx.Number.isEven(0)).to.be.ok();
            expect(utilx.Number.isEven(0.5)).to.not.be.ok();
            expect(utilx.Number.isEven(1)).to.not.be.ok();
            expect(utilx.Number.isEven(1.5)).to.not.be.ok();
            expect(utilx.Number.isEven(2)).to.be.ok();
            expect(utilx.Number.isEven(2.5)).to.not.be.ok();
            expect(utilx.Number.isEven(3)).to.not.be.ok();
            expect(utilx.Number.isEven(3.5)).to.not.be.ok();
            expect(utilx.Number.isEven(utilx.Object.ToObject(true))).to.not.be.ok();
            expect(utilx.Number.isEven(utilx.Object.ToObject(false))).to.not.be.ok();
            expect(utilx.Number.isEven(true)).to.not.be.ok();
            expect(utilx.Number.isEven(false)).to.not.be.ok();
            expect(utilx.Number.isEven()).to.not.be.ok();
            expect(utilx.Number.isEven(null)).to.not.be.ok();
            expect(utilx.Number.isEven('')).to.not.be.ok();
            expect(utilx.Number.isEven({})).to.not.be.ok();
            expect(utilx.Number.isEven([])).to.not.be.ok();
            expect(utilx.Number.isEven(NaN)).to.not.be.ok();
            expect(utilx.Number.isEven(Infinity)).to.not.be.ok();
            expect(utilx.Number.isEven(-Infinity)).to.not.be.ok();
            expect(utilx.Number.isEven(utilx.Number.UNSAFE_INTEGER)).to.be.ok();
            expect(utilx.Number.isEven(-utilx.Number.UNSAFE_INTEGER)).to.be.ok();
        });
    });
}());

},{"../scripts/":10}],78:[function(require,module,exports){
/*global Date, Error, RegExp, describe, it, require */

/*properties
    Number, be, expect, isFinite, not, ok, to, toString, utilx, valueOf
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.isFinite', function () {
        it('should not throw an error in each case', function () {
            var zero = 0;

            expect(utilx.Number.isFinite()).to.not.be.ok();
            expect(utilx.Number.isFinite(undefined)).to.not.be.ok();
            expect(utilx.Number.isFinite(null)).to.not.be.ok();
            expect(utilx.Number.isFinite(1)).to.be.ok();
            expect(utilx.Number.isFinite(Infinity)).to.not.be.ok();
            expect(utilx.Number.isFinite(-Infinity)).to.not.be.ok();
            expect(utilx.Number.isFinite(NaN)).to.not.be.ok();
            expect(utilx.Number.isFinite('')).to.not.be.ok();
            expect(utilx.Number.isFinite(true)).to.not.be.ok();
            expect(utilx.Number.isFinite(false)).to.not.be.ok();
            expect(utilx.Number.isFinite({})).to.not.be.ok();
            expect(utilx.Number.isFinite([])).to.not.be.ok();
            expect(utilx.Number.isFinite(new RegExp('c'))).to.not.be.ok();
            expect(utilx.Number.isFinite(new Date(2013, 11, 11))).to.not.be.ok();
            expect(utilx.Number.isFinite(new Error('x'))).to.not.be.ok();
            expect(utilx.Number.isFinite(4)).to.be.ok();
            expect(utilx.Number.isFinite(4.5)).to.be.ok();
            expect(utilx.Number.isFinite('hi')).to.not.be.ok();
            expect(utilx.Number.isFinite('1.3')).to.not.be.ok();
            expect(utilx.Number.isFinite('51')).to.not.be.ok();
            expect(utilx.Number.isFinite(0)).to.be.ok();
            expect(utilx.Number.isFinite(-0)).to.be.ok();
            expect(utilx.Number.isFinite({
                valueOf: function () {
                    return 3;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isFinite({
                valueOf: function () {
                    return zero / zero;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isFinite({
                valueOf: function () {
                    throw 17;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isFinite({
                toString: function () {
                    throw 17;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isFinite({
                valueOf: function () {
                    throw 17;
                },
                toString: function () {
                    throw 42;
                }
            })).to.not.be.ok();
        });
    });
}());

},{"../scripts/":10}],79:[function(require,module,exports){
/*global Math, RegExp, describe, it, require */

/*properties
    MAX_INT16, MIN_INT16, Number, be, expect, forEach, isInt16, noop, not, ok,
    pow, to, toString, utilx, valueOf
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.isInt16', function () {
        it('should be truthy on integers', function () {
            expect(utilx.Number.isInt16(4)).to.be.ok();
            expect(utilx.Number.isInt16(4.0)).to.be.ok();
            expect(utilx.Number.isInt16(required.MAX_INT16)).to.be.ok();
            expect(utilx.Number.isInt16(required.MIN_INT16)).to.be.ok();
        });

        it('should be falsy on non-integers', function () {
            var zero = 0;

            expect(utilx.Number.isInt16()).to.not.be.ok();
            expect(utilx.Number.isInt16(undefined)).to.not.be.ok();
            expect(utilx.Number.isInt16(null)).to.not.be.ok();
            expect(utilx.Number.isInt16(4.2)).to.not.be.ok();
            expect(utilx.Number.isInt16(Infinity)).to.not.be.ok();
            expect(utilx.Number.isInt16(-Infinity)).to.not.be.ok();
            expect(utilx.Number.isInt16(NaN)).to.not.be.ok();
            expect(utilx.Number.isInt16(true)).to.not.be.ok();
            expect(utilx.Number.isInt16(false)).to.not.be.ok();
            expect(utilx.Number.isInt16('str')).to.not.be.ok();
            expect(utilx.Number.isInt16('')).to.not.be.ok();
            expect(utilx.Number.isInt16({})).to.not.be.ok();
            expect(utilx.Number.isInt16({
                valueOf: function () {
                    return 3;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isInt16({
                valueOf: function () {
                    return zero / zero;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isInt16({
                valueOf: function () {
                    throw 17;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isInt16({
                toString: function () {
                    throw 17;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isInt16({
                valueOf: function () {
                    throw 17;
                },
                toString: function () {
                    throw 42;
                }
            })).to.not.be.ok();
        });

        it('should be false when the type is not number', function () {
            var nonNumbers = [
                false,
                true,
                null,
                undefined,
                '',
                required.noop,
                {
                    valueOf: function () {
                        return 3;
                    }
                },
                new RegExp('a', 'g'),
                {}
            ];

            required.forEach(nonNumbers, function (thing) {
                expect(utilx.Number.isInt16(thing)).to.not.be.ok();
            });
        });

        it('should be false when NaN', function () {
            expect(utilx.Number.isInt16(NaN)).to.not.be.ok();
        });

        it('should be false when Infinity', function () {
            expect(utilx.Number.isInt16(Infinity)).to.not.be.ok();
            expect(utilx.Number.isInt16(-Infinity)).to.not.be.ok();
        });

        it('should be false when number is not integer', function () {
            expect(utilx.Number.isInt16(3.4)).to.not.be.ok();
            expect(utilx.Number.isInt16(-3.4)).to.not.be.ok();
        });

        it('should be false when number is 2^15 or larger', function () {
            expect(utilx.Number.isInt16(Math.pow(2, 15))).to.not.be.ok();
        });

        it('should be false when number is -2^15-1 or smaller', function () {
            expect(utilx.Number.isInt16(-Math.pow(2, 15) - 1)).to.not.be.ok();
        });

        it('should be true for range', function () {
            var safeIntegers = [-Math.pow(2, 15), -1, 0, 1, Math.pow(2, 15) - 1];

            required.forEach(safeIntegers, function (safeInt) {
                expect(utilx.Number.isInt16(safeInt)).to.be.ok();
            });
        });
    });
}());

},{"../scripts/":10}],80:[function(require,module,exports){
/*global Math, RegExp, describe, it, require */

/*properties
    MAX_INT32, MIN_INT32, Number, be, expect, forEach, isInt32, noop, not, ok,
    pow, to, toString, utilx, valueOf
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.isInt32', function () {
        it('should be truthy on integers', function () {
            expect(utilx.Number.isInt32(4)).to.be.ok();
            expect(utilx.Number.isInt32(4.0)).to.be.ok();
            expect(utilx.Number.isInt32(required.MAX_INT32)).to.be.ok();
            expect(utilx.Number.isInt32(required.MIN_INT32)).to.be.ok();
        });

        it('should be falsy on non-integers', function () {
            var zero = 0;

            expect(utilx.Number.isInt32()).to.not.be.ok();
            expect(utilx.Number.isInt32(undefined)).to.not.be.ok();
            expect(utilx.Number.isInt32(null)).to.not.be.ok();
            expect(utilx.Number.isInt32(4.2)).to.not.be.ok();
            expect(utilx.Number.isInt32(Infinity)).to.not.be.ok();
            expect(utilx.Number.isInt32(-Infinity)).to.not.be.ok();
            expect(utilx.Number.isInt32(NaN)).to.not.be.ok();
            expect(utilx.Number.isInt32(true)).to.not.be.ok();
            expect(utilx.Number.isInt32(false)).to.not.be.ok();
            expect(utilx.Number.isInt32('str')).to.not.be.ok();
            expect(utilx.Number.isInt32('')).to.not.be.ok();
            expect(utilx.Number.isInt32({})).to.not.be.ok();
            expect(utilx.Number.isInt32({
                valueOf: function () {
                    return 3;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isInt32({
                valueOf: function () {
                    return zero / zero;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isInt32({
                valueOf: function () {
                    throw 17;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isInt32({
                toString: function () {
                    throw 17;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isInt32({
                valueOf: function () {
                    throw 17;
                },
                toString: function () {
                    throw 42;
                }
            })).to.not.be.ok();
        });

        it('should be false when the type is not number', function () {
            var nonNumbers = [
                false,
                true,
                null,
                undefined,
                '',
                required.noop,
                {
                    valueOf: function () {
                        return 3;
                    }
                },
                new RegExp('a', 'g'),
                {}
            ];

            required.forEach(nonNumbers, function (thing) {
                expect(utilx.Number.isInt32(thing)).to.not.be.ok();
            });
        });

        it('should be false when NaN', function () {
            expect(utilx.Number.isInt32(NaN)).to.not.be.ok();
        });

        it('should be false when Infinity', function () {
            expect(utilx.Number.isInt32(Infinity)).to.not.be.ok();
            expect(utilx.Number.isInt32(-Infinity)).to.not.be.ok();
        });

        it('should be false when number is not integer', function () {
            expect(utilx.Number.isInt32(3.4)).to.not.be.ok();
            expect(utilx.Number.isInt32(-3.4)).to.not.be.ok();
        });

        it('should be false when number is 2^31 or larger', function () {
            expect(utilx.Number.isInt32(Math.pow(2, 31))).to.not.be.ok();
        });

        it('should be false when number is -2^31-1 or smaller', function () {
            expect(utilx.Number.isInt32(-Math.pow(2, 31) - 1)).to.not.be.ok();
        });

        it('should be true for range', function () {
            var safeIntegers = [-Math.pow(2, 31), -1, 0, 1, Math.pow(2, 31) - 1];

            required.forEach(safeIntegers, function (safeInt) {
                expect(utilx.Number.isInt32(safeInt)).to.be.ok();
            });
        });
    });
}());

},{"../scripts/":10}],81:[function(require,module,exports){
/*global Math, RegExp, describe, it, require */

/*properties
    MAX_INT8, MIN_INT8, Number, be, expect, forEach, isInt8, noop, not, ok, pow,
    to, toString, utilx, valueOf
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.isInt8', function () {
        it('should be truthy on integers', function () {
            expect(utilx.Number.isInt8(4)).to.be.ok();
            expect(utilx.Number.isInt8(4.0)).to.be.ok();
            expect(utilx.Number.isInt8(required.MAX_INT8)).to.be.ok();
            expect(utilx.Number.isInt8(required.MIN_INT8)).to.be.ok();
        });

        it('should be falsy on non-integers', function () {
            var zero = 0;

            expect(utilx.Number.isInt8()).to.not.be.ok();
            expect(utilx.Number.isInt8(undefined)).to.not.be.ok();
            expect(utilx.Number.isInt8(null)).to.not.be.ok();
            expect(utilx.Number.isInt8(4.2)).to.not.be.ok();
            expect(utilx.Number.isInt8(Infinity)).to.not.be.ok();
            expect(utilx.Number.isInt8(-Infinity)).to.not.be.ok();
            expect(utilx.Number.isInt8(NaN)).to.not.be.ok();
            expect(utilx.Number.isInt8(true)).to.not.be.ok();
            expect(utilx.Number.isInt8(false)).to.not.be.ok();
            expect(utilx.Number.isInt8('str')).to.not.be.ok();
            expect(utilx.Number.isInt8('')).to.not.be.ok();
            expect(utilx.Number.isInt8({})).to.not.be.ok();
            expect(utilx.Number.isInt8({
                valueOf: function () {
                    return 3;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isInt8({
                valueOf: function () {
                    return zero / zero;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isInt8({
                valueOf: function () {
                    throw 17;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isInt8({
                toString: function () {
                    throw 17;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isInt8({
                valueOf: function () {
                    throw 17;
                },
                toString: function () {
                    throw 42;
                }
            })).to.not.be.ok();
        });

        it('should be false when the type is not number', function () {
            var nonNumbers = [
                false,
                true,
                null,
                undefined,
                '',
                required.noop,
                {
                    valueOf: function () {
                        return 3;
                    }
                },
                new RegExp('a', 'g'),
                {}
            ];

            required.forEach(nonNumbers, function (thing) {
                expect(utilx.Number.isInt8(thing)).to.not.be.ok();
            });
        });

        it('should be false when NaN', function () {
            expect(utilx.Number.isInt8(NaN)).to.not.be.ok();
        });

        it('should be false when Infinity', function () {
            expect(utilx.Number.isInt8(Infinity)).to.not.be.ok();
            expect(utilx.Number.isInt8(-Infinity)).to.not.be.ok();
        });

        it('should be false when number is not integer', function () {
            expect(utilx.Number.isInt8(3.4)).to.not.be.ok();
            expect(utilx.Number.isInt8(-3.4)).to.not.be.ok();
        });

        it('should be false when number is 2^7 or larger', function () {
            expect(utilx.Number.isInt8(Math.pow(2, 7))).to.not.be.ok();
        });

        it('should be false when number is -2^7-1 or smaller', function () {
            expect(utilx.Number.isInt8(-Math.pow(2, 7) - 1)).to.not.be.ok();
        });

        it('should be true for range', function () {
            var safeIntegers = [-Math.pow(2, 7), -1, 0, 1, Math.pow(2, 7) - 1];

            required.forEach(safeIntegers, function (safeInt) {
                expect(utilx.Number.isInt8(safeInt)).to.be.ok();
            });
        });
    });
}());

},{"../scripts/":10}],82:[function(require,module,exports){
/*global Math, RegExp, describe, it, require */

/*properties
    MAX_SAFE_INTEGER, MIN_SAFE_INTEGER, Number, be, expect, forEach, getTime,
    isInteger, noop, not, ok, pow, to, toString, utilx, valueOf
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.isInteger', function () {
        it('should be truthy on integers', function () {
            expect(utilx.Number.isInteger(4)).to.be.ok();
            expect(utilx.Number.isInteger(4.0)).to.be.ok();
            expect(utilx.Number.isInteger(required.MAX_SAFE_INTEGER)).to.be.ok();
            expect(utilx.Number.isInteger(required.MIN_SAFE_INTEGER)).to.be.ok();
        });

        it('should be falsy on non-integers', function () {
            var zero = 0;

            expect(utilx.Number.isInteger()).to.not.be.ok();
            expect(utilx.Number.isInteger(undefined)).to.not.be.ok();
            expect(utilx.Number.isInteger(null)).to.not.be.ok();
            expect(utilx.Number.isInteger(4.2)).to.not.be.ok();
            expect(utilx.Number.isInteger(Infinity)).to.not.be.ok();
            expect(utilx.Number.isInteger(-Infinity)).to.not.be.ok();
            expect(utilx.Number.isInteger(NaN)).to.not.be.ok();
            expect(utilx.Number.isInteger(true)).to.not.be.ok();
            expect(utilx.Number.isInteger(false)).to.not.be.ok();
            expect(utilx.Number.isInteger('str')).to.not.be.ok();
            expect(utilx.Number.isInteger('')).to.not.be.ok();
            expect(utilx.Number.isInteger({})).to.not.be.ok();

            expect(utilx.Number.isInteger(-10.123)).to.not.be.ok();
            expect(utilx.Number.isInteger(0)).to.be.ok();
            expect(utilx.Number.isInteger(0.123)).to.not.be.ok();
            expect(utilx.Number.isInteger(10)).to.be.ok();
            expect(utilx.Number.isInteger(10.123)).to.not.be.ok();
            expect(utilx.Number.isInteger([])).to.not.be.ok();
            expect(utilx.Number.isInteger([10.123])).to.not.be.ok();
            expect(utilx.Number.isInteger(new RegExp('c'))).to.not.be.ok();
            expect(utilx.Number.isInteger(new Error('x'))).to.not.be.ok();
            /*jshint -W047 */
            expect(utilx.Number.isInteger(10.)).to.be.ok();
            /*jshint +W047 */
            expect(utilx.Number.isInteger(10.0)).to.be.ok();
            expect(utilx.Number.isInteger('10.')).to.not.be.ok();
            expect(utilx.Number.isInteger(' 10.')).to.not.be.ok();
            expect(utilx.Number.isInteger('10. ')).to.not.be.ok();
            expect(utilx.Number.isInteger(' 10. ')).to.not.be.ok();
            expect(utilx.Number.isInteger('10.0')).to.not.be.ok();
            expect(utilx.Number.isInteger(' 10.0')).to.not.be.ok();
            expect(utilx.Number.isInteger('10.0 ')).to.not.be.ok();
            expect(utilx.Number.isInteger(' 10.0 ')).to.not.be.ok();
            expect(utilx.Number.isInteger('10.123')).to.not.be.ok();
            expect(utilx.Number.isInteger(' 10.123')).to.not.be.ok();
            expect(utilx.Number.isInteger('10.123 ')).to.not.be.ok();
            expect(utilx.Number.isInteger(' 10.123 ')).to.not.be.ok();

            expect(utilx.Number.isInteger('-1')).to.not.be.ok();
            expect(utilx.Number.isInteger('0')).to.not.be.ok();
            expect(utilx.Number.isInteger('1')).to.not.be.ok();
            expect(utilx.Number.isInteger('-1.')).to.not.be.ok();
            expect(utilx.Number.isInteger('0.')).to.not.be.ok();
            expect(utilx.Number.isInteger('1.')).to.not.be.ok();
            /*jshint -W047 */
            expect(utilx.Number.isInteger(-1.)).to.be.ok();
            expect(utilx.Number.isInteger(0.)).to.be.ok();
            expect(utilx.Number.isInteger(1.)).to.be.ok();
            /*jshint +W047 */
            expect(utilx.Number.isInteger(new Date(2013, 11, 11))).to.not.be.ok();
            expect(utilx.Number.isInteger(new Date(2013, 11, 11).getTime())).to.be.ok();
            expect(utilx.Number.isInteger('NaN')).to.not.be.ok();
            expect(utilx.Number.isInteger('Infinity')).to.not.be.ok();
            expect(utilx.Number.isInteger('-Infinity')).to.not.be.ok();
            expect(utilx.Number.isInteger([])).to.not.be.ok();
            expect(utilx.Number.isInteger([1])).to.not.be.ok();
            expect(utilx.Number.isInteger([1.1])).to.not.be.ok();

            expect(utilx.Number.isInteger({
                valueOf: function () {
                    return 3;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isInteger({
                valueOf: function () {
                    return zero / zero;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isInteger({
                valueOf: function () {
                    throw 17;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isInteger({
                toString: function () {
                    throw 17;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isInteger({
                valueOf: function () {
                    throw 17;
                },
                toString: function () {
                    throw 42;
                }
            })).to.not.be.ok();
        });

        it('should be false when the type is not number', function () {
            var nonNumbers = [
                false,
                true,
                null,
                undefined,
                '',
                required.noop,
                {
                    valueOf: function () {
                        return 3;
                    }
                },
                new RegExp('a', 'g'),
                {}
            ];

            required.forEach(nonNumbers, function (thing) {
                expect(utilx.Number.isInteger(thing)).to.not.be.ok();
            });
        });

        it('should be false when NaN', function () {
            expect(utilx.Number.isInteger(NaN)).to.not.be.ok();
        });

        it('should be false when Infinity', function () {
            expect(utilx.Number.isInteger(Infinity)).to.not.be.ok();
            expect(utilx.Number.isInteger(-Infinity)).to.not.be.ok();
        });

        it('should be false when number is not integer', function () {
            expect(utilx.Number.isInteger(3.4)).to.not.be.ok();
            expect(utilx.Number.isInteger(-3.4)).to.not.be.ok();
        });

        it('should be true when abs(number) is 2^53 or larger', function () {
            expect(utilx.Number.isInteger(Math.pow(2, 53))).to.be.ok();
            expect(utilx.Number.isInteger(-Math.pow(2, 53))).to.be.ok();
        });

        it('should be true when abs(number) is less than 2^53', function () {
            var safeIntegers = [0, 1, Math.pow(2, 53) - 1];

            required.forEach(safeIntegers, function (safeInt) {
                expect(utilx.Number.isInteger(safeInt)).to.be.ok();
                expect(utilx.Number.isInteger(-safeInt)).to.be.ok();
            });
        });
    });
}());

},{"../scripts/":10}],83:[function(require,module,exports){
/*global Date, Error, Object, RegExp, describe, it, require */

/*properties
    MAX_VALUE, MIN_VALUE, Number, be, expect, isNaN, noop, to, toString, utilx,
    valueOf
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.isNaN', function () {
        var toObj = Object;

        it('NaN should be be true', function () {
            expect(utilx.Number.isNaN(NaN)).to.be(true);
        });

        it('Object(NaN) should be false', function () {
            expect(utilx.Number.isNaN(toObj(NaN))).to.be(false);
        });

        it('No arguments, undefined and null should be false', function () {
            expect(utilx.Number.isNaN()).to.be(false);
            expect(utilx.Number.isNaN(undefined)).to.be(false);
            expect(utilx.Number.isNaN(null)).to.be(false);
        });

        it('Other numbers should be false', function () {
            expect(utilx.Number.isNaN(Infinity)).to.be(false);
            expect(utilx.Number.isNaN(-Infinity)).to.be(false);
            expect(utilx.Number.isNaN(0)).to.be(false);
            expect(utilx.Number.isNaN(-0)).to.be(false);
            expect(utilx.Number.isNaN(-4)).to.be(false);
            expect(utilx.Number.isNaN(4)).to.be(false);
            expect(utilx.Number.isNaN(4.5)).to.be(false);
            expect(utilx.Number.isNaN(required.MAX_VALUE)).to.be(false);
            expect(utilx.Number.isNaN(required.MIN_VALUE)).to.be(false);
        });

        it('Strings should be false', function () {
            expect(utilx.Number.isNaN('')).to.be(false);
            expect(utilx.Number.isNaN('hi')).to.be(false);
            expect(utilx.Number.isNaN('1.3')).to.be(false);
            expect(utilx.Number.isNaN('51')).to.be(false);
        });

        it('Booleans should be false', function () {
            expect(utilx.Number.isNaN(true)).to.be(false);
            expect(utilx.Number.isNaN(false)).to.be(false);
        });

        it('Functions should be false', function () {
            expect(utilx.Number.isNaN(required.noop)).to.be(false);
        });

        it('Objects should be false', function () {
            expect(utilx.Number.isNaN({})).to.be(false);
            expect(utilx.Number.isNaN([])).to.be(false);
            expect(utilx.Number.isNaN(new RegExp('c'))).to.be(false);
            expect(utilx.Number.isNaN(new Date(2013, 11, 11))).to.be(false);
            expect(utilx.Number.isNaN(new Error('x'))).to.be(false);
        });

        it('Others should be false', function () {
            expect(utilx.Number.isNaN({
                valueOf: function () {
                    return 3;
                }
            })).to.be(false);

            expect(utilx.Number.isNaN({
                valueOf: function () {
                    return Infinity;
                }
            })).to.be(false);

            expect(utilx.Number.isNaN({
                valueOf: function () {
                    throw 17;
                }
            })).to.be(false);

            expect(utilx.Number.isNaN({
                toString: function () {
                    throw 17;
                }
            })).to.be(false);

            expect(utilx.Number.isNaN({
                valueOf: function () {
                    throw 17;
                },

                toString: function () {
                    throw 42;
                }
            })).to.be(false);
        });
    });
}());

},{"../scripts/":10}],84:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.isNumber', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Number.isNumber(required.ToObject(10))).to.be.ok();
            expect(utilx.Number.isNumber(10)).to.be.ok();
            expect(utilx.Number.isNumber(NaN)).to.be.ok();
            expect(utilx.Number.isNumber(Infinity)).to.be.ok();
            expect(utilx.Number.isNumber(-Infinity)).to.be.ok();
            expect(utilx.Number.isNumber('10')).to.not.be.ok();
            expect(utilx.Number.isNumber()).to.not.be.ok();
            expect(utilx.Number.isNumber(null)).to.not.be.ok();
            expect(utilx.Number.isNumber({})).to.not.be.ok();
            expect(utilx.Number.isNumber([])).to.not.be.ok();
            expect(utilx.Number.isNumber(Number.prototype)).to.be.ok();
        });

        if (required.frame) {
            it('should work accross frames', function () {
                expect(utilx.Number.isNumber(new required.frame.Number(10))).to.be.ok();
            });
        }
    });
}());

},{"../scripts/":10}],85:[function(require,module,exports){
/*global require, describe, it */

/*properties
    Number, Object, ToObject, UNSAFE_INTEGER, be, expect, isOdd, not, ok, to,
    utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.isOdd', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Number.isOdd(-3.5)).to.not.be.ok();
            expect(utilx.Number.isOdd(-3)).to.be.ok();
            expect(utilx.Number.isOdd(-2.5)).to.not.be.ok();
            expect(utilx.Number.isOdd(-2)).to.not.be.ok();
            expect(utilx.Number.isOdd(-1.5)).to.not.be.ok();
            expect(utilx.Number.isOdd(-1)).to.be.ok();
            expect(utilx.Number.isOdd(-0.5)).to.not.be.ok();
            expect(utilx.Number.isOdd(0)).to.not.be.ok();
            expect(utilx.Number.isOdd(0.5)).to.not.be.ok();
            expect(utilx.Number.isOdd(1)).to.be.ok();
            expect(utilx.Number.isOdd(1.5)).to.not.be.ok();
            expect(utilx.Number.isOdd(2)).to.not.be.ok();
            expect(utilx.Number.isOdd(2.5)).to.not.be.ok();
            expect(utilx.Number.isOdd(3)).to.be.ok();
            expect(utilx.Number.isOdd(3.5)).to.not.be.ok();
            expect(utilx.Number.isOdd(utilx.Object.ToObject(true))).to.not.be.ok();
            expect(utilx.Number.isOdd(utilx.Object.ToObject(false))).to.not.be.ok();
            expect(utilx.Number.isOdd(true)).to.not.be.ok();
            expect(utilx.Number.isOdd(false)).to.not.be.ok();
            expect(utilx.Number.isOdd()).to.not.be.ok();
            expect(utilx.Number.isOdd(null)).to.not.be.ok();
            expect(utilx.Number.isOdd('')).to.not.be.ok();
            expect(utilx.Number.isOdd({})).to.not.be.ok();
            expect(utilx.Number.isOdd([])).to.not.be.ok();
            expect(utilx.Number.isOdd(NaN)).to.not.be.ok();
            expect(utilx.Number.isOdd(Infinity)).to.not.be.ok();
            expect(utilx.Number.isOdd(-Infinity)).to.not.be.ok();
            expect(utilx.Number.isOdd(utilx.Number.UNSAFE_INTEGER)).to.not.be.ok();
            expect(utilx.Number.isOdd(-utilx.Number.UNSAFE_INTEGER)).to.not.be.ok();
        });
    });
}());

},{"../scripts/":10}],86:[function(require,module,exports){
/*global Math, RegExp, describe, it, require */

/*properties
    MAX_SAFE_INTEGER, MIN_SAFE_INTEGER, Number, be, expect, forEach, getTime,
    isSafeInteger, noop, not, ok, pow, to, toString, utilx, valueOf
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.isSafeInteger', function () {
        it('should be truthy on integers', function () {
            expect(utilx.Number.isSafeInteger(4)).to.be.ok();
            expect(utilx.Number.isSafeInteger(4.0)).to.be.ok();
            expect(utilx.Number.isSafeInteger(required.MAX_SAFE_INTEGER)).to.be.ok();
            expect(utilx.Number.isSafeInteger(required.MIN_SAFE_INTEGER)).to.be.ok();
        });

        it('should be falsy on non-integers', function () {
            var zero = 0;

            expect(utilx.Number.isSafeInteger()).to.not.be.ok();
            expect(utilx.Number.isSafeInteger(undefined)).to.not.be.ok();
            expect(utilx.Number.isSafeInteger(null)).to.not.be.ok();
            expect(utilx.Number.isSafeInteger(4.2)).to.not.be.ok();
            expect(utilx.Number.isSafeInteger(Infinity)).to.not.be.ok();
            expect(utilx.Number.isSafeInteger(-Infinity)).to.not.be.ok();
            expect(utilx.Number.isSafeInteger(NaN)).to.not.be.ok();
            expect(utilx.Number.isSafeInteger(true)).to.not.be.ok();
            expect(utilx.Number.isSafeInteger(false)).to.not.be.ok();
            expect(utilx.Number.isSafeInteger('str')).to.not.be.ok();
            expect(utilx.Number.isSafeInteger('')).to.not.be.ok();
            expect(utilx.Number.isSafeInteger({})).to.not.be.ok();

            expect(utilx.Number.isSafeInteger(-10.123)).to.not.be.ok();
            expect(utilx.Number.isSafeInteger(0)).to.be.ok();
            expect(utilx.Number.isSafeInteger(0.123)).to.not.be.ok();
            expect(utilx.Number.isSafeInteger(10)).to.be.ok();
            expect(utilx.Number.isSafeInteger(10.123)).to.not.be.ok();
            expect(utilx.Number.isSafeInteger([])).to.not.be.ok();
            expect(utilx.Number.isSafeInteger([10.123])).to.not.be.ok();
            expect(utilx.Number.isSafeInteger(new RegExp('c'))).to.not.be.ok();
            expect(utilx.Number.isSafeInteger(new Error('x'))).to.not.be.ok();
            /*jshint -W047 */
            expect(utilx.Number.isSafeInteger(10.)).to.be.ok();
            /*jshint +W047 */
            expect(utilx.Number.isSafeInteger(10.0)).to.be.ok();
            expect(utilx.Number.isSafeInteger('10.')).to.not.be.ok();
            expect(utilx.Number.isSafeInteger(' 10.')).to.not.be.ok();
            expect(utilx.Number.isSafeInteger('10. ')).to.not.be.ok();
            expect(utilx.Number.isSafeInteger(' 10. ')).to.not.be.ok();
            expect(utilx.Number.isSafeInteger('10.0')).to.not.be.ok();
            expect(utilx.Number.isSafeInteger(' 10.0')).to.not.be.ok();
            expect(utilx.Number.isSafeInteger('10.0 ')).to.not.be.ok();
            expect(utilx.Number.isSafeInteger(' 10.0 ')).to.not.be.ok();
            expect(utilx.Number.isSafeInteger('10.123')).to.not.be.ok();
            expect(utilx.Number.isSafeInteger(' 10.123')).to.not.be.ok();
            expect(utilx.Number.isSafeInteger('10.123 ')).to.not.be.ok();
            expect(utilx.Number.isSafeInteger(' 10.123 ')).to.not.be.ok();

            expect(utilx.Number.isSafeInteger('-1')).to.not.be.ok();
            expect(utilx.Number.isSafeInteger('0')).to.not.be.ok();
            expect(utilx.Number.isSafeInteger('1')).to.not.be.ok();
            expect(utilx.Number.isSafeInteger('-1.')).to.not.be.ok();
            expect(utilx.Number.isSafeInteger('0.')).to.not.be.ok();
            expect(utilx.Number.isSafeInteger('1.')).to.not.be.ok();
            /*jshint -W047 */
            expect(utilx.Number.isSafeInteger(-1.)).to.be.ok();
            expect(utilx.Number.isSafeInteger(0.)).to.be.ok();
            expect(utilx.Number.isSafeInteger(1.)).to.be.ok();
            /*jshint +W047 */
            expect(utilx.Number.isSafeInteger(new Date(2013, 11, 11))).to.not.be.ok();
            expect(utilx.Number.isSafeInteger(new Date(2013, 11, 11).getTime())).to.be.ok();
            expect(utilx.Number.isSafeInteger('NaN')).to.not.be.ok();
            expect(utilx.Number.isSafeInteger('Infinity')).to.not.be.ok();
            expect(utilx.Number.isSafeInteger('-Infinity')).to.not.be.ok();
            expect(utilx.Number.isSafeInteger([])).to.not.be.ok();
            expect(utilx.Number.isSafeInteger([1])).to.not.be.ok();
            expect(utilx.Number.isSafeInteger([1.1])).to.not.be.ok();

            expect(utilx.Number.isSafeInteger({
                valueOf: function () {
                    return 3;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isSafeInteger({
                valueOf: function () {
                    return zero / zero;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isSafeInteger({
                valueOf: function () {
                    throw 17;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isSafeInteger({
                toString: function () {
                    throw 17;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isSafeInteger({
                valueOf: function () {
                    throw 17;
                },
                toString: function () {
                    throw 42;
                }
            })).to.not.be.ok();
        });

        it('should be false when the type is not number', function () {
            var nonNumbers = [
                false,
                true,
                null,
                undefined,
                '',
                required.noop,
                {
                    valueOf: function () {
                        return 3;
                    }
                },
                new RegExp('a', 'g'),
                {}
            ];

            required.forEach(nonNumbers, function (thing) {
                expect(utilx.Number.isSafeInteger(thing)).to.not.be.ok();
            });
        });

        it('should be false when NaN', function () {
            expect(utilx.Number.isSafeInteger(NaN)).to.not.be.ok();
        });

        it('should be false when Infinity', function () {
            expect(utilx.Number.isSafeInteger(Infinity)).to.not.be.ok();
            expect(utilx.Number.isSafeInteger(-Infinity)).to.not.be.ok();
        });

        it('should be false when number is not integer', function () {
            expect(utilx.Number.isSafeInteger(3.4)).to.not.be.ok();
            expect(utilx.Number.isSafeInteger(-3.4)).to.not.be.ok();
        });

        it('should be false when abs(number) is 2^53 or larger', function () {
            expect(utilx.Number.isSafeInteger(Math.pow(2, 53))).to.not.be.ok();
            expect(utilx.Number.isSafeInteger(-Math.pow(2, 53))).to.not.be.ok();
        });

        it('should be true when abs(number) is less than 2^53', function () {
            var safeIntegers = [0, 1, Math.pow(2, 53) - 1];

            required.forEach(safeIntegers, function (safeInt) {
                expect(utilx.Number.isSafeInteger(safeInt)).to.be.ok();
                expect(utilx.Number.isSafeInteger(-safeInt)).to.be.ok();
            });
        });
    });
}());

},{"../scripts/":10}],87:[function(require,module,exports){
/*global Math, RegExp, describe, it, require */

/*properties
    MAX_SAFE_INTEGER, Number, be, expect, forEach, isUint, noop, not, ok, pow,
    to, toString, utilx, valueOf
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.isUint', function () {
        it('should be truthy on integers', function () {
            expect(utilx.Number.isUint(4)).to.be.ok();
            expect(utilx.Number.isUint(4.0)).to.be.ok();
            expect(utilx.Number.isUint(0)).to.be.ok();
            expect(utilx.Number.isUint(required.MAX_SAFE_INTEGER)).to.be.ok();
        });

        it('should be falsy on non-integers', function () {
            var zero = 0;

            expect(utilx.Number.isUint()).to.not.be.ok();
            expect(utilx.Number.isUint(undefined)).to.not.be.ok();
            expect(utilx.Number.isUint(null)).to.not.be.ok();
            expect(utilx.Number.isUint(4.2)).to.not.be.ok();
            expect(utilx.Number.isUint(Infinity)).to.not.be.ok();
            expect(utilx.Number.isUint(-Infinity)).to.not.be.ok();
            expect(utilx.Number.isUint(NaN)).to.not.be.ok();
            expect(utilx.Number.isUint(true)).to.not.be.ok();
            expect(utilx.Number.isUint(false)).to.not.be.ok();
            expect(utilx.Number.isUint('str')).to.not.be.ok();
            expect(utilx.Number.isUint({})).to.not.be.ok();
            expect(utilx.Number.isUint({
                valueOf: function () {
                    return 3;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isUint({
                valueOf: function () {
                    return zero / zero;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isUint({
                valueOf: function () {
                    throw 17;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isUint({
                toString: function () {
                    throw 17;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isUint({
                valueOf: function () {
                    throw 17;
                },
                toString: function () {
                    throw 42;
                }
            })).to.not.be.ok();
        });

        it('should be false when the type is not number', function () {
            var nonNumbers = [
                false,
                true,
                null,
                undefined,
                '',
                required.noop,
                {
                    valueOf: function () {
                        return 3;
                    }
                },
                new RegExp('a', 'g'),
                {}
            ];

            required.forEach(nonNumbers, function (thing) {
                expect(utilx.Number.isUint(thing)).to.not.be.ok();
            });
        });

        it('should be false when NaN', function () {
            expect(utilx.Number.isUint(NaN)).to.not.be.ok();
        });

        it('should be false when Infinity', function () {
            expect(utilx.Number.isUint(Infinity)).to.not.be.ok();
            expect(utilx.Number.isUint(-Infinity)).to.not.be.ok();
        });

        it('should be false when number is not integer', function () {
            expect(utilx.Number.isUint(3.4)).to.not.be.ok();
            expect(utilx.Number.isUint(-3.4)).to.not.be.ok();
        });

        it('should be false when number is 2^53 or larger', function () {
            expect(utilx.Number.isUint(Math.pow(2, 53))).to.not.be.ok();
        });

        it('should be false when number is -1 or smaller', function () {
            expect(utilx.Number.isUint(-1)).to.not.be.ok();
        });

        it('should be true for range', function () {
            var safeIntegers = [0, 1, Math.pow(2, 53) - 1];

            required.forEach(safeIntegers, function (safeInt) {
                expect(utilx.Number.isUint(safeInt)).to.be.ok();
            });
        });
    });
}());

},{"../scripts/":10}],88:[function(require,module,exports){
/*global Math, RegExp, describe, it, require */

/*properties
    MAX_UINT16, Number, be, expect, forEach, isUint16, noop, not, ok, pow, to,
    toString, utilx, valueOf
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.isUint16', function () {
        it('should be truthy on integers', function () {
            expect(utilx.Number.isUint16(4)).to.be.ok();
            expect(utilx.Number.isUint16(4.0)).to.be.ok();
            expect(utilx.Number.isUint16(0)).to.be.ok();
            expect(utilx.Number.isUint16(required.MAX_UINT16)).to.be.ok();
        });

        it('should be falsy on non-integers', function () {
            var zero = 0;

            expect(utilx.Number.isUint16()).to.not.be.ok();
            expect(utilx.Number.isUint16(undefined)).to.not.be.ok();
            expect(utilx.Number.isUint16(null)).to.not.be.ok();
            expect(utilx.Number.isUint16(4.2)).to.not.be.ok();
            expect(utilx.Number.isUint16(Infinity)).to.not.be.ok();
            expect(utilx.Number.isUint16(-Infinity)).to.not.be.ok();
            expect(utilx.Number.isUint16(NaN)).to.not.be.ok();
            expect(utilx.Number.isUint16(true)).to.not.be.ok();
            expect(utilx.Number.isUint16(false)).to.not.be.ok();
            expect(utilx.Number.isUint16('str')).to.not.be.ok();
            expect(utilx.Number.isUint16({})).to.not.be.ok();
            expect(utilx.Number.isUint16({
                valueOf: function () {
                    return 3;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isUint16({
                valueOf: function () {
                    return zero / zero;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isUint16({
                valueOf: function () {
                    throw 17;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isUint16({
                toString: function () {
                    throw 17;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isUint16({
                valueOf: function () {
                    throw 17;
                },
                toString: function () {
                    throw 42;
                }
            })).to.not.be.ok();
        });

        it('should be false when the type is not number', function () {
            var nonNumbers = [
                false,
                true,
                null,
                undefined,
                '',
                required.noop,
                {
                    valueOf: function () {
                        return 3;
                    }
                },
                new RegExp('a', 'g'),
                {}
            ];

            required.forEach(nonNumbers, function (thing) {
                expect(utilx.Number.isUint16(thing)).to.not.be.ok();
            });
        });

        it('should be false when NaN', function () {
            expect(utilx.Number.isUint16(NaN)).to.not.be.ok();
        });

        it('should be false when Infinity', function () {
            expect(utilx.Number.isUint16(Infinity)).to.not.be.ok();
            expect(utilx.Number.isUint16(-Infinity)).to.not.be.ok();
        });

        it('should be false when number is not integer', function () {
            expect(utilx.Number.isUint16(3.4)).to.not.be.ok();
            expect(utilx.Number.isUint16(-3.4)).to.not.be.ok();
        });

        it('should be false when number is 2^16 or larger', function () {
            expect(utilx.Number.isUint16(Math.pow(2, 16))).to.not.be.ok();
        });

        it('should be false when number is -1 or smaller', function () {
            expect(utilx.Number.isUint16(-1)).to.not.be.ok();
        });

        it('should be true for range', function () {
            var safeIntegers = [0, 1, Math.pow(2, 16) - 1];

            required.forEach(safeIntegers, function (safeInt) {
                expect(utilx.Number.isUint16(safeInt)).to.be.ok();
            });
        });
    });
}());

},{"../scripts/":10}],89:[function(require,module,exports){
/*global Math, RegExp, describe, it, require */

/*properties
    MAX_UINT32, Number, be, expect, forEach, isUint32, noop, not, ok, pow, to,
    toString, utilx, valueOf
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.isUint32', function () {
        it('should be truthy on integers', function () {
            expect(utilx.Number.isUint32(4)).to.be.ok();
            expect(utilx.Number.isUint32(4.0)).to.be.ok();
            expect(utilx.Number.isUint32(0)).to.be.ok();
            expect(utilx.Number.isUint32(required.MAX_UINT32)).to.be.ok();
        });

        it('should be falsy on non-integers', function () {
            var zero = 0;

            expect(utilx.Number.isUint32()).to.not.be.ok();
            expect(utilx.Number.isUint32(undefined)).to.not.be.ok();
            expect(utilx.Number.isUint32(null)).to.not.be.ok();
            expect(utilx.Number.isUint32(4.2)).to.not.be.ok();
            expect(utilx.Number.isUint32(Infinity)).to.not.be.ok();
            expect(utilx.Number.isUint32(-Infinity)).to.not.be.ok();
            expect(utilx.Number.isUint32(NaN)).to.not.be.ok();
            expect(utilx.Number.isUint32(true)).to.not.be.ok();
            expect(utilx.Number.isUint32(false)).to.not.be.ok();
            expect(utilx.Number.isUint32('str')).to.not.be.ok();
            expect(utilx.Number.isUint32({})).to.not.be.ok();
            expect(utilx.Number.isUint32({
                valueOf: function () {
                    return 3;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isUint32({
                valueOf: function () {
                    return zero / zero;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isUint32({
                valueOf: function () {
                    throw 17;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isUint32({
                toString: function () {
                    throw 17;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isUint32({
                valueOf: function () {
                    throw 17;
                },
                toString: function () {
                    throw 42;
                }
            })).to.not.be.ok();
        });

        it('should be false when the type is not number', function () {
            var nonNumbers = [
                false,
                true,
                null,
                undefined,
                '',
                required.noop,
                {
                    valueOf: function () {
                        return 3;
                    }
                },
                new RegExp('a', 'g'),
                {}
            ];

            required.forEach(nonNumbers, function (thing) {
                expect(utilx.Number.isUint32(thing)).to.not.be.ok();
            });
        });

        it('should be false when NaN', function () {
            expect(utilx.Number.isUint32(NaN)).to.not.be.ok();
        });

        it('should be false when Infinity', function () {
            expect(utilx.Number.isUint32(Infinity)).to.not.be.ok();
            expect(utilx.Number.isUint32(-Infinity)).to.not.be.ok();
        });

        it('should be false when number is not integer', function () {
            expect(utilx.Number.isUint32(3.4)).to.not.be.ok();
            expect(utilx.Number.isUint32(-3.4)).to.not.be.ok();
        });

        it('should be false when number is 2^32 or larger', function () {
            expect(utilx.Number.isUint32(Math.pow(2, 32))).to.not.be.ok();
        });

        it('should be false when number is -1 or smaller', function () {
            expect(utilx.Number.isUint32(-1)).to.not.be.ok();
        });

        it('should be true for range', function () {
            var safeIntegers = [0, 1, Math.pow(2, 32) - 1];

            required.forEach(safeIntegers, function (safeInt) {
                expect(utilx.Number.isUint32(safeInt)).to.be.ok();
            });
        });
    });
}());

},{"../scripts/":10}],90:[function(require,module,exports){
/*global Math, RegExp, describe, it, require */

/*properties
    MAX_UINT8, Number, be, expect, forEach, isUint8, noop, not, ok, pow, to,
    toString, utilx, valueOf
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.isUint8', function () {
        it('should be truthy on integers', function () {
            expect(utilx.Number.isUint8(4)).to.be.ok();
            expect(utilx.Number.isUint8(4.0)).to.be.ok();
            expect(utilx.Number.isUint8(0)).to.be.ok();
            expect(utilx.Number.isUint8(required.MAX_UINT8)).to.be.ok();
        });

        it('should be falsy on non-integers', function () {
            var zero = 0;

            expect(utilx.Number.isUint8()).to.not.be.ok();
            expect(utilx.Number.isUint8(undefined)).to.not.be.ok();
            expect(utilx.Number.isUint8(null)).to.not.be.ok();
            expect(utilx.Number.isUint8(4.2)).to.not.be.ok();
            expect(utilx.Number.isUint8(Infinity)).to.not.be.ok();
            expect(utilx.Number.isUint8(-Infinity)).to.not.be.ok();
            expect(utilx.Number.isUint8(NaN)).to.not.be.ok();
            expect(utilx.Number.isUint8(true)).to.not.be.ok();
            expect(utilx.Number.isUint8(false)).to.not.be.ok();
            expect(utilx.Number.isUint8('str')).to.not.be.ok();
            expect(utilx.Number.isUint8({})).to.not.be.ok();
            expect(utilx.Number.isUint8({
                valueOf: function () {
                    return 3;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isUint8({
                valueOf: function () {
                    return zero / zero;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isUint8({
                valueOf: function () {
                    throw 17;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isUint8({
                toString: function () {
                    throw 17;
                }
            })).to.not.be.ok();

            expect(utilx.Number.isUint8({
                valueOf: function () {
                    throw 17;
                },
                toString: function () {
                    throw 42;
                }
            })).to.not.be.ok();
        });

        it('should be false when the type is not number', function () {
            var nonNumbers = [
                false,
                true,
                null,
                undefined,
                '',
                required.noop,
                {
                    valueOf: function () {
                        return 3;
                    }
                },
                new RegExp('a', 'g'),
                {}
            ];

            required.forEach(nonNumbers, function (thing) {
                expect(utilx.Number.isUint8(thing)).to.not.be.ok();
            });
        });

        it('should be false when NaN', function () {
            expect(utilx.Number.isUint8(NaN)).to.not.be.ok();
        });

        it('should be false when Infinity', function () {
            expect(utilx.Number.isUint8(Infinity)).to.not.be.ok();
            expect(utilx.Number.isUint8(-Infinity)).to.not.be.ok();
        });

        it('should be false when number is not integer', function () {
            expect(utilx.Number.isUint8(3.4)).to.not.be.ok();
            expect(utilx.Number.isUint8(-3.4)).to.not.be.ok();
        });

        it('should be false when number is 2^8 or larger', function () {
            expect(utilx.Number.isUint8(Math.pow(2, 8))).to.not.be.ok();
        });

        it('should be false when number is -1 or smaller', function () {
            expect(utilx.Number.isUint8(-1)).to.not.be.ok();
        });

        it('should be true for range', function () {
            var safeIntegers = [0, 1, Math.pow(2, 8) - 1];

            required.forEach(safeIntegers, function (safeInt) {
                expect(utilx.Number.isUint8(safeInt)).to.be.ok();
            });
        });
    });
}());

},{"../scripts/":10}],91:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.modulo', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Number.modulo(10, 3)).to.be(1);
            expect(utilx.Number.modulo(-10, 3)).to.be(2);
            expect(utilx.Number.modulo(10, 3.1)).to.be(0.6999999999999993);
            expect(utilx.Number.modulo(-10, 3.1)).to.be(2.4000000000000004);
            expect(utilx.Number.modulo(10.1, 3)).to.be(1.0999999999999996);
            expect(utilx.Number.modulo(10.1, 3.1)).to.be(0.7999999999999989);
            expect(utilx.Number.modulo(-10.1, 3.1)).to.be(2.3000000000000007);
        });
    });
}());

},{"../scripts/":10}],92:[function(require,module,exports){
/*global require, describe, it */

/*properties
    Number, be, expect, outRange, to, utilx
*/
(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.outRange', function () {
        it('arguments should be coerced to a number', function () {
            expect(utilx.Number.outRange()).to.be(true);
            expect(utilx.Number.outRange(undefined)).to.be(true);
            expect(utilx.Number.outRange(null)).to.be(true);
            expect(utilx.Number.outRange(10)).to.be(true);
            expect(utilx.Number.outRange(0)).to.be(true);
            expect(utilx.Number.outRange(-10, -5, '5')).to.be(true);
            expect(utilx.Number.outRange(-10, '-5', 5)).to.be(true);
            expect(utilx.Number.outRange(-10, -5, [])).to.be(true);
            expect(utilx.Number.outRange(-10, {}, 5)).to.be(true);
            expect(utilx.Number.outRange(-10, [], [])).to.be(true);
            expect(utilx.Number.outRange(-10, {}, {})).to.be(true);
            expect(utilx.Number.outRange([], [], [])).to.be(true);
            expect(utilx.Number.outRange({}, {}, {})).to.be(true);
            expect(utilx.Number.outRange(-10, '1', '1')).to.be(true);
            expect(utilx.Number.outRange(-10, 1, 1)).to.be(true);
            expect(utilx.Number.outRange(-10, NaN, 1)).to.be(true);
            expect(utilx.Number.outRange(-10, 1, NaN)).to.be(true);
            expect(utilx.Number.outRange(NaN, 1, 1)).to.be(true);
            expect(utilx.Number.outRange('x', 'a', 'a')).to.be(true);
        });

        it('number literals should not throw an error in each case', function () {
            expect(utilx.Number.outRange(-10, -5, 5)).to.be(true);
            expect(utilx.Number.outRange(10, -5, 5)).to.be(true);
            expect(utilx.Number.outRange(-5, -5, 5)).to.be(true);
            expect(utilx.Number.outRange(5, -5, 5)).to.be(true);
            expect(utilx.Number.outRange(0, -5, 5)).to.be(false);
            expect(utilx.Number.outRange(+0, -5, 5)).to.be(false);
            expect(utilx.Number.outRange(-0, -5, 5)).to.be(false);
            expect(utilx.Number.outRange(-4.9, -5, 5)).to.be(false);
            expect(utilx.Number.outRange(-4.9, -5, 5)).to.be(false);
            expect(utilx.Number.outRange(0, -Infinity, Infinity)).to.be(false);
            expect(utilx.Number.outRange(-Infinity, -5, 5)).to.be(true);
            expect(utilx.Number.outRange(Infinity, -5, 5)).to.be(true);
            expect(utilx.Number.outRange(NaN, -5, 5)).to.be(true);
        });

        it('string literals should not throw an error in each case', function () {
            expect(utilx.Number.outRange('.', 'a', 'z')).to.be(true);
            expect(utilx.Number.outRange('a', 'a', 'z')).to.be(true);
            expect(utilx.Number.outRange('h', 'a', 'z')).to.be(true);
            expect(utilx.Number.outRange('z', 'a', 'z')).to.be(true);
            expect(utilx.Number.outRange('', 'a', 'z')).to.be(true);
            expect(utilx.Number.outRange('?', 'a', 'z')).to.be(true);
        });
    });
}());

},{"../scripts/":10}],93:[function(require,module,exports){
/*global describe, it, require */

/*properties
    Array, Number, be, expect, forEach, isNaN, ok, parseInt, to, utilx, valueOf
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.parseInt', function () {
        var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
            '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' +
            '\u2029\uFEFF';

        it('accepts a radix', function () {
            var i;

            for (i = 2; i <= 36; i += 1) {
                expect(utilx.Number.parseInt('10', i)).to.be(i);
                if (i === 16) {
                    expect(utilx.Number.parseInt('0x16', i)).to.be(22);
                } else if (i === 34) {
                    expect(utilx.Number.parseInt('0x16', i)).to.be(38188);
                } else if (i === 35) {
                    expect(utilx.Number.parseInt('0x16', i)).to.be(40466);
                } else if (i === 36) {
                    expect(utilx.Number.parseInt('0x16', i)).to.be(42810);
                } else {
                    expect(utilx.Number.parseInt('0x16', i)).to.be(0);
                }
            }
        });

        it('returns NaN if radix < 2 or > 36', function () {
            expect(required.isNaN(utilx.Number.parseInt('10', 1))).to.be.ok();
            expect(required.isNaN(utilx.Number.parseInt('10', 37))).to.be.ok();
        });

        it('defaults the radix to 10 when the number does not start with 0x or 0X', function () {
            required.forEach(['01', '08', '10', '42'], function (str) {
                expect(utilx.Number.parseInt(str)).to.be(utilx.Number.parseInt(str, 10));
            });
        });

        it('defaults the radix to 16 when the number starts with 0x or 0X', function () {
            expect(utilx.Number.parseInt('0x16')).to.be(utilx.Number.parseInt('0x16', 16));
            expect(utilx.Number.parseInt('0X16')).to.be(utilx.Number.parseInt('0X16', 16));
        });

        it('ignores leading whitespace', function () {
            expect(utilx.Number.parseInt('  0x16')).to.be(utilx.Number.parseInt('0x16', 16));
            expect(utilx.Number.parseInt('  42')).to.be(utilx.Number.parseInt('42', 10));
            expect(utilx.Number.parseInt('  08')).to.be(utilx.Number.parseInt('08', 10));
            expect(utilx.Number.parseInt(ws + '08')).to.be(utilx.Number.parseInt('08', 10));
            expect(utilx.Number.parseInt(ws + '0x16')).to.be(utilx.Number.parseInt('0x16', 16));
        });

        it('ignores trailing whitespace', function () {
            expect(utilx.Number.parseInt('0x16  ')).to.be(utilx.Number.parseInt('0x16', 16));
            expect(utilx.Number.parseInt('42  ')).to.be(utilx.Number.parseInt('42', 10));
            expect(utilx.Number.parseInt('08  ')).to.be(utilx.Number.parseInt('08', 10));
            expect(utilx.Number.parseInt('08' + ws)).to.be(utilx.Number.parseInt('08', 10));
            expect(utilx.Number.parseInt('0x16' + ws)).to.be(utilx.Number.parseInt('0x16', 16));
        });

        it('ignores leading & trailing whitespace', function () {
            expect(utilx.Number.parseInt('  0x16  ')).to.be(utilx.Number.parseInt('0x16', 16));
            expect(utilx.Number.parseInt('  42  ')).to.be(utilx.Number.parseInt('42', 10));
            expect(utilx.Number.parseInt('  08  ')).to.be(utilx.Number.parseInt('08', 10));
            expect(utilx.Number.parseInt(ws + '08' + ws)).to.be(utilx.Number.parseInt('08', 10));
            expect(utilx.Number.parseInt(ws + '0x16' + ws)).to.be(utilx.Number.parseInt('0x16', 16));
        });

        it('defaults the radix properly when not a true number', function () {
            var fakeZero = {
                valueOf: function () {
                    return 0;
                }
            };

            expect(utilx.Number.parseInt('08', fakeZero)).to.be(utilx.Number.parseInt('08', 10));
            expect(utilx.Number.parseInt('0x16', fakeZero)).to.be(utilx.Number.parseInt('0x16', 16));
        });

        it('ignores leading 0', function () {
            expect(utilx.Number.parseInt('010')).to.be(10);
        });
    });
}());

},{"../scripts/":10}],94:[function(require,module,exports){
/*global require, describe, it */

/*properties
    MAX_SAFE_INTEGER, MAX_VALUE, MIN_SAFE_INTEGER, MIN_VALUE, Number, be, expect,
    fail, inRange, isSafeInteger, ok, randomInt, to, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.randomInt', function () {
        it('should be ok in each case', function () {
            var index,
                chk;

            for (index = 0; index < 100; index += 1) {
                expect(utilx.Number.isSafeInteger(utilx.Number.randomInt(utilx.Number.MIN_SAFE_INTEGER, utilx.Number.MAX_SAFE_INTEGER))).to.be.ok();
                expect(utilx.Number.isSafeInteger(utilx.Number.randomInt(utilx.Number.MIN_VALUE, utilx.Number.MAX_VALUE))).to.be.ok();
                expect(utilx.Number.inRange(utilx.Number.randomInt(), 0, 1)).to.be.ok();
                expect(utilx.Number.inRange(utilx.Number.randomInt(0), 0, 1)).to.be.ok();
                expect(utilx.Number.inRange(utilx.Number.randomInt(1), 0, 1)).to.be.ok();
                chk = utilx.Number.randomInt(0, 1000);
                if (chk === utilx.Number.randomInt(0, 1000)) {
                    if (chk === utilx.Number.randomInt(0, 1000)) {
                        if (chk === utilx.Number.randomInt(0, 1000)) {
                            expect().fail();
                        }
                    }
                }
            }
        });
    });
}());

},{"../scripts/":10}],95:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.toFixed', function () {
        it('should convert numbers correctly', function () {
            expect(utilx.Number.toFixed(0.00008, 3)).to.be('0.000');
            expect(utilx.Number.toFixed(0.9, 0)).to.be('1');
            expect(utilx.Number.toFixed(1.255, 2)).to.be('1.25');
            expect(utilx.Number.toFixed(1843654265.0774949, 5)).to.be('1843654265.07749');
            expect(utilx.Number.toFixed(1000000000000000128, 0)).to.be('1000000000000000128');
        });
    });
}());

},{"../scripts/":10}],96:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.toInt16', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Number.toInt16()).to.be(0);
            expect(utilx.Number.toInt16(undefined)).to.be(0);
            expect(utilx.Number.toInt16(null)).to.be(0);
            expect(utilx.Number.toInt16(-10.123)).to.be(-10);
            expect(utilx.Number.toInt16(0)).to.be(0);
            expect(utilx.Number.toInt16(0.123)).to.be(0);
            expect(utilx.Number.toInt16(10)).to.be(10);
            expect(utilx.Number.toInt16(10.123)).to.be(10);
            expect(utilx.Number.toInt16(Infinity)).to.be(0);
            expect(utilx.Number.toInt16(-Infinity)).to.be(0);
            expect(utilx.Number.toInt16(NaN)).to.be(0);
            expect(utilx.Number.toInt16('')).to.be(0);
            expect(utilx.Number.toInt16(' ')).to.be(0);
            expect(utilx.Number.toInt16('x')).to.be(0);
            expect(utilx.Number.toInt16(true)).to.be(1);
            expect(utilx.Number.toInt16(false)).to.be(0);
            expect(utilx.Number.toInt16({})).to.be(0);
            expect(utilx.Number.toInt16([])).to.be(0);
            expect(utilx.Number.toInt16([10.123])).to.be(10);
            expect(utilx.Number.toInt16(new RegExp('c'))).to.be(0);
            expect(utilx.Number.toInt16(new Error('x'))).to.be(0);
            /*jshint -W047 */
            expect(utilx.Number.toInt16(10.)).to.be(10);
            /*jshint +W047 */
            expect(utilx.Number.toInt16(10.0)).to.be(10);
            expect(utilx.Number.toInt16('10.')).to.be(10);
            expect(utilx.Number.toInt16(' 10.')).to.be(10);
            expect(utilx.Number.toInt16('10. ')).to.be(10);
            expect(utilx.Number.toInt16(' 10. ')).to.be(10);
            expect(utilx.Number.toInt16('10.0')).to.be(10);
            expect(utilx.Number.toInt16(' 10.0')).to.be(10);
            expect(utilx.Number.toInt16('10.0 ')).to.be(10);
            expect(utilx.Number.toInt16(' 10.0 ')).to.be(10);
            expect(utilx.Number.toInt16('10.123')).to.be(10);
            expect(utilx.Number.toInt16(' 10.123')).to.be(10);
            expect(utilx.Number.toInt16('10.123 ')).to.be(10);
            expect(utilx.Number.toInt16(' 10.123 ')).to.be(10);
            expect(utilx.Number.toInt16(utilx.Number.MAX_INT16 + 1)).to.be(utilx.Number.MIN_INT16);
            expect(utilx.Number.toInt16(utilx.Number.MIN_INT16 - 1)).to.be(utilx.Number.MAX_INT16);
        });
    });
}());

},{"../scripts/":10}],97:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    function toInt32(num) {
        /*jslint bitwise: true */
        return num >> 0;
    }

    describe('Number.toInt32', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Number.toInt32()).to.be(toInt32());
            expect(utilx.Number.toInt32(undefined)).to.be(toInt32(undefined));
            expect(utilx.Number.toInt32(null)).to.be(toInt32(null));
            expect(utilx.Number.toInt32(-10.123)).to.be(toInt32(-10.123));
            expect(utilx.Number.toInt32(0)).to.be(toInt32(0));
            expect(utilx.Number.toInt32(0.123)).to.be(toInt32(0.123));
            expect(utilx.Number.toInt32(10)).to.be(toInt32(10));
            expect(utilx.Number.toInt32(10.123)).to.be(toInt32(10.123));
            expect(utilx.Number.toInt32(Infinity)).to.be(toInt32(Infinity));
            expect(utilx.Number.toInt32(-Infinity)).to.be(toInt32(-Infinity));
            expect(utilx.Number.toInt32(NaN)).to.be(toInt32(NaN));
            expect(utilx.Number.toInt32('')).to.be(toInt32(''));
            expect(utilx.Number.toInt32(' ')).to.be(toInt32(' '));
            expect(utilx.Number.toInt32('x')).to.be(toInt32('x'));
            expect(utilx.Number.toInt32(true)).to.be(toInt32(true));
            expect(utilx.Number.toInt32(false)).to.be(toInt32(false));
            expect(utilx.Number.toInt32({})).to.be(toInt32({}));
            expect(utilx.Number.toInt32([])).to.be(toInt32([]));
            expect(utilx.Number.toInt32([10.123])).to.be(toInt32([10.123]));
            expect(utilx.Number.toInt32(new RegExp('c'))).to.be(toInt32(new RegExp('c')));
            expect(utilx.Number.toInt32(new Error('x'))).to.be(toInt32(new Error('x')));
            /*jshint -W047 */
            expect(utilx.Number.toInt32(10.)).to.be(toInt32(10.));
            /*jshint +W047 */
            expect(utilx.Number.toInt32(10.0)).to.be(toInt32(10.0));
            expect(utilx.Number.toInt32('10.')).to.be(toInt32('10.'));
            expect(utilx.Number.toInt32(' 10.')).to.be(toInt32(' 10.'));
            expect(utilx.Number.toInt32('10. ')).to.be(toInt32('10. '));
            expect(utilx.Number.toInt32(' 10. ')).to.be(toInt32(' 10. '));
            expect(utilx.Number.toInt32('10.0')).to.be(toInt32('10.0'));
            expect(utilx.Number.toInt32(' 10.0')).to.be(toInt32(' 10.0'));
            expect(utilx.Number.toInt32('10.0 ')).to.be(toInt32('10.0 '));
            expect(utilx.Number.toInt32(' 10.0 ')).to.be(toInt32(' 10.0 '));
            expect(utilx.Number.toInt32('10.123')).to.be(toInt32('10.123'));
            expect(utilx.Number.toInt32(' 10.123')).to.be(toInt32(' 10.123'));
            expect(utilx.Number.toInt32('10.123 ')).to.be(toInt32('10.123 '));
            expect(utilx.Number.toInt32(' 10.123 ')).to.be(toInt32(' 10.123 '));
            expect(utilx.Number.toInt32(utilx.Number.MAX_INT32 + 1)).to.be(utilx.Number.MIN_INT32);
            expect(utilx.Number.toInt32(utilx.Number.MIN_INT32 - 1)).to.be(utilx.Number.MAX_INT32);
        });
    });
}());

},{"../scripts/":10}],98:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.toInt8', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Number.toInt8()).to.be(0);
            expect(utilx.Number.toInt8(undefined)).to.be(0);
            expect(utilx.Number.toInt8(null)).to.be(0);
            expect(utilx.Number.toInt8(-10.123)).to.be(-10);
            expect(utilx.Number.toInt8(0)).to.be(0);
            expect(utilx.Number.toInt8(0.123)).to.be(0);
            expect(utilx.Number.toInt8(10)).to.be(10);
            expect(utilx.Number.toInt8(10.123)).to.be(10);
            expect(utilx.Number.toInt8(Infinity)).to.be(0);
            expect(utilx.Number.toInt8(-Infinity)).to.be(0);
            expect(utilx.Number.toInt8(NaN)).to.be(0);
            expect(utilx.Number.toInt8('')).to.be(0);
            expect(utilx.Number.toInt8(' ')).to.be(0);
            expect(utilx.Number.toInt8('x')).to.be(0);
            expect(utilx.Number.toInt8(true)).to.be(1);
            expect(utilx.Number.toInt8(false)).to.be(0);
            expect(utilx.Number.toInt8({})).to.be(0);
            expect(utilx.Number.toInt8([])).to.be(0);
            expect(utilx.Number.toInt8([10.123])).to.be(10);
            expect(utilx.Number.toInt8(new RegExp('c'))).to.be(0);
            expect(utilx.Number.toInt8(new Error('x'))).to.be(0);
            /*jshint -W047 */
            expect(utilx.Number.toInt8(10.)).to.be(10);
            /*jshint +W047 */
            expect(utilx.Number.toInt8(10.0)).to.be(10);
            expect(utilx.Number.toInt8('10.')).to.be(10);
            expect(utilx.Number.toInt8(' 10.')).to.be(10);
            expect(utilx.Number.toInt8('10. ')).to.be(10);
            expect(utilx.Number.toInt8(' 10. ')).to.be(10);
            expect(utilx.Number.toInt8('10.0')).to.be(10);
            expect(utilx.Number.toInt8(' 10.0')).to.be(10);
            expect(utilx.Number.toInt8('10.0 ')).to.be(10);
            expect(utilx.Number.toInt8(' 10.0 ')).to.be(10);
            expect(utilx.Number.toInt8('10.123')).to.be(10);
            expect(utilx.Number.toInt8(' 10.123')).to.be(10);
            expect(utilx.Number.toInt8('10.123 ')).to.be(10);
            expect(utilx.Number.toInt8(' 10.123 ')).to.be(10);
            expect(utilx.Number.toInt8(utilx.Number.MAX_INT8 + 1)).to.be(utilx.Number.MIN_INT8);
            expect(utilx.Number.toInt8(utilx.Number.MIN_INT8 - 1)).to.be(utilx.Number.MAX_INT8);
        });
    });
}());

},{"../scripts/":10}],99:[function(require,module,exports){
/*global Date, Error, RegExp, TypeError, describe, it, require */

/*properties
    Number, a, be, expect, isNaN, isNumber, not, ok, throwException, to,
    toInteger, toString, utilx, valueOf
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.toInteger', function () {
        it('should throw a TypeError in each case', function () {
            expect(function () {
                utilx.Number.toInteger({toString: ''});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Number.toInteger({toString: '1'});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Number.toInteger({toString: 1});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Number.toInteger({toString: 1.1});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            /*jshint -W047 */
            expect(function () {
                utilx.Number.toInteger({toString: 1.});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
            /*jshint +W047 */
        });

        it('argument missing, undefined and null', function () {
            expect(utilx.Number.toInteger()).to.be(0);
            expect(utilx.Number.toInteger(undefined)).to.be(0);
            expect(utilx.Number.toInteger(null)).to.be(0);
        });

        it('number', function () {
            expect(utilx.Number.toInteger(-10.123)).to.be(-10);
            expect(utilx.Number.toInteger(0)).to.be(0);
            expect(utilx.Number.toInteger(0.123)).to.be(0);
            expect(utilx.Number.toInteger(10)).to.be(10);
            expect(utilx.Number.toInteger(10.123)).to.be(10);
            expect(utilx.Number.toInteger(Infinity)).to.be(Infinity);
            expect(utilx.Number.toInteger(-Infinity)).to.be(-Infinity);
            expect(utilx.Number.toInteger(NaN)).to.be(0);
        });

        it('string', function () {
            expect(utilx.Number.toInteger('')).to.be(0);
            expect(utilx.Number.toInteger(' ')).to.be(0);
            expect(utilx.Number.toInteger('x')).to.be(0);
        });

        it('boolean', function () {
            expect(utilx.Number.toInteger(true)).to.be(1);
            expect(utilx.Number.toInteger(false)).to.be(0);
        });

        it('mixed objects', function () {
            expect(utilx.Number.toInteger({})).to.be(0);
            expect(utilx.Number.toInteger([])).to.be(0);
            expect(utilx.Number.toInteger([10.123])).to.be(10);
            expect(utilx.Number.toInteger(new RegExp('c'))).to.be(0);
            expect(utilx.Number.toInteger(new Error('x'))).to.be(0);
        });

        it('tens', function () {
            /*jshint -W047 */
            expect(utilx.Number.toInteger(10.)).to.be(10);
            /*jshint +W047 */
            expect(utilx.Number.toInteger(10.0)).to.be(10);
            expect(utilx.Number.toInteger('10.')).to.be(10);
            expect(utilx.Number.toInteger(' 10.')).to.be(10);
            expect(utilx.Number.toInteger('10. ')).to.be(10);
            expect(utilx.Number.toInteger(' 10. ')).to.be(10);
            expect(utilx.Number.toInteger('10.0')).to.be(10);
            expect(utilx.Number.toInteger(' 10.0')).to.be(10);
            expect(utilx.Number.toInteger('10.0 ')).to.be(10);
            expect(utilx.Number.toInteger(' 10.0 ')).to.be(10);
            expect(utilx.Number.toInteger('10.123')).to.be(10);
            expect(utilx.Number.toInteger(' 10.123')).to.be(10);
            expect(utilx.Number.toInteger('10.123 ')).to.be(10);
            expect(utilx.Number.toInteger(' 10.123 ')).to.be(10);
        });

        it('-1, 0, 1', function () {
            expect(utilx.Number.toInteger('-1')).to.be(-1);
            expect(utilx.Number.toInteger('0')).to.be(0);
            expect(utilx.Number.toInteger('1')).to.be(1);
            expect(utilx.Number.toInteger('-1.')).to.be(-1);
            expect(utilx.Number.toInteger('0.')).to.be(0);
            expect(utilx.Number.toInteger('1.')).to.be(1);
            /*jshint -W047 */
            expect(utilx.Number.toInteger(-1.)).to.be(-1);
            expect(utilx.Number.toInteger(0.)).to.be(0);
            expect(utilx.Number.toInteger(1.)).to.be(1);
            /*jshint +W047 */
            expect(utilx.Number.toInteger('-1.1')).to.be(-1);
            expect(utilx.Number.toInteger('0.1')).to.be(0);
            expect(utilx.Number.toInteger('1.1')).to.be(1);
        });

        it('date', function () {
            var dateInt;

            expect(function () {
                dateInt = utilx.Number.toInteger(new Date(2013, 11, 11));
            }).to.not.throwException();

            expect(typeof dateInt === 'number').to.be.ok();
            expect(required.isNaN(dateInt)).to.not.be.ok();
        });

        it('string NaN, Infinity, -Infinity', function () {
            expect(utilx.Number.toInteger('NaN')).to.be(0);
            expect(utilx.Number.toInteger('Infinity')).to.be(Infinity);
            expect(utilx.Number.toInteger('-Infinity')).to.be(-Infinity);
        });

        it('array', function () {
            expect(utilx.Number.toInteger([])).to.be(0);
            expect(utilx.Number.toInteger([1])).to.be(1);
            expect(utilx.Number.toInteger([1.1])).to.be(1);
            /*jshint -W047 */
            expect(utilx.Number.toInteger([1.])).to.be(1);
            /*jshint +W047 */
            expect(utilx.Number.toInteger([''])).to.be(0);
            expect(utilx.Number.toInteger(['1'])).to.be(1);
            expect(utilx.Number.toInteger(['1.1'])).to.be(1);
        });

        it('object', function () {
            expect(utilx.Number.toInteger({})).to.be(0);
            expect(utilx.Number.toInteger({valueOf: ''})).to.be(0);
            expect(utilx.Number.toInteger({valueOf: '1'})).to.be(0);
            expect(utilx.Number.toInteger({valueOf: 1})).to.be(0);
            expect(utilx.Number.toInteger({valueOf: 1.1})).to.be(0);
            /*jshint -W047 */
            expect(utilx.Number.toInteger({valueOf: 1.})).to.be(0);
            /*jshint +W047 */
        });

        it('function', function () {
            expect(utilx.Number.toInteger(function () { return 1; })).to.be(0);
        });
    });
}());

},{"../scripts/":10}],100:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    function toUint(num) {
        /*jslint bitwise: true */
        return num >>> 0;
    }

    describe('Number.toUint', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Number.toUint()).to.be(toUint());
            expect(utilx.Number.toUint(undefined)).to.be(toUint(undefined));
            expect(utilx.Number.toUint(null)).to.be(toUint(null));
            expect(utilx.Number.toUint(-10.123)).to.be(9007199254740982);
            expect(utilx.Number.toUint(0)).to.be(0);
            expect(utilx.Number.toUint(0.123)).to.be(0);
            expect(utilx.Number.toUint(10)).to.be(10);
            expect(utilx.Number.toUint(10.123)).to.be(10);
            expect(utilx.Number.toUint(Infinity)).to.be(toUint(Infinity));
            expect(utilx.Number.toUint(-Infinity)).to.be(toUint(-Infinity));
            expect(utilx.Number.toUint(NaN)).to.be(toUint(NaN));
            expect(utilx.Number.toUint('')).to.be(toUint(''));
            expect(utilx.Number.toUint(' ')).to.be(toUint(' '));
            expect(utilx.Number.toUint('x')).to.be(toUint('x'));
            expect(utilx.Number.toUint(true)).to.be(toUint(true));
            expect(utilx.Number.toUint(false)).to.be(toUint(false));
            expect(utilx.Number.toUint({})).to.be(toUint({}));
            expect(utilx.Number.toUint([])).to.be(toUint([]));
            expect(utilx.Number.toUint([10.123])).to.be(toUint([10.123]));
            expect(utilx.Number.toUint(new RegExp('c'))).to.be(toUint(new RegExp('c')));
            expect(utilx.Number.toUint(new Error('x'))).to.be(toUint(new Error('x')));
            /*jshint -W047 */
            expect(utilx.Number.toUint(10.)).to.be(10);
            /*jshint +W047 */
            expect(utilx.Number.toUint(10.0)).to.be(10);
            expect(utilx.Number.toUint('10.')).to.be(toUint('10.'));
            expect(utilx.Number.toUint(' 10.')).to.be(toUint(' 10.'));
            expect(utilx.Number.toUint('10. ')).to.be(toUint('10. '));
            expect(utilx.Number.toUint(' 10. ')).to.be(toUint(' 10. '));
            expect(utilx.Number.toUint('10.0')).to.be(toUint('10.0'));
            expect(utilx.Number.toUint(' 10.0')).to.be(toUint(' 10.0'));
            expect(utilx.Number.toUint('10.0 ')).to.be(toUint('10.0 '));
            expect(utilx.Number.toUint(' 10.0 ')).to.be(toUint(' 10.0 '));
            expect(utilx.Number.toUint('10.123')).to.be(toUint('10.123'));
            expect(utilx.Number.toUint(' 10.123')).to.be(toUint(' 10.123'));
            expect(utilx.Number.toUint('10.123 ')).to.be(toUint('10.123 '));
            expect(utilx.Number.toUint(' 10.123 ')).to.be(toUint(' 10.123 '));
            expect(utilx.Number.toUint(utilx.Number.MAX_SAFE_INTEGER + 1)).to.be(0);
            expect(utilx.Number.toUint(-1)).to.be(utilx.Number.MAX_SAFE_INTEGER);
        });
    });
}());

},{"../scripts/":10}],101:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.toUint16', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Number.toUint16()).to.be(0);
            expect(utilx.Number.toUint16(undefined)).to.be(0);
            expect(utilx.Number.toUint16(null)).to.be(0);
            expect(utilx.Number.toUint16(-10.123)).to.be(65526);
            expect(utilx.Number.toUint16(0)).to.be(0);
            expect(utilx.Number.toUint16(0.123)).to.be(0);
            expect(utilx.Number.toUint16(10)).to.be(10);
            expect(utilx.Number.toUint16(10.123)).to.be(10);
            expect(utilx.Number.toUint16(Infinity)).to.be(0);
            expect(utilx.Number.toUint16(-Infinity)).to.be(0);
            expect(utilx.Number.toUint16(NaN)).to.be(0);
            expect(utilx.Number.toUint16('')).to.be(0);
            expect(utilx.Number.toUint16(' ')).to.be(0);
            expect(utilx.Number.toUint16('x')).to.be(0);
            expect(utilx.Number.toUint16(true)).to.be(1);
            expect(utilx.Number.toUint16(false)).to.be(0);
            expect(utilx.Number.toUint16({})).to.be(0);
            expect(utilx.Number.toUint16([])).to.be(0);
            expect(utilx.Number.toUint16([10.123])).to.be(10);
            expect(utilx.Number.toUint16(new RegExp('c'))).to.be(0);
            expect(utilx.Number.toUint16(new Error('x'))).to.be(0);
            /*jshint -W047 */
            expect(utilx.Number.toUint16(10.)).to.be(10);
            /*jshint +W047 */
            expect(utilx.Number.toUint16(10.0)).to.be(10);
            expect(utilx.Number.toUint16('10.')).to.be(10);
            expect(utilx.Number.toUint16(' 10.')).to.be(10);
            expect(utilx.Number.toUint16('10. ')).to.be(10);
            expect(utilx.Number.toUint16(' 10. ')).to.be(10);
            expect(utilx.Number.toUint16('10.0')).to.be(10);
            expect(utilx.Number.toUint16(' 10.0')).to.be(10);
            expect(utilx.Number.toUint16('10.0 ')).to.be(10);
            expect(utilx.Number.toUint16(' 10.0 ')).to.be(10);
            expect(utilx.Number.toUint16('10.123')).to.be(10);
            expect(utilx.Number.toUint16(' 10.123')).to.be(10);
            expect(utilx.Number.toUint16('10.123 ')).to.be(10);
            expect(utilx.Number.toUint16(' 10.123 ')).to.be(10);
            expect(utilx.Number.toUint16(utilx.Number.MAX_UINT16 + 1)).to.be(0);
            expect(utilx.Number.toUint16(-1)).to.be(utilx.Number.MAX_UINT16);
        });
    });
}());

},{"../scripts/":10}],102:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    function toUint32(num) {
        /*jslint bitwise: true */
        return num >>> 0;
    }

    describe('Number.toUint32', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Number.toUint32()).to.be(toUint32());
            expect(utilx.Number.toUint32(undefined)).to.be(toUint32(undefined));
            expect(utilx.Number.toUint32(null)).to.be(toUint32(null));
            expect(utilx.Number.toUint32(-10.123)).to.be(toUint32(-10.123));
            expect(utilx.Number.toUint32(0)).to.be(toUint32(0));
            expect(utilx.Number.toUint32(0.123)).to.be(toUint32(0.123));
            expect(utilx.Number.toUint32(10)).to.be(toUint32(10));
            expect(utilx.Number.toUint32(10.123)).to.be(toUint32(10.123));
            expect(utilx.Number.toUint32(Infinity)).to.be(toUint32(Infinity));
            expect(utilx.Number.toUint32(-Infinity)).to.be(toUint32(-Infinity));
            expect(utilx.Number.toUint32(NaN)).to.be(toUint32(NaN));
            expect(utilx.Number.toUint32('')).to.be(toUint32(''));
            expect(utilx.Number.toUint32(' ')).to.be(toUint32(' '));
            expect(utilx.Number.toUint32('x')).to.be(toUint32('x'));
            expect(utilx.Number.toUint32(true)).to.be(toUint32(true));
            expect(utilx.Number.toUint32(false)).to.be(toUint32(false));
            expect(utilx.Number.toUint32({})).to.be(toUint32({}));
            expect(utilx.Number.toUint32([])).to.be(toUint32([]));
            expect(utilx.Number.toUint32([10.123])).to.be(toUint32([10.123]));
            expect(utilx.Number.toUint32(new RegExp('c'))).to.be(toUint32(new RegExp('c')));
            expect(utilx.Number.toUint32(new Error('x'))).to.be(toUint32(new Error('x')));
            /*jshint -W047 */
            expect(utilx.Number.toUint32(10.)).to.be(toUint32(10.));
            /*jshint +W047 */
            expect(utilx.Number.toUint32(10.0)).to.be(toUint32(10.0));
            expect(utilx.Number.toUint32('10.')).to.be(toUint32('10.'));
            expect(utilx.Number.toUint32(' 10.')).to.be(toUint32(' 10.'));
            expect(utilx.Number.toUint32('10. ')).to.be(toUint32('10. '));
            expect(utilx.Number.toUint32(' 10. ')).to.be(toUint32(' 10. '));
            expect(utilx.Number.toUint32('10.0')).to.be(toUint32('10.0'));
            expect(utilx.Number.toUint32(' 10.0')).to.be(toUint32(' 10.0'));
            expect(utilx.Number.toUint32('10.0 ')).to.be(toUint32('10.0 '));
            expect(utilx.Number.toUint32(' 10.0 ')).to.be(toUint32(' 10.0 '));
            expect(utilx.Number.toUint32('10.123')).to.be(toUint32('10.123'));
            expect(utilx.Number.toUint32(' 10.123')).to.be(toUint32(' 10.123'));
            expect(utilx.Number.toUint32('10.123 ')).to.be(toUint32('10.123 '));
            expect(utilx.Number.toUint32(' 10.123 ')).to.be(toUint32(' 10.123 '));
            expect(utilx.Number.toUint32(utilx.Number.MAX_UINT32 + 1)).to.be(0);
            expect(utilx.Number.toUint32(-1)).to.be(utilx.Number.MAX_UINT32);
        });
    });
}());

},{"../scripts/":10}],103:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Number.toUint8', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Number.toUint8()).to.be(0);
            expect(utilx.Number.toUint8(undefined)).to.be(0);
            expect(utilx.Number.toUint8(null)).to.be(0);
            expect(utilx.Number.toUint8(-10.123)).to.be(246);
            expect(utilx.Number.toUint8(0)).to.be(0);
            expect(utilx.Number.toUint8(0.123)).to.be(0);
            expect(utilx.Number.toUint8(10)).to.be(10);
            expect(utilx.Number.toUint8(10.123)).to.be(10);
            expect(utilx.Number.toUint8(Infinity)).to.be(0);
            expect(utilx.Number.toUint8(-Infinity)).to.be(0);
            expect(utilx.Number.toUint8(NaN)).to.be(0);
            expect(utilx.Number.toUint8('')).to.be(0);
            expect(utilx.Number.toUint8(' ')).to.be(0);
            expect(utilx.Number.toUint8('x')).to.be(0);
            expect(utilx.Number.toUint8(true)).to.be(1);
            expect(utilx.Number.toUint8(false)).to.be(0);
            expect(utilx.Number.toUint8({})).to.be(0);
            expect(utilx.Number.toUint8([])).to.be(0);
            expect(utilx.Number.toUint8([10.123])).to.be(10);
            expect(utilx.Number.toUint8(new RegExp('c'))).to.be(0);
            expect(utilx.Number.toUint8(new Error('x'))).to.be(0);
            /*jshint -W047 */
            expect(utilx.Number.toUint8(10.)).to.be(10);
            /*jshint +W047 */
            expect(utilx.Number.toUint8(10.0)).to.be(10);
            expect(utilx.Number.toUint8('10.')).to.be(10);
            expect(utilx.Number.toUint8(' 10.')).to.be(10);
            expect(utilx.Number.toUint8('10. ')).to.be(10);
            expect(utilx.Number.toUint8(' 10. ')).to.be(10);
            expect(utilx.Number.toUint8('10.0')).to.be(10);
            expect(utilx.Number.toUint8(' 10.0')).to.be(10);
            expect(utilx.Number.toUint8('10.0 ')).to.be(10);
            expect(utilx.Number.toUint8(' 10.0 ')).to.be(10);
            expect(utilx.Number.toUint8('10.123')).to.be(10);
            expect(utilx.Number.toUint8(' 10.123')).to.be(10);
            expect(utilx.Number.toUint8('10.123 ')).to.be(10);
            expect(utilx.Number.toUint8(' 10.123 ')).to.be(10);
            expect(utilx.Number.toUint8(utilx.Number.MAX_UINT8 + 1)).to.be(0);
            expect(utilx.Number.toUint8(-1)).to.be(utilx.Number.MAX_UINT8);
        });
    });
}());

},{"../scripts/":10}],104:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.RequireObjectCoercible', function () {
        it('should not throw an error in each case', function () {
            expect(function () {
                utilx.Object.RequireObjectCoercible();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.RequireObjectCoercible(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.RequireObjectCoercible(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.RequireObjectCoercible(-1);
            }).to.not.throwException();

            expect(function () {
                utilx.Object.RequireObjectCoercible(0);
            }).to.not.throwException();

            expect(function () {
                utilx.Object.RequireObjectCoercible(1);
            }).to.not.throwException();

            expect(function () {
                utilx.Object.RequireObjectCoercible(NaN);
            }).to.not.throwException();

            expect(function () {
                utilx.Object.RequireObjectCoercible(Infinity);
            }).to.not.throwException();

            expect(function () {
                utilx.Object.RequireObjectCoercible(-Infinity);
            }).to.not.throwException();

            expect(function () {
                utilx.Object.RequireObjectCoercible(true);
            }).to.not.throwException();

            expect(function () {
                utilx.Object.RequireObjectCoercible(false);
            }).to.not.throwException();

            expect(function () {
                utilx.Object.RequireObjectCoercible('');
            }).to.not.throwException();

            expect(function () {
                utilx.Object.RequireObjectCoercible('x');
            }).to.not.throwException();

            expect(function () {
                utilx.Object.RequireObjectCoercible(required.noop);
            }).to.not.throwException();

            expect(function () {
                utilx.Object.RequireObjectCoercible(new RegExp('y'));
            }).to.not.throwException();

            expect(function () {
                utilx.Object.RequireObjectCoercible(new Date());
            }).to.not.throwException();
        });
    });
}());

},{"../scripts/":10}],105:[function(require,module,exports){
/*global Date, Error, RegExp, TypeError, describe, it, require */

/*properties
    Object, a, be, expect, isNaN, isNumber, not, ok, throwException, to,
    ToNumber, toString, utilx, valueOf
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.ToNumber', function () {
        it('should throw a TypeError in each case', function () {
            expect(function () {
                utilx.Object.ToNumber({toString: ''});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.ToNumber({toString: '1'});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.ToNumber({toString: 1});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.ToNumber({toString: 1.1});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            /*jshint -W047 */
            expect(function () {
                utilx.Object.ToNumber({toString: 1.});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
            /*jshint +W047 */
        });

        it('argument missing, undefined and null', function () {
            expect(required.isNaN(utilx.Object.ToNumber())).to.be.ok();
            expect(required.isNaN(utilx.Object.ToNumber(undefined))).to.be.ok();
            expect(utilx.Object.ToNumber(null)).to.be(0);
        });

        it('number', function () {
            expect(utilx.Object.ToNumber(-10.123)).to.be(-10.123);
            expect(utilx.Object.ToNumber(0)).to.be(0);
            expect(utilx.Object.ToNumber(0.123)).to.be(0.123);
            expect(utilx.Object.ToNumber(10)).to.be(10);
            expect(utilx.Object.ToNumber(10.123)).to.be(10.123);
            expect(utilx.Object.ToNumber(Infinity)).to.be(Infinity);
            expect(utilx.Object.ToNumber(-Infinity)).to.be(-Infinity);
            expect(required.isNaN(utilx.Object.ToNumber(NaN))).to.be.ok();
        });

        it('string', function () {
            expect(utilx.Object.ToNumber('')).to.be(0);
            expect(utilx.Object.ToNumber(' ')).to.be(0);
            expect(required.isNaN(utilx.Object.ToNumber('x'))).to.be.ok();
        });

        it('boolean', function () {
            expect(utilx.Object.ToNumber(true)).to.be(1);
            expect(utilx.Object.ToNumber(false)).to.be(0);
        });

        it('mixed objects', function () {
            expect(required.isNaN(utilx.Object.ToNumber({}))).to.be.ok();
            expect(utilx.Object.ToNumber([])).to.be(0);
            expect(utilx.Object.ToNumber([10.123])).to.be(10.123);
            expect(required.isNaN(utilx.Object.ToNumber(new RegExp('c')))).to.be.ok();
            expect(required.isNaN(utilx.Object.ToNumber(new Error('x')))).to.be.ok();
            expect(utilx.Object.ToNumber(new Date(123456789))).to.be(123456789);
        });

        it('tens', function () {
            /*jshint -W047 */
            expect(utilx.Object.ToNumber(10.)).to.be(10);
            /*jshint +W047 */
            expect(utilx.Object.ToNumber(10.0)).to.be(10);
            expect(utilx.Object.ToNumber('10.')).to.be(10);
            expect(utilx.Object.ToNumber(' 10.')).to.be(10);
            expect(utilx.Object.ToNumber('10. ')).to.be(10);
            expect(utilx.Object.ToNumber(' 10. ')).to.be(10);
            expect(utilx.Object.ToNumber('10.0')).to.be(10);
            expect(utilx.Object.ToNumber(' 10.0')).to.be(10);
            expect(utilx.Object.ToNumber('10.0 ')).to.be(10);
            expect(utilx.Object.ToNumber(' 10.0 ')).to.be(10);
            expect(utilx.Object.ToNumber('10.123')).to.be(10.123);
            expect(utilx.Object.ToNumber(' 10.123')).to.be(10.123);
            expect(utilx.Object.ToNumber('10.123 ')).to.be(10.123);
            expect(utilx.Object.ToNumber(' 10.123 ')).to.be(10.123);
        });

        it('-1, 0, 1', function () {
            expect(utilx.Object.ToNumber('-1')).to.be(-1);
            expect(utilx.Object.ToNumber('0')).to.be(0);
            expect(utilx.Object.ToNumber('1')).to.be(1);
            expect(utilx.Object.ToNumber('-1.')).to.be(-1);
            expect(utilx.Object.ToNumber('0.')).to.be(0);
            expect(utilx.Object.ToNumber('1.')).to.be(1);
            /*jshint -W047 */
            expect(utilx.Object.ToNumber(-1.)).to.be(-1);
            expect(utilx.Object.ToNumber(0.)).to.be(0);
            expect(utilx.Object.ToNumber(1.)).to.be(1);
            /*jshint +W047 */
            expect(utilx.Object.ToNumber('-1.1')).to.be(-1.1);
            expect(utilx.Object.ToNumber('0.1')).to.be(0.1);
            expect(utilx.Object.ToNumber('1.1')).to.be(1.1);
        });

        it('date', function () {
            var dateInt;

            expect(function () {
                dateInt = utilx.Object.ToNumber(new Date(2013, 11, 11));
            }).to.not.throwException();

            expect(typeof dateInt === 'number').to.be.ok();
            expect(required.isNaN(dateInt)).to.not.be.ok();
        });

        it('string NaN, Infinity, -Infinity', function () {
            expect(required.isNaN(utilx.Object.ToNumber('NaN'))).to.be.ok();
            expect(utilx.Object.ToNumber('Infinity')).to.be(Infinity);
            expect(utilx.Object.ToNumber('-Infinity')).to.be(-Infinity);
        });

        it('array', function () {
            expect(utilx.Object.ToNumber([])).to.be(0);
            expect(utilx.Object.ToNumber([1])).to.be(1);
            expect(utilx.Object.ToNumber([1.1])).to.be(1.1);
            /*jshint -W047 */
            expect(utilx.Object.ToNumber([1.])).to.be(1);
            /*jshint +W047 */
            expect(utilx.Object.ToNumber([''])).to.be(0);
            expect(utilx.Object.ToNumber(['1'])).to.be(1);
            expect(utilx.Object.ToNumber(['1.1'])).to.be(1.1);
        });

        it('object', function () {
            expect(required.isNaN(utilx.Object.ToNumber({}))).to.be.ok();
            expect(required.isNaN(utilx.Object.ToNumber({valueOf: ''}))).to.be.ok();
            expect(required.isNaN(utilx.Object.ToNumber({valueOf: '1'}))).to.be.ok();
            expect(required.isNaN(utilx.Object.ToNumber({valueOf: 1}))).to.be.ok();
            expect(required.isNaN(utilx.Object.ToNumber({valueOf: 1.1}))).to.be.ok();
            /*jshint -W047 */
            expect(required.isNaN(utilx.Object.ToNumber({valueOf: 1.}))).to.be.ok();
            /*jshint +W047 */
        });

        it('function', function () {
            expect(required.isNaN(utilx.Object.ToNumber(function () { return 1; }))).to.be.ok();
        });
    });
}());

},{"../scripts/":10}],106:[function(require,module,exports){
/*global Date, RegExp, TypeError, describe, it, require */

/*properties
    Object, ToObject, a, be, charAt, expect, length, noop, required,
    throwException, to, toString, toStringTag, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.ToObject', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Object.ToObject();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Object.ToObject(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Object.ToObject(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(typeof utilx.Object.ToObject(1)).to.be('object');
            expect(typeof utilx.Object.ToObject(true)).to.be('object');
            expect(typeof utilx.Object.ToObject('')).to.be('object');
            expect(typeof utilx.Object.ToObject([])).to.be('object');
            expect(typeof utilx.Object.ToObject({})).to.be('object');
            expect(typeof utilx.Object.ToObject(required.Object('a'))).to.be('object');
            expect(typeof utilx.Object.ToObject(required.noop)).to.be('function');
            expect(typeof utilx.Object.ToObject(new Date())).to.be('object');
            expect(utilx.Object.ToObject(new RegExp('c')).toString()).to.be('/c/');
        });

        it('should have correct values', function () {
            var str = utilx.Object.ToObject('foo');

            expect(typeof str).to.be('object');
            expect(str.length).to.be(3);
            expect(utilx.Object.toStringTag(str)).to.be('[object String]');
            expect(str.toString()).to.be('foo');
            expect(str.charAt(0)).to.be('f');
            expect(str.charAt(1)).to.be('o');
            expect(str.charAt(2)).to.be('o');
        });

        it('should be same object', function () {
            var testObject = [];

            expect(utilx.Object.ToObject(testObject)).to.be(testObject);
            testObject = {};
            expect(utilx.Object.ToObject(testObject)).to.be(testObject);
            testObject = required.noop;
            expect(utilx.Object.ToObject(testObject)).to.be(testObject);
            testObject = required.Object('test');
            expect(utilx.Object.ToObject(testObject)).to.be(testObject);
            testObject = required.Object(true);
            expect(utilx.Object.ToObject(testObject)).to.be(testObject);
            testObject = required.Object(10);
            expect(utilx.Object.ToObject(testObject)).to.be(testObject);
        });
    });
}());

},{"../scripts/":10}],107:[function(require,module,exports){
/*global Date, Error, RegExp, TypeError, describe, it, require */

/*properties
    Object, a, be, expect, isNaN, isNumber, not, ok, throwException, to,
    ToPrimitive, toString, utilx, valueOf
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.ToPrimitive', function () {
        it('should throw a TypeError in each case', function () {
            expect(function () {
                utilx.Object.ToPrimitive({toString: ''});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.ToPrimitive({toString: '1'});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.ToPrimitive({toString: 1});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.ToPrimitive({toString: 1.1});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            /*jshint -W047 */
            expect(function () {
                utilx.Object.ToPrimitive({toString: 1.});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
            /*jshint +W047 */
        });

        it('argument missing, undefined and null', function () {
            expect(utilx.Object.ToPrimitive()).to.be(undefined);
            expect(utilx.Object.ToPrimitive(undefined)).to.be(undefined);
            expect(utilx.Object.ToPrimitive(null)).to.be(null);
        });

        it('number', function () {
            expect(utilx.Object.ToPrimitive(-10.123)).to.be(-10.123);
            expect(utilx.Object.ToPrimitive(0)).to.be(0);
            expect(utilx.Object.ToPrimitive(0.123)).to.be(0.123);
            expect(utilx.Object.ToPrimitive(10)).to.be(10);
            expect(utilx.Object.ToPrimitive(10.123)).to.be(10.123);
            expect(utilx.Object.ToPrimitive(Infinity)).to.be(Infinity);
            expect(utilx.Object.ToPrimitive(-Infinity)).to.be(-Infinity);
            expect(required.isNaN(utilx.Object.ToPrimitive(NaN))).to.be.ok();
        });

        it('string', function () {
            expect(utilx.Object.ToPrimitive('')).to.be('');
            expect(utilx.Object.ToPrimitive(' ')).to.be(' ');
            expect(utilx.Object.ToPrimitive('x')).to.be('x');
        });

        it('boolean', function () {
            expect(utilx.Object.ToPrimitive(true)).to.be(true);
            expect(utilx.Object.ToPrimitive(false)).to.be(false);
        });

        it('mixed objects', function () {
            expect(utilx.Object.ToPrimitive({})).to.be.ok();
            expect(utilx.Object.ToPrimitive([])).to.be('');
            expect(utilx.Object.ToPrimitive([10.123])).to.be('10.123');
            expect(utilx.Object.ToPrimitive(new RegExp('c'))).to.be(new RegExp('c').toString());
            expect(utilx.Object.ToPrimitive(new Error('x'))).to.be(new Error('x').toString());
            expect(utilx.Object.ToPrimitive(new Date(123456789))).to.be(new Date(123456789).toString());
            expect(utilx.Object.ToPrimitive(new Date(123456789), 0)).to.be(123456789);
        });

        it('tens', function () {
            /*jshint -W047 */
            expect(utilx.Object.ToPrimitive(10.)).to.be(10);
            /*jshint +W047 */
            expect(utilx.Object.ToPrimitive(10.0)).to.be(10);
            expect(utilx.Object.ToPrimitive('10.')).to.be('10.');
            expect(utilx.Object.ToPrimitive(' 10.')).to.be(' 10.');
            expect(utilx.Object.ToPrimitive('10. ')).to.be('10. ');
            expect(utilx.Object.ToPrimitive(' 10. ')).to.be(' 10. ');
            expect(utilx.Object.ToPrimitive('10.0')).to.be('10.0');
            expect(utilx.Object.ToPrimitive(' 10.0')).to.be(' 10.0');
            expect(utilx.Object.ToPrimitive('10.0 ')).to.be('10.0 ');
            expect(utilx.Object.ToPrimitive(' 10.0 ')).to.be(' 10.0 ');
            expect(utilx.Object.ToPrimitive('10.123')).to.be('10.123');
            expect(utilx.Object.ToPrimitive(' 10.123')).to.be(' 10.123');
            expect(utilx.Object.ToPrimitive('10.123 ')).to.be('10.123 ');
            expect(utilx.Object.ToPrimitive(' 10.123 ')).to.be(' 10.123 ');
        });

        it('-1, 0, 1', function () {
            expect(utilx.Object.ToPrimitive('-1')).to.be('-1');
            expect(utilx.Object.ToPrimitive('0')).to.be('0');
            expect(utilx.Object.ToPrimitive('1')).to.be('1');
            expect(utilx.Object.ToPrimitive('-1.')).to.be('-1.');
            expect(utilx.Object.ToPrimitive('0.')).to.be('0.');
            expect(utilx.Object.ToPrimitive('1.')).to.be('1.');
            /*jshint -W047 */
            expect(utilx.Object.ToPrimitive(-1.)).to.be(-1);
            expect(utilx.Object.ToPrimitive(0.)).to.be(0);
            expect(utilx.Object.ToPrimitive(1.)).to.be(1);
            /*jshint +W047 */
            expect(utilx.Object.ToPrimitive('-1.1')).to.be('-1.1');
            expect(utilx.Object.ToPrimitive('0.1')).to.be('0.1');
            expect(utilx.Object.ToPrimitive('1.1')).to.be('1.1');
        });

        it('date', function () {
            var date;

            expect(function () {
                date = utilx.Object.ToPrimitive(new Date(2013, 11, 11));
            }).to.not.throwException();

            expect(typeof date === 'string').to.be.ok();
            expect(date).to.be(new Date(2013, 11, 11).toString());

            expect(function () {
                date = utilx.Object.ToPrimitive(new Date(2013, 11, 11), 0);
            }).to.not.throwException();

            expect(typeof date === 'number').to.be.ok();
            expect(date).to.be(new Date(2013, 11, 11).valueOf());
        });

        it('string NaN, Infinity, -Infinity', function () {
            expect(utilx.Object.ToPrimitive('NaN')).to.be('NaN');
            expect(utilx.Object.ToPrimitive('Infinity')).to.be('Infinity');
            expect(utilx.Object.ToPrimitive('-Infinity')).to.be('-Infinity');
        });

        it('array', function () {
            expect(utilx.Object.ToPrimitive([])).to.be('');
            expect(utilx.Object.ToPrimitive([1])).to.be('1');
            expect(utilx.Object.ToPrimitive([1.1])).to.be('1.1');
            /*jshint -W047 */
            expect(utilx.Object.ToPrimitive([1.])).to.be('1');
            /*jshint +W047 */
            expect(utilx.Object.ToPrimitive([''])).to.be('');
            expect(utilx.Object.ToPrimitive(['1', '2'])).to.be('1,2');
            expect(utilx.Object.ToPrimitive(['1.1'])).to.be('1.1');
        });

        it('object', function () {
            expect(utilx.Object.ToPrimitive({})).to.be('[object Object]');
            expect(utilx.Object.ToPrimitive({valueOf: ''})).to.be('[object Object]');
            expect(utilx.Object.ToPrimitive({valueOf: '1'})).to.be('[object Object]');
            expect(utilx.Object.ToPrimitive({valueOf: 1})).to.be('[object Object]');
            expect(utilx.Object.ToPrimitive({valueOf: 1.1})).to.be('[object Object]');
            /*jshint -W047 */
            expect(utilx.Object.ToPrimitive({valueOf: 1.})).to.be('[object Object]');
            /*jshint +W047 */
        });

        it('function', function () {
            var fn = function () { return 1; };

            expect(utilx.Object.ToPrimitive(fn)).to.be(fn.toString());
        });
    });
}());

},{"../scripts/":10}],108:[function(require,module,exports){
/*global require, describe, it */
/*jshint -W009, -W010, -W053, -W064 */
(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.areSameClass', function () {
        it('are same internal class in each case', function () {
            expect(utilx.Object.areSameClass()).to.be.ok();
            expect(utilx.Object.areSameClass(undefined)).to.be.ok();
            expect(utilx.Object.areSameClass(1)).to.not.be.ok();
            expect(utilx.Object.areSameClass(undefined, undefined)).to.be.ok();
            expect(utilx.Object.areSameClass(null, null)).to.be.ok();
            expect(utilx.Object.areSameClass(1, 2)).to.be.ok();
            expect(utilx.Object.areSameClass(1, NaN)).to.be.ok();
            expect(utilx.Object.areSameClass(1, Infinity)).to.be.ok();
            expect(utilx.Object.areSameClass(1, -Infinity)).to.be.ok();
            expect(utilx.Object.areSameClass('1', '2')).to.be.ok();
            expect(utilx.Object.areSameClass('1', String(1))).to.be.ok();
            expect(utilx.Object.areSameClass(true, false)).to.be.ok();
            expect(utilx.Object.areSameClass({}, {})).to.be.ok();
            expect(utilx.Object.areSameClass(undefined, undefined, undefined)).to.be.ok();
            expect(utilx.Object.areSameClass(null, null, null)).to.be.ok();
            expect(utilx.Object.areSameClass(1, 2, Object(3))).to.be.ok();
            expect(utilx.Object.areSameClass(1, NaN, Infinity)).to.be.ok();
            expect(utilx.Object.areSameClass(1, Infinity, -Infinity)).to.be.ok();
            expect(utilx.Object.areSameClass(1, -Infinity, NaN)).to.be.ok();
            expect(utilx.Object.areSameClass('1', '2', Object('3'))).to.be.ok();
            expect(utilx.Object.areSameClass(true, false, Object(true))).to.be.ok();
            expect(utilx.Object.areSameClass({}, {}, Object())).to.be.ok();
            expect(utilx.Object.areSameClass(1, 2, 3, 4, 5, 6, 7, 8, 9, 0)).to.be.ok();
        });

        it('are not same internal class in each case', function () {
            expect(utilx.Object.areSameClass(undefined, null)).to.not.be.ok();
            expect(utilx.Object.areSameClass(null, undefined)).to.not.be.ok();
            expect(utilx.Object.areSameClass(1, '2')).to.not.be.ok();
            expect(utilx.Object.areSameClass('1', NaN)).to.not.be.ok();
            expect(utilx.Object.areSameClass('1', Object(1))).to.not.be.ok();
            expect(utilx.Object.areSameClass(true, 'false')).to.not.be.ok();
            expect(utilx.Object.areSameClass({}, true)).to.not.be.ok();
            expect(utilx.Object.areSameClass({}, 1)).to.not.be.ok();
            expect(utilx.Object.areSameClass({}, '')).to.not.be.ok();
            expect(utilx.Object.areSameClass({}, [])).to.not.be.ok();
            expect(utilx.Object.areSameClass({}, new Date())).to.not.be.ok();
            expect(utilx.Object.areSameClass(undefined, undefined, null)).to.not.be.ok();
            expect(utilx.Object.areSameClass(null, null, 'null')).to.not.be.ok();
            expect(utilx.Object.areSameClass(1, 2, Object('3'))).to.not.be.ok();
            expect(utilx.Object.areSameClass(Object('1'), NaN, Infinity)).to.not.be.ok();
            expect(utilx.Object.areSameClass(1, Infinity, true)).to.not.be.ok();
            expect(utilx.Object.areSameClass('1', '2', Object(3))).to.not.be.ok();
            expect(utilx.Object.areSameClass(true, false, 'true')).to.not.be.ok();
            expect(utilx.Object.areSameClass(1, 2, 3, 4, 5, 6, 7, 8, 9, '0')).to.not.be.ok();
            expect(utilx.Object.areSameClass({}, [], new Array())).to.not.be.ok();
            expect(utilx.Object.areSameClass({}, new Date())).to.not.be.ok();
        });
    });
}());

},{"../scripts/":10}],109:[function(require,module,exports){
/*global require, describe, it */
/*jshint -W009, -W010, -W053, -W064 */
(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.areSameTypeOf', function () {
        it('are same typeof in each case', function () {
            expect(utilx.Object.areSameTypeOf()).to.be.ok();
            expect(utilx.Object.areSameTypeOf(undefined)).to.be.ok();
            expect(utilx.Object.areSameTypeOf(1)).to.not.be.ok();
            expect(utilx.Object.areSameTypeOf(undefined, undefined)).to.be.ok();
            expect(utilx.Object.areSameTypeOf(null, null)).to.be.ok();
            expect(utilx.Object.areSameTypeOf(1, 2)).to.be.ok();
            expect(utilx.Object.areSameTypeOf(1, NaN)).to.be.ok();
            expect(utilx.Object.areSameTypeOf(1, Infinity)).to.be.ok();
            expect(utilx.Object.areSameTypeOf(1, -Infinity)).to.be.ok();
            expect(utilx.Object.areSameTypeOf('1', '2')).to.be.ok();
            expect(utilx.Object.areSameTypeOf('1', Object(1))).to.not.be.ok();
            expect(utilx.Object.areSameTypeOf('1', Object('2'))).to.not.be.ok();
            expect(utilx.Object.areSameTypeOf(true, false)).to.be.ok();
            expect(utilx.Object.areSameTypeOf({}, {})).to.be.ok();
            expect(utilx.Object.areSameTypeOf({}, [])).to.be.ok();
            expect(utilx.Object.areSameTypeOf({}, new Date())).to.be.ok();
            expect(utilx.Object.areSameTypeOf(undefined, undefined, undefined)).to.be.ok();
            expect(utilx.Object.areSameTypeOf(null, null, null)).to.be.ok();
            expect(utilx.Object.areSameTypeOf(1, 2, Object(3))).to.not.be.ok();
            expect(utilx.Object.areSameTypeOf(1, NaN, Infinity)).to.be.ok();
            expect(utilx.Object.areSameTypeOf(1, Infinity, -Infinity)).to.be.ok();
            expect(utilx.Object.areSameTypeOf(1, -Infinity, NaN)).to.be.ok();
            expect(utilx.Object.areSameTypeOf('1', '2', Object('3'))).to.not.be.ok();
            expect(utilx.Object.areSameTypeOf(true, false, Object(true))).to.not.be.ok();
            expect(utilx.Object.areSameTypeOf({}, {}, new Object())).to.be.ok();
            expect(utilx.Object.areSameTypeOf({}, [], new Array())).to.be.ok();
            expect(utilx.Object.areSameTypeOf({}, new Date())).to.be.ok();
            expect(utilx.Object.areSameTypeOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 0)).to.be.ok();
        });

        it('are not same typeof in each case', function () {
            expect(utilx.Object.areSameTypeOf(undefined, null)).to.not.be.ok();
            expect(utilx.Object.areSameTypeOf(null, undefined)).to.not.be.ok();
            expect(utilx.Object.areSameTypeOf(1, '2')).to.not.be.ok();
            expect(utilx.Object.areSameTypeOf('1', NaN)).to.not.be.ok();
            expect(utilx.Object.areSameTypeOf('1', Object('1'))).to.not.be.ok();
            expect(utilx.Object.areSameTypeOf(true, 'false')).to.not.be.ok();
            expect(utilx.Object.areSameTypeOf({}, true)).to.not.be.ok();
            expect(utilx.Object.areSameTypeOf({}, 1)).to.not.be.ok();
            expect(utilx.Object.areSameTypeOf({}, '')).to.not.be.ok();
            expect(utilx.Object.areSameTypeOf(undefined, undefined, null)).to.not.be.ok();
            expect(utilx.Object.areSameTypeOf(null, null, 'null')).to.not.be.ok();
            expect(utilx.Object.areSameTypeOf(1, 2, Object(3))).to.not.be.ok();
            expect(utilx.Object.areSameTypeOf(Object('1'), NaN, Infinity)).to.not.be.ok();
            expect(utilx.Object.areSameTypeOf(1, Infinity, true)).to.not.be.ok();
            expect(utilx.Object.areSameTypeOf('1', '2', Object('3'))).to.not.be.ok();
            expect(utilx.Object.areSameTypeOf(true, false, 'true')).to.not.be.ok();
            expect(utilx.Object.areSameTypeOf(1, 2, 3, 4, 5, 6, 7, 8, 9, '0')).to.not.be.ok();
        });
    });
}());

},{"../scripts/":10}],110:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.assign', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Object.assign();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Object.assign(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Object.assign(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if source argument is undefined', function () {
            expect(function () {
                utilx.Object.assign({}, undefined);
            }).to.not.throwException();
        });

        it('should throw if source argument is null', function () {
            expect(function () {
                utilx.Object.assign({}, null);
            }).to.not.throwException();
        });

        it('returns the modified target object', function () {
            var target = {},
                returned = utilx.Object.assign(target, {
                    a: 1
                });

            expect(returned).to.equal(target);
        });

        it('should return target if no sources', function () {
            var target = {};

            expect(utilx.Object.assign(target)).to.be(target);
        });

        it('should merge two objects', function () {
            var target = {
                a: 1
            },
                returned = utilx.Object.assign(target, {
                    b: 2
                });

            expect(returned).to.eql({
                a: 1,
                b: 2
            });
        });

        it('should merge three objects', function () {
            var target = {
                    a: 1
                },
                source1 = {
                    b: 2
                },
                source2 = {
                    c: 3
                },
                returned = utilx.Object.assign(target, source1, source2);

            expect(returned).to.eql({
                a: 1,
                b: 2,
                c: 3
            });
        });

        it('only iterates over own keys', function () {
            var Foo = function () {
                    return;
                },
                target = {
                    a: 1
                },
                foo,
                returned;

            Foo.prototype.bar = true;
            foo = new Foo();
            foo.baz = true;
            returned = utilx.Object.assign(target, foo);
            expect(returned).to.equal(target);
            expect(target).to.eql({
                baz: true,
                a: 1
            });
        });

        it('works with arrays', function () {
            var x = required.create(undefined, undefined, undefined, {}, 4, 5, 6),
                y = required.create(1, null, undefined, {}, 4, 5, 6);

            delete x[0];
            delete x[1];
            delete x[2];
            expect(utilx.Object.assign([1, 2, 3], x)).to.eql([1, 2, 3, {}, 4, 5, 6]);
            expect(utilx.Object.assign([1, 2, 3], y)).to.eql(y);

            expect(utilx.Object.assign([1, 2, 3], {
                3: 4,
                4: 5,
                5: 6,
                length: 6
            })).to.eql([1, 2, 3, 4, 5, 6]);

            expect(utilx.Object.assign([1, 2, 3, 6, 7, 8, 9], {
                3: 4,
                4: 5,
                5: 6,
                length: 6
            })).to.eql([1, 2, 3, 4, 5, 6]);

            expect(utilx.Object.assign([1, 2, 3, 6, 7, 8, 9], {
                3: 4,
                4: 5,
                5: 6
            })).to.eql([1, 2, 3, 4, 5, 6, 9]);
        });

        it('should not throw when target is not an object', function () {
            expect(function () {
                utilx.Object.assign(true, {});
            }).to.not.throwException();

            expect(function () {
                utilx.Object.assign(1, {});
            }).to.not.throwException();

            expect(function () {
                utilx.Object.assign('a', {});
            }).to.not.throwException();
        });

        it('should not throw when source is not an object', function () {
            var target = {};

            expect(function () {
                utilx.Object.assign(target, true);
            }).to.not.throwException();

            expect(function () {
                utilx.Object.assign(target, 1);
            }).to.not.throwException();
            expect(function () {
                utilx.Object.assign(target, 'a');
            }).to.not.throwException();
        });
    });
}());

},{"../scripts/":10}],111:[function(require,module,exports){
/*global Date, RegExp, describe, it, require */

/*properties
    Array, Object, UTC, a, b, be, deepEqual, expect, isArguments, keys,
    ok, push, returnArgs, to, utilx, valueOf, x, y
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.deepEqual', function () {
        it('equal', function () {
            expect(utilx.Object.deepEqual({
                a: [2, 3],
                b: [4]
            }, {
                a: [2, 3],
                b: [4]
            })).to.be(true);

            expect(utilx.Object.deepEqual([
                undefined,
                null,
                -1,
                0,
                1,
                false,
                true,
                undefined,
                '',
                'abc',
                null,
                undefined
            ], [
                undefined,
                null,
                -1,
                0,
                1,
                false,
                true,
                undefined,
                '',
                'abc',
                null,
                undefined
            ])).to.be(true);

            expect(utilx.Object.deepEqual([{
                a: 3
            }, {
                b: 4
            }], [{
                a: '3'
            }, {
                b: '4'
            }])).to.be(true);

            expect(utilx.Object.deepEqual([], {})).to.be(true);
            expect(utilx.Object.deepEqual([6], ['6'])).to.be(true);
        });

        it('not equal', function () {
            expect(utilx.Object.deepEqual(NaN, NaN)).to.be(false);
            expect(utilx.Object.deepEqual({
                x: 5,
                y: [6]
            }, {
                x: 5,
                y: 6
            })).to.be(false);

            expect(utilx.Object.deepEqual([3], {valueOf: 3})).to.be(false);
        });

        it('nested nulls', function () {
            expect(utilx.Object.deepEqual([null, null, null], [null, null, null])).to.be(true);
        });

        it('non-objects', function () {
            expect(utilx.Object.deepEqual(3, 3)).to.be(true);
            expect(utilx.Object.deepEqual('beep', 'beep')).to.be(true);
            expect(utilx.Object.deepEqual('3', 3)).to.be(true);
            expect(utilx.Object.deepEqual('3', [3])).to.be(false);
            expect(utilx.Object.deepEqual(3, [3])).to.be(false);
            expect(utilx.Object.deepEqual(3, {valueOf: 3})).to.be(false);
        });

        it('arguments class', function () {
            var x = required.returnArgs(1, 2, 3),
                y = required.returnArgs(1, 2, 3);

            expect(utilx.Object.deepEqual(x, y)).to.be(true);
            expect(utilx.Object.deepEqual(x, [1, 2, 3])).to.be(false);
        });

        it('test the arguments shim', function () {
            expect(required.isArguments(required.returnArgs())).to.be(true);
            expect(required.isArguments([1, 2, 3])).to.be(false);
        });

        it('test the keys shim', function () {
            expect(utilx.Object.deepEqual(utilx.Object.keys({
                a: 1,
                b: 2
            }), ['a', 'b'])).to.be(true);
        });

        it('dates', function () {
            var d0 = new Date(1391297899000),
                d1 = new Date(Date.UTC(2014, 1, 1, 23, 38, 19));

            expect(utilx.Object.deepEqual(d0, d1)).to.be(true);
        });

        it('regexp', function () {
            var r0 = /test/gi,
                r1 = new RegExp('test', 'gi');

            expect(utilx.Object.deepEqual(r0, r1)).to.be(true);

            r0 = /test/g;
            r1 = new RegExp('test', 'gi');
            expect(utilx.Object.deepEqual(r0, r1)).to.be(false);
        });

        it('arrays', function () {
            var arrCmp = [
                    undefined,
                    null,
                    -1,
                    0,
                    1,
                    false,
                    true,
                    undefined,
                    '',
                    'abc',
                    null,
                    undefined
                ],
                arrCmp2 = [
                    undefined,
                    null,
                    -1,
                    0,
                    1,
                    false,
                    true,
                    undefined,
                    '',
                    'abc',
                    null,
                    undefined
                ];

            expect(utilx.Object.deepEqual(arrCmp, arrCmp2)).to.be(true);
        });
    });
}());

},{"../scripts/":10}],112:[function(require,module,exports){
/*global Date, RegExp, describe, it, require */

/*properties
    Array, Object, UTC, a, b, be, deepStrictEqual, expect, isArguments,
    keys, ok, push, returnArgs, to, utilx, valueOf, x, y
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.deepStrictEqual', function () {
        it('equal', function () {
            expect(utilx.Object.deepStrictEqual({
                a: [2, 3],
                b: [4]
            }, {
                a: [2, 3],
                b: [4]
            })).to.be(true);

            expect(utilx.Object.deepStrictEqual([
                undefined,
                null,
                -1,
                0,
                1,
                false,
                true,
                undefined,
                '',
                'abc',
                null,
                undefined
            ], [
                undefined,
                null,
                -1,
                0,
                1,
                false,
                true,
                undefined,
                '',
                'abc',
                null,
                undefined
            ])).to.be(true);
        });

        it('not equal', function () {
            expect(utilx.Object.deepStrictEqual([{
                a: 3
            }, {
                b: 4
            }], [{
                a: '3'
            }, {
                b: '4'
            }])).to.be(false);

            expect(utilx.Object.deepStrictEqual([], {})).to.be(false);
            expect(utilx.Object.deepStrictEqual([6], ['6'])).to.be(false);
            expect(utilx.Object.deepStrictEqual(NaN, NaN)).to.be(false);
            expect(utilx.Object.deepStrictEqual({
                x: 5,
                y: [6]
            }, {
                x: 5,
                y: 6
            })).to.be(false);

            expect(utilx.Object.deepStrictEqual([3], {valueOf: 3})).to.be(false);
        });

        it('nested nulls', function () {
            expect(utilx.Object.deepStrictEqual([null, null, null], [null, null, null])).to.be(true);
        });

        it('non-objects', function () {
            expect(utilx.Object.deepStrictEqual(3, 3)).to.be(true);
            expect(utilx.Object.deepStrictEqual('beep', 'beep')).to.be(true);
            expect(utilx.Object.deepStrictEqual('3', 3)).to.be(false);
            expect(utilx.Object.deepStrictEqual('3', [3])).to.be(false);
            expect(utilx.Object.deepStrictEqual(3, [3])).to.be(false);
            expect(utilx.Object.deepStrictEqual(3, {valueOf: 3})).to.be(false);
        });

        it('arguments class', function () {
            var x = required.returnArgs(1, 2, 3),
                y = required.returnArgs(1, 2, 3);

            expect(utilx.Object.deepStrictEqual(x, y)).to.be(true);
            expect(utilx.Object.deepStrictEqual(x, [1, 2, 3])).to.be(false);
        });

        it('test the arguments shim', function () {
            expect(required.isArguments(required.returnArgs())).to.be(true);
            expect(required.isArguments([1, 2, 3])).to.be(false);
        });

        it('test the keys shim', function () {
            expect(utilx.Object.deepStrictEqual(utilx.Object.keys({
                a: 1,
                b: 2
            }), ['a', 'b'])).to.be(true);
        });

        it('dates', function () {
            var d0 = new Date(1391297899000),
                d1 = new Date(Date.UTC(2014, 1, 1, 23, 38, 19));

            expect(utilx.Object.deepStrictEqual(d0, d1)).to.be(true);
        });

        it('regexp', function () {
            var r0 = /test/gi,
                r1 = new RegExp('test', 'gi');

            expect(utilx.Object.deepStrictEqual(r0, r1)).to.be(true);

            r0 = /test/g;
            r1 = new RegExp('test', 'gi');
            expect(utilx.Object.deepStrictEqual(r0, r1)).to.be(false);
        });

        it('arrays', function () {
            var arrCmp = [
                    undefined,
                    null,
                    -1,
                    0,
                    1,
                    false,
                    true,
                    undefined,
                    '',
                    'abc',
                    null,
                    undefined
                ],
                arrCmp2 = [
                    undefined,
                    null,
                    -1,
                    0,
                    1,
                    false,
                    true,
                    undefined,
                    '',
                    'abc',
                    null,
                    undefined
                ];

            expect(utilx.Object.deepStrictEqual(arrCmp, arrCmp2)).to.be(true);
        });
    });
}());

},{"../scripts/":10}],113:[function(require,module,exports){
/*global Object, TypeError, describe, it, require */

/*properties
    '0', '1', '2', Object, a, be, call, configurable, defineProperties,
    enumerable, expect, foo, foo1, foo2, foo3, hasOwnProperty, length, noop, not,
    ok, prototype, throwException, to, utilx, value, writable
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.defineProperties', function () {
        it('should throw a TypeError in each case', function () {
            expect(function () {
                utilx.Object.defineProperties();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.defineProperties(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.defineProperties(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.defineProperties({});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.defineProperties({}, undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.defineProperties({}, null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.defineProperties({}, 'a');
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw a TypeError in each case', function () {
            var obj = {},
                res;

            expect(function () {
                res = utilx.Object.defineProperties(obj, true);
            }).to.not.throwException();

            expect(res).to.be(obj);

            obj = {};
            expect(function () {
                res = utilx.Object.defineProperties(obj, 1);
            }).to.not.throwException();

            expect(res).to.be(obj);
        });

        it('should not throw an error definining properties on plain objects', function () {
            var obj = {};

            expect(function () {
                utilx.Object.defineProperties(obj, {
                    foo: {
                        enumerable: true,
                        writable: true,
                        configurable: true
                    },

                    foo1: {
                        value: undefined,
                        enumerable: true,
                        writable: true,
                        configurable: true
                    },

                    foo2: {
                        value: null,
                        enumerable: true,
                        writable: true,
                        configurable: true
                    },

                    foo3: {
                        value: 1,
                        enumerable: true,
                        writable: true,
                        configurable: true
                    }
                });
            }).to.not.throwException();

            expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
            expect(obj.foo).to.be(undefined);
            expect(Object.prototype.hasOwnProperty.call(obj, 'foo1')).to.be.ok();
            expect(obj.foo1).to.be(undefined);
            expect(Object.prototype.hasOwnProperty.call(obj, 'foo2')).to.be.ok();
            expect(obj.foo2).to.be(null);
            expect(Object.prototype.hasOwnProperty.call(obj, 'foo3')).to.be.ok();
            expect(obj.foo3).to.be(1);
        });

        it('should not throw an error redefinining properties on plain objects', function () {
            var obj = {
                foo: 10,
                foo1: true,
                foo2: 'x'
            };

            expect(function () {
                utilx.Object.defineProperties(obj, {
                    foo: {
                        enumerable: true,
                        writable: true,
                        configurable: true
                    },

                    foo1: {
                        enumerable: false,
                        writable: false,
                        configurable: false
                    },

                    foo2: {
                        enumerable: false,
                        writable: false,
                        configurable: false
                    }
                });
            }).to.not.throwException();

            expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
            expect(obj.foo).to.be(10);
            expect(Object.prototype.hasOwnProperty.call(obj, 'foo1')).to.be.ok();
            expect(obj.foo1).to.be(true);
            expect(Object.prototype.hasOwnProperty.call(obj, 'foo2')).to.be.ok();
            expect(obj.foo2).to.be('x');
        });

        it('should not throw an error redefinining elements on arrays', function () {
            var obj = [10, true, 'x'];

            expect(function () {
                utilx.Object.defineProperties(obj, {
                    0: {
                        enumerable: true,
                        writable: true,
                        configurable: true
                    },

                    1: {
                        enumerable: true,
                        writable: true,
                        configurable: true
                    },

                    2: {
                        enumerable: true,
                        writable: true,
                        configurable: true
                    }
                });
            }).to.not.throwException();

            expect(obj.length).to.be(3);
            expect(obj[0]).to.be(10);
            expect(obj[1]).to.be(true);
            expect(obj[2]).to.be('x');
        });

        it('should not throw an error definining elements/properties on arrays', function () {
            var obj = [];

            expect(function () {
                utilx.Object.defineProperties(obj, {
                    0: {
                        value: 10,
                        enumerable: true,
                        writable: true,
                        configurable: true
                    },

                    1: {
                        value: true,
                        enumerable: true,
                        writable: true,
                        configurable: true
                    },

                    2: {
                        value: 'x',
                        enumerable: true,
                        writable: true,
                        configurable: true
                    },

                    foo: {
                        value: required.noop,
                        enumerable: true,
                        writable: true,
                        configurable: true
                    }
                });
            }).to.not.throwException();

            expect(obj.length).to.be(3);
            expect(obj[0]).to.be(10);
            expect(obj[1]).to.be(true);
            expect(obj[2]).to.be('x');
            expect(obj.foo).to.be(required.noop);
        });

        it('should not throw an error definining properties on functions', function () {
            var obj = function () {
                return;
            };

            expect(function () {
                utilx.Object.defineProperties(obj, {
                    foo: {
                        value: 10,
                        enumerable: true,
                        writable: true,
                        configurable: true
                    },

                    foo1: {
                        value: true,
                        enumerable: true,
                        writable: true,
                        configurable: true
                    },

                    foo2: {
                        value: 'x',
                        enumerable: true,
                        writable: true,
                        configurable: true
                    },

                    foo3: {
                        value: required.noop,
                        enumerable: true,
                        writable: true,
                        configurable: true
                    }
                });
            }).to.not.throwException();

            expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
            expect(obj.foo).to.be(10);
            expect(Object.prototype.hasOwnProperty.call(obj, 'foo1')).to.be.ok();
            expect(obj.foo1).to.be(true);
            expect(Object.prototype.hasOwnProperty.call(obj, 'foo2')).to.be.ok();
            expect(obj.foo2).to.be('x');
            expect(Object.prototype.hasOwnProperty.call(obj, 'foo3')).to.be.ok();
            expect(obj.foo3).to.be(required.noop);
        });

        it('should not throw an error redefinining properties on functions', function () {
            var obj = function () {
                return;
            };

            obj.foo = 10;
            obj.foo1 = true;
            obj.foo2 = 'x';
            obj.foo3 = required.noop;

            expect(function () {
                utilx.Object.defineProperties(obj, {
                    foo: {
                        enumerable: true,
                        writable: true,
                        configurable: true
                    },

                    foo1: {
                        enumerable: true,
                        writable: true,
                        configurable: true
                    },

                    foo2: {
                        enumerable: true,
                        writable: true,
                        configurable: true
                    },

                    foo3: {
                        enumerable: true,
                        writable: true,
                        configurable: true
                    }
                });
            }).to.not.throwException();

            expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
            expect(obj.foo).to.be(10);
            expect(Object.prototype.hasOwnProperty.call(obj, 'foo1')).to.be.ok();
            expect(obj.foo1).to.be(true);
            expect(Object.prototype.hasOwnProperty.call(obj, 'foo2')).to.be.ok();
            expect(obj.foo2).to.be('x');
            expect(Object.prototype.hasOwnProperty.call(obj, 'foo3')).to.be.ok();
            expect(obj.foo3).to.be(required.noop);
        });
    });
}());

},{"../scripts/":10}],114:[function(require,module,exports){
/*global Object, TypeError, describe, it, require */

/*properties
    '01', '0x1', '1.', Object, a, be, call, configurable, defineProperty, enumerable, eql,
    expect, foo, hasOwnProperty, length, noop, not, ok, prototype,
    throwException, to, utilx, value, writable
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.defineProperty', function () {
        var result;

        it('should throw a TypeError in each case', function () {
            expect(function () {
                utilx.Object.defineProperty();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.defineProperty(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.defineProperty(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.defineProperty({}, 'foo');
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.defineProperty({}, 'foo', undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.defineProperty({}, 'foo', null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.defineProperty({}, 'foo', true);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.defineProperty({}, 'foo', 1);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error definining properties on plain objects', function () {
            expect(function () {
                var obj = utilx.Object.defineProperty({}, 'foo', {
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be(undefined);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty({}, 'foo', {
                    value: undefined,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be(undefined);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty({}, 'foo', {
                    value: null,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be(null);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty({}, 'foo', {
                    value: 1,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be(1);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty({}, 'foo', {
                    value: true,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be(true);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty({}, 'foo', {
                    value: '',
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be('');
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty({}, 'foo', {
                    value: {},
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.eql({});
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty({}, 'foo', {
                    value: [],
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.eql([]);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty({}, 'foo', {
                    value: required.noop,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be(required.noop);
            }).to.not.throwException();
        });

        it('should not throw an error redefinining properties on plain objects', function () {
            expect(function () {
                var obj = {
                    foo: 10
                };

                utilx.Object.defineProperty(obj, 'foo', {
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be(10);

                utilx.Object.defineProperty(obj, 'foo', {
                    enumerable: false,
                    writable: false,
                    configurable: false
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be(10);
            }).to.not.throwException();
        });

        it('should not throw an error redefinining elements on arrays', function () {
            expect(function () {
                result = utilx.Object.defineProperty([10], '0', {
                    enumerable: true,
                    writable: true,
                    configurable: true
                });
            }).to.not.throwException();
        });

        it('should have correct length after redefinining element on arrays', function () {
            expect(result.length).to.be(1);
        });

        it('should have correct value after redefinining element on arrays', function () {
            expect(result[0]).to.be(10);
        });

        it('should not throw an error definining properties on arrays', function () {
            expect(function () {
                var obj = utilx.Object.defineProperty([], 'foo', {
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be(undefined);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], 'foo', {
                    value: undefined,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be(undefined);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], 'foo', {
                    value: null,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be(null);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], 'foo', {
                    value: 1,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be(1);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], 'foo', {
                    value: true,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be(true);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], 'foo', {
                    value: '',
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be('');
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], 'foo', {
                    value: required.noop,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be(required.noop);
            }).to.not.throwException();
        });

        it('should not throw an error definining elements on arrays using integer strings', function () {
            expect(function () {
                var obj = utilx.Object.defineProperty([], '0', {
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(obj.length).to.be(1);
                expect(obj[0]).to.be(undefined);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], '0', {
                    value: undefined,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(obj.length).to.be(1);
                expect(obj[0]).to.be(undefined);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], '0', {
                    value: null,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, '0')).to.be.ok();
                expect(obj.length).to.be(1);
                expect(obj[0]).to.be(null);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], '0', {
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(obj.length).to.be(1);
                expect(obj[0]).to.be(undefined);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], '0', {
                    value: undefined,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(obj.length).to.be(1);
                expect(obj[0]).to.be(undefined);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], '0', {
                    value: null,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, '0')).to.be.ok();
                expect(obj.length).to.be(1);
                expect(obj[0]).to.be(null);
            }).to.not.throwException();
        });

        it('should not throw an error definining elements on arrays using integer numbers', function () {
            expect(function () {
                var obj = utilx.Object.defineProperty([], 0, {
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(obj.length).to.be(1);
                expect(obj[0]).to.be(undefined);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], 0, {
                    value: undefined,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(obj.length).to.be(1);
                expect(obj[0]).to.be(undefined);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], 0, {
                    value: null,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 0)).to.be.ok();
                expect(obj.length).to.be(1);
                expect(obj[0]).to.be(null);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], 1, {
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(obj.length).to.be(2);
                expect(obj[1]).to.be(undefined);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], 1, {
                    value: undefined,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(obj.length).to.be(2);
                expect(obj[1]).to.be(undefined);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], 1, {
                    value: null,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 1)).to.be.ok();
                expect(obj.length).to.be(2);
                expect(obj[1]).to.be(null);
            }).to.not.throwException();
        });

        it('should not throw an error definining elements on arrays using float numbers', function () {
            expect(function () {
                var obj = utilx.Object.defineProperty([], 1.1, {
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 1.1)).to.be.ok();
                expect(obj.length).to.be(0);
                expect(obj[1.1]).to.be(undefined);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], 1.1, {
                    value: undefined,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 1.1)).to.be.ok();
                expect(obj.length).to.be(0);
                expect(obj[1.1]).to.be(undefined);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], 1.1, {
                    value: null,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 1.1)).to.be.ok();
                expect(obj.length).to.be(0);
                expect(obj[1.1]).to.be(null);
            }).to.not.throwException();
        });

        it('should not throw an error definining elements on arrays using trailing point numbers', function () {
            /*jshint -W047 */
            expect(function () {
                var obj = utilx.Object.defineProperty([], 1., {
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(obj.length).to.be(2);
                expect(obj[1]).to.be(undefined);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], 1., {
                    value: undefined,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(obj.length).to.be(2);
                expect(obj[1]).to.be(undefined);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], 1., {
                    value: null,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(obj.length).to.be(2);
                expect(obj[1]).to.be(null);
            }).to.not.throwException();
        });

        it('should not throw an error definining elements on arrays using trailing point numbers strings', function () {
            expect(function () {
                var obj = utilx.Object.defineProperty([], '1.', {
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(obj.length).to.be(0);
                expect(obj['1.']).to.be(undefined);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], '1.', {
                    value: undefined,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(obj.length).to.be(0);
                expect(obj['1.']).to.be(undefined);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], '1.', {
                    value: null,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(obj.length).to.be(0);
                expect(obj['1.']).to.be(null);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], '1.', {
                    value: true,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(obj.length).to.be(0);
                expect(obj['1.']).to.be(true);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], '01', {
                    value: true,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(obj.length).to.be(0);
                expect(obj['01']).to.be(true);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty([], '0x1', {
                    value: true,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(obj.length).to.be(0);
                expect(obj['0x1']).to.be(true);
            }).to.not.throwException();
            /*jshint +W047 */
        });

        it('should not throw an error definining properties on functions', function () {
            expect(function () {
                var obj = utilx.Object.defineProperty(function () { return; }, 'foo', {
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be(undefined);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty(function () { return; }, 'foo', {
                    value: undefined,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be(undefined);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty(function () { return; }, 'foo', {
                    value: null,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be(null);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty(function () { return; }, 'foo', {
                    value: {},
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.eql({});
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty(function () { return; }, 'foo', {
                    value: [],
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.eql([]);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty(function () { return; }, 'foo', {
                    value: '',
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be('');
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty(function () { return; }, 'foo', {
                    value: true,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be(true);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty(function () { return; }, 'foo', {
                    value: 1,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be(1);
            }).to.not.throwException();

            expect(function () {
                var obj = utilx.Object.defineProperty(function () { return; }, 'foo', {
                    value: required.noop,
                    enumerable: true,
                    writable: true,
                    configurable: true
                });

                expect(Object.prototype.hasOwnProperty.call(obj, 'foo')).to.be.ok();
                expect(obj.foo).to.be(required.noop);
            }).to.not.throwException();
        });
    });
}());

},{"../scripts/":10}],115:[function(require,module,exports){
/*global TypeError, beforeEach, describe, it, require */

/*properties
    Number, Object, String, a, arr, be, blah, blah1, blah2, blah3, bool, call,
    constructor, eql, expect, forKeys, hasOwnProperty, isNaN, isNumber,
    isPrototypeOf, isStrictMode, isString, noop, null, num, obj, ok, charAt,
    propertyIsEnumerable, push, sort, str, throwException, to, toStringTag,
    toLocaleString, toString, undefined, utilx, valueOf, wibble, wobble, ToString
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.forKeys', function () {
        var forKeys;

        beforeEach(function () {
            /*jshint -W001 */
            forKeys = {
                'str': 'boz',
                'obj': {},
                'arr': [],
                'bool': true,
                'num': 42,
                'null': null,
                'undefined': undefined,
                'toString': required.noop,
                'toLocaleString': required.noop,
                'valueOf': required.noop,
                'hasOwnProperty': required.noop,
                'isPrototypeOf': required.noop,
                'propertyIsEnumerable': required.noop,
                'constructor': required.noop
            };
            /*jshint +W001 */
        });

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Object.forKeys();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Object.forKeys(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Object.forKeys(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is a boolean', function () {
            expect(function () {
                utilx.Object.forKeys(true);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is a string', function () {
            expect(function () {
                utilx.Object.forKeys('1');
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is a number', function () {
            expect(function () {
                utilx.Object.forKeys(1);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if function argument is not a function', function () {
            expect(function () {
                utilx.Object.forKeys(forKeys);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.forKeys(forKeys, undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.forKeys(forKeys, null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(utilx.Object.forKeys(forKeys, function (element, prop, obj) {
                expect(obj).to.be(forKeys);
                expect(utilx.String.isString(prop)).to.be.ok();
                if (required.isNaN(element)) {
                    expect(required.isNaN(forKeys[prop])).to.be(true);
                } else {
                    expect(element).to.be(forKeys[prop]);
                }

                if (prop === 'toString') {
                    return true;
                }

                return false;
            })).to.be(true);
        });

        it('should pass the right parameters', function () {
            var object = {'blah': '1'};

            utilx.Object.forKeys(object, function (item, prop, obj) {
                expect(item).to.be('1');
                expect(prop).to.be('blah');
                expect(obj).to.be(object);
            });
        });

        it('should not affect elements added to the object after it has begun', function () {
            var object = {
                    'blah': '1',
                    'wibble': '1',
                    'wobble': '1'
                },
                i = 0;

            utilx.Object.forKeys(object, function (item, prop, obj) {
                /*jslint unparam: true */
                /*jshint unused: false */
                i += 1;
                obj['blah' + i] = i;

                return i === 3;
            });

            expect(object).to.eql({
                'blah': '1',
                'wibble': '1',
                'wobble': '1',
                'blah1': 1,
                'blah2': 2,
                'blah3': 3
            });

            expect(i).to.be(3);
        });

        it('should set the right context when given none', function () {
            var context;

            utilx.Object.forKeys({'blah': '1'}, function () {
                context = this;
            });

            expect(context).to.be((function () {
                return function () {
                    return this;
                };
            }()).call());
        });

        it('should return false if it runs to the end', function () {
            var actual = utilx.Object.forKeys(forKeys, function () {
                return;
            });

            expect(actual).to.be(false);
        });

        it('should return true if it is stopped somewhere', function () {
            var actual = utilx.Object.forKeys(forKeys, function () {
                return true;
            });

            expect(actual).to.be(true);
        });

        it('should return false if there are no elements', function () {
            var actual = utilx.Object.forKeys([], function () {
                return true;
            });

            expect(actual).to.be(false);
        });

        it('should enumerate all', function () {
            var actual = {};

            utilx.Object.forKeys(forKeys, function (item, prop) {
                actual[prop] = item;
            });

            expect(actual).to.eql(forKeys);
        });

        it('should stop after 3 elements', function () {
            var numberOfRuns = 0;

            utilx.Object.forKeys(forKeys, function () {
                numberOfRuns += 1;

                return numberOfRuns === 3;
            });

            expect(numberOfRuns).to.be(3);
        });

        it('should enumerate all in string', function () {
            var count = 0,
                inner = [],
                props = [];

            utilx.Object.forKeys('foo', function (item, prop) {
                inner.push(item);
                props.push(prop);
                count += 1;
            });

            expect(props.sort()).to.eql(['0', '1', '2']);
            expect(inner.sort()).to.eql(['f', 'o', 'o']);
            expect(count).to.be(3);
        });

        it('should have a boxed object as list argument of callback', function () {
            var actual;

            utilx.Object.forKeys('foo', function (item, prop, list) {
                /*jslint unparam: true */
                /*jshint unused: true */
                actual = list;

                return true;
            });

            expect(typeof actual).to.be('object');
            expect(utilx.Object.toStringTag(actual)).to.be('[object String]');
            expect(required.ToString(actual)).to.be('foo');
            expect(actual.charAt(0)).to.be('f');
        });

        it('does not autobox the content in strict mode', function () {
            var actual;

            utilx.Object.forKeys({'blah': '1'}, function () {
                actual = this;
            }, 'x');

            expect(typeof actual).to.be(required.isStrictMode() ? 'string' : 'object');
        });
    });
}());

},{"../scripts/":10}],116:[function(require,module,exports){
/*global TypeError, describe, it, require */

/*properties
    Object, a, be, configurable, create, enumerable, expect,
    getOwnPropertyDescriptor, hasOwnProperty, hasProperty, name, not, ok,
    throwException, to, utilx, value, writable, prototype, call
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.getOwnPropertyDescriptor', function () {
        it('should return undefined because the object does not own the property', function () {
            var descr = utilx.Object.getOwnPropertyDescriptor({}, 'name');

            expect(descr).to.be(undefined);
        });

        it('should return a data descriptor', function () {
            var descr = utilx.Object.getOwnPropertyDescriptor({name: 'Testing'}, 'name');

            expect(descr).to.not.be(undefined);
            expect(descr.value).to.be('Testing');
            expect(descr.writable).to.be(true);
            expect(descr.enumerable).to.be(true);
            expect(descr.configurable).to.be(true);
        });

        it('should return undefined because the object does not own the property', function () {
            var descr = utilx.Object.getOwnPropertyDescriptor(utilx.Object.create({name: 'Testing'}, {}), 'name');

            expect(descr).to.be(undefined);
        });

        it('test Object.create hasProperty', function () {
            var obj = utilx.Object.create({name: 'Testing'}, {});

            expect(utilx.Object.hasProperty(obj, 'name')).to.be.ok();
        });

        it('test Object.create hasOwn', function () {
            var obj = utilx.Object.create({name: 'Testing'}, {});

            expect(Object.prototype.hasOwnProperty.call(obj, 'name')).to.not.be.ok();
        });

        it('should return a data descriptor', function () {
            var obj = utilx.Object.create({}, {
                    name: {
                        value: 'Testing',
                        configurable: true,
                        enumerable: true,
                        writable: true
                    }
                }),
                descr = utilx.Object.getOwnPropertyDescriptor(obj, 'name');

            expect(descr).to.not.be(undefined);
            expect(descr.value).to.be('Testing');
            expect(descr.writable).to.be(true);
            expect(descr.enumerable).to.be(true);
            expect(descr.configurable).to.be(true);
        });

        it('should throw error for undefined and null', function () {
            expect(function () {
                utilx.Object.getOwnPropertyDescriptor(undefined, 'name');
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.getOwnPropertyDescriptor(null, 'name');
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw error for other non-objects', function () {
            expect(function () {
                utilx.Object.getOwnPropertyDescriptor(42, 'name');
            }).to.not.throwException();

            expect(function () {
                utilx.Object.getOwnPropertyDescriptor(true, 'name');
            }).to.not.throwException();

            expect(function () {
                utilx.Object.getOwnPropertyDescriptor('a', 'name');
            }).to.not.throwException();
        });

        if (utilx.Object.getOwnPropertyDescriptor === Object.getOwnPropertyDescriptor) {
            it('A function\'s length should be false for all', function () {
                var lengthProp;

                expect(function () {
                    lengthProp = utilx.Object.getOwnPropertyDescriptor(function () { return; }, 'name');
                }).to.not.throwException();

                expect(lengthProp).to.not.be(null);
                expect(typeof lengthProp).to.be('object');
                expect(lengthProp.value).to.be('Testing');
                expect(lengthProp.writable).to.be(false);
                expect(lengthProp.enumerable).to.be(false);
                expect(lengthProp.configurable).to.be(false);
            });
        }
    });
}());

},{"../scripts/":10}],117:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.getPrototypeOf', function () {
        it('primitive argument should throw an TypeError in each case', function () {
            expect(function () {
                utilx.Object.getPrototypeOf();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.getPrototypeOf(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.getPrototypeOf(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('native objects should return their own prototype', function () {
            expect(utilx.Object.getPrototypeOf(1)).to.be(Number.prototype);
            expect(utilx.Object.getPrototypeOf(true)).to.be(Boolean.prototype);
            expect(utilx.Object.getPrototypeOf('')).to.be(String.prototype);
            expect(utilx.Object.getPrototypeOf([])).to.be(Array.prototype);
            expect(utilx.Object.getPrototypeOf({})).to.be(Object.prototype);
            expect(utilx.Object.getPrototypeOf(required.noop)).to.be(Function.prototype);
            expect(utilx.Object.getPrototypeOf(new RegExp('c'))).to.be(RegExp.prototype);
            expect(utilx.Object.getPrototypeOf(new Date())).to.be(Date.prototype);
            expect(utilx.Object.getPrototypeOf(new Error('x'))).to.be(Error.prototype);
        });

        it('arguments object should return Object.prototype', function () {
            expect(utilx.Object.getPrototypeOf(required.returnArgs())).to.be(Object.prototype);
        });

        it('custom error should return own prototype', function () {
            var MyError = utilx.customError('MyError');

            expect(utilx.Object.getPrototypeOf(new MyError('x'))).to.be(MyError.prototype);
        });

        it('other custom objects should return their own prototype', function () {
            function Person() {
                return;
            }

            function Employee() {
                return;
            }

            utilx.Function.inherits(Employee, Person);

            function Manager() {
                return;
            }

            utilx.Function.inherits(Manager, Employee);

            expect(utilx.Object.getPrototypeOf(new Person())).to.be(Person.prototype);
            expect(utilx.Object.getPrototypeOf(new Employee())).to.be(Employee.prototype);
            expect(utilx.Object.getPrototypeOf(new Manager())).to.be(Manager.prototype);

            function Constructor() {
                this.prototype = new Manager();
                this.constructor = Employee;
            }

            Constructor.prototype.constructor = Person;
            expect(utilx.Object.getPrototypeOf(new Constructor().prototype).constructor).to.be(Manager);
        });
    });
}());

},{"../scripts/":10}],118:[function(require,module,exports){
/*global require, describe, it */

/*properties
    Object, be, constructor, expect, hasOwnProperty, isPrototypeOf, noop, not,
    ok, propertyIsEnumerable, prototype, to, toLocaleString, toString, utilx,
    valueOf, String, returnArgs
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.hasOwnProperty', function () {
        /*jshint -W001 */
        var obj = {
                'toString': required.noop,
                'toLocaleString': required.noop,
                'valueOf': required.noop,
                'hasOwnProperty': required.noop,
                'isPrototypeOf': required.noop,
                'propertyIsEnumerable': required.noop,
                'constructor': required.noop
            },
            obj2 = {};
        /*jshint +W001 */

        it('defined on object "toString"', function () {
            expect(utilx.Object.hasOwnProperty(obj, 'toString')).to.be.ok();
        });

        it('defined on object "toLocaleString"', function () {
            expect(utilx.Object.hasOwnProperty(obj, 'toLocaleString')).to.be.ok();
        });

        it('defined on object "valueOf"', function () {
            expect(utilx.Object.hasOwnProperty(obj, 'valueOf')).to.be.ok();
        });

        it('defined on object "hasOwnProperty"', function () {
            expect(utilx.Object.hasOwnProperty(obj, 'hasOwnProperty')).to.be.ok();
        });

        it('defined on object "isPrototypeOf"', function () {
            expect(utilx.Object.hasOwnProperty(obj, 'isPrototypeOf')).to.be.ok();
        });

        it('defined on object "propertyIsEnumerable"', function () {
            expect(utilx.Object.hasOwnProperty(obj, 'propertyIsEnumerable')).to.be.ok();
        });

        it('defined on object "constructor"', function () {
            expect(utilx.Object.hasOwnProperty(obj, 'constructor')).to.be.ok();
        });

        it('properties that are not defined', function () {
            expect(utilx.Object.hasOwnProperty(obj, 'foo')).to.not.be.ok();
            expect(utilx.Object.hasOwnProperty(obj, 'bar')).to.not.be.ok();
            expect(utilx.Object.hasOwnProperty(obj, 'fuz')).to.not.be.ok();
        });

        it('not defined on object "toString"', function () {
            expect(utilx.Object.hasOwnProperty(obj2, 'toString')).to.not.be.ok();
        });

        it('not defined on object "toLocaleString"', function () {
            expect(utilx.Object.hasOwnProperty(obj2, 'toLocaleString')).to.not.be.ok();
        });

        it('not defined on object "valueOf"', function () {
            expect(utilx.Object.hasOwnProperty(obj2, 'valueOf')).to.not.be.ok();
        });

        it('not defined on object "hasOwnProperty"', function () {
            expect(utilx.Object.hasOwnProperty(obj2, 'hasOwnProperty')).to.not.be.ok();
        });

        it('not defined on object "isPrototypeOf"', function () {
            expect(utilx.Object.hasOwnProperty(obj2, 'isPrototypeOf')).to.not.be.ok();
        });

        it('not defined on object "propertyIsEnumerable"', function () {
            expect(utilx.Object.hasOwnProperty(obj2, 'propertyIsEnumerable')).to.not.be.ok();
        });

        it('not defined on object "constructor"', function () {
            expect(utilx.Object.hasOwnProperty(obj2, 'constructor')).to.not.be.ok();
        });

        it('not defined on object should be not ok in each case', function () {
            expect(utilx.Object.hasOwnProperty(obj2, 'foo')).to.not.be.ok();
            expect(utilx.Object.hasOwnProperty(obj2, 'bar')).to.not.be.ok();
            expect(utilx.Object.hasOwnProperty(obj2, 'fuz')).to.not.be.ok();
        });

        it('defined on object with "undefined" value "toString"', function () {
            expect(utilx.Object.hasOwnProperty({
                toString: undefined
            }, 'toString')).to.be.ok();
        });

        it('defined on object with "undefined" value "toLocaleString"', function () {
            expect(utilx.Object.hasOwnProperty({
                toLocaleString: undefined
            }, 'toLocaleString')).to.be.ok();
        });

        it('defined on object with "undefined" value "valueOf"', function () {
            expect(utilx.Object.hasOwnProperty({
                valueOf: undefined
            }, 'valueOf')).to.be.ok();
        });

        it('defined on object with "undefined" value "hasOwnProperty"', function () {
            /*jshint -W001 */
            expect(utilx.Object.hasOwnProperty({
                hasOwnProperty: undefined
            }, 'hasOwnProperty')).to.be.ok();
            /*jshint +W001 */
        });

        it('defined on object with "undefined" value "isPrototypeOf"', function () {
            expect(utilx.Object.hasOwnProperty({
                isPrototypeOf: undefined
            }, 'isPrototypeOf')).to.be.ok();
        });

        it('defined on object with "undefined" value "propertyIsEnumerable"', function () {
            expect(utilx.Object.hasOwnProperty({
                propertyIsEnumerable: undefined
            }, 'propertyIsEnumerable')).to.be.ok();
        });

        it('defined on object with "undefined" value "constructor"', function () {
            expect(utilx.Object.hasOwnProperty({
                constructor: undefined
            }, 'constructor')).to.be.ok();
        });

        it('string defined', function () {
            var str = 'abc';

            expect(utilx.Object.hasOwnProperty(str, '0')).to.be.ok();
            expect(utilx.Object.hasOwnProperty(str, '1')).to.be.ok();
            expect(utilx.Object.hasOwnProperty(str, '2')).to.be.ok();
        });

        it('string not-defined', function () {
            var str = 'abc';

            expect(utilx.Object.hasOwnProperty(str, '3')).to.not.be.ok();
        });

        it('string object defined', function () {
            var strObj = required.Object('abc');

            expect(utilx.Object.hasOwnProperty(strObj, '0')).to.be.ok();
            expect(utilx.Object.hasOwnProperty(strObj, '1')).to.be.ok();
            expect(utilx.Object.hasOwnProperty(strObj, '2')).to.be.ok();
        });

        it('string object not-defined', function () {
            var strObj = required.Object('abc');

            expect(utilx.Object.hasOwnProperty(strObj, '3')).to.not.be.ok();
        });

        it('arguments defined', function () {
            var args = required.returnArgs(false, undefined, null, '', 0);

            expect(utilx.Object.hasOwnProperty(args, '0')).to.be.ok();
            expect(utilx.Object.hasOwnProperty(args, '1')).to.be.ok();
            expect(utilx.Object.hasOwnProperty(args, '2')).to.be.ok();
            expect(utilx.Object.hasOwnProperty(args, '3')).to.be.ok();
            expect(utilx.Object.hasOwnProperty(args, '4')).to.be.ok();
        });

        it('arguments not-defined', function () {
            var args = required.returnArgs(false, undefined, null, '', 0);

            expect(utilx.Object.hasOwnProperty(args, '5')).to.not.be.ok();
        });

        it('should not list prototype or constructor', function () {
            function Constructor() {
                this.constructor = this.prototype = 1;
            }

            Constructor.prototype.constructor = 1;
            expect(utilx.Object.hasOwnProperty(Constructor, 'constructor')).to.not.be.ok();
        });

        it('should list prototype and constructor', function () {
            function Constructor() {
                this.constructor = this.prototype = 1;
            }

            Constructor.prototype.constructor = 1;
            expect(utilx.Object.hasOwnProperty(Constructor, 'prototype')).to.be.ok();
            expect(utilx.Object.hasOwnProperty(Constructor.prototype, 'constructor')).to.be.ok();
            expect(utilx.Object.hasOwnProperty(new Constructor(), 'prototype')).to.be.ok();
            expect(utilx.Object.hasOwnProperty(new Constructor(), 'constructor')).to.be.ok();
        });
    });
}());

},{"../scripts/":10}],119:[function(require,module,exports){
/*global require, describe, it */

/*properties
    Object, String, bar, be, expect, foo, hasProperty, not, ok, returnArgs, to, utilx, getPrototypeOf
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.hasProperty', function () {
        it('object, enumerable bugged properties', function () {
            var testObj = [];

            expect(utilx.Object.hasProperty(testObj, 'toString')).to.be.ok();
            expect(utilx.Object.hasProperty(testObj, 'toLocaleString')).to.be.ok();
            expect(utilx.Object.hasProperty(testObj, 'valueOf')).to.be.ok();
            expect(utilx.Object.hasProperty(testObj, 'hasOwnProperty')).to.be.ok();
            expect(utilx.Object.hasProperty(testObj, 'isPrototypeOf')).to.be.ok();
            expect(utilx.Object.hasProperty(testObj, 'propertyIsEnumerable')).to.be.ok();
            expect(utilx.Object.hasProperty(testObj, 'constructor')).to.be.ok();
        });

        it('array, enumerable bugged properties', function () {
            var testArr = [];

            expect(utilx.Object.hasProperty(testArr, 'toString')).to.be.ok();
            expect(utilx.Object.hasProperty(testArr, 'toLocaleString')).to.be.ok();
            expect(utilx.Object.hasProperty(testArr, 'valueOf')).to.be.ok();
            expect(utilx.Object.hasProperty(testArr, 'hasOwnProperty')).to.be.ok();
            expect(utilx.Object.hasProperty(testArr, 'isPrototypeOf')).to.be.ok();
            expect(utilx.Object.hasProperty(testArr, 'propertyIsEnumerable')).to.be.ok();
            expect(utilx.Object.hasProperty(testArr, 'constructor')).to.be.ok();
        });

        it('function prototype property', function () {
            expect(utilx.Object.hasProperty(function () { return; }, 'prototype')).to.be.ok();
        });

        it('string index, literal and object', function () {
            var testStr = 'abc',
                testObj = required.Object(testStr);

            expect(utilx.Object.hasProperty(testStr, 0)).to.be.ok();
            expect(utilx.Object.hasProperty(testStr, 3)).to.not.be.ok();
            expect(utilx.Object.hasProperty(testObj, 0)).to.be.ok();
            expect(utilx.Object.hasProperty(testObj, 3)).to.not.be.ok();
        });

        it('array index', function () {
            var testArr = ['a', 'b', 'c'];

            expect(utilx.Object.hasProperty(testArr, 0)).to.be.ok();
            expect(utilx.Object.hasProperty(testArr, 3)).to.not.be.ok();
        });

        it('arguments index', function () {
            var testArg = required.returnArgs('a', 'b', 'c');

            expect(utilx.Object.hasProperty(testArg, 0)).to.be.ok();
            expect(utilx.Object.hasProperty(testArg, 3)).to.not.be.ok();
        });

        it('array prototype methods', function () {
            var testArr = [];

            expect(utilx.Object.hasProperty(testArr, 'push')).to.be.ok();
            expect(utilx.Object.hasProperty(testArr, 'pop')).to.be.ok();
            expect(utilx.Object.hasProperty(testArr, 'foo')).to.not.be.ok();
            expect(utilx.Object.hasProperty(testArr, 'bar')).to.not.be.ok();
            expect(utilx.Object.hasProperty(testArr, 'fuz')).to.not.be.ok();
        });

        it('object direct properties', function () {
            var testObj = {
                foo: undefined,
                bar: null
            };

            if (testObj.getPrototypeOf) {
                expect(utilx.Object.hasProperty(testObj, 'getPrototypeOf')).to.be.ok();
            }

            expect(utilx.Object.hasProperty(testObj, 'foo')).to.be.ok();
            expect(utilx.Object.hasProperty(testObj, 'bar')).to.be.ok();
            expect(utilx.Object.hasProperty(testObj, 'fuz')).to.not.be.ok();
        });
    });
}());

},{"../scripts/":10}],120:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.instanceOf', function () {
        it('argument that is not a constructor should throw TypeError in each case', function () {
            expect(function () {
                utilx.Object.instanceOf();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.instanceOf(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.instanceOf(undefined, undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.instanceOf(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.instanceOf(null, null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.instanceOf(1, 1);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.instanceOf(true, true);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.instanceOf('x', 'x');
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.instanceOf([], []);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.instanceOf({}, {});
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('primitives should be false in each case', function () {
            expect(utilx.Object.instanceOf(undefined, Object)).to.not.be.ok();
            expect(utilx.Object.instanceOf(null, Object)).to.not.be.ok();
            expect(utilx.Object.instanceOf(1, Number)).to.not.be.ok();
            expect(utilx.Object.instanceOf('', String)).to.not.be.ok();
            expect(utilx.Object.instanceOf(true, Boolean)).to.not.be.ok();
            expect(utilx.Object.instanceOf(false, Boolean)).to.not.be.ok();
        });

        it('native objects should be true in each case', function () {
            expect(utilx.Object.instanceOf({}, Object)).to.be.ok();
            expect(utilx.Object.instanceOf(required.noop, Function)).to.be.ok();
            expect(utilx.Object.instanceOf(new RegExp('c'), RegExp)).to.be.ok();
            expect(utilx.Object.instanceOf(new Date(), Date)).to.be.ok();
            expect(utilx.Object.instanceOf(new Error('x'), Error)).to.be.ok();
        });

        it('arguments object should be an instance of Object', function () {
            expect(utilx.Object.instanceOf(required.returnArgs(), Object)).to.be.ok();
        });

        it('custom error should be an instance of MyError, Error and Object', function () {
            var MyError = utilx.customError('MyError');

            expect(utilx.Object.instanceOf(new MyError('x'), MyError)).to.be.ok();
            expect(utilx.Object.instanceOf(new MyError('x'), Error)).to.be.ok();
            expect(utilx.Object.instanceOf(new MyError('x'), Object)).to.be.ok();
        });

        it('other custom objects should be an instance of their own constructor and parents', function () {
            function Person() {
                return;
            }

            function Employee() {
                return;
            }

            utilx.Function.inherits(Employee, Person);

            function Manager() {
                return;
            }

            utilx.Function.inherits(Manager, Employee);

            expect(utilx.Object.instanceOf(new Person(), Person)).to.be.ok();
            expect(utilx.Object.instanceOf(new Person(), Object)).to.be.ok();
            expect(utilx.Object.instanceOf(new Employee(), Employee)).to.be.ok();
            expect(utilx.Object.instanceOf(new Employee(), Person)).to.be.ok();
            expect(utilx.Object.instanceOf(new Employee(), Object)).to.be.ok();
            expect(utilx.Object.instanceOf(new Manager(), Manager)).to.be.ok();
            expect(utilx.Object.instanceOf(new Manager(), Employee)).to.be.ok();
            expect(utilx.Object.instanceOf(new Manager(), Person)).to.be.ok();
            expect(utilx.Object.instanceOf(new Manager(), Object)).to.be.ok();
        });
    });
}());

},{"../scripts/":10}],121:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.is', function () {
        var date = new Date(),
            rx = new RegExp('x'),
            err = new Error('y');

        it('should not throw an error in each case', function () {
            expect(utilx.Object.is(undefined, undefined)).to.be.ok();
            expect(utilx.Object.is(null, null)).to.be.ok();
            expect(utilx.Object.is(1, 1)).to.be.ok();
            expect(utilx.Object.is(true, true)).to.be.ok();
            expect(utilx.Object.is('x', 'x')).to.be.ok();
            expect(utilx.Object.is([1, 2, 3], [1, 2, 3])).to.not.be.ok();
            expect(utilx.Object.is(required.returnArgs(), required.returnArgs())).to.not.be.ok();
            expect(utilx.Object.is({}, {}), false, 'Object.is');
            expect(utilx.Object.is(required.noop, required.noop)).to.be.ok();
            expect(utilx.Object.is(new RegExp('c'), new RegExp('c'))).to.not.be.ok();
            expect(utilx.Object.is(new Date(2013, 11, 23), new Date(2013, 11, 23))).to.not.be.ok();
            expect(utilx.Object.is(new Error('x'), new Error('x'))).to.not.be.ok();
            expect(utilx.Object.is(date, date)).to.be.ok();
            expect(utilx.Object.is(rx, rx)).to.be.ok();
            expect(utilx.Object.is(err, err)).to.be.ok();
            expect(utilx.Object.is(NaN, NaN)).to.be.ok();
            expect(utilx.Object.is(0, -0)).to.not.be.ok();
            expect(utilx.Object.is(0, 0)).to.be.ok();
            expect(utilx.Object.is(0, +0)).to.be.ok();
        });
    });
}());

},{"../scripts/":10}],122:[function(require,module,exports){
/*global Date, Error, RegExp, describe, it, require */

/*properties
    Object, be, expect, isArguments, noop, not, ok, returnArgs, to, utilx, frame, Arg
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.isArguments', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Object.isArguments()).to.not.be.ok();
            expect(utilx.Object.isArguments(undefined)).to.not.be.ok();
            expect(utilx.Object.isArguments(null)).to.not.be.ok();
            expect(utilx.Object.isArguments(1)).to.not.be.ok();
            expect(utilx.Object.isArguments(true)).to.not.be.ok();
            expect(utilx.Object.isArguments('')).to.not.be.ok();
            expect(utilx.Object.isArguments(new Error('x'))).to.not.be.ok();
            expect(utilx.Object.isArguments(new Date())).to.not.be.ok();
            expect(utilx.Object.isArguments(new RegExp('x'))).to.not.be.ok();
            expect(utilx.Object.isArguments(required.noop)).to.not.be.ok();
            expect(utilx.Object.isArguments([])).to.not.be.ok();
            expect(utilx.Object.isArguments({})).to.not.be.ok();
            expect(utilx.Object.isArguments(required.returnArgs())).to.be.ok();
        });

        if (required.frame) {
            it('should work accross frames', function () {
                expect(utilx.Object.isArguments(required.frame.Arg)).to.be.ok();
            });
        }
    });
}());

},{"../scripts/":10}],123:[function(require,module,exports){
/*global Date, describe, it, require */

/*properties
    Object, b, c, be, expect, isCircular, not, ok, to, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.isCircular', function () {
        it('are not circular', function () {
            expect(utilx.Object.isCircular()).to.not.be.ok();
            expect(utilx.Object.isCircular(undefined)).to.not.be.ok();
            expect(utilx.Object.isCircular(null)).to.not.be.ok();
            expect(utilx.Object.isCircular(1)).to.not.be.ok();
            expect(utilx.Object.isCircular('a')).to.not.be.ok();
            expect(utilx.Object.isCircular(true)).to.not.be.ok();
            expect(utilx.Object.isCircular([])).to.not.be.ok();
            expect(utilx.Object.isCircular({})).to.not.be.ok();
        });

        it('are circular', function () {
            var a = [],
                b = {},
                c = new Date();

            a[0] = a;
            b.b = b;
            c.c = c;

            expect(utilx.Object.isCircular(a)).to.be.ok();
            expect(utilx.Object.isCircular(b)).to.be.ok();
            expect(utilx.Object.isCircular(c)).to.be.ok();
        });
    });
}());

},{"../scripts/":10}],124:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.isNil', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Object.isNil()).to.be.ok();
            expect(utilx.Object.isNil(null)).to.be.ok();
            expect(utilx.Object.isNil(undefined)).to.be.ok();
            expect(utilx.Object.isNil('undefined')).to.not.be.ok();
            expect(utilx.Object.isNil('null')).to.not.be.ok();
            expect(utilx.Object.isNil(0)).to.not.be.ok();
            expect(utilx.Object.isNil(1)).to.not.be.ok();
            expect(utilx.Object.isNil('')).to.not.be.ok();
            expect(utilx.Object.isNil([])).to.not.be.ok();
            expect(utilx.Object.isNil({})).to.not.be.ok();
        });
    });
}());

},{"../scripts/":10}],125:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.isNull', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Object.isNull()).to.not.be.ok();
            expect(utilx.Object.isNull(null)).to.be.ok();
            expect(utilx.Object.isNull(undefined)).to.not.be.ok();
            expect(utilx.Object.isNull('undefined')).to.not.be.ok();
            expect(utilx.Object.isNull('null')).to.not.be.ok();
            expect(utilx.Object.isNull(0)).to.not.be.ok();
            expect(utilx.Object.isNull(1)).to.not.be.ok();
            expect(utilx.Object.isNull('')).to.not.be.ok();
            expect(utilx.Object.isNull([])).to.not.be.ok();
            expect(utilx.Object.isNull({})).to.not.be.ok();
        });
    });
}());

},{"../scripts/":10}],126:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.isNumeric - Integer Literals', function () {
        it('should not throw an error in each case', function () {
            // Negative integer string
            expect(utilx.Object.isNumeric('-10')).to.be.ok();
            // Zero string
            expect(utilx.Object.isNumeric('0')).to.be.ok();
            // Positive integer string
            expect(utilx.Object.isNumeric('5')).to.be.ok();
            // Negative integer number
            expect(utilx.Object.isNumeric(-16)).to.be.ok();
            // Zero integer number
            expect(utilx.Object.isNumeric(0)).to.be.ok();
            // Positive integer number
            expect(utilx.Object.isNumeric(32)).to.be.ok();
            // Octal integer literal string
            expect(utilx.Object.isNumeric('040')).to.be.ok();
            //t.ok(utilx.Object.isNumeric(0144), 'Octal integer literal');
            // Negative Octal integer literal string
            expect(utilx.Object.isNumeric('-040')).to.be.ok();
            //t.ok(utilx.Object.isNumeric(-0144), 'Negative Octal integer literal');
            // Hexadecimal integer literal string
            expect(utilx.Object.isNumeric('0xFF')).to.be.ok();
            // Hexadecimal integer literal
            expect(utilx.Object.isNumeric(0xFFF)).to.be.ok();
            // Negative Hexadecimal integer literal string
            expect(utilx.Object.isNumeric('-0xFF')).to.be.ok();
            // Negative Hexadecimal integer literal
            expect(utilx.Object.isNumeric(-0xFFF)).to.be.ok();
        });
    });

    describe('Object.isNumeric - Foating-Point Literals', function () {
        it('should not throw an error in each case', function () {
            // Negative floating point string
            expect(utilx.Object.isNumeric('-1.6')).to.be.ok();
            // Positive floating point string
            expect(utilx.Object.isNumeric('4.536')).to.be.ok();
            // Negative floating point number
            expect(utilx.Object.isNumeric(-2.6)).to.be.ok();
            // Positive floating point number
            expect(utilx.Object.isNumeric(3.1415)).to.be.ok();
            // Exponential notation
            expect(utilx.Object.isNumeric(8e5)).to.be.ok();
            // Exponential notation string
            expect(utilx.Object.isNumeric('123e-2')).to.be.ok();
        });
    });

    describe('Object.isNumeric - Non-Numeric values', function () {
        it('should not throw an error in each case', function () {
            // Empty string
            expect(utilx.Object.isNumeric('')).to.not.be.ok();
            // Whitespace characters string
            expect(utilx.Object.isNumeric('        ')).to.not.be.ok();
            // Tab characters string
            expect(utilx.Object.isNumeric('\t\t')).to.not.be.ok();
            // Alphanumeric character string
            expect(utilx.Object.isNumeric('abcdefghijklm1234567890')).to.not.be.ok();
            // Non-numeric character string
            expect(utilx.Object.isNumeric('xabcdefx')).to.not.be.ok();
            // Boolean true literal
            expect(utilx.Object.isNumeric(true)).to.not.be.ok();
            // Boolean false literal
            expect(utilx.Object.isNumeric(false)).to.not.be.ok();
            // Number with preceding non-numeric characters
            expect(utilx.Object.isNumeric('bcfed5.2')).to.not.be.ok();
            // Number with trailling non-numeric characters
            expect(utilx.Object.isNumeric('7.2acdgs')).to.not.be.ok();
            // Undefined value
            expect(utilx.Object.isNumeric(undefined)).to.not.be.ok();
            // Null value
            expect(utilx.Object.isNumeric(null)).to.not.be.ok();
            // NaN value
            expect(utilx.Object.isNumeric(NaN)).to.not.be.ok();
            // Infinity primitive
            expect(utilx.Object.isNumeric(Infinity)).to.not.be.ok();
            // Negative Infinity
            expect(utilx.Object.isNumeric(-Infinity)).to.not.be.ok();
            // Date object
            expect(utilx.Object.isNumeric(new Date(2009, 1, 1))).to.not.be.ok();
            // Empty object
            expect(utilx.Object.isNumeric({})).to.not.be.ok();
            // Instance of a function
            expect(utilx.Object.isNumeric(required.noop)).to.not.be.ok();
            // Empty Array
            expect(utilx.Object.isNumeric([])).to.not.be.ok();
            // Array Negative integer string
            expect(utilx.Object.isNumeric(['-10'])).to.not.be.ok();
            // Array Zero string
            expect(utilx.Object.isNumeric(['0'])).to.not.be.ok();
            // Array Positive integer string
            expect(utilx.Object.isNumeric(['5'])).to.not.be.ok();
            // Array Negative integer number
            expect(utilx.Object.isNumeric([-16])).to.not.be.ok();
            // Array Zero integer number
            expect(utilx.Object.isNumeric([0])).to.not.be.ok();
            // Array Positive integer number
            expect(utilx.Object.isNumeric([32])).to.not.be.ok();
            // Array Octal integer literal string
            expect(utilx.Object.isNumeric(['040'])).to.not.be.ok();
            // Array Negative Octal integer literal string
            expect(utilx.Object.isNumeric(['-040'])).to.not.be.ok();
            // Array Hexadecimal integer literal string
            expect(utilx.Object.isNumeric(['0xFF'])).to.not.be.ok();
            // Array Hexadecimal integer literal
            expect(utilx.Object.isNumeric([0xFFF])).to.not.be.ok();
            // Array Negative Hexadecimal integer literal string
            expect(utilx.Object.isNumeric(['-0xFF'])).to.not.be.ok();
            // Array Negative Hexadecimal integer literal
            expect(utilx.Object.isNumeric([-0xFFF])).to.not.be.ok();
            // Array with more than 1 Positive interger number
            expect(utilx.Object.isNumeric([1, 2])).to.not.be.ok();
            // Array with more than 1 Negative interger number
            expect(utilx.Object.isNumeric([-1, -2])).to.not.be.ok();
            // Functions that could be considered numbers
            expect(utilx.Object.isNumeric({
                toString: function () {
                    return '1.2';
                }
            })).to.not.be.ok();
        });
    });
}());

},{"../scripts/":10}],127:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    function F() {
        return;
    }

    describe('Object.isPlainObject', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Object.isPlainObject()).to.not.be.ok();
            expect(utilx.Object.isPlainObject(undefined)).to.not.be.ok();
            expect(utilx.Object.isPlainObject(null)).to.not.be.ok();
            expect(utilx.Object.isPlainObject(1)).to.not.be.ok();
            expect(utilx.Object.isPlainObject(true)).to.not.be.ok();
            expect(utilx.Object.isPlainObject('')).to.not.be.ok();
            expect(utilx.Object.isPlainObject(new Error('x'))).to.not.be.ok();
            expect(utilx.Object.isPlainObject(new Date())).to.not.be.ok();
            expect(utilx.Object.isPlainObject(new RegExp('x'))).to.not.be.ok();
            expect(utilx.Object.isPlainObject(required.noop)).to.not.be.ok();
            expect(utilx.Object.isPlainObject([])).to.not.be.ok();
            expect(utilx.Object.isPlainObject({})).to.be.ok();
            expect(utilx.Object.isPlainObject(new F())).to.not.be.ok();
            expect(utilx.Object.isPlainObject(required.returnArgs())).to.not.be.ok();
        });
    });
}());

},{"../scripts/":10}],128:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.isPrimitive', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Object.isPrimitive()).to.be.ok();
            expect(utilx.Object.isPrimitive(null)).to.be.ok();
            expect(utilx.Object.isPrimitive('')).to.be.ok();
            expect(utilx.Object.isPrimitive(1)).to.be.ok();
            expect(utilx.Object.isPrimitive(false)).to.be.ok();
            expect(utilx.Object.isPrimitive({})).to.not.be.ok();
            expect(utilx.Object.isPrimitive([])).to.not.be.ok();
        });
    });
}());

},{"../scripts/":10}],129:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.isUndefined', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Object.isUndefined()).to.be.ok();
            expect(utilx.Object.isUndefined(null)).to.not.be.ok();
            expect(utilx.Object.isUndefined(undefined)).to.be.ok();
            expect(utilx.Object.isUndefined('undefined')).to.not.be.ok();
            expect(utilx.Object.isUndefined('null')).to.not.be.ok();
            expect(utilx.Object.isUndefined(0)).to.not.be.ok();
            expect(utilx.Object.isUndefined(1)).to.not.be.ok();
            expect(utilx.Object.isUndefined('')).to.not.be.ok();
            expect(utilx.Object.isUndefined([])).to.not.be.ok();
            expect(utilx.Object.isUndefined({})).to.not.be.ok();
        });
    });
}());

},{"../scripts/":10}],130:[function(require,module,exports){
/*global Boolean, Date, Error, EvalError, Function, Number, Object, RangeError,
    ReferenceError, RegExp, String, SyntaxError, TypeError, URIError, describe,
    it, require
*/

/*properties
    Array, Object, a, arr, be, bool, constructor, eql, expect, forEach,
    hasOwnProperty, indexOf, isArray, isPrototypeOf, keys, length, noop, not,
    null, num, obj, ok, propertyIsEnumerable, prototype, returnArgs, sort, str,
    throwException, to, toLocaleString, toString, undefined, utilx, valueOf,
    Object, call
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.keys', function () {
        /*jshint -W001 */
        var loopedValues = [
                'str',
                'obj',
                'arr',
                'bool',
                'num',
                'null',
                'undefined',
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ],
            obj = {
                'str': 'boz',
                'obj': {},
                'arr': [],
                'bool': true,
                'num': 42,
                'null': null,
                'undefined': undefined,
                'toString': required.noop,
                'toLocaleString': required.noop,
                'valueOf': required.noop,
                'hasOwnProperty': required.noop,
                'isPrototypeOf': required.noop,
                'propertyIsEnumerable': required.noop,
                'constructor': required.noop
            },
            keys = utilx.Object.keys(obj),
            loopedValues2 = [
                'str',
                'obj',
                'arr',
                'bool',
                'num',
                'null',
                'undefined'
            ],
            obj2 = {
                'str': 'boz',
                'obj': {},
                'arr': [],
                'bool': true,
                'num': 42,
                'null': null,
                'undefined': undefined
            },
            keys2 = utilx.Object.keys(obj2);
            /*jshint +W001 */

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.Object.keys();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.Object.keys(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.Object.keys(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an TypeError if argument is primitive', function () {
            var primKeys;

            expect(function () {
                primKeys = utilx.Object.keys(42);
            }).to.not.throwException();

            expect(primKeys.length).to.be(0);

            expect(function () {
                primKeys = utilx.Object.keys(true);
            }).to.not.throwException();

            expect(primKeys.length).to.be(0);

            expect(function () {
                primKeys = utilx.Object.keys('abc');
            }).to.not.throwException();

            expect(primKeys.length).to.be(3);
        });

        it('should not throw an error in each case', function () {
            expect(keys.length).to.be(14);
            expect(required.isArray(keys)).to.be.ok();
            required.forEach(keys, function (name) {
                expect(Object.prototype.hasOwnProperty.call(obj, name)).to.be.ok();
            });

            required.forEach(keys, function (name) {
                // should return names which are enumerable
                expect(required.indexOf(loopedValues, name)).not.to.be(-1);
            });

            expect(keys2.length).to.be(7);
            expect(required.isArray(keys2)).to.be.ok();
            required.forEach(keys2, function (name) {
                expect(Object.prototype.hasOwnProperty.call(obj, name)).to.be.ok();
            });

            required.forEach(keys2, function (name) {
                // should return names which are enumerable
                expect(required.indexOf(loopedValues2, name)).not.to.be(-1);
            });
        });

        it('should work with arguments object', function () {
            var testValue = [0, 1],
                theArgs = required.returnArgs(1, 2),
                theKeys;

            expect(function () {
                theKeys = utilx.Object.keys(theArgs);
            }).to.not.throwException();

            expect(theKeys.length).to.be(2);
            expect(theKeys).to.eql(testValue);
        });

        it('should work with string object', function () {
            var testValue = ['0', '1', '2'],
                theObj = required.Object('hej'),
                theKeys;

            expect(function () {
                theKeys = utilx.Object.keys(theObj);
            }).to.not.throwException();

            expect(theKeys).to.eql(testValue);
            expect(theKeys.length).to.be(3);
        });

        it('Constructor should not list prototype or constructor', function () {
            var pKeys;

            function Constructor() {
                this.constructor = this.prototype = 1;
            }

            Constructor.prototype.constructor = 1;

            expect(function () {
                pKeys = utilx.Object.keys(Constructor);
            }).to.not.throwException();

            expect(pKeys).to.eql([]);
        });

        it('Constructor prototype should not list constructor', function () {
            var pKeys;

            function Constructor() {
                this.constructor = this.prototype = 1;
            }

            Constructor.prototype.constructor = 1;

            expect(function () {
                pKeys = utilx.Object.keys(Constructor.prototype);
            }).to.not.throwException();

            expect(pKeys).to.eql([]);
        });

        it('should list prototype and constructor', function () {
            var pKeys;

            function Constructor() {
                this.constructor = this.prototype = 1;
            }

            Constructor.prototype.constructor = 1;

            expect(function () {
                pKeys = utilx.Object.keys(new Constructor());
            }).to.not.throwException();

            expect(pKeys.sort()).to.eql(['constructor', 'prototype']);
        });

        it('Object prototype should not list', function () {
            var pKeys;

            expect(function () {
                pKeys = utilx.Object.keys(Object.prototype);
            }).to.not.throwException(function (e) {
                expect(e).to.be(undefined);
            });

            expect(pKeys).to.eql([]);
        });

        it('Function prototype should not list', function () {
            var pKeys;

            expect(function () {
                pKeys = utilx.Object.keys(Function.prototype);
            }).to.not.throwException(function (e) {
                expect(e).to.be(undefined);
            });

            expect(pKeys).to.eql([]);
        });

        it('Boolean prototype should not list', function () {
            var pKeys;

            expect(function () {
                pKeys = utilx.Object.keys(Boolean.prototype);
            }).to.not.throwException(function (e) {
                expect(e).to.be(undefined);
            });

            expect(pKeys).to.eql([]);
        });

        it('String prototype should not list', function () {
            var pKeys;

            expect(function () {
                pKeys = utilx.Object.keys(String.prototype);
            }).to.not.throwException();

            expect(pKeys).to.eql([]);
        });

        it('Number prototype should not list', function () {
            var pKeys;

            expect(function () {
                pKeys = utilx.Object.keys(Number.prototype);
            }).to.not.throwException();

            expect(pKeys).to.eql([]);
        });

        it('Error prototype should not list', function () {
            var pKeys;

            expect(function () {
                pKeys = utilx.Object.keys(Error.prototype);
            }).to.not.throwException();

            expect(pKeys).to.eql([]);
        });

        it('TypeError prototype should not list', function () {
            var pKeys;

            expect(function () {
                pKeys = utilx.Object.keys(TypeError.prototype);
            }).to.not.throwException();

            expect(pKeys).to.eql([]);
        });

        it('SyntaxError prototype should not list', function () {
            var pKeys;

            expect(function () {
                pKeys = utilx.Object.keys(SyntaxError.prototype);
            }).to.not.throwException();

            expect(pKeys).to.eql([]);
        });

        it('RangeError prototype should not list', function () {
            var pKeys;

            expect(function () {
                pKeys = utilx.Object.keys(RangeError.prototype);
            }).to.not.throwException();

            expect(pKeys).to.eql([]);
        });

        it('EvalError prototype should not list', function () {
            var pKeys;

            expect(function () {
                pKeys = utilx.Object.keys(EvalError.prototype);
            }).to.not.throwException();

            expect(pKeys).to.eql([]);
        });

        it('URIError prototype should not list', function () {
            var pKeys;

            expect(function () {
                pKeys = utilx.Object.keys(URIError.prototype);
            }).to.not.throwException();

            expect(pKeys).to.eql([]);
        });

        it('ReferenceError prototypes should not list', function () {
            var pKeys;

            expect(function () {
                pKeys = utilx.Object.keys(ReferenceError.prototype);
            }).to.not.throwException();

            expect(pKeys).to.eql([]);
        });

        it('Date prototype should not list', function () {
            var pKeys;

            expect(function () {
                pKeys = utilx.Object.keys(Date.prototype);
            }).to.not.throwException();

            expect(pKeys).to.eql([]);
        });

        it('RegExp prototype should not list', function () {
            var pKeys;

            expect(function () {
                pKeys = utilx.Object.keys(RegExp.prototype);
            }).to.not.throwException();

            expect(pKeys).to.eql([]);
        });

        it('should not enumerate over non-enumerable properties', function () {
            var Foo = function () { return; },
                pKeys;

            expect(function () {
                pKeys = utilx.Object.keys(Foo.prototype);
            }).to.not.throwException();

            expect(pKeys).to.eql([]);
        });
    });
}());

},{"../scripts/":10}],131:[function(require,module,exports){
/*global require, describe, it */

/*properties
    Object, be, constructor, expect, propertyIsEnumerable, isPrototypeOf, noop, not,
    ok, propertyIsEnumerable, prototype, to, toLocaleString, toString, utilx,
    valueOf, String, returnArgs, hasOwnProperty
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.propertyIsEnumerable', function () {
        /*jshint -W001 */
        var obj = {
                'toString': required.noop,
                'toLocaleString': required.noop,
                'valueOf': required.noop,
                'hasOwnProperty': required.noop,
                'isPrototypeOf': required.noop,
                'propertyIsEnumerable': required.noop,
                'constructor': required.noop
            },
            obj2 = {};
        /*jshint +W001 */

        it('defined on object "toString"', function () {
            expect(utilx.Object.propertyIsEnumerable(obj, 'toString')).to.be.ok();
        });

        it('defined on object "toLocaleString"', function () {
            expect(utilx.Object.propertyIsEnumerable(obj, 'toLocaleString')).to.be.ok();
        });

        it('defined on object "valueOf"', function () {
            expect(utilx.Object.propertyIsEnumerable(obj, 'valueOf')).to.be.ok();
        });

        it('defined on object "propertyIsEnumerable"', function () {
            expect(utilx.Object.propertyIsEnumerable(obj, 'propertyIsEnumerable')).to.be.ok();
        });

        it('defined on object "isPrototypeOf"', function () {
            expect(utilx.Object.propertyIsEnumerable(obj, 'isPrototypeOf')).to.be.ok();
        });

        it('defined on object "propertyIsEnumerable"', function () {
            expect(utilx.Object.propertyIsEnumerable(obj, 'propertyIsEnumerable')).to.be.ok();
        });

        it('defined on object "constructor"', function () {
            expect(utilx.Object.propertyIsEnumerable(obj, 'constructor')).to.be.ok();
        });

        it('properties that are not defined', function () {
            expect(utilx.Object.propertyIsEnumerable(obj, 'foo')).to.not.be.ok();
            expect(utilx.Object.propertyIsEnumerable(obj, 'bar')).to.not.be.ok();
            expect(utilx.Object.propertyIsEnumerable(obj, 'fuz')).to.not.be.ok();
        });

        it('Object.prototype "toString"', function () {
            expect(utilx.Object.propertyIsEnumerable(Object.prototype, 'toString')).to.not.be.ok();
        });

        it('Object.prototype "toLocaleString"', function () {
            expect(utilx.Object.propertyIsEnumerable(Object.prototype, 'toLocaleString')).to.not.be.ok();
        });

        it('Object.prototype "valueOf"', function () {
            expect(utilx.Object.propertyIsEnumerable(Object.prototype, 'valueOf')).to.not.be.ok();
        });

        it('Object.prototype "propertyIsEnumerable"', function () {
            expect(utilx.Object.propertyIsEnumerable(Object.prototype, 'propertyIsEnumerable')).to.not.be.ok();
        });

        it('Object.prototype "isPrototypeOf"', function () {
            expect(utilx.Object.propertyIsEnumerable(Object.prototype, 'isPrototypeOf')).to.not.be.ok();
        });

        it('Object.prototype "propertyIsEnumerable"', function () {
            expect(utilx.Object.propertyIsEnumerable(Object.prototype, 'propertyIsEnumerable')).to.not.be.ok();
        });

        it('Object.prototype "constructor"', function () {
            expect(utilx.Object.propertyIsEnumerable(Object.prototype, 'constructor')).to.not.be.ok();
        });

        it('Object.prototype not defined', function () {
            expect(utilx.Object.propertyIsEnumerable(Object.prototype, 'foo')).to.not.be.ok();
            expect(utilx.Object.propertyIsEnumerable(Object.prototype, 'bar')).to.not.be.ok();
            expect(utilx.Object.propertyIsEnumerable(Object.prototype, 'fuz')).to.not.be.ok();
        });

        it('not defined on object "toString"', function () {
            expect(utilx.Object.propertyIsEnumerable(obj2, 'toString')).to.not.be.ok();
        });

        it('not defined on object "toLocaleString"', function () {
            expect(utilx.Object.propertyIsEnumerable(obj2, 'toLocaleString')).to.not.be.ok();
        });

        it('not defined on object "valueOf"', function () {
            expect(utilx.Object.propertyIsEnumerable(obj2, 'valueOf')).to.not.be.ok();
        });

        it('not defined on object "propertyIsEnumerable"', function () {
            expect(utilx.Object.propertyIsEnumerable(obj2, 'propertyIsEnumerable')).to.not.be.ok();
        });

        it('not defined on object "isPrototypeOf"', function () {
            expect(utilx.Object.propertyIsEnumerable(obj2, 'isPrototypeOf')).to.not.be.ok();
        });

        it('not defined on object "propertyIsEnumerable"', function () {
            expect(utilx.Object.propertyIsEnumerable(obj2, 'propertyIsEnumerable')).to.not.be.ok();
        });

        it('not defined on object "constructor"', function () {
            expect(utilx.Object.propertyIsEnumerable(obj2, 'constructor')).to.not.be.ok();
        });

        it('not defined on object should be not ok in each case', function () {
            expect(utilx.Object.propertyIsEnumerable(obj2, 'foo')).to.not.be.ok();
            expect(utilx.Object.propertyIsEnumerable(obj2, 'bar')).to.not.be.ok();
            expect(utilx.Object.propertyIsEnumerable(obj2, 'fuz')).to.not.be.ok();
        });

        it('defined on object with "undefined" value "toString"', function () {
            expect(utilx.Object.propertyIsEnumerable({
                toString: undefined
            }, 'toString')).to.be.ok();
        });

        it('defined on object with "undefined" value "toLocaleString"', function () {
            expect(utilx.Object.propertyIsEnumerable({
                toLocaleString: undefined
            }, 'toLocaleString')).to.be.ok();
        });

        it('defined on object with "undefined" value "valueOf"', function () {
            expect(utilx.Object.propertyIsEnumerable({
                valueOf: undefined
            }, 'valueOf')).to.be.ok();
        });

        it('defined on object with "undefined" value "propertyIsEnumerable"', function () {
            /*jshint -W001 */
            expect(utilx.Object.propertyIsEnumerable({
                propertyIsEnumerable: undefined
            }, 'propertyIsEnumerable')).to.be.ok();
            /*jshint +W001 */
        });

        it('defined on object with "undefined" value "isPrototypeOf"', function () {
            expect(utilx.Object.propertyIsEnumerable({
                isPrototypeOf: undefined
            }, 'isPrototypeOf')).to.be.ok();
        });

        it('defined on object with "undefined" value "propertyIsEnumerable"', function () {
            expect(utilx.Object.propertyIsEnumerable({
                propertyIsEnumerable: undefined
            }, 'propertyIsEnumerable')).to.be.ok();
        });

        it('defined on object with "undefined" value "constructor"', function () {
            expect(utilx.Object.propertyIsEnumerable({
                constructor: undefined
            }, 'constructor')).to.be.ok();
        });

        it('string defined', function () {
            var str = 'abc';

            expect(utilx.Object.propertyIsEnumerable(str, '0')).to.be.ok();
            expect(utilx.Object.propertyIsEnumerable(str, '1')).to.be.ok();
            expect(utilx.Object.propertyIsEnumerable(str, '2')).to.be.ok();
        });

        it('string not-defined', function () {
            var str = 'abc';

            expect(utilx.Object.propertyIsEnumerable(str, '3')).to.not.be.ok();
        });

        it('string object defined', function () {
            var strObj = required.Object('abc');

            expect(utilx.Object.propertyIsEnumerable(strObj, '0')).to.be.ok();
            expect(utilx.Object.propertyIsEnumerable(strObj, '1')).to.be.ok();
            expect(utilx.Object.propertyIsEnumerable(strObj, '2')).to.be.ok();
        });

        it('string object not-defined', function () {
            var strObj = required.Object('abc');

            expect(utilx.Object.propertyIsEnumerable(strObj, '3')).to.not.be.ok();
        });

        it('arguments defined', function () {
            var args = required.returnArgs(false, undefined, null, '', 0);

            expect(utilx.Object.propertyIsEnumerable(args, '0')).to.be.ok();
            expect(utilx.Object.propertyIsEnumerable(args, '1')).to.be.ok();
            expect(utilx.Object.propertyIsEnumerable(args, '2')).to.be.ok();
            expect(utilx.Object.propertyIsEnumerable(args, '3')).to.be.ok();
            expect(utilx.Object.propertyIsEnumerable(args, '4')).to.be.ok();
        });

        it('arguments not-defined', function () {
            var args = required.returnArgs(false, undefined, null, '', 0);

            expect(utilx.Object.propertyIsEnumerable(args, '5')).to.not.be.ok();
        });

        it('should not list prototype or constructor', function () {
            function Constructor() {
                this.constructor = this.prototype = 1;
            }

            Constructor.prototype.constructor = 1;
            expect(utilx.Object.propertyIsEnumerable(Constructor, 'constructor')).to.not.be.ok();
        });

        it('should list prototype and constructor', function () {
            function Constructor() {
                this.constructor = this.prototype = 1;
            }

            Constructor.prototype.constructor = 1;
            expect(utilx.Object.propertyIsEnumerable(Constructor, 'prototype')).to.not.be.ok();
            expect(utilx.Object.propertyIsEnumerable(Constructor.prototype, 'constructor')).to.not.be.ok();
            expect(utilx.Object.propertyIsEnumerable(new Constructor(), 'prototype')).to.be.ok();
            expect(utilx.Object.propertyIsEnumerable(new Constructor(), 'constructor')).to.be.ok();
        });
    });
}());

},{"../scripts/":10}],132:[function(require,module,exports){
/*global TypeError, describe, it, require */

/*properties
    '0', '1', '2', '3', Array, Object, a, be, eql, expect, foo, length,
    swapItems, throwException, to, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.swapItems', function () {
        it('should throw a TypeError in each case', function () {
            expect(function () {
                utilx.Object.swapItems();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.swapItems(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.swapItems(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.swapItems('');
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.swapItems(1);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.Object.swapItems(true);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should do nothing in each case', function () {
            expect(utilx.Object.swapItems([1, 2, 3])).to.eql([1, 2, 3]);
            expect(utilx.Object.swapItems([1, 2, 3], undefined)).to.eql([1, 2, 3]);
            expect(utilx.Object.swapItems([1, 2, 3], null)).to.eql([1, 2, 3]);
            expect(utilx.Object.swapItems([1, 2, 3], undefined, undefined)).to.eql([1, 2, 3]);
            expect(utilx.Object.swapItems([1, 2, 3], null, null)).to.eql([1, 2, 3]);
            expect(utilx.Object.swapItems([1, 2, 3], 1, 1, undefined)).to.eql([1, 2, 3]);
            expect(utilx.Object.swapItems([1, 2, 3], '2', '2')).to.eql([1, 2, 3]);
            expect(utilx.Object.swapItems([1, 2, 3], 'foo', 'foo')).to.eql([1, 2, 3]);
            expect(utilx.Object.swapItems([1, 2, 3], 'foo', 'bar')).to.eql([1, 2, 3]);
            expect(utilx.Object.swapItems({
                0: 1,
                1: 2,
                2: 3,
                length: 3
            })).to.eql({
                0: 1,
                1: 2,
                2: 3,
                length: 3
            });
            expect(utilx.Object.swapItems({
                0: 1,
                1: 2,
                2: 3,
                length: 3
            }, undefined)).to.eql({
                0: 1,
                1: 2,
                2: 3,
                length: 3
            });
            expect(utilx.Object.swapItems({
                0: 1,
                1: 2,
                2: 3,
                length: 3
            }, null)).to.eql({
                0: 1,
                1: 2,
                2: 3,
                length: 3
            });
            expect(utilx.Object.swapItems({
                0: 1,
                1: 2,
                2: 3,
                length: 3
            }, undefined, undefined)).to.eql({
                0: 1,
                1: 2,
                2: 3,
                length: 3
            });
            expect(utilx.Object.swapItems({
                0: 1,
                1: 2,
                2: 3,
                length: 3
            }, null, null)).to.eql({
                0: 1,
                1: 2,
                2: 3,
                length: 3
            });
            expect(utilx.Object.swapItems({
                0: 1,
                1: 2,
                2: 3,
                length: 3
            }, 1, 1)).to.eql({
                0: 1,
                1: 2,
                2: 3,
                length: 3
            });
            expect(utilx.Object.swapItems({
                0: 1,
                1: 2,
                2: 3,
                length: 3
            }, '1', '1')).to.eql({
                0: 1,
                1: 2,
                2: 3,
                length: 3
            });
            expect(utilx.Object.swapItems({
                0: 1,
                1: 2,
                2: 3,
                length: 3
            }, 'foo', 'foo')).to.eql({
                0: 1,
                1: 2,
                2: 3,
                length: 3
            });
            expect(utilx.Object.swapItems({
                0: 1,
                1: 2,
                2: 3,
                length: 3
            }, 'foo', 'bar')).to.eql({
                0: 1,
                1: 2,
                2: 3,
                length: 3
            });
        });

        it('should work with arrays', function () {
            var arr1 = [1, 2, 3],
                arr2 = [1, 2, 3],
                arr3 = [3, 2, 1],
                arr4 = [0, 2, 3, 1],
                arr5 = [1, 2];

            arr5.foo = 3;
            delete arr4[0];
            expect(utilx.Object.swapItems(arr1, 0, 2)).to.eql(arr3);
            expect(arr1.length).to.be(3);
            arr1 = [1, 2, 3];
            expect(utilx.Object.swapItems(arr1, 0, 3)).to.eql(arr4);
            expect(arr1.length).to.be(4);
            expect(utilx.Object.swapItems(arr4, 0, 3)).to.eql(arr2);
            expect(arr4.length).to.be(3);
            arr1 = [1, 2, 3];
            arr2 = [1, 2, 3];
            arr3 = [3, 2, 1];
            arr4 = [0, 2, 3, 1];
            delete arr4[0];
            expect(utilx.Object.swapItems(arr1, '0', '2')).to.eql(arr3);
            expect(arr1.length).to.be(3);
            arr1 = [1, 2, 3];
            expect(utilx.Object.swapItems(arr1, '0', '3')).to.eql(arr4);
            expect(arr1.length).to.be(4);
            expect(utilx.Object.swapItems(arr4, '0', '3')).to.eql(arr2);
            expect(arr4.length).to.be(3);
            expect(utilx.Object.swapItems(arr2, 2, 'foo')).to.eql(arr5);
            expect(arr2.length).to.be(2);
            expect(arr2.foo).to.be(3);
            arr1 = [1, 2, 3];
            expect(utilx.Object.swapItems(arr2, 2, 'foo')).to.eql(arr1);
            expect(arr2.length).to.be(3);
        });

        it('should work with objects with length', function () {
            var obj1 = {
                    0: 1,
                    1: 2,
                    2: 3,
                    length: 3
                },
                obj2 = {
                    0: 1,
                    1: 2,
                    2: 3,
                    length: 3
                },
                obj3 = {
                    0: 3,
                    1: 2,
                    2: 1,
                    length: 3
                },
                obj4 = {
                    1: 2,
                    2: 3,
                    3: 1,
                    length: 4
                },
                obj5 = {
                    0: 1,
                    1: 2,
                    length: 2
                };

            obj5.foo = 3;
            expect(utilx.Object.swapItems(obj1, 0, 2)).to.eql(obj3);
            expect(obj1.length).to.be(3);
            obj1 = {
                0: 1,
                1: 2,
                2: 3,
                length: 3
            };
            expect(utilx.Object.swapItems(obj1, 0, 3)).to.eql(obj4);
            expect(obj1.length).to.be(4);
            expect(utilx.Object.swapItems(obj4, 0, 3)).to.eql(obj2);
            expect(obj4.length).to.be(3);
            obj1 = {
                0: 1,
                1: 2,
                2: 3,
                length: 3
            };
            obj2 = {
                0: 1,
                1: 2,
                2: 3,
                length: 3
            };
            obj3 = {
                0: 3,
                1: 2,
                2: 1,
                length: 3
            };
            obj4 = {
                1: 2,
                2: 3,
                3: 1,
                length: 4
            };
            expect(utilx.Object.swapItems(obj1, '0', '2')).to.eql(obj3);
            expect(obj1.length).to.be(3);
            obj1 = {
                0: 1,
                1: 2,
                2: 3,
                length: 3
            };
            expect(utilx.Object.swapItems(obj1, '0', '3')).to.eql(obj4);
            expect(obj1.length).to.be(4);
            expect(utilx.Object.swapItems(obj4, '0', '3')).to.eql(obj2);
            expect(obj4.length).to.be(3);
            expect(utilx.Object.swapItems(obj2, 2, 'foo')).to.eql(obj5);
            expect(obj2.length).to.be(2);
            expect(obj2.foo).to.be(3);
            obj1 = {
                0: 1,
                1: 2,
                2: 3,
                length: 3
            };
            expect(utilx.Object.swapItems(obj2, 2, 'foo')).to.eql(obj1);
            expect(obj2.length).to.be(3);
        });

        it('should work with objects without length', function () {
            var obj1 = {
                    0: 1,
                    1: 2,
                    2: 3
                },
                obj2 = {
                    0: 1,
                    1: 2,
                    2: 3
                },
                obj3 = {
                    0: 3,
                    1: 2,
                    2: 1
                },
                obj4 = {
                    1: 2,
                    2: 3,
                    3: 1
                },
                obj5 = {
                    0: 1,
                    1: 2
                };

            obj5.foo = 3;
            expect(utilx.Object.swapItems(obj1, 0, 2)).to.eql(obj3);
            obj1 = {
                0: 1,
                1: 2,
                2: 3
            };
            expect(utilx.Object.swapItems(obj1, 0, 3)).to.eql(obj4);
            expect(utilx.Object.swapItems(obj4, 0, 3)).to.eql(obj2);
            obj1 = {
                0: 1,
                1: 2,
                2: 3
            };
            obj2 = {
                0: 1,
                1: 2,
                2: 3
            };
            obj3 = {
                0: 3,
                1: 2,
                2: 1
            };
            obj4 = {
                1: 2,
                2: 3,
                3: 1
            };
            expect(utilx.Object.swapItems(obj1, '0', '2')).to.eql(obj3);
            obj1 = {
                0: 1,
                1: 2,
                2: 3
            };
            expect(utilx.Object.swapItems(obj1, '0', '3')).to.eql(obj4);
            expect(utilx.Object.swapItems(obj4, '0', '3')).to.eql(obj2);
            expect(utilx.Object.swapItems(obj2, 2, 'foo')).to.eql(obj5);
            expect(obj2.foo).to.be(3);
            obj1 = {
                0: 1,
                1: 2,
                2: 3
            };
            expect(utilx.Object.swapItems(obj2, 2, 'foo')).to.eql(obj1);
        });
    });
}());

},{"../scripts/":10}],133:[function(require,module,exports){
/*global Array, Boolean, Date, Error, Function, Number, Object, RegExp, String, describe, it, require */

/*properties
    Object, be, expect, noop, prototype, returnArgs, to, toStringTag, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.toStringTag', function () {
        it('basic', function () {
            expect(utilx.Object.toStringTag()).to.be('[object Undefined]');
            expect(utilx.Object.toStringTag(undefined)).to.be('[object Undefined]');
            expect(utilx.Object.toStringTag(null)).to.be('[object Null]');
            expect(utilx.Object.toStringTag(1)).to.be('[object Number]');
            expect(utilx.Object.toStringTag(true)).to.be('[object Boolean]');
            expect(utilx.Object.toStringTag('x')).to.be('[object String]');
            expect(utilx.Object.toStringTag([1, 2, 3])).to.be('[object Array]');
            expect(utilx.Object.toStringTag(required.returnArgs())).to.be('[object Arguments]');
            expect(utilx.Object.toStringTag({})).to.be('[object Object]');
            expect(utilx.Object.toStringTag(required.noop)).to.be('[object Function]');
            expect(utilx.Object.toStringTag(new RegExp('c'))).to.be('[object RegExp]');
            expect(utilx.Object.toStringTag(new Date())).to.be('[object Date]');
            expect(utilx.Object.toStringTag(new Error('x'))).to.be('[object Error]');
        });

        it('Object prototypes', function () {
            expect(utilx.Object.toStringTag(Object.prototype)).to.be('[object Object]');
            expect(utilx.Object.toStringTag(Array.prototype)).to.be('[object Array]');
            expect(utilx.Object.toStringTag(Boolean.prototype)).to.be('[object Boolean]');
            expect(utilx.Object.toStringTag(Number.prototype)).to.be('[object Number]');
            expect(utilx.Object.toStringTag(String.prototype)).to.be('[object String]');
            expect(utilx.Object.toStringTag(Error.prototype)).to.be('[object Error]');
            expect(utilx.Object.toStringTag(Date.prototype)).to.be('[object Date]');
            expect(utilx.Object.toStringTag(RegExp.prototype)).to.be('[object RegExp]');
            expect(utilx.Object.toStringTag(Function.prototype)).to.be('[object Function]');
        });
    });
}());

},{"../scripts/":10}],134:[function(require,module,exports){
/*global Array, Boolean, Date, Error, Function, Number, Object, RegExp, String, describe, it, require, window*/

/*properties
    Object, alert, be, expect, noop, prototype, returnArgs, to, typeOf, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('Object.typeOf', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.Object.typeOf()).to.be('undefined');
            expect(utilx.Object.typeOf(undefined)).to.be('undefined');
            expect(utilx.Object.typeOf(null)).to.be('object');
            expect(utilx.Object.typeOf(1)).to.be('number');
            expect(utilx.Object.typeOf(true)).to.be('boolean');
            expect(utilx.Object.typeOf('x')).to.be('string');
            expect(utilx.Object.typeOf([1, 2, 3])).to.be('object');
            expect(utilx.Object.typeOf(required.returnArgs())).to.be('object');
            expect(utilx.Object.typeOf({})).to.be('object');
            expect(utilx.Object.typeOf(required.noop)).to.be('function');
            expect(utilx.Object.typeOf(new RegExp('c'))).to.be('object');
            expect(utilx.Object.typeOf(new Date())).to.be('object');
            expect(utilx.Object.typeOf(new Error('x'))).to.be('object');
            expect(utilx.Object.typeOf(Object)).to.be('function');
            expect(utilx.Object.typeOf(Array)).to.be('function');
            expect(utilx.Object.typeOf(Boolean)).to.be('function');
            expect(utilx.Object.typeOf(Number)).to.be('function');
            expect(utilx.Object.typeOf(String)).to.be('function');
            expect(utilx.Object.typeOf(Error)).to.be('function');
            expect(utilx.Object.typeOf(Date)).to.be('function');
            expect(utilx.Object.typeOf(RegExp)).to.be('function');
            expect(utilx.Object.typeOf(Function)).to.be('function');
            expect(utilx.Object.typeOf(Object.prototype)).to.be('object');
            expect(utilx.Object.typeOf(Array.prototype)).to.be('object');
            expect(utilx.Object.typeOf(Boolean.prototype)).to.be('object');
            expect(utilx.Object.typeOf(Number.prototype)).to.be('object');
            expect(utilx.Object.typeOf(String.prototype)).to.be('object');
            expect(utilx.Object.typeOf(Error.prototype)).to.be('object');
            expect(utilx.Object.typeOf(Date.prototype)).to.be('object');
            expect(utilx.Object.typeOf(RegExp.prototype)).to.be('object');
            expect(utilx.Object.typeOf(Function.prototype)).to.be('function');
            if ((typeof window === 'object' || typeof window === 'function' || false) && window.alert) {
                expect(utilx.Object.typeOf(window.alert)).to.be('function');
            }
        });
    });
}());

},{"../scripts/":10}],135:[function(require,module,exports){
/*global describe, it, require */

/*properties
    RegExp, be, eql, exec, expect, index, lastIndex, length, slice, to, utilx, a, throwException, not
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('RegExp.exec', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.RegExp.exec();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.RegExp.exec(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.RegExp.exec(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw if no string argument', function () {
            expect(function () {
                utilx.RegExp.exec(/x/g);
            }).to.not.throwException();
        });

        it('should not throw if string argument is undefined', function () {
            expect(function () {
                utilx.RegExp.exec(/x/g, undefined);
            }).to.not.throwException();
        });

        it('should not throw if string argument is null', function () {
            expect(function () {
                utilx.RegExp.exec(/x/g, null);
            }).to.not.throwException();
        });

        it('should ignore lastIndex and set the search start position at 0 for a nonglobal regex', function () {
            var regex = /x/;

            regex.lastIndex = 4;
            expect(required.slice(utilx.RegExp.exec(regex, '123x5'))).to.eql(['x']);
        });

        it('should use lastIndex to set the search start position for a global regex', function () {
            var regex = /x/g;

            regex.lastIndex = 4;
            expect(utilx.RegExp.exec(regex, '123x5')).to.be(null);

            regex.lastIndex = 2;
            expect(required.slice(utilx.RegExp.exec(regex, '123x5'))).to.eql(['x']);
        });

        it('should type convert lastIndex when setting the search start position', function () {
            var regex = /x/g;

            expect(function () {
                regex.lastIndex = '3';
            }).to.not.throwException();

            expect(required.slice(utilx.RegExp.exec(regex, '123x5'))).to.eql(['x']);

            expect(function () {
                regex.lastIndex = '4';
            }).to.not.throwException();

            expect(utilx.RegExp.exec(regex, '123x5')).to.be(null);
        });

        it('should not increment index on zero length mathces', function () {
            var regex = /\b/g,
                match = utilx.RegExp.exec(regex, '1,2');

            expect(match[0].length).to.eql(0);
            expect(regex.lastIndex).to.eql(match.index);
        });

        it('should not increment lastIndex non global', function () {
            var regex = /x/;

            utilx.RegExp.exec(regex, '123x5');

            expect(regex.lastIndex).to.eql(0);
        });
    });
}());

},{"../scripts/":10}],136:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('RegExp.isRegExp', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.RegExp.isRegExp()).to.not.be.ok();
            expect(utilx.RegExp.isRegExp(undefined)).to.not.be.ok();
            expect(utilx.RegExp.isRegExp(null)).to.not.be.ok();
            expect(utilx.RegExp.isRegExp(1)).to.not.be.ok();
            expect(utilx.RegExp.isRegExp(true)).to.not.be.ok();
            expect(utilx.RegExp.isRegExp('')).to.not.be.ok();
            expect(utilx.RegExp.isRegExp(new Error('x'))).to.not.be.ok();
            expect(utilx.RegExp.isRegExp(new Date())).to.not.be.ok();
            expect(utilx.RegExp.isRegExp(new RegExp('x'))).to.be.ok();
            expect(utilx.RegExp.isRegExp(required.noop)).to.not.be.ok();
            expect(utilx.RegExp.isRegExp([])).to.not.be.ok();
            expect(utilx.RegExp.isRegExp({})).to.not.be.ok();
            expect(utilx.RegExp.isRegExp(required.returnArgs())).to.not.be.ok();
            expect(utilx.RegExp.isRegExp(RegExp.prototype)).to.be.ok();
        });

        if (required.frame) {
            it('should work accross frames', function () {
                expect(utilx.RegExp.isRegExp(new required.frame.RegExp('x'))).to.be.ok();
            });
        }
    });
}());

},{"../scripts/":10}],137:[function(require,module,exports){
/*global TypeError, describe, it, require */

/*properties
    RegExp, a, be, expect, lastIndex, not, ok, test, throwException, to, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('RegExp.test', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.RegExp.test();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.RegExp.test(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.RegExp.test(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw if no string argument', function () {
            expect(function () {
                utilx.RegExp.test(/x/g);
            }).to.not.throwException();
        });

        it('should not throw if string argument is undefined', function () {
            expect(function () {
                utilx.RegExp.test(/x/g, undefined);
            }).to.not.throwException();
        });

        it('should not throw if string argument is null', function () {
            expect(function () {
                utilx.RegExp.test(/x/g, null);
            }).to.not.throwException();
        });

        it('should ignore lastIndex and set the search start position at 0 for a nonglobal regex', function () {
            var regex = /x/;

            regex.lastIndex = 4;
            expect(utilx.RegExp.test(regex, '123x5')).to.be.ok();
        });

        it('should use lastIndex to set the search start position for a global regex', function () {
            var regex = /x/g;

            regex.lastIndex = 4;
            expect(utilx.RegExp.test(regex, '123x5')).to.not.be.ok();

            regex.lastIndex = 2;
            expect(utilx.RegExp.test(regex, '123x5')).to.be.ok();
        });

        it('should type convert lastIndex when setting the search start position', function () {
            var regex = /x/g;

            regex.lastIndex = '3';
            expect(utilx.RegExp.test(regex, '123x5')).to.be.ok();

            regex.lastIndex = '4';
            expect(utilx.RegExp.test(regex, '123x5')).to.not.be.ok();
        });

        it('should type no argument to string', function () {
            var regex = /x/g;

            expect(utilx.RegExp.test(regex)).to.not.be.ok();
        });

        it('should type undefined to string', function () {
            var regex = /x/g;

            expect(utilx.RegExp.test(regex, undefined)).to.not.be.ok();
        });

        it('should type null to string', function () {
            var regex = /x/g;

            expect(utilx.RegExp.test(regex, null)).to.not.be.ok();
        });

        it('should type 1 to string', function () {
            var regex = /x/g;

            expect(utilx.RegExp.test(regex, 1)).to.not.be.ok();
        });

        it('should type true to string', function () {
            var regex = /x/g;

            expect(utilx.RegExp.test(regex, true)).to.not.be.ok();
        });

        it('should type {} to string', function () {
            var regex = /x/g;

            expect(utilx.RegExp.test(regex, {})).to.not.be.ok();
        });

        it('should type [] to string', function () {
            var regex = /x/g;

            expect(utilx.RegExp.test(regex, [])).to.not.be.ok();
        });
    });
}());

},{"../scripts/":10}],138:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.ToString', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.String.ToString()).to.be('undefined');
            expect(utilx.String.ToString(undefined)).to.be('undefined');
            expect(utilx.String.ToString(null)).to.be('null');
            expect(utilx.String.ToString(1)).to.be('1');
            expect(utilx.String.ToString(true)).to.be('true');
            expect(utilx.String.ToString('x')).to.be('x');
            expect(utilx.String.ToString([1, 2, 3])).to.be('1,2,3');
            expect(utilx.String.ToString({})).to.be('[object Object]');
            expect(utilx.String.ToString(required.noop)).to.be(required.noop.toString());
            expect(utilx.String.ToString(new RegExp('c'))).to.be('/c/');
            expect(utilx.String.ToString(NaN)).to.be('NaN');
            expect(utilx.String.ToString(Infinity)).to.be('Infinity');
            expect(utilx.String.ToString(-Infinity)).to.be('-Infinity');
        });
    });
}());

},{"../scripts/":10}],139:[function(require,module,exports){
/*global describe, it, require */

/*property
    String, Object, a, be, eql, expect, returnArgs, chunk, keys, length, not,
    throwException, to, utilx, noop, '0', '1', '2', '3', '4', '5', '6', '7',
    source, global, multiline, ignoreCase, lastIndex
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.chunk', function () {
        var testStr = 'abcdefgabcdefgabcdefg';

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.chunk();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.chunk(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.chunk(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an TypeError if chunkSize is not a valid number', function () {
            var expected = [],
                result;

            expect(function () {
                result = utilx.String.chunk(testStr);
            }).to.not.throwException();

            expect(result).to.eql(expected);

            expect(function () {
                result = utilx.String.chunk(testStr, undefined);
            }).to.not.throwException();

            expect(result).to.eql(expected);

            expect(function () {
                result = utilx.String.chunk(testStr, null);
            }).to.not.throwException();

            expect(result).to.eql(expected);

            expect(function () {
                result = utilx.String.chunk(testStr, {});
            }).to.not.throwException();

            expect(result).to.eql(expected);

            expect(function () {
                result = utilx.String.chunk(testStr, []);
            }).to.not.throwException();

            expect(result).to.eql(expected);

            expect(function () {
                result = utilx.String.chunk(testStr, NaN);
            }).to.not.throwException();

            expect(result).to.eql(expected);

            expect(function () {
                result = utilx.String.chunk(testStr, required.noop);
            }).to.not.throwException();

            expect(result).to.eql(expected);

            expect(function () {
                result = utilx.String.chunk(testStr, Infinity);
            }).to.not.throwException();

            expect(result).to.eql(expected);

            expect(function () {
                result = utilx.String.chunk(testStr, -Infinity);
            }).to.not.throwException();

            expect(result).to.eql(expected);

            expect(function () {
                result = utilx.String.chunk(testStr, 0);
            }).to.not.throwException();

            expect(result).to.eql(expected);

            expect(function () {
                result = utilx.String.chunk(testStr, -1);
            }).to.not.throwException();

            expect(result).to.eql(expected);

            expect(function () {
                result = utilx.String.chunk(testStr, '');
            }).to.not.throwException();

            expect(result).to.eql(expected);
        });

        it('should not throw an TypeError if argument is primitive', function () {
            var expected = [],
                result;

            expect(function () {
                result = utilx.String.chunk(42);
            }).to.not.throwException();

            expect(result).to.eql(expected);

            expect(function () {
                result = utilx.String.chunk(true);
            }).to.not.throwException();

            expect(result).to.eql(expected);

            expect(function () {
                result = utilx.String.chunk('abc');
            }).to.not.throwException();

            expect(result).to.eql(expected);
        });

        it('should not throw an TypeError if argument is an object', function () {
            var expected = [],
                result;

            expect(function () {
                result = utilx.String.chunk({});
            }).to.not.throwException();

            expect(result).to.eql(expected);

            expect(function () {
                result = utilx.String.chunk([]);
            }).to.not.throwException();

            expect(result).to.eql(expected);

            expect(function () {
                result = utilx.String.chunk(required.noop);
            }).to.not.throwException();

            expect(result).to.eql(expected);
        });

        it('should return the correct result', function () {
            var result;

            expect(function () {
                result = utilx.String.chunk(testStr, 1);
            }).to.not.throwException();

            expect(result).to.eql(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'a', 'b', 'c', 'd', 'e', 'f', 'g']);

            expect(function () {
                result = utilx.String.chunk(testStr, 2);
            }).to.not.throwException();

            expect(result).to.eql(['ab', 'cd', 'ef', 'ga', 'bc', 'de', 'fg', 'ab', 'cd', 'ef', 'g']);

            expect(function () {
                result = utilx.String.chunk(testStr, 3);
            }).to.not.throwException();

            expect(result).to.eql(['abc', 'def', 'gab', 'cde', 'fga', 'bcd', 'efg']);

            expect(function () {
                result = utilx.String.chunk(testStr, 30);
            }).to.not.throwException();

            expect(result).to.eql([testStr]);
        });
    });
}());

},{"../scripts/":10}],140:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.clipDuplicates', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.clipDuplicates();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.clipDuplicates(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.clipDuplicates(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(utilx.String.clipDuplicates('')).to.be('');
            expect(utilx.String.clipDuplicates('      ')).to.be(' ');
            expect(utilx.String.clipDuplicates('abc')).to.be('abc');
            expect(utilx.String.clipDuplicates('aabc')).to.be('abc');
            expect(utilx.String.clipDuplicates('abca')).to.be('bca');
            expect(utilx.String.clipDuplicates('aabaacaa')).to.be('bca');
        });
    });
}());

},{"../scripts/":10}],141:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.contains', function () {
        var str = 'The quick sly fox jumped over the lazy dog.';

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.contains();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.contains(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.contains(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(utilx.String.contains(str, 'The')).to.be.ok();
            expect(utilx.String.contains(str, 'quick')).to.be.ok();
            expect(utilx.String.contains(str, 'sly')).to.be.ok();
            expect(utilx.String.contains(str, 'fox')).to.be.ok();
            expect(utilx.String.contains(str, 'jumped')).to.be.ok();
            expect(utilx.String.contains(str, 'over')).to.be.ok();
            expect(utilx.String.contains(str, 'the')).to.be.ok();
            expect(utilx.String.contains(str, 'lazy')).to.be.ok();
            expect(utilx.String.contains(str, 'dog')).to.be.ok();
            expect(utilx.String.contains(str, 'foo')).to.not.be.ok();
            expect(utilx.String.contains(str, 'bar')).to.not.be.ok();
            expect(utilx.String.contains(str, 'buz')).to.not.be.ok();
            expect(utilx.String.contains(str, 'The', 4)).to.not.be.ok();
            expect(utilx.String.contains(str, 'fox', 20)).to.not.be.ok();
            expect(utilx.String.contains(str, 'fox', 0)).to.be.ok();
        });
    });
}());

},{"../scripts/":10}],142:[function(require,module,exports){
/*global TypeError, describe, it, require */

/*properties
    String, a, be, countCharacter, expect, throwException, to, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.countCharacter', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.countCharacter();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.countCharacter(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.countCharacter(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if no character argument', function () {
            expect(function () {
                utilx.String.countCharacter('abacadaeafa');
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if character argument is undefined', function () {
            expect(function () {
                utilx.String.countCharacter('abacadaeafa', undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if character argument is null', function () {
            expect(function () {
                utilx.String.countCharacter('abacadaeafa', null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(utilx.String.countCharacter('abacadaeafa', 'a')).to.be(6);
            expect(utilx.String.countCharacter('abacadaeafa', 'z')).to.be(0);
            expect(utilx.String.countCharacter('abacadaeafa', '')).to.be(Infinity);

        });
    });
}());

},{"../scripts/":10}],143:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.endsWith', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.endsWith();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.endsWith(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.endsWith(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(utilx.String.endsWith('abcdefghijklmnopqrstuvwxyz', 'xyz')).to.be.ok();
            expect(utilx.String.endsWith('abcdefghijklmnopqrstuvwxyz', 'abc')).to.not.be.ok();
            expect(utilx.String.endsWith('abcdefghijklmnopqrstuvwxyz', 'abc', 3)).to.be.ok();
            expect(utilx.String.endsWith('abcdefghijklmnopqrstuvwxyz', 'xyz', 24)).to.not.be.ok();
        });
    });
}());

},{"../scripts/":10}],144:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.escapeRegex', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.escapeRegex();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.escapeRegex(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.escapeRegex(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });


        it('should be ok in each case', function () {
            var str = '[](){}?*+^$\\.|',
                obj = utilx.Object.ToObject(str);

            expect(utilx.String.escapeRegex(str)).to.not.be('[](){}?*+^$\\.|');
            expect(utilx.String.escapeRegex(str)).to.be('\\[\\]\\(\\)\\{\\}\\?\\*\\+\\^\\$\\\\\\.\\|');
            expect(utilx.String.escapeRegex(obj)).to.not.be('[](){}?*+^$\\.|');
            expect(utilx.String.escapeRegex(obj)).to.be('\\[\\]\\(\\)\\{\\}\\?\\*\\+\\^\\$\\\\\\.\\|');
        });
    });
}());

},{"../scripts/":10}],145:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.first', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.first();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.first(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.first(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(function () {
                utilx.String.first();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.String.first(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.String.first(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(utilx.String.first('')).to.be('');
            expect(utilx.String.first('abcdef')).to.be('a');
        });
    });
}());

},{"../scripts/":10}],146:[function(require,module,exports){
/*global describe, it, require */

/*property
    String, Object, a, be, eql, expect, returnArgs, indexOf, keys, length, not,
    throwException, to, utilx, noop, '0', '1', '2', '3', '4', '5', '6', '7',
    source, global, multiline, ignoreCase, lastIndex
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.indexOf', function () {
        var testStr = 'abcdefgabcdefgabcdefg';

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.indexOf();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.indexOf(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.indexOf(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an TypeError if argument is primitive', function () {
            var index;

            expect(function () {
                index = utilx.String.indexOf(42);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.indexOf(true);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.indexOf('abc');
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should not throw an TypeError if argument is an object', function () {
            var index;

            expect(function () {
                index = utilx.String.indexOf({});
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.indexOf([]);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.indexOf(required.noop);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return -1 if indexOf undefined', function () {
            var index;

            expect(function () {
                index = utilx.String.indexOf(testStr);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.indexOf(testStr, undefined);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return -1 if indexOf not found', function () {
            var index;

            expect(function () {
                index = utilx.String.indexOf(testStr, null);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.indexOf(testStr, 0);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.indexOf(testStr, 10);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.indexOf(testStr, true);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return correct index with string argument', function () {
            var index;

            expect(function () {
                index = utilx.String.indexOf(testStr, 'a');
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.indexOf(testStr, 'b');
            }).to.not.throwException();

            expect(index).to.be(1);

            expect(function () {
                index = utilx.String.indexOf(testStr, 'c');
            }).to.not.throwException();

            expect(index).to.be(2);

            expect(function () {
                index = utilx.String.indexOf('', 'a');
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.indexOf('', 'b');
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.indexOf('', 'c');
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return correct index with string argument and position', function () {
            var index;

            expect(function () {
                index = utilx.String.indexOf(testStr, 'a', 0);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.indexOf(testStr, 'b', 0);
            }).to.not.throwException();

            expect(index).to.be(1);

            expect(function () {
                index = utilx.String.indexOf(testStr, 'c', 0);
            }).to.not.throwException();

            expect(index).to.be(2);

            expect(function () {
                index = utilx.String.indexOf(testStr, 'a', 6);
            }).to.not.throwException();

            expect(index).to.be(7);

            expect(function () {
                index = utilx.String.indexOf(testStr, 'b', 6);
            }).to.not.throwException();

            expect(index).to.be(8);

            expect(function () {
                index = utilx.String.indexOf(testStr, 'c', 6);
            }).to.not.throwException();

            expect(index).to.be(9);

            expect(function () {
                index = utilx.String.indexOf(testStr, 'a', -7);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.indexOf(testStr, 'b', -7);
            }).to.not.throwException();

            expect(index).to.be(1);

            expect(function () {
                index = utilx.String.indexOf(testStr, 'c', -7);
            }).to.not.throwException();

            expect(index).to.be(2);

            expect(function () {
                index = utilx.String.indexOf(testStr, 'a', -70);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.indexOf(testStr, 'b', -70);
            }).to.not.throwException();

            expect(index).to.be(1);

            expect(function () {
                index = utilx.String.indexOf(testStr, 'c', -70);
            }).to.not.throwException();

            expect(index).to.be(2);

            expect(function () {
                index = utilx.String.indexOf(testStr, 'a', 70);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.indexOf(testStr, 'b', 70);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.indexOf(testStr, 'c', 70);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return correct index with empty strings', function () {
            var index;

            expect(function () {
                index = utilx.String.indexOf('', '');
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.indexOf('', '', -1);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.indexOf('', '', 4);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.indexOf('', '', 6);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.indexOf('', {});
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.indexOf('', []);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.indexOf('', required.noop);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.indexOf('', {}, -2);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.indexOf('', [], 2);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.indexOf('', required.noop, 4);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.indexOf(testStr, '');
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.indexOf(testStr, '', -1);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.indexOf(testStr, '', 4);
            }).to.not.throwException();

            expect(index).to.be(4);

            expect(function () {
                index = utilx.String.indexOf(testStr, '', 6);
            }).to.not.throwException();

            expect(index).to.be(6);

            expect(function () {
                index = utilx.String.indexOf(testStr, {});
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.indexOf(testStr, []);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.indexOf(testStr, required.noop);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.indexOf(testStr, {}, -2);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.indexOf(testStr, [], 2);
            }).to.not.throwException();

            expect(index).to.be(2);

            expect(function () {
                index = utilx.String.indexOf(testStr, required.noop, 4);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should not throw an TypeError if search argument is an object', function () {
            var index;

            expect(function () {
                index = utilx.String.indexOf(testStr, {});
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.indexOf(testStr, []);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.indexOf(testStr, required.noop);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return index as long as search begins within fromIndex', function () {
            var index;

            expect(function () {
                index = utilx.String.indexOf(testStr, 'abcd', 0);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.indexOf(testStr,  'abcd', 1);
            }).to.not.throwException();

            expect(index).to.be(7);

            expect(function () {
                index = utilx.String.indexOf(testStr,  'abcd', 2);
            }).to.not.throwException();

            expect(index).to.be(7);
        });

        it('should return -1 if no match after fromIndex', function () {
            var index;

            expect(function () {
                index = utilx.String.indexOf(testStr, 'a', 15);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.indexOf(testStr,  'b', 16);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.indexOf(testStr,  'c', 17);
            }).to.not.throwException();
        });
    });
}());

},{"../scripts/":10}],147:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.isDigits', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.isDigits();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.isDigits(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.isDigits(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(utilx.String.isDigits(true)).to.not.be.ok();
            expect(utilx.String.isDigits(false)).to.not.be.ok();
            expect(utilx.String.isDigits('')).to.not.be.ok();
            expect(utilx.String.isDigits(' ')).to.not.be.ok();
            expect(utilx.String.isDigits(0)).to.be.ok();
            expect(utilx.String.isDigits(1)).to.be.ok();
            expect(utilx.String.isDigits({})).to.not.be.ok();
            expect(utilx.String.isDigits([])).to.not.be.ok();
            expect(utilx.String.isDigits('1234567890.0')).to.not.be.ok();
            expect(utilx.String.isDigits('-1234567890')).to.not.be.ok();
            expect(utilx.String.isDigits('-1234567890')).to.not.be.ok();
            expect(utilx.String.isDigits('1234567890')).to.be.ok();
        });
    });
}());

},{"../scripts/":10}],148:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.isString', function () {
        it('should not throw an error in each case', function () {
            expect(utilx.String.isString(required.ToObject('a'))).to.be.ok();
            expect(utilx.String.isString(true)).to.not.be.ok();
            expect(utilx.String.isString(false)).to.not.be.ok();
            expect(utilx.String.isString()).to.not.be.ok();
            expect(utilx.String.isString(null)).to.not.be.ok();
            expect(utilx.String.isString('')).to.be.ok();
            expect(utilx.String.isString(0)).to.not.be.ok();
            expect(utilx.String.isString(1)).to.not.be.ok();
            expect(utilx.String.isString({})).to.not.be.ok();
            expect(utilx.String.isString([])).to.not.be.ok();
            expect(utilx.String.isString(String.prototype)).to.be.ok();
        });

        if (required.frame) {
            it('should work accross frames', function () {
                expect(utilx.String.isString(new required.frame.String('a'))).to.be.ok();
            });
        }
    });
}());

},{"../scripts/":10}],149:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.last', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.last();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.last(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.last(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(utilx.String.last('')).to.be('');
            expect(utilx.String.last('abcdef')).to.be('f');
        });
    });
}());

},{"../scripts/":10}],150:[function(require,module,exports){
/*global describe, it, require */

/*property
    String, Object, a, be, eql, expect, returnArgs, lastIndexOf, keys, length, not,
    throwException, to, utilx, noop, '0', '1', '2', '3', '4', '5', '6', '7',
    source, global, multiline, ignoreCase, lastIndex
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.lastIndexOf', function () {
        var testStr = 'abcdefgabcdefgabcdefg';

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.lastIndexOf();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.lastIndexOf(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.lastIndexOf(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an TypeError if argument is primitive', function () {
            var index;

            expect(function () {
                index = utilx.String.lastIndexOf(42);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf(true);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf('abc');
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should not throw an TypeError if argument is an object', function () {
            var index;

            expect(function () {
                index = utilx.String.lastIndexOf({});
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf([]);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf(required.noop);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return -1 if lastIndexOf undefined', function () {
            var index;

            expect(function () {
                index = utilx.String.lastIndexOf(testStr);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, undefined);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return -1 if lastIndexOf not found', function () {
            var index;

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, null);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, 0);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, 10);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, true);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return correct index with string argument', function () {
            var index;

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, 'a');
            }).to.not.throwException();

            expect(index).to.be(14);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, 'b');
            }).to.not.throwException();

            expect(index).to.be(15);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, 'c');
            }).to.not.throwException();

            expect(index).to.be(16);

            expect(function () {
                index = utilx.String.lastIndexOf('', 'a');
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf('', 'b');
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf('', 'c');
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return correct index with string argument and position', function () {
            var index;

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, 'a', 0);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, 'b', 0);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, 'c', 0);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, 'a', 6);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, 'b', 6);
            }).to.not.throwException();

            expect(index).to.be(1);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, 'c', 6);
            }).to.not.throwException();

            expect(index).to.be(2);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, 'a', -7);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, 'b', -7);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, 'c', -7);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, 'a', -70);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, 'b', -70);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, 'c', -70);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, 'a', 70);
            }).to.not.throwException();

            expect(index).to.be(14);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, 'b', 70);
            }).to.not.throwException();

            expect(index).to.be(15);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, 'c', 70);
            }).to.not.throwException();

            expect(index).to.be(16);
        });

        it('should return correct index with empty strings', function () {
            var index;

            expect(function () {
                index = utilx.String.lastIndexOf('', '');
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.lastIndexOf('', '', -1);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.lastIndexOf('', '', 4);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.lastIndexOf('', '', 6);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.lastIndexOf('', {});
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf('', []);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.lastIndexOf('', required.noop);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf('', {}, -2);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf('', [], 2);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.lastIndexOf('', required.noop, 4);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, '');
            }).to.not.throwException();

            expect(index).to.be(21);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, '', -1);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, '', 4);
            }).to.not.throwException();

            expect(index).to.be(4);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, '', 6);
            }).to.not.throwException();

            expect(index).to.be(6);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, {});
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, []);
            }).to.not.throwException();

            expect(index).to.be(21);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, required.noop);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, {}, -2);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, [], 2);
            }).to.not.throwException();

            expect(index).to.be(2);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, required.noop, 4);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should not throw an TypeError if search argument is an object', function () {
            var index;

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, {});
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, []);
            }).to.not.throwException();

            expect(index).to.be(21);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, required.noop);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return index as long as search begins within fromIndex', function () {
            var index;

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, 'abcd', 0);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr,  'abcd', 1);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr,  'abcd', 2);
            }).to.not.throwException();

            expect(index).to.be(0);
        });

        it('should return -1 if match is after fromIndex', function () {
            var index;

            expect(function () {
                index = utilx.String.lastIndexOf(testStr, 'g', 0);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr,  'g', 1);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.lastIndexOf(testStr,  'g', 2);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });
    });
}());

},{"../scripts/":10}],151:[function(require,module,exports){
/*global Array, TypeError, describe, it, require */

/*properties
    String, a, be, call, eql, expect, forEach, lastIndex, match, ok, prototype,
    regex, result, slice, str, throwException, to, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.match', function () {
        //var msg;

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.match();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.match(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.match(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        // https://github.com/es-shims/es5-shim/issues/293
        it('"4".match(/(?=(?:...)*$)/) == [""]', function () {
            expect(Array.prototype.slice.call(utilx.String.match('4', /(?=(?:...)*$)/))).to.eql(['']);
        });

        describe('with a global regex', function () {
            it('should return an array with all matches', function () {
                expect(Array.prototype.slice.call(utilx.String.match('a bc', /(\w)/g))).to.eql(['a', 'b', 'c']);
            });

            it('should return null if no match is found', function () {
                expect(utilx.String.match('a bc', /x/g)).to.be(null);
            });

            it('should reset lastIndex to 0 when a match is found', function () {
                var regex = /x/g;

                regex.lastIndex = 1;
                utilx.String.match('123x5', regex);
                expect(regex.lastIndex).to.be(0);
            });

            it('should reset lastIndex to 0 when no match is found', function () {
                var regex = /x/g;

                regex.lastIndex = 1;
                utilx.String.match('123', regex);
                expect(regex.lastIndex).to.be(0);
            });

            it('should start the search at the beginning of the string, ignoring lastIndex', function () {
                var regex = /x/g;

                regex.lastIndex = 4;
                expect(utilx.String.match('123x5', regex)).to.be.ok();
            });

            it('should convert any nonstring context to a string (except null and undefined)', function () {
                expect(Array.prototype.slice.call(utilx.String.match(11, /1/g))).to.eql(['1', '1']);
            });

            /*
            msg = 'should throw an exception when called on null or undefined context, if strict mode is supported';
            it(msg, function () {
                required.forEach([null, undefined], function (value) {
                    // This doesn't work the same when strict mode isn't supported, because the match
                    // method will be called with the global object (window) as its context, rather
                    // than null or undefined
                    if (hasStrictMode) {
                        expect(function () {
                            utilx.String.match(value, /x/g);
                        }).toThrow(TypeError);
                    } else {
                        // Keep the assertion count consistent cross-browser
                        expect(hasStrictMode).to.be(false);
                    }
                });
            });
            */
        });

        describe('with a nonglobal regex', function () {
            it('should convert any provided non RegExp object to a RegExp', function () {
                // These don't error because, per the spec, the values are passed through new RegExp()
                // before being used as the context object for the (fixed) RegExp.prototype.exec
                var tests = [
                    {
                        str: '12',
                        regex: '^(1)',
                        result: ['1', '1']
                    },
                    // This would throw if the string was converted to an XRegExp rather than RegExp
                    {
                        str: '\x01',
                        regex: '\\1',
                        result: ['\x01']
                    },
                    // The converted value '[object Object]' creates a character class
                    {
                        str: '[obj]',
                        regex: {},
                        result: ['o']
                    }, {
                        str: 'null',
                        regex: null,
                        result: ['null']
                    }
                ];

                required.forEach(tests, function (test) {
                    expect(Array.prototype.slice.call(utilx.String.match(test.str, test.regex))).to.eql(test.result);
                });
            });

            /*
            msg = 'should throw an exception when called on null or undefined context, if strict mode is supported';
            it(msg, function () {
                required.forEach([null, undefined], function (value) {
                    // This doesn't work the same when strict mode isn't supported, because the match
                    // method will be called with the global object (window) as its context, rather
                    // than null or undefined
                    if (hasStrictMode) {
                        expect(function () {
                            utilx.String.match(value, /x/);
                        }).toThrow(TypeError);
                    } else {
                        // Keep the assertion count consistent cross-browser
                        expect(hasStrictMode).to.be(false);
                    }
                });
            });
            */
        });
    });
}());

},{"../scripts/":10}],152:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.padLeadingChar', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.padLeadingChar();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.padLeadingChar(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.padLeadingChar(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(function () {
                utilx.String.padLeadingChar();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.String.padLeadingChar(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.String.padLeadingChar(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(utilx.String.padLeadingChar('1', '0')).to.be('1');
            expect(utilx.String.padLeadingChar('1', '0', undefined)).to.be('1');
            expect(utilx.String.padLeadingChar('1', '0', null)).to.be('1');
            expect(utilx.String.padLeadingChar('1', '0', -1)).to.be('1');
            expect(utilx.String.padLeadingChar('1', '0', 0)).to.be('1');
            expect(utilx.String.padLeadingChar('1', '0', 5)).to.be('00001');
            expect(utilx.String.padLeadingChar('1', 'ab', 5)).to.be('aaaa1');
            expect(utilx.String.padLeadingChar('1', '', 5)).to.be('1');
        });
    });
}());

},{"../scripts/":10}],153:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.repeat', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.repeat();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.repeat(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.repeat(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(utilx.String.repeat(' ', 0)).to.be('');
            expect(utilx.String.repeat(' ', 5)).to.be('     ');
            expect(utilx.String.repeat('ab', 5)).to.be('ababababab');
            expect(utilx.String.repeat('', 5)).to.be('');
        });
    });
}());

},{"../scripts/":10}],154:[function(require,module,exports){
/*global RegExp, TypeError, describe, it, require */

/*properties
    String, ToString, a, be, expect, expected, forEach, lastIndex, repeat,
    replace, replacement, search, target, throwException, to, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.replace', function () {
        var msg;

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.replace();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.replace(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.replace(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should replace the first match only when given a nonglobal regex', function () {
            expect(utilx.String.replace('aaa', /a/, 'b')).to.be('baa');
        });

        it('should replace all matches when given a global regex', function () {
            expect(utilx.String.replace('aaa', /a/g, 'b')).to.be('bbb');
        });

        it('should replace the first match only when given a string as the search pattern', function () {
            expect(utilx.String.replace('aaa', 'a', 'b')).to.be('baa');
        });

        it('should not type convert a string search pattern to a regex', function () {
            expect(utilx.String.replace('aaa', 'a(a)', 'b')).to.be('aaa');
            expect(utilx.String.replace('a(a)a', 'a(a)', 'b')).to.be('ba');
        });

        it('should handle single-digit backreference $1 in the replacement string', function () {
            expect(utilx.String.replace('aaa', /a(a)/, '$1b')).to.be('aba');

            // Backreference to a nonparticipating capturing group
            expect(utilx.String.replace('test', /t|(e)/g, '$1')).to.be('es');
        });

        it('should handle double-digit backreferences $01, $10, and $99 in the replacement string', function () {
            expect(utilx.String.replace('aaa', /a(a)/, '$01b')).to.be('aba');
            expect(utilx.String.replace('aaa', new RegExp('a' + utilx.String.repeat('()', 9) + '(a)'), '$10b'))
                .to.be('aba');
            expect(utilx.String.replace('aaa', new RegExp('a' + utilx.String.repeat('()', 98) + '(a)'), '$99b'))
                .to.be('aba');
        });

        it('should end backreferences in the replacement string after two digits', function () {
            expect(utilx.String.replace('aaa', new RegExp('a' + utilx.String.repeat('()', 99) + '(a)'), '$100b'))
                .to.be('0ba');
        });

        // NOTE: IE < 9 incorrectly treats all occurrences of $ as literal text when performing a
        // replacement based on a search value that is not a regex. Restores the special
        // meaning of $$, $&, etc. for all replacements.

        it('should handle backreference $& in the replacement string', function () {
            expect(utilx.String.replace('aaa', /aa/, '$&b')).to.be('aaba');
            expect(utilx.String.replace('aaa', 'aa', '$&b')).to.be('aaba');
        });

        it('should handle right context token $\' in the replacement string', function () {
            expect(utilx.String.replace('aaa', /aa/, '$\'b')).to.be('aba');
            expect(utilx.String.replace('aaa', 'aa', '$\'b')).to.be('aba');
        });

        it('should handle left context token $` in the replacement string', function () {
            expect(utilx.String.replace('xaaa', /aa/, '$`b')).to.be('xxba');
            expect(utilx.String.replace('xaaa', 'aa', '$`b')).to.be('xxba');
        });

        it('should handle token $$ in the replacement string', function () {
            expect(utilx.String.replace('aaa', /aa/, '$$b')).to.be('$ba');
            expect(utilx.String.replace('aaa', 'aa', '$$b')).to.be('$ba');
        });

        it('should allow a function to generate the replacement', function () {
            expect(utilx.String.replace('aaa', /a/, function () {
                return 'b';
            })).to.be('baa');
            expect(utilx.String.replace('aaa', /a/g, function () {
                return 'b';
            })).to.be('bbb');
            expect(utilx.String.replace('aaa', 'a', function () {
                return 'b';
            })).to.be('baa');
        });

        it('should allow using backreferences with replacement functions', function () {
            expect(utilx.String.replace('aaa', /aa/, function ($0) {
                return $0 + 'b';
            })).to.be('aaba');

            /*jshint -W098 */
            expect(utilx.String.replace('aaa', /a(a)/, function ($0, $1) {
                /*jslint unparam: true */
                /*jshint unused: false */
                return $1 + 'b';
            })).to.be('aba');
            /*jshint +W098 */

            expect(utilx.String.replace('aaa', 'aa', function ($0) {
                return $0 + 'b';
            })).to.be('aaba');
        });

        it('should not substitute tokens returned by replacement functions', function () {
            // Regex search...
            /*jshint -W098 */
            expect(utilx.String.replace('aaa', /a(a)/, function ($0, $1) {
                /*jslint unparam: true */
                /*jshint unused: false */
                return '$1';
            })).to.be('$1a');
            /*jshint +W098 */

            expect(utilx.String.replace('aaa', /a/, function () {
                return '$&';
            })).to.be('$&aa');
        });

        it('should allow using the match position within replacement functions', function () {
            /*jshint -W098 */
            expect(utilx.String.replace('xaaa', /a/, function ($0, pos) {
                /*jslint unparam: true */
                /*jshint unused: false */
                return required.ToString(pos);
            })).to.be('x1aa');

            expect(utilx.String.replace('xaaa', /a/g, function ($0, pos) {
                /*jslint unparam: true */
                /*jshint unused: false */
                return required.ToString(pos);
            })).to.be('x123');

            expect(utilx.String.replace('xaaa', /(a)/g, function ($0, $1, pos) {
                /*jslint unparam: true */
                /*jshint unused: false */
                return required.ToString(pos);
            })).to.be('x123');

            expect(utilx.String.replace('xaaa', 'a', function ($0, pos) {
                /*jslint unparam: true */
                /*jshint unused: false */
                return required.ToString(pos);
            })).to.be('x1aa');
            /*jshint +W098 */
        });

        it('should allow using the source string within replacement functions', function () {
            /*jshint -W098 */
            expect(utilx.String.replace('xaaa', /a/, function ($0, pos, str) {
                /*jslint unparam: true */
                /*jshint unused: false */
                return str;
            })).to.be('xxaaaaa');

            expect(utilx.String.replace('xaaa', /(a)/, function ($0, $1, pos, str) {
                /*jslint unparam: true */
                /*jshint unused: false */
                return str;
            })).to.be('xxaaaaa');

            expect(utilx.String.replace('xaaa', 'a', function ($0, pos, str) {
                /*jslint unparam: true */
                /*jshint unused: false */
                return str;
            })).to.be('xxaaaaa');
            /*jshint +W098 */
        });

        it('should return string as the typeof the last argument in replacement functions', function () {
            // NOTE: This tests a fix for IE < 9, which doesn't get this correct natively

            /*jshint -W098 */
            expect(utilx.String.replace('100', /0/, function ($0, pos, str) {
                /*jslint unparam: true */
                /*jshint unused: false */
                return typeof str;
            })).to.be('1string0');

            /*jshint -W053 */
            expect(utilx.String.replace(new required.String('100'), /0/, function ($0, pos, str) {
                /*jslint unparam: true */
                /*jshint unused: false */
                return typeof str;
            })).to.be('1string0');
            /*jshint +W053 */

            expect(utilx.String.replace(100, /0/, function ($0, pos, str) {
                /*jslint unparam: true */
                /*jshint unused: false */
                return typeof str;
            })).to.be('1string0');
            /*jshint +W098 */
        });

        msg = 'should handle nonstring context when using a replacement text token that references the subject text';
        it(msg, function () {
            expect(utilx.String.replace(0, /^/, '$`')).to.be('0');
        });

        it('should not modify the lastIndex of a nonglobal regex', function () {
            var regex = /x/;

            utilx.String.replace('123x567', regex, '_');
            expect(regex.lastIndex).to.be(0);

            regex.lastIndex = 1;
            utilx.String.replace('123x567', regex, '_');
            expect(regex.lastIndex).to.be(1);

            utilx.String.replace('nomatch', regex, '_');
            expect(regex.lastIndex).to.be(1);
        });

        it('should reset the lastIndex of a global regex to 0', function () {
            var regex = /x/g;

            regex.lastIndex = 1;
            utilx.String.replace('123x567', regex, '_');
            expect(regex.lastIndex).to.be(0);

            regex.lastIndex = 1;
            utilx.String.replace('nomatch', regex, '_');
            expect(regex.lastIndex).to.be(0);
        });

        it('should ignore lastIndex when setting the search start position', function () {
            required.forEach([/x/, /x/g], function (regex) {
                regex.lastIndex = 5;
                expect(utilx.String.replace('123x567', regex, '_')).to.be('123_567');
            });
        });

        it('should update lastIndex during replacement iterations', function () {
            var regex = /x/g,
                interimLastIndex = 0;

            utilx.String.replace('1x2', regex, function () {
                interimLastIndex = regex.lastIndex;
            });

            expect(interimLastIndex).to.be(2);
        });

        it('should convert any provided nonstring search to a string', function () {
            var values = [{
                target: '10x10',
                search: 10,
                replacement: 'x',
                expected: 'xx10'
            }, {
                target: 'xaaa,ba,b',
                search: ['a', 'b'],
                replacement: 'x',
                expected: 'xaaxa,b'
            }, {
                target: 'undefined',
                search: undefined,
                replacement: 'x',
                expected: 'x'
            }];

            required.forEach(values, function (value) {
                expect(utilx.String.replace(value.target, value.search, value.replacement)).to.be(value.expected);
            });

            // Implicit undefined search and replacement
            expect(utilx.String.replace('undefined')).to.be('undefined');
        });

        it('should convert any provided nonstring/nonfunction replacement to a string', function () {
            var values = [{
                target: 'xaaa',
                search: /a/g,
                replacement: 1.1,
                expected: 'x1.11.11.1'
            }, {
                target: 'xaaa',
                search: /a/g,
                replacement: ['a', 'b'],
                expected: 'xa,ba,ba,b'
            }, {
                target: 'x',
                search: /x/,
                replacement: /x/,
                expected: '/x/'
            }, {
                target: 'xaaa',
                search: /a/,
                replacement: undefined,
                expected: 'xundefinedaa'
            }];

            required.forEach(values, function (value) {
                expect(utilx.String.replace(value.target, value.search, value.replacement)).to.be(value.expected);
            });

            // Implicit undefined replacement
            expect(utilx.String.replace('xaaa', /a/)).to.be('xundefinedaa');
        });

        it('should convert any nonstring context to a string (except null and undefined)', function () {
            var values = [
                100,
                {},
                true,
                false,
                NaN,
                ['a']
            ];

            required.forEach(values, function (value) {
                expect(utilx.String.replace(value, /^/, 'x')).to.be('x' + value);
            });
        });

        /*
        msg = 'should throw an exception when called on null or undefined context, if strict mode is supported';
        it(msg, function () {
            required.forEach([null, undefined], function (value) {
                // This doesn't work the same when strict mode isn't supported, because the replace
                // method will be called with the global object (window) as its context, rather
                // than null or undefined
                if (hasStrictMode) {
                    expect(function () {
                        utilx.String.replace(value, /^/, '');
                    }).to.throwException(function (e) {
                        expect(e).to.be.a(TypeError);
                    });
                } else {
                    // Keep the assertion count consistent cross-browser
                    expect(hasStrictMode).to.not.be.ok();
                }
            });
        });
        */
    });
}());

},{"../scripts/":10}],155:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.replaceAll', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.replaceAll();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.replaceAll(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.replaceAll(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should replace all matches', function () {
            expect(utilx.String.replaceAll('aaa', 'a')).to.be('');
            expect(utilx.String.replaceAll('aaa', 'a', undefined)).to.be('');
            expect(utilx.String.replaceAll('aaa', 'a', null)).to.be('');
            expect(utilx.String.replaceAll('acaacaac', 'ac')).to.be('aa');
            expect(utilx.String.replaceAll('aaa', 'a', 'b')).to.be('bbb');
            expect(utilx.String.replaceAll('acaacaac', 'ac', 'b')).to.be('babab');
            expect(utilx.String.replaceAll('aaa', utilx.Object.ToObject('a'), utilx.Object.ToObject('b'))).to.be('bbb');
            expect(utilx.String.replaceAll('acaacaac', utilx.Object.ToObject('ac'), utilx.Object.ToObject('b'))).to.be('babab');
            expect(utilx.String.replaceAll('aaa', /a/, 'b')).to.be('bbb');
            expect(utilx.String.replaceAll('acaacaac', /ac/, 'b')).to.be('babab');
            expect(utilx.String.replaceAll('aaa', 'a', [])).to.be('');
            expect(utilx.String.replaceAll('aaa', 'a', {})).to.be('');
            expect(utilx.String.replaceAll('aaa', 'a', true)).to.be('');
        });
    });
}());

},{"../scripts/":10}],156:[function(require,module,exports){
/*global describe, it, require */

/*property
    String, Object, a, be, eql, expect, returnArgs, search, keys, length, not,
    throwException, to, utilx, noop, '0', '1', '2', '3', '4', '5', '6', '7',
    source, global, multiline, ignoreCase, lastIndex
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.search', function () {
        var testStr = 'abcdefgabcdefgabcdefg';

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.search();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.search(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.search(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an TypeError if argument is primitive', function () {
            var index;

            expect(function () {
                index = utilx.String.search(42);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.search(true);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.search('abc');
            }).to.not.throwException();

            expect(index).to.be(0);
        });

        it('should not throw an TypeError if argument is an object', function () {
            var index;

            expect(function () {
                index = utilx.String.search({});
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.search([]);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.search(required.noop);
            }).to.not.throwException();

            expect(index).to.be(0);
        });

        it('should return 0 if search undefined', function () {
            var index;

            expect(function () {
                index = utilx.String.search(testStr);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.search(testStr, undefined);
            }).to.not.throwException();

            expect(index).to.be(0);
        });

        it('should return -1 if search not found', function () {
            var index;

            expect(function () {
                index = utilx.String.search(testStr, null);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.search(testStr, 0);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.search(testStr, 10);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.search(testStr, true);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return correct index with string argument', function () {
            var index;

            expect(function () {
                index = utilx.String.search(testStr, 'a');
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.search(testStr, 'b');
            }).to.not.throwException();

            expect(index).to.be(1);

            expect(function () {
                index = utilx.String.search(testStr, 'c');
            }).to.not.throwException();

            expect(index).to.be(2);

            expect(function () {
                index = utilx.String.search('', 'a');
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.search('', 'b');
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.search('', 'c');
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return correct index with regex argument', function () {
            var index;

            expect(function () {
                index = utilx.String.search(testStr, /a/);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.search(testStr, /b/);
            }).to.not.throwException();

            expect(index).to.be(1);

            expect(function () {
                index = utilx.String.search(testStr, /c/);
            }).to.not.throwException();

            expect(index).to.be(2);

            expect(function () {
                index = utilx.String.search('', /a/);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.search('', /b/);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.search('', /c/);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should be same index for string and regex searches', function () {
            var indexS,
                indexR;

            expect(function () {
                indexS = utilx.String.search(testStr, 'a');
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.search(testStr, /a/);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            expect(function () {
                indexS = utilx.String.search(testStr, 'b');
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.search(testStr, /b/);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            expect(function () {
                indexS = utilx.String.search(testStr, 'c');
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.search(testStr, /c/);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);
        });

        it('should return correct index with empty strings', function () {
            var index;

            expect(function () {
                index = utilx.String.search('', '');
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.search('', {});
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.search('', []);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.search('', required.noop);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.search(testStr, '');
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.search(testStr, {});
            }).to.not.throwException();

            expect(index).to.be(1);

            expect(function () {
                index = utilx.String.search(testStr, []);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.search(testStr, required.noop);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should not throw an TypeError if search argument is an object', function () {
            var index;

            expect(function () {
                index = utilx.String.search(testStr, {});
            }).to.not.throwException();

            expect(index).to.be(1);

            expect(function () {
                index = utilx.String.search(testStr, []);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.search(testStr, required.noop);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should not alter the original regex', function () {
            var rx1 = new RegExp('c'),
                rx2 = new RegExp('c', 'gmi'),
                index;

            expect(function () {
                index = utilx.String.search(testStr, rx1);
            }).to.not.throwException();

            expect(index).to.be(2);
            expect(rx1.source).to.be('c');
            expect(rx1.global).to.be(false);
            expect(rx1.ignoreCase).to.be(false);
            expect(rx1.multiline).to.be(false);
            expect(rx1.lastIndex).to.be(0);

            expect(function () {
                index = utilx.String.search(testStr, rx1);
            }).to.not.throwException();

            expect(index).to.be(2);
            expect(rx1.source).to.be('c');
            expect(rx1.global).to.be(false);
            expect(rx1.ignoreCase).to.be(false);
            expect(rx1.multiline).to.be(false);
            expect(rx1.lastIndex).to.be(0);

            expect(function () {
                index = utilx.String.search(testStr, rx2);
            }).to.not.throwException();

            expect(index).to.be(2);
            expect(rx2.source).to.be('c');
            expect(rx2.global).to.be(true);
            expect(rx2.ignoreCase).to.be(true);
            expect(rx2.multiline).to.be(true);
            expect(rx2.lastIndex).to.be(0);

            expect(function () {
                index = utilx.String.search(testStr, rx2);
            }).to.not.throwException();

            expect(index).to.be(2);
            expect(rx2.source).to.be('c');
            expect(rx2.global).to.be(true);
            expect(rx2.ignoreCase).to.be(true);
            expect(rx2.multiline).to.be(true);
            expect(rx2.lastIndex).to.be(0);

            rx2.lastIndex = 10;
            expect(function () {
                index = utilx.String.search(testStr, rx2);
            }).to.not.throwException();

            expect(index).to.be(2);
            expect(rx2.source).to.be('c');
            expect(rx2.global).to.be(true);
            expect(rx2.ignoreCase).to.be(true);
            expect(rx2.multiline).to.be(true);
            expect(rx2.lastIndex).to.be(10);

            expect(function () {
                index = utilx.String.search(testStr, rx2);
            }).to.not.throwException();

            expect(index).to.be(2);
            expect(rx2.source).to.be('c');
            expect(rx2.global).to.be(true);
            expect(rx2.ignoreCase).to.be(true);
            expect(rx2.multiline).to.be(true);
            expect(rx2.lastIndex).to.be(10);
        });
    });
}());

},{"../scripts/":10}],157:[function(require,module,exports){
/*global describe, it, require */

/*property
    String, Object, a, be, eql, expect, returnArgs, searchLastOf, keys, length, not,
    throwException, to, utilx, noop, '0', '1', '2', '3', '4', '5', '6', '7',
    source, global, multiline, ignoreCase, lastIndex
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.searchLastOf', function () {
        var testStr = 'abcdefgabcdefgabcdefg';

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.searchLastOf();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.searchLastOf(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.searchLastOf(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an TypeError if argument is primitive', function () {
            var index;

            expect(function () {
                index = utilx.String.searchLastOf(42);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(true);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf('abc');
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should not throw an TypeError if argument is an object', function () {
            var index;

            expect(function () {
                index = utilx.String.searchLastOf({});
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf([]);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(required.noop);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return -1 if searchLastOf undefined', function () {
            var index;

            expect(function () {
                index = utilx.String.searchLastOf(testStr);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, undefined);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return -1 if searchLastOf not found', function () {
            var index;

            expect(function () {
                index = utilx.String.searchLastOf(testStr, null);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, 0);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, 10);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, true);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return correct index with string argument', function () {
            var index;

            expect(function () {
                index = utilx.String.searchLastOf(testStr, 'a');
            }).to.not.throwException();

            expect(index).to.be(14);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, 'b');
            }).to.not.throwException();

            expect(index).to.be(15);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, 'c');
            }).to.not.throwException();

            expect(index).to.be(16);

            expect(function () {
                index = utilx.String.searchLastOf('', 'a');
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf('', 'b');
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf('', 'c');
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return correct index with regex argument', function () {
            var index;

            expect(function () {
                index = utilx.String.searchLastOf(testStr, /a/);
            }).to.not.throwException();

            expect(index).to.be(14);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, /b/);
            }).to.not.throwException();

            expect(index).to.be(15);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, /c/);
            }).to.not.throwException();

            expect(index).to.be(16);

            expect(function () {
                index = utilx.String.searchLastOf('', /a/);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf('', /b/);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf('', /c/);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return correct index with string argument and position', function () {
            var index;

            expect(function () {
                index = utilx.String.searchLastOf(testStr, 'a', 0);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, 'b', 0);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, 'c', 0);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, 'a', 6);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, 'b', 6);
            }).to.not.throwException();

            expect(index).to.be(1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, 'c', 6);
            }).to.not.throwException();

            expect(index).to.be(2);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, 'a', -7);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, 'b', -7);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, 'c', -7);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, 'a', -70);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, 'b', -70);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, 'c', -70);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, 'a', 70);
            }).to.not.throwException();

            expect(index).to.be(14);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, 'b', 70);
            }).to.not.throwException();

            expect(index).to.be(15);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, 'c', 70);
            }).to.not.throwException();

            expect(index).to.be(16);
        });

        it('should return correct index with regex argument and position', function () {
            var index;

            expect(function () {
                index = utilx.String.searchLastOf(testStr, /a/, 0);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, /b/, 0);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, /c/, 0);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, /a/, 6);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, /b/, 6);
            }).to.not.throwException();

            expect(index).to.be(1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, /c/, 6);
            }).to.not.throwException();

            expect(index).to.be(2);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, /a/, -7);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, /b/, -7);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, /c/, -7);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, /a/, -70);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, /b/, -70);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, /c/, -70);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, /a/, 70);
            }).to.not.throwException();

            expect(index).to.be(14);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, /b/, 70);
            }).to.not.throwException();

            expect(index).to.be(15);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, /c/, 70);
            }).to.not.throwException();

            expect(index).to.be(16);
        });

        it('should be same index for string and regex searches', function () {
            var fromIndex = 0,
                indexS,
                indexR;

            expect(function () {
                indexS = utilx.String.searchLastOf(testStr, 'a', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchLastOf(testStr, /a/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            expect(function () {
                indexS = utilx.String.searchLastOf(testStr, 'b', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchLastOf(testStr, /b/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            expect(function () {
                indexS = utilx.String.searchLastOf(testStr, 'c', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchLastOf(testStr, /c/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            fromIndex = 6;
            expect(function () {
                indexS = utilx.String.searchLastOf(testStr, 'a', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchLastOf(testStr, /a/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            expect(function () {
                indexS = utilx.String.searchLastOf(testStr, 'b', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchLastOf(testStr, /b/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            expect(function () {
                indexS = utilx.String.searchLastOf(testStr, 'c', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchLastOf(testStr, /c/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            fromIndex = -7;
            expect(function () {
                indexS = utilx.String.searchLastOf(testStr, 'a', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchLastOf(testStr, /a/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            expect(function () {
                indexS = utilx.String.searchLastOf(testStr, 'b', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchLastOf(testStr, /b/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            expect(function () {
                indexS = utilx.String.searchLastOf(testStr, 'c', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchLastOf(testStr, /c/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            fromIndex = -70;
            expect(function () {
                indexS = utilx.String.searchLastOf(testStr, 'a', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchLastOf(testStr, /a/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            expect(function () {
                indexS = utilx.String.searchLastOf(testStr, 'b', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchLastOf(testStr, /b/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            expect(function () {
                indexS = utilx.String.searchLastOf(testStr, 'c', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchLastOf(testStr, /c/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            fromIndex = 70;
            expect(function () {
                indexS = utilx.String.searchLastOf(testStr, 'a', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchLastOf(testStr, /a/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            expect(function () {
                indexS = utilx.String.searchLastOf(testStr, 'b', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchLastOf(testStr, /b/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            expect(function () {
                indexS = utilx.String.searchLastOf(testStr, 'c', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchLastOf(testStr, /c/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);
        });

        it('should return correct index with empty strings', function () {
            var index;

            expect(function () {
                index = utilx.String.searchLastOf('', '');
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf('', '', -1);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf('', '', 4);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf('', '', 6);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf('', {});
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf('', []);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf('', required.noop);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf('', {}, -2);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf('', [], 2);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf('', required.noop, 4);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, '');
            }).to.not.throwException();

            expect(index).to.be(21);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, '', -1);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, '', 4);
            }).to.not.throwException();

            expect(index).to.be(4);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, '', 6);
            }).to.not.throwException();

            expect(index).to.be(6);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, {});
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, []);
            }).to.not.throwException();

            expect(index).to.be(21);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, required.noop);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, {}, -2);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, [], 2);
            }).to.not.throwException();

            expect(index).to.be(2);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, required.noop, 4);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should not throw an TypeError if search argument is an object', function () {
            var index;

            expect(function () {
                index = utilx.String.searchLastOf(testStr, {});
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, []);
            }).to.not.throwException();

            expect(index).to.be(21);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, required.noop);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return index as long as search begins within fromIndex', function () {
            var index;

            expect(function () {
                index = utilx.String.searchLastOf(testStr, 'abcd', 0);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf(testStr,  'abcd', 1);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf(testStr,  'abcd', 2);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, /abcd/, 0);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf(testStr,  /abcd/, 1);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf(testStr,  /abcd/, 2);
            }).to.not.throwException();

            expect(index).to.be(0);
        });

        it('should return -1 if match is after fromIndex', function () {
            var index;

            expect(function () {
                index = utilx.String.searchLastOf(testStr, 'g', 0);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr,  'g', 1);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr,  'g', 2);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, /g/, 0);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr,  /g/, 1);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchLastOf(testStr,  /g/, 2);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should not alter the original regex', function () {
            var rx1 = new RegExp('c'),
                rx2 = new RegExp('c', 'gmi'),
                index;

            expect(function () {
                index = utilx.String.searchLastOf(testStr, rx1, 0);
            }).to.not.throwException();

            expect(index).to.be(-1);
            expect(rx1.source).to.be('c');
            expect(rx1.global).to.be(false);
            expect(rx1.ignoreCase).to.be(false);
            expect(rx1.multiline).to.be(false);
            expect(rx1.lastIndex).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, rx1, 6);
            }).to.not.throwException();

            expect(index).to.be(2);
            expect(rx1.source).to.be('c');
            expect(rx1.global).to.be(false);
            expect(rx1.ignoreCase).to.be(false);
            expect(rx1.multiline).to.be(false);
            expect(rx1.lastIndex).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, rx2, 0);
            }).to.not.throwException();

            expect(index).to.be(-1);
            expect(rx2.source).to.be('c');
            expect(rx2.global).to.be(true);
            expect(rx2.ignoreCase).to.be(true);
            expect(rx2.multiline).to.be(true);
            expect(rx2.lastIndex).to.be(0);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, rx2, 6);
            }).to.not.throwException();

            expect(index).to.be(2);
            expect(rx2.source).to.be('c');
            expect(rx2.global).to.be(true);
            expect(rx2.ignoreCase).to.be(true);
            expect(rx2.multiline).to.be(true);
            expect(rx2.lastIndex).to.be(0);

            rx2.lastIndex = 10;
            expect(function () {
                index = utilx.String.searchLastOf(testStr, rx2, 0);
            }).to.not.throwException();

            expect(index).to.be(-1);
            expect(rx2.source).to.be('c');
            expect(rx2.global).to.be(true);
            expect(rx2.ignoreCase).to.be(true);
            expect(rx2.multiline).to.be(true);
            expect(rx2.lastIndex).to.be(10);

            expect(function () {
                index = utilx.String.searchLastOf(testStr, rx2, 6);
            }).to.not.throwException();

            expect(index).to.be(2);
            expect(rx2.source).to.be('c');
            expect(rx2.global).to.be(true);
            expect(rx2.ignoreCase).to.be(true);
            expect(rx2.multiline).to.be(true);
            expect(rx2.lastIndex).to.be(10);
        });
    });
}());

},{"../scripts/":10}],158:[function(require,module,exports){
/*global describe, it, require */

/*property
    String, Object, a, be, eql, expect, returnArgs, searchOf, keys, length, not,
    throwException, to, utilx, noop, '0', '1', '2', '3', '4', '5', '6', '7',
    source, global, multiline, ignoreCase, lastIndex
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.searchOf', function () {
        var testStr = 'abcdefgabcdefgabcdefg';

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.searchOf();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.searchOf(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.searchOf(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an TypeError if argument is primitive', function () {
            var index;

            expect(function () {
                index = utilx.String.searchOf(42);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf(true);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf('abc');
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should not throw an TypeError if argument is an object', function () {
            var index;

            expect(function () {
                index = utilx.String.searchOf({});
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf([]);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf(required.noop);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return -1 if searchOf undefined', function () {
            var index;

            expect(function () {
                index = utilx.String.searchOf(testStr);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf(testStr, undefined);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return -1 if searchOf not found', function () {
            var index;

            expect(function () {
                index = utilx.String.searchOf(testStr, null);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf(testStr, 0);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf(testStr, 10);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf(testStr, true);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return correct index with string argument', function () {
            var index;

            expect(function () {
                index = utilx.String.searchOf(testStr, 'a');
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchOf(testStr, 'b');
            }).to.not.throwException();

            expect(index).to.be(1);

            expect(function () {
                index = utilx.String.searchOf(testStr, 'c');
            }).to.not.throwException();

            expect(index).to.be(2);

            expect(function () {
                index = utilx.String.searchOf('', 'a');
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf('', 'b');
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf('', 'c');
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return correct index with regex argument', function () {
            var index;

            expect(function () {
                index = utilx.String.searchOf(testStr, /a/);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchOf(testStr, /b/);
            }).to.not.throwException();

            expect(index).to.be(1);

            expect(function () {
                index = utilx.String.searchOf(testStr, /c/);
            }).to.not.throwException();

            expect(index).to.be(2);

            expect(function () {
                index = utilx.String.searchOf('', /a/);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf('', /b/);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf('', /c/);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return correct index with string argument and position', function () {
            var index;

            expect(function () {
                index = utilx.String.searchOf(testStr, 'a', 0);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchOf(testStr, 'b', 0);
            }).to.not.throwException();

            expect(index).to.be(1);

            expect(function () {
                index = utilx.String.searchOf(testStr, 'c', 0);
            }).to.not.throwException();

            expect(index).to.be(2);

            expect(function () {
                index = utilx.String.searchOf(testStr, 'a', 6);
            }).to.not.throwException();

            expect(index).to.be(7);

            expect(function () {
                index = utilx.String.searchOf(testStr, 'b', 6);
            }).to.not.throwException();

            expect(index).to.be(8);

            expect(function () {
                index = utilx.String.searchOf(testStr, 'c', 6);
            }).to.not.throwException();

            expect(index).to.be(9);

            expect(function () {
                index = utilx.String.searchOf(testStr, 'a', -7);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchOf(testStr, 'b', -7);
            }).to.not.throwException();

            expect(index).to.be(1);

            expect(function () {
                index = utilx.String.searchOf(testStr, 'c', -7);
            }).to.not.throwException();

            expect(index).to.be(2);

            expect(function () {
                index = utilx.String.searchOf(testStr, 'a', -70);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchOf(testStr, 'b', -70);
            }).to.not.throwException();

            expect(index).to.be(1);

            expect(function () {
                index = utilx.String.searchOf(testStr, 'c', -70);
            }).to.not.throwException();

            expect(index).to.be(2);

            expect(function () {
                index = utilx.String.searchOf(testStr, 'a', 70);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf(testStr, 'b', 70);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf(testStr, 'c', 70);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return correct index with regex argument and position', function () {
            var index;

            expect(function () {
                index = utilx.String.searchOf(testStr, /a/, 0);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchOf(testStr, /b/, 0);
            }).to.not.throwException();

            expect(index).to.be(1);

            expect(function () {
                index = utilx.String.searchOf(testStr, /c/, 0);
            }).to.not.throwException();

            expect(index).to.be(2);

            expect(function () {
                index = utilx.String.searchOf(testStr, /a/, 6);
            }).to.not.throwException();

            expect(index).to.be(7);

            expect(function () {
                index = utilx.String.searchOf(testStr, /b/, 6);
            }).to.not.throwException();

            expect(index).to.be(8);

            expect(function () {
                index = utilx.String.searchOf(testStr, /c/, 6);
            }).to.not.throwException();

            expect(index).to.be(9);

            expect(function () {
                index = utilx.String.searchOf(testStr, /a/, -7);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchOf(testStr, /b/, -7);
            }).to.not.throwException();

            expect(index).to.be(1);

            expect(function () {
                index = utilx.String.searchOf(testStr, /c/, -7);
            }).to.not.throwException();

            expect(index).to.be(2);

            expect(function () {
                index = utilx.String.searchOf(testStr, /a/, -70);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchOf(testStr, /b/, -70);
            }).to.not.throwException();

            expect(index).to.be(1);

            expect(function () {
                index = utilx.String.searchOf(testStr, /c/, -70);
            }).to.not.throwException();

            expect(index).to.be(2);

            expect(function () {
                index = utilx.String.searchOf(testStr, /a/, 70);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf(testStr, /b/, 70);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf(testStr, /c/, 70);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should be same index for string and regex searches', function () {
            var fromIndex = 0,
                indexS,
                indexR;

            expect(function () {
                indexS = utilx.String.searchOf(testStr, 'a', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchOf(testStr, /a/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            expect(function () {
                indexS = utilx.String.searchOf(testStr, 'b', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchOf(testStr, /b/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            expect(function () {
                indexS = utilx.String.searchOf(testStr, 'c', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchOf(testStr, /c/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            fromIndex = 6;
            expect(function () {
                indexS = utilx.String.searchOf(testStr, 'a', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchOf(testStr, /a/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            expect(function () {
                indexS = utilx.String.searchOf(testStr, 'b', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchOf(testStr, /b/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            expect(function () {
                indexS = utilx.String.searchOf(testStr, 'c', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchOf(testStr, /c/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            fromIndex = -7;
            expect(function () {
                indexS = utilx.String.searchOf(testStr, 'a', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchOf(testStr, /a/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            expect(function () {
                indexS = utilx.String.searchOf(testStr, 'b', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchOf(testStr, /b/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            expect(function () {
                indexS = utilx.String.searchOf(testStr, 'c', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchOf(testStr, /c/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            fromIndex = -70;
            expect(function () {
                indexS = utilx.String.searchOf(testStr, 'a', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchOf(testStr, /a/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            expect(function () {
                indexS = utilx.String.searchOf(testStr, 'b', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchOf(testStr, /b/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            expect(function () {
                indexS = utilx.String.searchOf(testStr, 'c', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchOf(testStr, /c/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            fromIndex = 70;
            expect(function () {
                indexS = utilx.String.searchOf(testStr, 'a', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchOf(testStr, /a/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            expect(function () {
                indexS = utilx.String.searchOf(testStr, 'b', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchOf(testStr, /b/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);

            expect(function () {
                indexS = utilx.String.searchOf(testStr, 'c', fromIndex);
            }).to.not.throwException();

            expect(function () {
                indexR = utilx.String.searchOf(testStr, /c/, fromIndex);
            }).to.not.throwException();

            expect(indexS).to.be(indexR);
        });

        it('should return correct index with empty strings', function () {
            var index;

            expect(function () {
                index = utilx.String.searchOf('', '');
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchOf('', '', -1);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchOf('', '', 4);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchOf('', '', 6);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchOf('', {});
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf('', []);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchOf('', required.noop);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf('', {}, -2);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf('', [], 2);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchOf('', required.noop, 4);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf(testStr, '');
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchOf(testStr, '', -1);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchOf(testStr, '', 4);
            }).to.not.throwException();

            expect(index).to.be(4);

            expect(function () {
                index = utilx.String.searchOf(testStr, '', 6);
            }).to.not.throwException();

            expect(index).to.be(6);

            expect(function () {
                index = utilx.String.searchOf(testStr, {});
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf(testStr, []);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchOf(testStr, required.noop);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf(testStr, {}, -2);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf(testStr, [], 2);
            }).to.not.throwException();

            expect(index).to.be(2);

            expect(function () {
                index = utilx.String.searchOf(testStr, required.noop, 4);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should not throw an TypeError if search argument is an object', function () {
            var index;

            expect(function () {
                index = utilx.String.searchOf(testStr, {});
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf(testStr, []);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchOf(testStr, required.noop);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should return index as long as search begins within fromIndex', function () {
            var index;

            expect(function () {
                index = utilx.String.searchOf(testStr, 'abcd', 0);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchOf(testStr,  'abcd', 1);
            }).to.not.throwException();

            expect(index).to.be(7);

            expect(function () {
                index = utilx.String.searchOf(testStr,  'abcd', 2);
            }).to.not.throwException();

            expect(index).to.be(7);

            expect(function () {
                index = utilx.String.searchOf(testStr, /abcd/, 0);
            }).to.not.throwException();

            expect(index).to.be(0);

            expect(function () {
                index = utilx.String.searchOf(testStr,  /abcd/, 1);
            }).to.not.throwException();

            expect(index).to.be(7);

            expect(function () {
                index = utilx.String.searchOf(testStr,  /abcd/, 2);
            }).to.not.throwException();

            expect(index).to.be(7);
        });

        it('should return -1 if no match after fromIndex', function () {
            var index;

            expect(function () {
                index = utilx.String.searchOf(testStr, 'a', 15);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf(testStr,  'b', 16);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf(testStr,  'c', 17);
            }).to.not.throwException();

            expect(function () {
                index = utilx.String.searchOf(testStr, /a/, 15);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf(testStr,  /b/, 16);
            }).to.not.throwException();

            expect(index).to.be(-1);

            expect(function () {
                index = utilx.String.searchOf(testStr,  /c/, 17);
            }).to.not.throwException();

            expect(index).to.be(-1);
        });

        it('should not alter the original regex', function () {
            var rx1 = new RegExp('c'),
                rx2 = new RegExp('c', 'gmi'),
                index;

            expect(function () {
                index = utilx.String.searchOf(testStr, rx1, 0);
            }).to.not.throwException();

            expect(index).to.be(2);
            expect(rx1.source).to.be('c');
            expect(rx1.global).to.be(false);
            expect(rx1.ignoreCase).to.be(false);
            expect(rx1.multiline).to.be(false);
            expect(rx1.lastIndex).to.be(0);

            expect(function () {
                index = utilx.String.searchOf(testStr, rx1, 6);
            }).to.not.throwException();

            expect(index).to.be(9);
            expect(rx1.source).to.be('c');
            expect(rx1.global).to.be(false);
            expect(rx1.ignoreCase).to.be(false);
            expect(rx1.multiline).to.be(false);
            expect(rx1.lastIndex).to.be(0);

            expect(function () {
                index = utilx.String.searchOf(testStr, rx2, 0);
            }).to.not.throwException();

            expect(index).to.be(2);
            expect(rx2.source).to.be('c');
            expect(rx2.global).to.be(true);
            expect(rx2.ignoreCase).to.be(true);
            expect(rx2.multiline).to.be(true);
            expect(rx2.lastIndex).to.be(0);

            expect(function () {
                index = utilx.String.searchOf(testStr, rx2, 6);
            }).to.not.throwException();

            expect(index).to.be(9);
            expect(rx2.source).to.be('c');
            expect(rx2.global).to.be(true);
            expect(rx2.ignoreCase).to.be(true);
            expect(rx2.multiline).to.be(true);
            expect(rx2.lastIndex).to.be(0);

            rx2.lastIndex = 10;
            expect(function () {
                index = utilx.String.searchOf(testStr, rx2, 0);
            }).to.not.throwException();

            expect(index).to.be(2);
            expect(rx2.source).to.be('c');
            expect(rx2.global).to.be(true);
            expect(rx2.ignoreCase).to.be(true);
            expect(rx2.multiline).to.be(true);
            expect(rx2.lastIndex).to.be(10);

            expect(function () {
                index = utilx.String.searchOf(testStr, rx2, 6);
            }).to.not.throwException();

            expect(index).to.be(9);
            expect(rx2.source).to.be('c');
            expect(rx2.global).to.be(true);
            expect(rx2.ignoreCase).to.be(true);
            expect(rx2.multiline).to.be(true);
            expect(rx2.lastIndex).to.be(10);
        });
    });
}());

},{"../scripts/":10}],159:[function(require,module,exports){
/*global Boolean, Number, describe, it, require */

/*properties
    String, a, be, expect, noop, slice, to, toString, throwException, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.slice', function () {
        it('should throw', function () {
            expect(function () {
                utilx.String.slice();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.String.slice(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.String.slice(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('basic', function () {
            expect(utilx.String.slice(-1)).to.be('-1');
            expect(utilx.String.slice(0)).to.be('0');
            expect(utilx.String.slice(1)).to.be('1');
            expect(utilx.String.slice(Number(1))).to.be('1');
            expect(utilx.String.slice(false)).to.be('false');
            expect(utilx.String.slice(true)).to.be('true');
            expect(utilx.String.slice(Boolean(true))).to.be('true');
            expect(utilx.String.slice('')).to.be('');
            expect(utilx.String.slice('abc')).to.be('abc');
            expect(utilx.String.slice(required.String('abc'))).to.be('abc');
            expect(utilx.String.slice(required.noop)).to.be(required.noop.toString());
        });

        it('start', function () {
            expect(utilx.String.slice('abcdef')).to.be('abcdef');
            expect(utilx.String.slice('abcdef', null)).to.be('abcdef');
            expect(utilx.String.slice('abcdef', undefined)).to.be('abcdef');

            expect(utilx.String.slice('abcdef', 1)).to.be('bcdef');
            expect(utilx.String.slice('abcdef', 3)).to.be('def');
            expect(utilx.String.slice('abcdef', 5)).to.be('f');
            expect(utilx.String.slice('abcdef', 7)).to.be('');

            expect(utilx.String.slice('abcdef', -1)).to.be('f');
            expect(utilx.String.slice('abcdef', -3)).to.be('def');
            expect(utilx.String.slice('abcdef', -5)).to.be('bcdef');
            expect(utilx.String.slice('abcdef', -7)).to.be('abcdef');
        });

        it('start and end', function () {
            expect(utilx.String.slice('abcdef', 1, null)).to.be('');
            expect(utilx.String.slice('abcdef', 1, undefined)).to.be('bcdef');

            expect(utilx.String.slice('abcdef', 0, 0)).to.be('');
            expect(utilx.String.slice('abcdef', 0, 5)).to.be('abcde');
            expect(utilx.String.slice('abcdef', 1, 4)).to.be('bcd');
            expect(utilx.String.slice('abcdef', 5, 6)).to.be('f');
            expect(utilx.String.slice('abcdef', 5, 10)).to.be('f');
            expect(utilx.String.slice('abcdef', 7, 2)).to.be('');

            expect(utilx.String.slice('abcdef', -1, 0)).to.be('');
            expect(utilx.String.slice('abcdef', -1, 6)).to.be('f');
            expect(utilx.String.slice('abcdef', -1, 10)).to.be('f');
            expect(utilx.String.slice('abcdef', -3, 5)).to.be('de');
            expect(utilx.String.slice('abcdef', -5, 4)).to.be('bcd');
            expect(utilx.String.slice('abcdef', -7, 7)).to.be('abcdef');
        });
    });
}());

},{"../scripts/":10}],160:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.split', function () {
        var test,
            msg;

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.split();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.split(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.split(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw on basic tests', function () {
            expect(utilx.String.split('abcdef', '')).to.eql(['a', 'b', 'c', 'd', 'e', 'f']);
            expect(utilx.String.split('abcdefabcdefabcdef', 'c')).to.eql(['ab', 'defab', 'defab', 'def']);
            expect(utilx.String.split('abcdefabcdefabcdef', new RegExp('c'))).to.eql(['ab', 'defab', 'defab', 'def']);
        });

        test = 'ab';

        it('If "separator" is undefined must return Array with one String - "this" string', function () {
            expect(utilx.String.split(test)).to.eql([test]);
            expect(utilx.String.split(test, undefined)).to.eql([test]);
        });

        it('If "separator" is undefined and "limit" set to 0 must return Array[]', function () {
            expect(utilx.String.split(test, undefined, 0)).to.eql([]);
        });

        it('(\'\') results in [\'\']', function () {
            var txt = '';

            expect(utilx.String.split(txt)).to.eql(['']);
        });

        it('(\'\', /./) results in [\'\']', function () {
            var txt = '',
                rx = new RegExp('.');

            expect(utilx.String.split(txt, rx)).to.eql(['']);
        });

        it('(\'\', /.?/) results in []', function () {
            var txt = '',
                rx = new RegExp('.?');

            expect(utilx.String.split(txt, rx)).to.eql([]);
        });

        it('(\'\', /.??/) results in []', function () {
            var txt = '',
                rx = new RegExp('.??');

            expect(utilx.String.split(txt, rx)).to.eql([]);
        });

        it('(\'ab\', /a*/) results in [\'\', \'b\']', function () {
            var txt = 'ab';

            expect(utilx.String.split(txt, /a*/)).to.eql(['', 'b']);
        });

        it('(\'ab\', /a*?/) results in [\'a\', \'b\']', function () {
            var txt = 'ab';

            expect(utilx.String.split(txt, /a*?/)).to.eql(['a', 'b']);
        });

        it('(\'ab\', /(?:ab)/) results in [\'\', \'\']', function () {
            var txt = 'ab';

            expect(utilx.String.split(txt, /(?:ab)/)).to.eql(['', '']);
        });

        it('(\'ab\', /(?:ab)*/) results in [\'\', \'\']', function () {
            var txt = 'ab';

            expect(utilx.String.split(txt, /(?:ab)*/)).to.eql(['', '']);
        });

        it('(\'ab\', /(?:ab)*?/) results in [\'a\', \'b\']', function () {
            var txt = 'ab';

            expect(utilx.String.split(txt, /(?:ab)*?/)).to.eql(['a', 'b']);
        });

        it('(\'test\', \'\') results in [\'t\', \'e\', \'s\', \'t\']', function () {
            var txt = 'test';

            expect(utilx.String.split(txt, '')).to.eql(['t', 'e', 's', 't']);
        });

        it('(\'test\', ) results in [\'test\']', function () {
            var txt = 'test';

            expect(utilx.String.split(txt)).to.eql(['test']);
        });

        it('(\'111\', 1) results in [\'\', \'\', \'\', \'\']', function () {
            var txt = '111';

            expect(utilx.String.split(txt, 1)).to.eql(['', '', '', '']);
        });

        it('(\'test\', /(?:)/, 2) results in [\'t\', \'e\']', function () {
            var txt = 'test';

            expect(utilx.String.split(txt, /(?:)/, 2)).to.eql(['t', 'e']);
        });

        it('(\'test\', /(?:)/, -1) results in []', function () {
            var txt = 'test';

            expect(utilx.String.split(txt, /(?:)/, -1)).to.eql([]);
        });

        it('(\'test\', /(?:)/, undefined) results in [\'t\', \'e\', \'s\', \'t\']', function () {
            var txt = 'test';

            expect(utilx.String.split(txt, /(?:)/, undefined)).to.eql(['t', 'e', 's', 't']);
        });

        it('(\'test\', /(?:)/, null) results in []', function () {
            var txt = 'test';

            expect(utilx.String.split(txt, /(?:)/, null)).to.eql([]);
        });

        it('(\'test\', /(?:)/, NaN) results in []', function () {
            var txt = 'test';

            expect(utilx.String.split(txt, /(?:)/, NaN)).to.eql([]);
        });

        it('(\'test\', /(?:)/, true) results in [\'t\']', function () {
            var txt = 'test';

            expect(utilx.String.split(txt, /(?:)/, true)).to.eql(['t']);
        });

        it('(\'test\', /(?:)/, \'2\') results in [\'t\', \'e\']', function () {
            var txt = 'test';

            expect(utilx.String.split(txt, /(?:)/, '2')).to.eql(['t', 'e']);
        });

        it('(\'test\', /(?:)/, \'two\') results in []', function () {
            var txt = 'test';

            expect(utilx.String.split(txt, /(?:)/, 'two')).to.eql([]);
        });

        it('(\'a\', /-/) results in [\'a\']', function () {
            var txt = 'a';

            expect(utilx.String.split(txt, /-/)).to.eql(['a']);
        });

        it('(\'a\', /-?/) results in [\'a\']', function () {
            var txt = 'a';

            expect(utilx.String.split(txt, /-?/)).to.eql(['a']);
        });

        it('(\'a\', /-??/) results in [\'a\']', function () {
            var txt = 'a';

            expect(utilx.String.split(txt, /-??/)).to.eql(['a']);
        });

        it('(\'a\', /a/) results in [\'\', \'\']', function () {
            var txt = 'a';

            expect(utilx.String.split(txt, /a/)).to.eql(['', '']);
        });

        it('(\'a\', /a?/) results in [\'\', \'\']', function () {
            var txt = 'a';

            expect(utilx.String.split(txt, /a?/)).to.eql(['', '']);
        });

        it('(\'a\', /a??/) results in [\'a\']', function () {
            var txt = 'a';

            expect(utilx.String.split(txt, /a??/)).to.eql(['a']);
        });

        it('(\'ab\', /-/) results in [\'ab\']', function () {
            var txt = 'ab';

            expect(utilx.String.split(txt, /-/)).to.eql(['ab']);
        });

        it('(\'ab\', /-?/) results in [\'a\', \'b\']', function () {
            var txt = 'ab';

            expect(utilx.String.split(txt, /-?/)).to.eql(['a', 'b']);
        });

        it('(\'ab\', /-??/) results in [\'a\', \'b\']', function () {
            var txt = 'ab';

            expect(utilx.String.split(txt, /-??/)).to.eql(['a', 'b']);
        });

        it('(\'a-b\', /-/) results in [\'a\', \'b\']', function () {
            var txt = 'a-b';

            expect(utilx.String.split(txt, /-/)).to.eql(['a', 'b']);
        });

        it('(\'a-b\', /-?/) results in [\'a\', \'b\']', function () {
            var txt = 'a-b';

            expect(utilx.String.split(txt, /-?/)).to.eql(['a', 'b']);
        });

        it('(\'a-b\', /-??/) results in [\'a\', \'-\', \'b\']', function () {
            var txt = 'a-b';

            expect(utilx.String.split(txt, /-??/)).to.eql(['a', '-', 'b']);
        });

        it('(\'a--b\', /-/) results in [\'a\', \'\', \'b\']', function () {
            var txt = 'a--b';

            expect(utilx.String.split(txt, /-/)).to.eql(['a', '', 'b']);
        });

        it('(\'a--b\', /-?/) results in [\'a\', \'\', \'b\']', function () {
            var txt = 'a--b';

            expect(utilx.String.split(txt, /-?/)).to.eql(['a', '', 'b']);
        });

        it('(\'a--b\', /-??/) results in [\'a\', \'-\', \'-\', \'b\']', function () {
            var txt = 'a--b';

            expect(utilx.String.split(txt, /-??/)).to.eql(['a', '-', '-', 'b']);
        });

        it('(\'\', /()()/) results in []', function () {
            var txt = '';

            expect(utilx.String.split(txt, /()()/)).to.eql([]);
        });

        it('(\'.\', /()()/) results in [\'.\']', function () {
            var txt = '.';

            expect(utilx.String.split(txt, /()()/)).to.eql(['.']);
        });

        it('(\'.\', /(.?)(.?)/) results in [\'\', \'.\', \'\', \'\']', function () {
            var txt = '.',
                rx = new RegExp('(.?)(.?)');

            expect(utilx.String.split(txt, rx)).to.eql(['', '.', '', '']);
        });

        it('(\'.\', /(.??)(.??)/) results in [\'.\']', function () {
            var txt = '.',
                rx = new RegExp('(.??)(.??)');

            expect(utilx.String.split(txt, rx)).to.eql(['.']);
        });

        it('(\'.\', /(.)?(.)?/) results in [\'\', \'.\', undefined, \'\']', function () {
            var txt = '.',
                rx = new RegExp('(.)?(.)?');

            expect(utilx.String.split(txt, rx)).to.eql(required.create('', '.', undefined, ''));
        });

        msg = '(\'A<B>bold</B>and<CODE>coded</CODE>\', /<(\\/)?([^<>]+)>/) results in [\'A\', undefined, ' +
            '\'B\', \'bold\', \'/\', \'B\', \'and\', undefined, \'CODE\', \'coded\', \'/\', \'CODE\', \'\']';
        it(msg, function () {
            var txt = 'A<B>bold</B>and<CODE>coded</CODE>',
                rx = new RegExp('<(\\/)?([^<>]+)>');

            expect(utilx.String.split(txt, rx))
                .to.eql(required.create(
                    'A',
                    undefined,
                    'B',
                    'bold',
                    '/',
                    'B',
                    'and',
                    undefined,
                    'CODE',
                    'coded',
                    '/',
                    'CODE',
                    ''
                ));
        });

        it('(\'test\', /(s)*/) results in [\'t\', undefined, \'e\', \'s\', \'t\']', function () {
            var txt = 'tesst';

            expect(utilx.String.split(txt, /(s)*/)).to.eql(required.create(
                't',
                undefined,
                'e',
                's',
                't'
            ));
        });

        msg = '(\'test\', /(s)*?/) results in [\'t\', undefined, \'e\',' +
            'undefined, \'s\', undefined, \'s\', undefined, \'t\']';
        it(msg, function () {
            var txt = 'tesst';

            expect(utilx.String.split(txt, /(s)*?/))
                .to.eql(required.create(
                    't',
                    undefined,
                    'e',
                    undefined,
                    's',
                    undefined,
                    's',
                    undefined,
                    't'
                ));
        });

        it('(\'test\', /(s*)/) results in [\'t\', \'\', \'e\', \'ss\', \'t\']', function () {
            var txt = 'tesst';

            expect(utilx.String.split(txt, /(s*)/)).to.eql(['t', '', 'e', 'ss', 't']);
        });


        msg = '(\'test\', /(s*?)/) results in [\'t\', \'\', \'e\', \'\', \'s\', \'\', \'s\', \'\', \'t\']';
        it(msg, function () {
            var txt = 'tesst';

            expect(utilx.String.split(txt, /(s*?)/)).to.eql(['t', '', 'e', '', 's', '', 's', '', 't']);
        });

        it('(\'test\', /(?:s)*/) results in [\'t\', \'e\', \'t\']', function () {
            var txt = 'tesst';

            expect(utilx.String.split(txt, /(?:s)*/)).to.eql(['t', 'e', 't']);
        });

        it('(\'test\', /(?=s+)/) results in [\'te\', \'s\', \'st\']', function () {
            var txt = 'tesst';

            expect(utilx.String.split(txt, /(?=s+)/)).to.eql(['te', 's', 'st']);
        });

        it('(\'test\', \'t\') results in [\'\', \'es\', \'\']', function () {
            var txt = 'test';

            expect(utilx.String.split(txt, 't')).to.eql(['', 'es', '']);
        });

        it('(\'test\', \'es\') results in [\'t\', \'t\']', function () {
            var txt = 'test';

            expect(utilx.String.split(txt, 'es')).to.eql(['t', 't']);
        });

        it('(\'test\', /t/) results in [\'\', \'es\', \'\']', function () {
            var txt = 'test';

            expect(utilx.String.split(txt, /t/)).to.eql(['', 'es', '']);
        });

        it('(\'test\', /es/) results in [\'t\', \'t\']', function () {
            var txt = 'test';

            expect(utilx.String.split(txt, /es/)).to.eql(['t', 't']);
        });

        it('(\'test\', /(t)/) results in [\'\', \'t\', \'es\', \'t\', \'\']', function () {
            var txt = 'test';

            expect(utilx.String.split(txt, /(t)/)).to.eql(['', 't', 'es', 't', '']);
        });

        it('(\'test\', /(es)/) results in [\'t\', \'es\', \'t\']', function () {
            var txt = 'test';

            expect(utilx.String.split(txt, /(es)/)).to.eql(['t', 'es', 't']);
        });

        it('(\'test\', /(t)(e)(s)(t)/) results in [\'\', \'t\', \'e\', \'s\', \'t\', \'\']', function () {
            var txt = 'test';

            expect(utilx.String.split(txt, /(t)(e)(s)(t)/)).to.eql(['', 't', 'e', 's', 't', '']);
        });

        it('(\'.\', /(((.((.??)))))/) results in [\'\', \'.\', \'.\', \'.\', \'\', \'\', \'\']', function () {
            var txt = '.',
                rx = new RegExp('(((.((.??)))))');

            expect(utilx.String.split(txt, rx)).to.eql(['', '.', '.', '.', '', '', '']);
        });

        it('(\'.\', /(((((.??)))))/) results in [\'.\']', function () {
            var txt = '.',
                rx = new RegExp('(((((.??)))))');

            expect(utilx.String.split(txt, rx)).to.eql(['.']);
        });

        it('(\'a b c d\', / /, -(Math.pow(2, 32) - 1)) results in []', function () {
            var txt = 'a b c d';

            expect(utilx.String.split(txt, / /, -(Math.pow(2, 32) - 1))).to.eql([]);
        });

        it('(\'a b c d\', / /, Math.pow(2, 32) + 1) results in []', function () {
            var txt = 'a b c d';

            expect(utilx.String.split(txt, / /, Math.pow(2, 32) + 1)).to.eql(['a', 'b', 'c', 'd']);
        });

        it('(\'a b c d\', / /, Infinity) results in []', function () {
            var txt = 'a b c d';

            expect(utilx.String.split(txt, / /, Infinity)).to.eql(['a', 'b', 'c', 'd']);
        });

        /*
        it('supports sticky flag', function () {
            var text = 'First line\nSecond line',
                regex = new RegExp('(\\S+) line\\n?', 'y'),
                match = regex.exec(text),
                match2,
                match3;

            expect(match[1]).to.be('First');
            expect(regex.lastIndex).to.be(11);

            match2 = regex.exec(text);
            expect(match2[1]).to.be('second');
            expect(regex.lastIndex).to.be(22);

            match3 = regex.exec(text);
            expect(match3 === null).to.be.ok();
        });
        */
    });
}());

},{"../scripts/":10}],161:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.startsWith', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.startsWith();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.startsWith(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.startsWith(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(utilx.String.startsWith('abcdefghijklmnopqrstuvwxyz', 'abc')).to.be.ok();
            expect(utilx.String.startsWith('abcdefghijklmnopqrstuvwxyz', 'xyz')).to.not.be.ok();
            expect(utilx.String.startsWith('abcdefghijklmnopqrstuvwxyz', 'def', 3)).to.be.ok();
            expect(utilx.String.startsWith('abcdefghijklmnopqrstuvwxyz', 'def', 4)).to.not.be.ok();
        });
    });
}());

},{"../scripts/":10}],162:[function(require,module,exports){
/*global Boolean, Number, describe, it, require */

/*properties
    String, a, be, expect, noop, substr, to, toString, throwException, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.substr', function () {
        it('should throw', function () {
            expect(function () {
                utilx.String.substr();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.String.substr(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.String.substr(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('basic', function () {
            expect(utilx.String.substr(-1)).to.be('-1');
            expect(utilx.String.substr(0)).to.be('0');
            expect(utilx.String.substr(1)).to.be('1');
            expect(utilx.String.substr(Number(1))).to.be('1');
            expect(utilx.String.substr(false)).to.be('false');
            expect(utilx.String.substr(true)).to.be('true');
            expect(utilx.String.substr(Boolean(true))).to.be('true');
            expect(utilx.String.substr('')).to.be('');
            expect(utilx.String.substr('abc')).to.be('abc');
            expect(utilx.String.substr(required.String('abc'))).to.be('abc');
            expect(utilx.String.substr(required.noop)).to.be(required.noop.toString());
        });

        it('start', function () {
            expect(utilx.String.substr('abcdef')).to.be('abcdef');
            expect(utilx.String.substr('abcdef', null)).to.be('abcdef');
            expect(utilx.String.substr('abcdef', undefined)).to.be('abcdef');

            expect(utilx.String.substr('abcdef', 1)).to.be('bcdef');
            expect(utilx.String.substr('abcdef', 3)).to.be('def');
            expect(utilx.String.substr('abcdef', 5)).to.be('f');
            expect(utilx.String.substr('abcdef', 7)).to.be('');

            expect(utilx.String.substr('abcdef', -1)).to.be('f');
            expect(utilx.String.substr('abcdef', -3)).to.be('def');
            expect(utilx.String.substr('abcdef', -5)).to.be('bcdef');
            expect(utilx.String.substr('abcdef', -7)).to.be('abcdef');
        });

        it('start and end', function () {
            expect(utilx.String.substr('abcdef', 1, null)).to.be('');
            expect(utilx.String.substr('abcdef', 1, undefined)).to.be('bcdef');

            expect(utilx.String.substr('abcdef', 0, 0)).to.be('');
            expect(utilx.String.substr('abcdef', 0, 5)).to.be('abcde');
            expect(utilx.String.substr('abcdef', 1, 4)).to.be('bcde');
            expect(utilx.String.substr('abcdef', 5, 1)).to.be('f');
            expect(utilx.String.substr('abcdef', 5, 10)).to.be('f');
            expect(utilx.String.substr('abcdef', 7, 2)).to.be('');

            expect(utilx.String.substr('abcdef', -1, 0)).to.be('');
            expect(utilx.String.substr('abcdef', -1, 1)).to.be('f');
            expect(utilx.String.substr('abcdef', -1, 10)).to.be('f');
            expect(utilx.String.substr('abcdef', -3, 2)).to.be('de');
            expect(utilx.String.substr('abcdef', -5, 3)).to.be('bcd');
            expect(utilx.String.substr('abcdef', -7, 7)).to.be('abcdef');
        });
    });
}());

},{"../scripts/":10}],163:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.trim', function () {
        var ws = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u180E\u2000\u2001\u2002\u2003' +
                    '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF',

            test = ws + 'Hello, World!' + ws;

        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.trim();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.trim(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.trim(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should work with strings', function () {
            expect(utilx.String.trim('')).to.be('');
            expect(utilx.String.trim('     ')).to.be('');
            expect(utilx.String.trim('x ')).to.be('x');
            expect(utilx.String.trim(' x')).to.be('x');
            expect(utilx.String.trim(' x ')).to.be('x');
            expect(utilx.String.trim('    x x x    ')).to.be('x x x');
            expect(utilx.String.trim(Object(''))).to.be('');
            expect(utilx.String.trim(Object('     '))).to.be('');
            expect(utilx.String.trim(Object('x '))).to.be('x');
            expect(utilx.String.trim(Object(' x'))).to.be('x');
            expect(utilx.String.trim(Object(' x '))).to.be('x');
            expect(utilx.String.trim(Object('    x x x    '))).to.be('x x x');
        });

        it('should work with numbers', function () {
            expect(utilx.String.trim(1234567890)).to.be('1234567890');
            expect(utilx.String.trim(Object(1234567890))).to.be('1234567890');
        });

        it('trims all ES5 whitespace', function () {
            expect(utilx.String.trim(test)).to.be('Hello, World!');
            expect(utilx.String.trim(test).length).to.be(13);
            expect(utilx.String.trim(Object(test))).to.be('Hello, World!');
            expect(utilx.String.trim(Object(test)).length).to.be(13);
        });

        it('does not have 0x200b bug', function () {
            expect(utilx.String.trim('\u200b')).to.be('\u200b');
        });

        it('does not have 0x0085 bug', function () {
            expect(utilx.String.trim('\u0085')).to.be('\u0085');
        });
    });
}());

},{"../scripts/":10}],164:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.truncate', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.truncate();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.truncate(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.truncate(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(utilx.String.truncate('null', -1)).to.be('null');
            expect(utilx.String.truncate('-1', 1)).to.be('-');
            expect(utilx.String.truncate('0', 0)).to.be('');
            expect(utilx.String.truncate('1', 2)).to.be('1');
            expect(utilx.String.truncate(false, 4)).to.be('fals');
            expect(utilx.String.truncate(true, 4)).to.be('true');
            expect(utilx.String.truncate('null', -1)).to.be('null');
            expect(utilx.String.truncate('null', -Infinity)).to.be('null');
            expect(utilx.String.truncate('null', NaN)).to.be('null');
            expect(utilx.String.truncate('null', Infinity)).to.be('null');
        });
    });
}());

},{"../scripts/":10}],165:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('String.wrapInChars', function () {
        it('should throw if no arguments', function () {
            expect(function () {
                utilx.String.wrapInChars();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is undefined', function () {
            expect(function () {
                utilx.String.wrapInChars(undefined);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should throw if argument is null', function () {
            expect(function () {
                utilx.String.wrapInChars(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });
        });

        it('should not throw an error in each case', function () {
            expect(utilx.String.wrapInChars('a')).to.be('a');
            expect(utilx.String.wrapInChars('a', '')).to.be('a');
            expect(utilx.String.wrapInChars('a', ' ')).to.be(' a ');
            expect(utilx.String.wrapInChars('a', 1)).to.be('1a1');
            expect(utilx.String.wrapInChars('a', 12)).to.be('12a12');
            expect(utilx.String.wrapInChars('a', -1)).to.be('-1a-1');
            expect(utilx.String.wrapInChars('a', utilx.Object.ToObject(' '))).to.be(' a ');
            expect(utilx.String.wrapInChars('a', utilx.Object.ToObject(1))).to.be('1a1');
            expect(utilx.String.wrapInChars('a', [])).to.be('a');
            expect(utilx.String.wrapInChars('a', {})).to.be('a');
            expect(utilx.String.wrapInChars('a', true)).to.be('a');
            expect(utilx.String.wrapInChars('a', utilx.Object.ToObject(false))).to.be('a');
            expect(utilx.String.wrapInChars('a', 'xyz')).to.be('xyzaxyz');
            expect(utilx.String.wrapInChars('a', '\u0021')).to.be('!a!');
        });
    });
}());

},{"../scripts/":10}],166:[function(require,module,exports){
/*global Error, RegExp, SyntaxError, TypeError, describe, it, require */

/*properties
    Object, RegExp, String, a, be, constructor, customError, expect, instanceOf,
    isString, join, message, noop, not, ok, prototype, split, stack, test,
    throwException, to, toString, utilx
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('customError', function () {
        var MyError,
            MySyntaxError;

        it('setting up should not throw an error', function () {
            expect(function () {
                MyError = utilx.customError('MyError');
            }).to.not.throwException();

            expect(MyError.prototype.constructor).to.be(MyError);

            expect(function () {
                MySyntaxError = utilx.customError('MySyntaxError', SyntaxError);
            }).to.not.throwException();

            expect(MySyntaxError.prototype.constructor).to.be(MySyntaxError);
        });

        it('should not throw an error in each case', function () {
            expect(function () {
                utilx.customError();
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.customError(null);
            }).to.throwException(function (e) {
                expect(e).to.be.a(TypeError);
            });

            expect(function () {
                utilx.customError('');
            }).to.throwException(function (e) {
                expect(e).to.be.a(SyntaxError);
            });

            expect(function () {
                utilx.customError('NullError', null);
            }).to.not.throwException();

            expect(function () {
                utilx.customError('FnError', required.noop);
            }).to.not.throwException();

            expect(function () {
                throw new MyError('test');
            }).to.throwException(function (e) {
                expect(utilx.RegExp.test(new RegExp('^MyError: test'), e.toString())).to.be.ok();
            });

            expect(function () {
                throw new MySyntaxError('test');
            }).to.throwException(function (e) {
                expect(utilx.RegExp.test(new RegExp('^MySyntaxError: test'), e.toString())).to.be.ok();
            });

            expect(function () {
                throw new MyError('test');
            }).to.throwException(function (e) {
                expect(e).to.be.a(MyError);
            });

            expect(function () {
                throw new MySyntaxError('test');
            }).to.throwException(function (e) {
                expect(e).to.be.a(MySyntaxError);
            });

            expect(new MyError('test').message).to.be('test');
            expect(function () {
                throw new MyError('test');
            }).to.throwException(function (e) {
                expect(e).to.be.a(Error);
            });

            expect(function () {
                throw new MyError('test');
            }).to.throwException(function (e) {
                expect(e).to.be.a(MyError);
            });

            expect(function () {
                throw new MyError('test');
            }).to.throwException(function (e) {
                expect(e).to.not.be.a(SyntaxError);
            });

            expect(function () {
                throw new MyError('test');
            }).to.throwException(function (e) {
                expect(e).to.not.be.a(TypeError);
            });

            expect(utilx.Object.instanceOf(new MyError('test'), Error)).to.be(true);
            expect(utilx.Object.instanceOf(new MyError('test'), MyError)).to.be(true);
            expect(utilx.Object.instanceOf(new MyError('test'), SyntaxError)).to.be(false);
            expect(utilx.Object.instanceOf(new MyError('test'), TypeError)).to.be(false);

            expect(new MySyntaxError('test').message).to.be('test');
            expect(utilx.Object.instanceOf(new MySyntaxError('test'), Error)).to.be(true);
            expect(utilx.Object.instanceOf(new MySyntaxError('test'), MySyntaxError)).to.be(true);
            expect(utilx.Object.instanceOf(new MySyntaxError('test'), TypeError)).to.be(false);

            expect(function () {
                throw new MyError('test');
            }).to.throwException(function (e) {
                expect(utilx.RegExp.test(new RegExp('^MyError: test'), e.toString())).to.be.ok();
            });
        });

        describe('Detected ', function () {
            var MySyntaxErrorX,
                msex;

            expect(function () {
                MySyntaxErrorX = utilx.customError('MySyntaxError', SyntaxError);
            }).to.not.throwException();

            expect(function () {
                msex = new MySyntaxErrorX('test');
            }).to.not.throwException();

            try {
                if (!utilx.Object.instanceOf(msex, SyntaxError)) {
                    throw msex;
                }

                it('environment supports all Error types', function () {
                    expect(true).to.be(true);
                });
            } catch (e) {
                it('environment supports Error type', function () {
                    expect(utilx.Object.instanceOf(e, Error)).to.be(true);
                });
            }
        });
    });
}());

},{"../scripts/":10}],167:[function(require,module,exports){
/*global Date, Error, RegExp, describe, it, require */

/*properties
    a, be, expect, isFinite, not, ok, throwException, to, toString, utilx, valueOf
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('isFinite', function () {
        it('should not throw an error in each case', function () {
            var zero = 0;

            expect(utilx.isFinite()).to.not.be.ok();
            expect(utilx.isFinite(undefined)).to.not.be.ok();
            expect(utilx.isFinite(null)).to.be.ok();
            expect(utilx.isFinite(1)).to.be.ok();
            expect(utilx.isFinite(Infinity)).to.not.be.ok();
            expect(utilx.isFinite(-Infinity)).to.not.be.ok();
            expect(utilx.isFinite(NaN)).to.not.be.ok();
            expect(utilx.isFinite('')).to.be.ok();
            expect(utilx.isFinite(true)).to.be.ok();
            expect(utilx.isFinite(false)).to.be.ok();
            expect(utilx.isFinite({})).to.not.be.ok();
            expect(utilx.isFinite([])).to.be.ok();
            expect(utilx.isFinite(new RegExp('c'))).to.not.be.ok();
            expect(utilx.isFinite(new Date(2013, 11, 11))).to.be.ok();
            expect(utilx.isFinite(new Error('x'))).to.not.be.ok();
            expect(utilx.isFinite(4)).to.be.ok();
            expect(utilx.isFinite(4.5)).to.be.ok();
            expect(utilx.isFinite('hi')).to.not.be.ok();
            expect(utilx.isFinite('1.3')).to.be.ok();
            expect(utilx.isFinite('51')).to.be.ok();
            expect(utilx.isFinite(0)).to.be.ok();
            expect(utilx.isFinite(-0)).to.be.ok();
            expect(utilx.isFinite({
                valueOf: function () {
                    return 3;
                }
            })).to.be.ok();

            expect(utilx.isFinite({
                valueOf: function () {
                    return zero / zero;
                }
            })).to.not.be.ok();
        });
    });
}());

},{"../scripts/":10}],168:[function(require,module,exports){
/*global Date, Error, Object, RegExp, describe, it, require */

/*properties
    MAX_VALUE, MIN_VALUE, be, expect, isNaN, noop, to, toString, utilx, valueOf
*/

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('isNaN', function () {
        var toObj = Object;

        it('NaN', function () {
            expect(utilx.isNaN(NaN)).to.be(true);
        });

        it('Object(NaN)', function () {
            expect(utilx.isNaN(toObj(NaN))).to.be(true);
        });

        it('No arguments, undefined and null', function () {
            expect(utilx.isNaN()).to.be(true);
            expect(utilx.isNaN(undefined)).to.be(true);
            expect(utilx.isNaN(null)).to.be(false);
        });

        it('numbers', function () {
            expect(utilx.isNaN(Infinity)).to.be(false);
            expect(utilx.isNaN(-Infinity)).to.be(false);
            expect(utilx.isNaN(0)).to.be(false);
            expect(utilx.isNaN(-0)).to.be(false);
            expect(utilx.isNaN(-4)).to.be(false);
            expect(utilx.isNaN(4)).to.be(false);
            expect(utilx.isNaN(4.5)).to.be(false);
            expect(utilx.isNaN(required.MAX_VALUE)).to.be(false);
            expect(utilx.isNaN(required.MIN_VALUE)).to.be(false);
        });

        it('Strings', function () {
            expect(utilx.isNaN('')).to.be(false);
            expect(utilx.isNaN('hi')).to.be(true);
            expect(utilx.isNaN('1.3')).to.be(false);
            expect(utilx.isNaN('51')).to.be(false);
        });

        it('Booleans', function () {
            expect(utilx.isNaN(true)).to.be(false);
            expect(utilx.isNaN(false)).to.be(false);
        });

        it('Functions', function () {
            expect(utilx.isNaN(required.noop)).to.be(true);
        });

        it('Objects', function () {
            expect(utilx.isNaN({})).to.be(true);
            expect(utilx.isNaN([])).to.be(false);
            expect(utilx.isNaN(new RegExp('c'))).to.be(true);
            expect(utilx.isNaN(new Date(2013, 11, 11))).to.be(false);
            expect(utilx.isNaN(new Error('x'))).to.be(true);
        });

        it('Others', function () {
            expect(utilx.isNaN({
                valueOf: function () {
                    return 3;
                }
            })).to.be(false);

            expect(utilx.isNaN({
                valueOf: function () {
                    return Infinity;
                }
            })).to.be(false);
        });
    });
}());

},{"../scripts/":10}],169:[function(require,module,exports){
/*global require, describe, it */

(function () {
    'use strict';

    var required = require('../scripts/'),
        utilx = required.utilx,
        expect = required.expect;

    describe('normaliseErrorIEToString', function () {
        it('should not throw an error in each case', function () {
            var message = 'We want a normalised toString!';

            expect(!utilx.normaliseErrorIEToStringOff()).to.be.ok();
            expect(!utilx.normaliseErrorIEToStringState()).to.be.ok();

            try {
                throw new Error(message);
            } catch (e) {
                if (e.message === message &&
                        e.toString() === '[object Error]') {

                    expect(utilx.normaliseErrorIEToStringOn()).to.be.ok();
                    expect(utilx.normaliseErrorIEToStringState()).to.be.ok();
                }
            }

            expect(function () {
                throw new Error(message);
            }).to.throwException(function (e) {
                expect(e).to.be.a(Error);
                expect(utilx.RegExp.test(new RegExp('^Error: ' + message), e.toString())).to.be.ok();
            });

            expect(!utilx.normaliseErrorIEToStringOff()).to.be.ok();
            expect(!utilx.normaliseErrorIEToStringState()).to.be.ok();
        });
    });
}());

},{"../scripts/":10}]},{},[11,12,13,14,15,16,17,18,19,21,20,23,22,24,25,26,27,28,29,30,31,34,33,32,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,166,54,55,56,57,58,59,60,62,63,64,65,66,67,68,69,61,167,168,70,71,72,169,73,74,75,76,77,78,79,80,81,82,83,84,85,86,88,89,90,87,91,92,93,94,95,96,97,98,99,101,102,103,100,108,109,110,111,112,113,114,115,116,117,118,119,120,122,123,121,124,125,126,127,128,129,130,131,104,132,105,106,107,133,134,135,136,137,139,140,141,142,143,144,145,146,147,148,150,149,151,152,153,155,154,156,157,158,159,160,161,162,138,163,164,165]);
